   // --- Setup ---
   const canvas = document.getElementById("demo");
   const canvasArea = document.getElementById("canvas-area");
   const ctx = canvas.getContext("2d", { alpha: true });

   console.log('🚀 NEW VERSION LOADED - design-editor.js v1751197100000 - FIXED DOUBLE-SCALING IN GRADIENTS');
   alert('🚀 CACHE TEST: JavaScript file loaded at ' + new Date().toISOString());
   // 📦 FILE RELOAD TEST: Verify file is being reloaded with text wrapping changes
   console.log('📦 DESIGN EDITOR: File loaded with text wrapping bounds fix at', new Date().toISOString());
   // Temporary alert to confirm new version is loading
   setTimeout(() => {
       console.log('🚀 DELAYED LOG - New version confirmed loaded');
   }, 1000);

   // --- High-DPI Canvas Enhancement ---
   function setupHighDPICanvas(canvas, ctx, scaleFactor = 2) {
       console.log(`🔧 [HIGH-DPI] Starting setupHighDPICanvas with scaleFactor: ${scaleFactor}`);

       // Get the device pixel ratio, fallback to 1 if not available
       const dpr = window.devicePixelRatio || 1;
       console.log(`🔧 [HIGH-DPI] Device pixel ratio: ${dpr}`);

       // Apply additional scaling factor (2x or 4x for higher quality)
       const totalScale = dpr * scaleFactor;
       console.log(`🔧 [HIGH-DPI] Total scale factor: ${totalScale} (dpr: ${dpr} × scaleFactor: ${scaleFactor})`);

       // Get the display size (CSS pixels) - use the original canvas size as reference
       const displayWidth = 2048;  // Original canvas width
       const displayHeight = 2048; // Original canvas height

       // Log current canvas state before changes
       console.log(`🔧 [HIGH-DPI] BEFORE - Canvas dimensions: ${canvas.width}x${canvas.height}`);
       console.log(`🔧 [HIGH-DPI] BEFORE - Canvas style: ${canvas.style.width} x ${canvas.style.height}`);
       console.log(`🔧 [HIGH-DPI] BEFORE - Current transform:`, ctx.getTransform());

       // Reset any existing transformations before setting up new ones
       ctx.setTransform(1, 0, 0, 1, 0, 0);
       console.log(`🔧 [HIGH-DPI] Reset transform to identity`);

       // Set the actual canvas size in memory (scaled up for higher quality)
       canvas.width = displayWidth * totalScale;
       canvas.height = displayHeight * totalScale;
       console.log(`🔧 [HIGH-DPI] Set canvas dimensions to: ${canvas.width}x${canvas.height}`);

       // Scale the canvas back down using CSS to maintain the same visual size
       canvas.style.width = displayWidth + 'px';
       canvas.style.height = displayHeight + 'px';
       console.log(`🔧 [HIGH-DPI] Set CSS dimensions to: ${canvas.style.width} x ${canvas.style.height}`);

       // Scale the drawing context so everything draws at the higher resolution
       ctx.scale(totalScale, totalScale);
       console.log(`🔧 [HIGH-DPI] Applied context scaling: ${totalScale}x`);
       console.log(`🔧 [HIGH-DPI] AFTER - Current transform:`, ctx.getTransform());

       // Enable better text rendering
       ctx.textRenderingOptimization = 'optimizeQuality';
       ctx.imageSmoothingEnabled = true;
       ctx.imageSmoothingQuality = 'high';
       console.log(`🔧 [HIGH-DPI] Enabled high-quality rendering options`);

       // Store the scale factor for coordinate calculations
       canvas.scaleFactor = totalScale;
       console.log(`🔧 [HIGH-DPI] Stored scaleFactor on canvas: ${canvas.scaleFactor}`);

       console.log(`✅ [HIGH-DPI] Canvas enhanced with ${scaleFactor}x scaling (total: ${totalScale}x)`);
       console.log(`✅ [HIGH-DPI] Final canvas dimensions: ${canvas.width}x${canvas.height} (display: ${displayWidth}x${displayHeight})`);
       return totalScale;
   }

   // Apply high-DPI enhancement (2x scaling by default)
   let currentScaleFactor = 2;
   let canvasScale = setupHighDPICanvas(canvas, ctx, currentScaleFactor);

   const w = 2048; // Use original dimensions for calculations
   const h = 2048;

   // --- Artboard ---
   let artboard = null;
   let isArtboardEditMode = false;
   const toggleArtboardBtn = document.getElementById('toggleArtboardBtn');

   // Make artboard globally accessible for project saving
   window.artboard = artboard;

   toggleArtboardBtn.addEventListener('click', () => {
       if (!artboard) {
           // Create centered artboard with default size
           artboard = {
               x: w / 2 - 300,
               y: h / 2 - 300,
               width: 600,
               height: 600,
               isSelected: true
           };
           // Update global reference
           window.artboard = artboard;
           console.log('[Artboard] ✅ Created new artboard:', artboard);
           console.log('[Artboard] ✅ Updated window.artboard:', window.artboard);

           // Enter artboard edit mode
           isArtboardEditMode = true;
           toggleArtboardBtn.textContent = 'Confirm';
           toggleArtboardBtn.style.backgroundColor = '#dcffcb';
           canvas.classList.add('artboard-edit-mode');

           // Deselect any selected object when entering artboard mode
           if (selectedObjectIndex !== -1) {
               canvasObjects[selectedObjectIndex].isSelected = false;
               selectedObjectIndex = -1;
               updateUIFromSelectedObject();
           }
       } else if (isArtboardEditMode) {
           // Exit artboard edit mode but keep artboard visible
           isArtboardEditMode = false;
           toggleArtboardBtn.textContent = 'Artboard';
           toggleArtboardBtn.style.backgroundColor = '';
           canvas.classList.remove('artboard-edit-mode');
       } else {
           // Toggle artboard visibility and enter edit mode
           artboard.isSelected = true;
           // Update global reference
           window.artboard = artboard;
           console.log('[Artboard] ✅ Toggled artboard selection:', artboard.isSelected);
           console.log('[Artboard] ✅ Updated window.artboard:', window.artboard);

           isArtboardEditMode = true;
           toggleArtboardBtn.textContent = 'Confirm';
           toggleArtboardBtn.style.backgroundColor = '#dcffcb';
           canvas.classList.add('artboard-edit-mode');

           // Deselect any selected object when entering artboard mode
           if (selectedObjectIndex !== -1) {
               canvasObjects[selectedObjectIndex].isSelected = false;
               selectedObjectIndex = -1;
               updateUIFromSelectedObject();
           }
       }
       update();
   });

   // --- Zoom/Pan State ---
   let scale = 1.0; let offsetX = 0; let offsetY = 0; const MIN_SCALE = 0.1; const MAX_SCALE = 10.0; const ZOOM_SENSITIVITY = 0.001; let isPanning = false; let panStartX, panStartY;

   // Make zoom/pan variables globally accessible for save/load
   window.scale = scale;
   window.offsetX = offsetX;
   window.offsetY = offsetY;

   // --- Artboard Resize State ---
   let isResizingArtboard = false;
   let resizeCorner = null;

   canvas.addEventListener('mousedown', (e) => {
       const coords = getCanvasCoordinates(e);
       const world = canvasToWorld(coords.x, coords.y);

       // Check for artboard corners when artboard is selected AND in edit mode
       if (artboard && artboard.isSelected && isArtboardEditMode) {
           const size = 8 / scale;
           const half = size / 2;
           const corners = [
               ['tl', artboard.x, artboard.y],
               ['tr', artboard.x + artboard.width, artboard.y],
               ['bl', artboard.x, artboard.y + artboard.height],
               ['br', artboard.x + artboard.width, artboard.y + artboard.height]
           ];
           for (const [cornerName, cx, cy] of corners) {
               if (
                   world.x >= cx - half &&
                   world.x <= cx + half &&
                   world.y >= cy - half &&
                   world.y <= cy + half
               ) {
                   isResizingArtboard = true;
                   resizeCorner = cornerName;
                   e.preventDefault();
                   return;
               }
           }

           // If in artboard edit mode, prevent other interactions
           if (isArtboardEditMode) {
               e.preventDefault();
               return;
           }
       }
   });

   canvas.addEventListener('mousemove', (e) => {
       if (!isResizingArtboard) return;
       const coords = getCanvasCoordinates(e);
       const world = canvasToWorld(coords.x, coords.y);

       // Make sure we're in artboard edit mode when resizing
       if (!isArtboardEditMode) {
           isArtboardEditMode = true;
           toggleArtboardBtn.textContent = 'Confirm';
           toggleArtboardBtn.style.backgroundColor = '#dcffcb';
           canvas.classList.add('artboard-edit-mode');
       }

       switch (resizeCorner) {
           case 'tl':
               artboard.width += artboard.x - world.x;
               artboard.height += artboard.y - world.y;
               artboard.x = world.x;
               artboard.y = world.y;
               break;
           case 'tr':
               artboard.width = world.x - artboard.x;
               artboard.height += artboard.y - world.y;
               artboard.y = world.y;
               break;
           case 'bl':
               artboard.width += artboard.x - world.x;
               artboard.x = world.x;
               artboard.height = world.y - artboard.y;
               break;
           case 'br':
               artboard.width = world.x - artboard.x;
               artboard.height = world.y - artboard.y;
               break;
       }
       update();
   });

   window.addEventListener('mouseup', () => {
       isResizingArtboard = false;
       resizeCorner = null;
   });

   // --- Layout Tool ---
   let layoutRectangles = []; // Array to store layout rectangles
   let isLayoutToolActive = false;
   let isDrawingLayoutRect = false;
   let layoutRectStartX, layoutRectStartY;
   let selectedLayoutRectIndex = -1;
   let isResizingLayoutRect = false;
   let layoutResizeCorner = null;
   let areGuidelinesLocked = false;
   let areGuidelinesVisible = true; // Track guidelines visibility
   const layoutToolBtn = document.getElementById('layoutToolBtn');
   const clearLayoutBtn = document.getElementById('clearLayoutBtn');
   const lockGuidelinesBtn = document.getElementById('lockGuidelinesBtn');
   const toggleGuidelinesBtn = document.getElementById('toggleGuidelinesBtn');

   // Debug: Check if buttons exist
   console.log('🔍 Button check - toggleGuidelinesBtn:', toggleGuidelinesBtn);
   console.log('🔍 Button check - clearGuidelinesBtn:', document.getElementById('clearGuidelinesBtn'));

   // --- Snap to Guidelines ---
   const SNAP_TOLERANCE = 30; // pixels - distance to snap to guidelines (increased for easier testing)

   // Function to get all active guidelines
   function getActiveGuidelines() {
       // Simply return the existing guidelines array - no need to recreate them every time
       console.log('🔍 [Guidelines] Returning existing guidelines, count:', guidelines.length);
       return guidelines;
   }



   // Function to snap coordinates to nearby guidelines
   function snapToGuidelines(worldX, worldY) {
       const guidelines = getActiveGuidelines();
       let snappedX = worldX;
       let snappedY = worldY;

       console.log('🧲 [Snap] Checking snap for world coords:', worldX, worldY);
       console.log('🧲 [Snap] Found', guidelines.length, 'guidelines');

       if (guidelines.length === 0) {
           return { x: snappedX, y: snappedY };
       }

       // Convert world coordinates to screen coordinates for guideline comparison
       const screenCoords = worldToCanvas(worldX, worldY);
       console.log('🧲 [Snap] Screen coords:', screenCoords.x, screenCoords.y);

       for (const guideline of guidelines) {
           if (guideline.type === 'vertical') {
               // Convert guideline world position to screen coordinates for comparison
               const guidelineScreenCoords = worldToCanvas(guideline.worldPosition, 0);
               const distance = Math.abs(screenCoords.x - guidelineScreenCoords.x);
               console.log('🧲 [Snap] Vertical guideline at world x:', guideline.worldPosition, 'screen x:', guidelineScreenCoords.x, 'mouse screen x:', screenCoords.x, 'distance:', distance, 'tolerance:', SNAP_TOLERANCE);
               if (distance <= SNAP_TOLERANCE) {
                   // Snap to guideline - use the fixed world coordinate
                   snappedX = guideline.worldPosition;
                   console.log('🧲 [Snap] ✅ SNAPPED to vertical guideline at world x:', snappedX);
               }
           } else if (guideline.type === 'horizontal') {
               // Convert guideline world position to screen coordinates for comparison
               const guidelineScreenCoords = worldToCanvas(0, guideline.worldPosition);
               const distance = Math.abs(screenCoords.y - guidelineScreenCoords.y);
               console.log('🧲 [Snap] Horizontal guideline at world y:', guideline.worldPosition, 'screen y:', guidelineScreenCoords.y, 'mouse screen y:', screenCoords.y, 'distance:', distance, 'tolerance:', SNAP_TOLERANCE);
               if (distance <= SNAP_TOLERANCE) {
                   // Snap to guideline - use the fixed world coordinate
                   snappedY = guideline.worldPosition;
                   console.log('🧲 [Snap] ✅ SNAPPED to horizontal guideline at world y:', snappedY);
               }
           }
       }

       return { x: snappedX, y: snappedY };
   }

   // Make layout tool variables globally accessible
   window.layoutRectangles = layoutRectangles;
   window.selectedLayoutRectIndex = selectedLayoutRectIndex;

   // Layout Tool button event listener
   layoutToolBtn.addEventListener('click', () => {
       if (isLayoutToolActive) {
           // Exit layout tool mode (keep selected rectangle)
           isLayoutToolActive = false;
           isDrawingLayoutRect = false;
           // Don't reset selectedLayoutRectIndex - keep it selected for normal mode
           layoutToolBtn.style.backgroundColor = '';
           layoutToolBtn.style.color = '';
           canvas.style.cursor = '';
           console.log('[LayoutTool] Exited layout tool mode, keeping rectangle selection');
       } else {
           // Enter layout tool mode
           isLayoutToolActive = true;
           layoutToolBtn.style.backgroundColor = '#4ade80';
           layoutToolBtn.style.color = 'white';
           canvas.style.cursor = 'crosshair';

           // Deselect any selected objects when entering layout mode
           if (selectedObjectIndex !== -1) {
               canvasObjects[selectedObjectIndex].isSelected = false;
               selectedObjectIndex = -1;
               updateUIFromSelectedObject();
           }

           console.log('[LayoutTool] Entered layout tool mode');
       }
       update();
   });

   // Smart Clear Layout Rectangles button event listener
   clearLayoutBtn.addEventListener('click', () => {
       if (layoutRectangles.length === 0) {
           console.log('[LayoutTool] No layout rectangles to delete');
           return;
       }

       // Check if a specific layout rectangle is selected
       if (selectedLayoutRectIndex !== -1 && layoutRectangles[selectedLayoutRectIndex]) {
           // Delete only the selected layout rectangle
           if (confirm('Are you sure you want to delete the selected layout rectangle?')) {
               console.log('[LayoutTool] Deleting selected layout rectangle:', selectedLayoutRectIndex);
               layoutRectangles.splice(selectedLayoutRectIndex, 1);
               window.layoutRectangles = layoutRectangles;
               selectedLayoutRectIndex = -1;
               window.selectedLayoutRectIndex = selectedLayoutRectIndex;

               // Update UI since layout selection changed
               updateLayoutSelectionUI();

               console.log('[LayoutTool] Deleted selected layout rectangle');
               update();
           }
       } else {
           // No specific rectangle selected - delete all rectangles (original behavior)
           if (confirm('Are you sure you want to delete all layout rectangles?')) {
               layoutRectangles = [];
               window.layoutRectangles = layoutRectangles;
               selectedLayoutRectIndex = -1;
               window.selectedLayoutRectIndex = selectedLayoutRectIndex;

               // Update UI since layout selection changed
               updateLayoutSelectionUI();

               console.log('[LayoutTool] Cleared all layout rectangles');
               update();
           }
       }
   });

   // Lock Guidelines Button
   if (lockGuidelinesBtn) {
       lockGuidelinesBtn.addEventListener('click', () => {
           areGuidelinesLocked = !areGuidelinesLocked;
           console.log('🔒 Guidelines lock state changed:', areGuidelinesLocked ? 'LOCKED' : 'UNLOCKED');

           // Update button appearance
           if (areGuidelinesLocked) {
               lockGuidelinesBtn.style.backgroundColor = '#ff6b6b';
               lockGuidelinesBtn.style.color = 'white';
               lockGuidelinesBtn.title = 'Unlock Guidelines - Allow guideline movement';
           } else {
               lockGuidelinesBtn.style.backgroundColor = '';
               lockGuidelinesBtn.style.color = '';
               lockGuidelinesBtn.title = 'Lock Guidelines - Prevent guideline movement';
           }
       });
   }

   // Toggle Guidelines Visibility Button
   if (toggleGuidelinesBtn) {
       toggleGuidelinesBtn.addEventListener('click', () => {
           areGuidelinesVisible = !areGuidelinesVisible;
           console.log('👁️ Guidelines visibility changed:', areGuidelinesVisible ? 'VISIBLE' : 'HIDDEN');

           // Update button appearance
           if (areGuidelinesVisible) {
               toggleGuidelinesBtn.style.backgroundColor = '';
               toggleGuidelinesBtn.style.color = '';
               toggleGuidelinesBtn.title = 'Hide All Guidelines';
               toggleGuidelinesBtn.textContent = '👁️‍🗨️';
           } else {
               toggleGuidelinesBtn.style.backgroundColor = '#6b7280';
               toggleGuidelinesBtn.style.color = 'white';
               toggleGuidelinesBtn.title = 'Show All Guidelines';
               toggleGuidelinesBtn.textContent = '🙈';
           }

           // Redraw canvas to show/hide guidelines
           update();
       });
   }

   // --- Offscreen Canvases (Text Effects) ---
   // Apply high-DPI scaling to offscreen canvases to match main canvas quality
   const devicePixelRatio = window.devicePixelRatio || 1;
   const qualityMultiplier = 2; // Same as main canvas
   const offscreenScaleFactor = devicePixelRatio * qualityMultiplier;

   const os = document.createElement("canvas");
   os.width = 8192 * offscreenScaleFactor;
   os.height = 8192 * offscreenScaleFactor;
   os.style.width = '8192px';
   os.style.height = '8192px';
   const octx = os.getContext("2d");
   octx.scale(offscreenScaleFactor, offscreenScaleFactor);
   octx.imageSmoothingEnabled = true;
   octx.imageSmoothingQuality = 'high';
   os.scaleFactor = offscreenScaleFactor;

   const tempWarpCanvas = document.createElement("canvas");
   tempWarpCanvas.width = 8192 * offscreenScaleFactor;
   tempWarpCanvas.height = 8192 * offscreenScaleFactor;
   tempWarpCanvas.style.width = '8192px';
   tempWarpCanvas.style.height = '8192px';
   const tempWarpCtx = tempWarpCanvas.getContext("2d");
   tempWarpCtx.scale(offscreenScaleFactor, offscreenScaleFactor);
   tempWarpCtx.imageSmoothingEnabled = true;
   tempWarpCtx.imageSmoothingQuality = 'high';
   tempWarpCanvas.scaleFactor = offscreenScaleFactor;

   const letterCanvas = document.createElement("canvas");
   letterCanvas.width = 2048 * offscreenScaleFactor;
   letterCanvas.height = 2048 * offscreenScaleFactor;
   letterCanvas.style.width = '2048px';
   letterCanvas.style.height = '2048px';
   const letterCtx = letterCanvas.getContext("2d");
   letterCtx.scale(offscreenScaleFactor, offscreenScaleFactor);
   letterCtx.imageSmoothingEnabled = true;
   letterCtx.imageSmoothingQuality = 'high';
   letterCanvas.scaleFactor = offscreenScaleFactor;

   // --- Controls References ---
   const textControlsWrapper = document.getElementById('text-controls'); const iText = document.getElementById("iText"); const addEditTextBtn = document.getElementById("addEditTextBtn"); const deleteTextBtn = document.getElementById("deleteTextBtn"); const iTextColor = document.getElementById("iTextColor"); const iTextColorIntensity = document.getElementById("iTextColorIntensity"); const iTextBoxWidth = document.getElementById("iTextBoxWidth"); const textBoxWidthValue = document.getElementById("textBoxWidthValue"); const iLineHeight = document.getElementById("iLineHeight"); const lineHeightValue = document.getElementById("lineHeightValue"); const iFontFamily = document.getElementById("iFontFamily"); const iBold = document.getElementById("iBold"); const iItalic = document.getElementById("iItalic"); const iFontSize = document.getElementById("iFontSize"); const iTextRotation = document.getElementById("iTextRotation"); const vFontSize = document.getElementById("vFontSize"); const vTextRotation = document.getElementById("vTextRotation"); const effectModeSelect = document.getElementById("effectMode"); const skewSlider = document.getElementById("skewSlider"); const skewYSlider = document.getElementById("skewYSlider"); const vSkew = document.getElementById("vSkew"); const vSkewY = document.getElementById("vSkewY"); const iCurve = document.getElementById("iCurve"); const iOffset = document.getElementById("iOffset"); const iHeight = document.getElementById("iHeight"); const iBottom = document.getElementById("iBottom"); const iTriangle = document.getElementById("iTriangle"); const iShiftCenter = document.getElementById("iShiftCenter"); const vCurve = document.getElementById("vCurve"); const vOffset = document.getElementById("vOffset"); const vHeight = document.getElementById("vHeight"); const vBottom = document.getElementById("vBottom"); const vShiftCenter = document.getElementById("vShiftCenter"); const iDiameter = document.getElementById("iDiameter"); const iKerning = document.getElementById("iKerning"); const iFlip = document.getElementById("iFlip"); const vDiameter = document.getElementById("vDiameter"); const vKerning = document.getElementById("vKerning"); const iCurveAmount = document.getElementById("iCurveAmount"); const iCurveKerning = document.getElementById("iCurveKerning"); const iCurveFlip = document.getElementById("iCurveFlip"); const vCurveAmount = document.getElementById("vCurveAmount"); const vCurveKerning = document.getElementById("vCurveKerning"); const shadowSelect = document.getElementById("shadow"); const shadowColorPicker = document.getElementById("shadowColor"); const shadowOffsetXSlider = document.getElementById("shadowOffsetX"); const shadowOffsetYSlider = document.getElementById("shadowOffsetY"); const shadowBlurSlider = document.getElementById("shadowBlur"); const vShadowOffsetX = document.getElementById("vShadowOffsetX"); const vShadowOffsetY = document.getElementById("vShadowOffsetY"); const vShadowBlur = document.getElementById("vShadowBlur"); const blockShadowColorPicker = document.getElementById("blockShadowColor"); const blockShadowOpacitySlider = document.getElementById("blockShadowOpacity"); const blockShadowOffsetSlider = document.getElementById("blockShadowOffset"); const blockShadowAngleSlider = document.getElementById("blockShadowAngle"); const blockShadowBlurSlider = document.getElementById("blockShadowBlur"); const blockShadowPerspective = document.getElementById("blockShadowPerspective"); const blockShadowPerspectiveIntensity = document.getElementById("blockShadowPerspectiveIntensity"); const vBlockShadowOpacity = document.getElementById("vBlockShadowOpacity"); const vBlockShadowOffset = document.getElementById("vBlockShadowOffset"); const vBlockShadowAngle = document.getElementById("vBlockShadowAngle"); const vBlockShadowBlur = document.getElementById("vBlockShadowBlur"); const vBlockShadowPerspectiveIntensity = document.getElementById("vBlockShadowPerspectiveIntensity"); const lineShadowColorPicker = document.getElementById("lineShadowColor"); const lineShadowDistanceSlider = document.getElementById("lineShadowDistance"); const lineShadowAngleSlider = document.getElementById("lineShadowAngle"); const lineShadowThicknessSlider = document.getElementById("lineShadowThickness"); const vLineShadowDistance = document.getElementById("vLineShadowDistance"); const vLineShadowAngle = document.getElementById("vLineShadowAngle"); const vLineShadowThickness = document.getElementById("vLineShadowThickness"); const detailed3DPrimaryColorPicker = document.getElementById("detailed3DPrimaryColor"); const detailed3DPrimaryOpacitySlider = document.getElementById("detailed3DPrimaryOpacity"); const detailed3DOffsetSlider = document.getElementById("detailed3DOffset"); const detailed3DAngleSlider = document.getElementById("detailed3DAngle"); const detailed3DBlurSlider = document.getElementById("detailed3DBlur"); const detailed3DSecondaryColorPicker = document.getElementById("detailed3DSecondaryColor"); const detailed3DSecondaryOpacitySlider = document.getElementById("detailed3DSecondaryOpacity"); const detailed3DSecondaryWidthSlider = document.getElementById("detailed3DSecondaryWidth"); const detailed3DSecondaryOffsetXSlider = document.getElementById("detailed3DSecondaryOffsetX"); const detailed3DSecondaryOffsetYSlider = document.getElementById("detailed3DSecondaryOffsetY"); const vDetailed3DPrimaryOpacity = document.getElementById("vDetailed3DPrimaryOpacity"); const vDetailed3DOffset = document.getElementById("vDetailed3DOffset"); const vDetailed3DAngle = document.getElementById("vDetailed3DAngle"); const vDetailed3DBlur = document.getElementById("vDetailed3DBlur"); const vDetailed3DSecondaryOpacity = document.getElementById("vDetailed3DSecondaryOpacity"); const vDetailed3DSecondaryWidth = document.getElementById("vDetailed3DSecondaryWidth"); const vDetailed3DSecondaryOffsetX = document.getElementById("vDetailed3DSecondaryOffsetX"); const vDetailed3DSecondaryOffsetY = document.getElementById("vDetailed3DSecondaryOffsetY"); const strokeToggle = document.getElementById("strokeToggle"); const linesDecorationSelect = document.getElementById("linesDecoration"); const strokeWidthSlider = document.getElementById("strokeWidth"); const strokeColorPicker = document.getElementById("strokeColor"); const strokeOpacitySlider = document.getElementById("strokeOpacity"); const vStrokeWidth = document.getElementById("vStrokeWidth"); const vStrokeOpacity = document.getElementById("vStrokeOpacity"); const hWeight = document.getElementById("hWeight"); const hDistance = document.getElementById("hDistance"); const hColor = document.getElementById("hColor"); const hOpacity = document.getElementById("hOpacity"); const vHWeight = document.getElementById("vHWeight"); const vHDistance = document.getElementById("vHDistance"); const vHOpacity = document.getElementById("vHOpacity"); const ccDistance = document.getElementById("ccDistance"); const ccColor = document.getElementById("ccColor"); const ccOpacity = document.getElementById("ccOpacity"); const ccFillTop = document.getElementById("ccFillTop"); const ccFillBottom = document.getElementById("ccFillBottom"); const vCcDistance = document.getElementById("vCcDistance"); const vCcOpacity = document.getElementById("vCcOpacity"); const oWeight = document.getElementById("oWeight"); const oDistance = document.getElementById("oDistance"); const oColor = document.getElementById("oColor"); const oOpacity = document.getElementById("oOpacity"); const vOWeight = document.getElementById("vOWeight"); const vODistance = document.getElementById("vODistance"); const vOOpacity = document.getElementById("vOOpacity"); const flcDistance = document.getElementById("flcDistance"); const flcFillTop = document.getElementById("flcFillTop"); const flcFillBottom = document.getElementById("flcFillBottom"); const flcColor = document.getElementById("flcColor"); const flcOpacity = document.getElementById("flcOpacity"); const flcMaxWeight = document.getElementById("flcMaxWeight"); const flcSpacing = document.getElementById("flcSpacing"); const vFlcDistance = document.getElementById("vFlcDistance"); const vFlcOpacity = document.getElementById("vFlcOpacity"); const vFlcMaxWeight = document.getElementById("vFlcMaxWeight"); const vFlcSpacing = document.getElementById("vFlcSpacing");
   const addImageBtn = document.getElementById('addImageBtn'); const imageFileInput = document.getElementById('image-file-input'); const deleteImageBtn = document.getElementById('deleteImageBtn'); const imageControlsWrapper = document.getElementById('image-controls'); const noImageSelectedMsg = document.getElementById('no-image-selected-msg'); const iImageSize = document.getElementById('iImageSize'); const vImageSize = document.getElementById('vImageSize'); const iImageRotation = document.getElementById('iImageRotation'); const vImageRotation = document.getElementById('vImageRotation');
   // Image opacity controls
   const iImageOpacity = document.getElementById('iImageOpacity'); const vImageOpacity = document.getElementById('vImageOpacity');
   // Image stroke controls
   const iImageStroke = document.getElementById('iImageStroke'); const iImageStrokeWidth = document.getElementById('iImageStrokeWidth'); const vImageStrokeWidth = document.getElementById('vImageStrokeWidth'); const iImageStrokeColor = document.getElementById('iImageStrokeColor'); const iImageStrokeOpacity = document.getElementById('iImageStrokeOpacity'); const vImageStrokeOpacity = document.getElementById('vImageStrokeOpacity');
   // Image shadow controls
   const iImageShadow = document.getElementById('iImageShadow'); const iImageShadowColor = document.getElementById('iImageShadowColor'); const iImageShadowOpacity = document.getElementById('iImageShadowOpacity'); const vImageShadowOpacity = document.getElementById('vImageShadowOpacity'); const iImageShadowOffsetX = document.getElementById('iImageShadowOffsetX'); const vImageShadowOffsetX = document.getElementById('vImageShadowOffsetX'); const iImageShadowOffsetY = document.getElementById('iImageShadowOffsetY'); const vImageShadowOffsetY = document.getElementById('vImageShadowOffsetY'); const iImageShadowBlur = document.getElementById('iImageShadowBlur'); const vImageShadowBlur = document.getElementById('vImageShadowBlur');
   // Image color intensity control
   const iImageColorIntensity = document.getElementById('iImageColorIntensity');
   const zoomInBtn = document.getElementById('zoomInBtn'); const zoomOutBtn = document.getElementById('zoomOutBtn'); const zoomLevelSpan = document.getElementById('zoomLevel');
   const moveForwardBtn = document.getElementById('moveForwardBtn'); const moveBackwardBtn = document.getElementById('moveBackwardBtn'); // Ensure references are declared
   // Image masking controls
   const maskImageBtn = document.getElementById('maskImageBtn'); const unmaskImageBtn = document.getElementById('unmaskImageBtn'); const imageMaskingGroup = document.getElementById('imageMaskingGroup');

   // --- State & Constants ---
   let canvasObjects = [];
   let _selectedObjectIndex = -1; // Private variable
   let nextId = 0; let isDraggingObject = false; let dragStartX, dragStartY; let dragInitialObjectX, dragInitialObjectY; let dragInitialControlPoints = null; // <-- ADDED for mesh drag fix

   // 🔒 UI INTERACTION LOCK: Prevent accidental object selection during property adjustments
   let isUIInteractionActive = false;
   let uiInteractionTimeout = null;

   // 🔍 SELECTION TRACKING: Getter/setter to track when selectedObjectIndex changes
   Object.defineProperty(window, 'selectedObjectIndex', {
       get: function() { return _selectedObjectIndex; },
       set: function(value) {
           if (_selectedObjectIndex !== value) {
               console.log('🔍 SELECTION CHANGE: selectedObjectIndex changing from', _selectedObjectIndex, 'to', value);
               console.log('🔍 SELECTION CHANGE: Stack trace:', new Error().stack);
               _selectedObjectIndex = value;
           }
       },
       enumerable: true,
       configurable: true
   });

   // Create a local getter/setter that uses the same tracking
   Object.defineProperty(this, 'selectedObjectIndex', {
       get: function() { return _selectedObjectIndex; },
       set: function(value) {
           if (_selectedObjectIndex !== value) {
               console.log('🔍 SELECTION CHANGE: LOCAL selectedObjectIndex changing from', _selectedObjectIndex, 'to', value);
               console.log('🔍 SELECTION CHANGE: LOCAL Stack trace:', new Error().stack);
               _selectedObjectIndex = value;
           }
       },
       enumerable: true,
       configurable: true
   });

   // 🔒 UI INTERACTION LOCK: Functions to manage UI interaction state
   function startUIInteraction() {
       console.log('🔒 UI LOCK: Starting UI interaction - preventing canvas object selection');
       isUIInteractionActive = true;

       // Clear any existing timeout
       if (uiInteractionTimeout) {
           clearTimeout(uiInteractionTimeout);
       }

       // Set a timeout to automatically release the lock after 2 seconds of inactivity
       uiInteractionTimeout = setTimeout(() => {
           console.log('🔒 UI LOCK: Auto-releasing UI interaction lock after timeout');
           isUIInteractionActive = false;
           uiInteractionTimeout = null;
       }, 2000);
   }

   function endUIInteraction() {
       console.log('🔒 UI LOCK: Ending UI interaction - allowing canvas object selection');
       isUIInteractionActive = false;

       if (uiInteractionTimeout) {
           clearTimeout(uiInteractionTimeout);
           uiInteractionTimeout = null;
       }
   }

   // 🔗 LINKED RESIZE: Rectangle resize state
   let isResizingRectangle = false;
   let resizeHandle = null;
   let resizeInitialWidth, resizeInitialHeight;
   let resizeInitialX, resizeInitialY;

   // Multi-select state
   let selectedObjectIndices = []; // Array of selected object indices
   let isMultiSelectMode = false; // Whether we're in multi-select mode
   let currentTemplateName = null; // Store the current template name for updates
   let currentProjectId = null; // Store the current project ID for updates
   let currentProjectTitle = null; // Store the current project title for updates
   let currentProjectFolderId = null; // Store the current project folder ID for updates
   const selectionBoxPadding = 5; const letterSourcePadding = 50; // Increased padding for text effects
   let canvasBackgroundColor = '#ffffff'; // Initial background color

   // Make background color globally accessible for save/load
   window.canvasBackgroundColor = canvasBackgroundColor;

   // --- Masking State ---
   let isMaskSelectionMode = false; // Whether we're in mask selection mode
   let pendingMaskImage = null; // Image waiting for mask selection

   // --- Performance Optimization Variables ---
   let DEBUG_MODE = false; // Set to true to enable detailed logging
   let PERFORMANCE_MODE = true; // Set to false to disable performance optimizations
   let lastRenderTime = 0;
   let renderCount = 0;
   let fontLoadCache = new Map(); // Cache for font loading status
   let isDuringMovement = false; // Track if we're currently moving objects
   let movementStartTime = 0;
   let lastMovementTime = 0;

   // --- Expose variables to global scope for external scripts ---
   window.canvasObjects = canvasObjects;
   window.selectedObjectIndex = selectedObjectIndex;
   window.nextId = nextId;
   window.w = w;
   window.h = h;
   window.canvas = canvas;
   window.ctx = ctx;
   window.update = update;
   window.updateUIFromSelectedObject = updateUIFromSelectedObject;
   window.createImageObject = createImageObject;

   // Function to sync global references when local variables change
   function syncGlobalReferences() {
       window.canvasObjects = canvasObjects;
       window.selectedObjectIndex = selectedObjectIndex;
       window.nextId = nextId;
   }

   // Function to sync local variables from global references (when external code modifies globals)
   function syncFromGlobalReferences() {
       // 🚨 CRITICAL: Don't sync during active drag operations to prevent interrupting user interactions
       if (isDraggingObject || isDraggingGuideline || isDraggingGridPoint || isPanning || isResizingRectangle) {
           console.log('🔄 SYNC: Skipping sync during active drag operation', {
               isDraggingObject, isDraggingGuideline, isDraggingGridPoint, isPanning, isResizingRectangle
           });
           return;
       }

       if (window.canvasObjects && Array.isArray(window.canvasObjects)) {
           canvasObjects = window.canvasObjects;
       }
       if (typeof window.selectedObjectIndex === 'number') {
           const oldSelectedObjectIndex = selectedObjectIndex;
           selectedObjectIndex = window.selectedObjectIndex;

           // 🔧 BOUNDS CHECK: Ensure selectedObjectIndex is valid
           if (selectedObjectIndex >= canvasObjects.length) {
               console.log('🚨 ROTATION BUG: syncFromGlobalReferences detected out of bounds selectedObjectIndex!');
               console.log('🚨 ROTATION BUG: oldSelectedObjectIndex:', oldSelectedObjectIndex, 'newSelectedObjectIndex:', selectedObjectIndex, 'canvasObjects.length:', canvasObjects.length);
               console.log('🚨 ROTATION BUG: window.selectedObjectIndex:', window.selectedObjectIndex);
               console.log('🚨 ROTATION BUG: This sync operation is likely causing the selection change during rotation');

               // 🔧 TEMPORARY FIX: Instead of auto-selecting the last object, revert to the old selection if it was valid
               if (oldSelectedObjectIndex >= 0 && oldSelectedObjectIndex < canvasObjects.length) {
                   console.log('🔧 SYNC BOUNDS FIX: Reverting to previous valid selection:', oldSelectedObjectIndex);
                   selectedObjectIndex = oldSelectedObjectIndex;
                   window.selectedObjectIndex = selectedObjectIndex; // Update global too
               } else {
                   console.log('🔧 SYNC BOUNDS FIX: Setting selectedObjectIndex to -1 instead of auto-selecting last object');
                   selectedObjectIndex = -1;
                   window.selectedObjectIndex = selectedObjectIndex; // Update global too
               }
           }
       }
       if (typeof window.nextId === 'number') {
           nextId = window.nextId;
       }
   }

   // 🔧 HELPER: Reset all drag flags to prevent stuck states
   function resetAllDragFlags() {
       const wasAnyDragActive = isDraggingObject || isDraggingGuideline || isDraggingGridPoint || isPanning || isResizingRectangle;

       isDraggingObject = false;
       isDraggingGuideline = false;
       isDraggingGridPoint = false;
       isPanning = false;
       isResizingRectangle = false;

       if (wasAnyDragActive) {
           console.log('🔧 DRAG FLAGS: Reset all drag flags to prevent stuck states');
       }
   }

   // --- Project Loading Functionality ---
   async function loadProjectFromUrl() {
       const urlParams = new URLSearchParams(window.location.search);
       const projectId = urlParams.get('projectId');

       if (projectId) {
           console.log('[ProjectLoader] Loading project:', projectId);
           try {
               const response = await fetch(`/api/projects/${projectId}`, { credentials: 'include' });
               if (!response.ok) {
                   throw new Error(`Failed to load project: ${response.statusText}`);
               }

               const project = await response.json();
               console.log('[ProjectLoader] Project loaded:', project);

               await loadProjectData(project);

           } catch (error) {
               console.error('[ProjectLoader] Error loading project:', error);
               alert(`Failed to load project: ${error.message}`);
           }
       }
   }

   async function loadProjectData(project) {
       try {
           console.log('[ProjectLoader] ===== LOADING PROJECT DEBUG =====');
           console.log('[ProjectLoader] Loading project data:', project.title);
           console.log('[ProjectLoader] Complete project object:', project);
           console.log('[ProjectLoader] Project keys:', Object.keys(project));
           console.log('[ProjectLoader] EditorState:', project.editorState);
           console.log('[ProjectLoader] Artboard:', project.artboard);
           console.log('[ProjectLoader] CanvasObjects length:', project.canvasObjects?.length);
           console.log('[ProjectLoader] 🎯 AdminData check:', project.adminData);

           // Clear current canvas
           canvasObjects = [];
           selectedObjectIndex = -1;

           // Load artboard (from root level, not editorState)
           if (project.artboard) {
               artboard = project.artboard;
               // Update global reference
               window.artboard = artboard;
               console.log('[ProjectLoader] Artboard restored from root level:', artboard);
           }

           // Load editor state
           if (project.editorState) {

               // Load canvas background
               if (project.editorState.canvasBackgroundColor) {
                   canvasBackgroundColor = project.editorState.canvasBackgroundColor;
                   window.canvasBackgroundColor = project.editorState.canvasBackgroundColor;
                   console.log('[ProjectLoader] Restored canvas background color:', canvasBackgroundColor);
               }

               // Load zoom state
               if (project.editorState.zoom) {
                   scale = project.editorState.zoom.scale || 1.0;
                   offsetX = project.editorState.zoom.offsetX || 0;
                   offsetY = project.editorState.zoom.offsetY || 0;
                   // Sync global variables
                   window.scale = scale;
                   window.offsetX = offsetX;
                   window.offsetY = offsetY;
                   console.log('[ProjectLoader] Restored zoom state:', { scale, offsetX, offsetY });
               } else {
                   console.log('[ProjectLoader] No zoom state found, using defaults');
               }

               // Load next ID
               if (project.editorState.nextId) {
                   nextId = project.editorState.nextId;
               }

           }

           // Load canvas objects (from root level, not editorState)
           if (project.canvasObjects && project.canvasObjects.length > 0) {
               console.log('[ProjectLoader] Loading canvas objects from root level:', project.canvasObjects.length);
               await loadCanvasObjects(project.canvasObjects);
           } else {
               console.log('[ProjectLoader] No canvas objects found in project data');
           }

           // Load admin data
           if (project.adminData) {
               const adminImageUrl = document.getElementById('adminImageUrl');
               const adminModel = document.getElementById('adminModel');
               const adminPrompt = document.getElementById('adminPrompt');
               const adminPalette = document.getElementById('adminPalette');
               const adminBackgroundType = document.getElementById('adminBackgroundType');
               // 🎯 ADD: Get original palette and object fields
               const adminOriginalPalette = document.getElementById('adminOriginalPalette');
               const adminOriginalObject = document.getElementById('adminOriginalObject');

               if (adminImageUrl) adminImageUrl.value = project.adminData.imageUrl || '';
               if (adminModel) adminModel.value = project.adminData.model || '';
               if (adminPrompt) adminPrompt.value = project.adminData.prompt || '';
               if (adminPalette) adminPalette.value = project.adminData.palette || '';
               if (adminBackgroundType) adminBackgroundType.value = project.adminData.backgroundType || '';
               // 🎯 ADD: Restore original palette and object fields
               if (adminOriginalPalette) adminOriginalPalette.value = project.adminData.originalPalette || '';
               if (adminOriginalObject) adminOriginalObject.value = project.adminData.originalObject || '';

               console.log('[ProjectLoader] 🎯 Restored admin original fields:', {
                   originalPalette: project.adminData.originalPalette,
                   originalObject: project.adminData.originalObject
               });
           }

           // 🎯 RESTORE FONT STYLES AND DECOR STYLES FROM PROJECT (following template loading pattern)
           // IMPORTANT: This must be OUTSIDE the adminData check to access both top-level and adminData locations
           console.log('[ProjectLoader] 🎨 ===== FONT/DECOR STYLES RESTORATION STARTING =====');
           console.log('[ProjectLoader] 🎨 🔍 FONT STYLES LOADING - Checking for font styles...');
           console.log('[ProjectLoader] 🎨 🔍 project object keys:', Object.keys(project));
           console.log('[ProjectLoader] 🎨 🔍 project.fontStylesList exists:', 'fontStylesList' in project);
           console.log('[ProjectLoader] 🎨 🔍 project.fontStylesList value:', project.fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 project.fontStylesList type:', typeof project.fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 project.fontStylesList isArray:', Array.isArray(project.fontStylesList));
           console.log('[ProjectLoader] 🎨 🔍 project.fontStylesList length:', project.fontStylesList?.length);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData exists:', !!project.adminData);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.fontStylesList exists:', project.adminData && 'fontStylesList' in project.adminData);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.fontStylesList value:', project.adminData?.fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.fontStylesList type:', typeof project.adminData?.fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.fontStylesList isArray:', Array.isArray(project.adminData?.fontStylesList));
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.fontStylesList length:', project.adminData?.fontStylesList?.length);

           // Check both locations for font styles (same pattern as template loading)
           console.log('[ProjectLoader] 🎨 🔍 STEP 1: Checking top-level fontStylesList...');
           const topLevelCheck = project.fontStylesList && project.fontStylesList.length > 0;
           console.log('[ProjectLoader] 🎨 🔍 STEP 1 RESULT: topLevelCheck =', topLevelCheck);

           console.log('[ProjectLoader] 🎨 🔍 STEP 2: Checking adminData fontStylesList...');
           const adminDataCheck = project.adminData?.fontStylesList;
           console.log('[ProjectLoader] 🎨 🔍 STEP 2 RESULT: adminDataCheck =', adminDataCheck);

           console.log('[ProjectLoader] 🎨 🔍 STEP 3: Applying selection logic...');
           const fontStylesList = topLevelCheck ? project.fontStylesList : adminDataCheck;
           console.log('[ProjectLoader] 🎨 🔍 STEP 3 RESULT: Selected fontStylesList =', fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 STEP 3 RESULT: fontStylesList type =', typeof fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 STEP 3 RESULT: fontStylesList isArray =', Array.isArray(fontStylesList));
           console.log('[ProjectLoader] 🎨 🔍 STEP 3 RESULT: fontStylesList length =', fontStylesList?.length);

           console.log('[ProjectLoader] 🎨 🔍 STEP 4: Checking if restoration should proceed...');
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: fontStylesList exists =', !!fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: fontStylesList isArray =', Array.isArray(fontStylesList));
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: fontStylesList actual content =', fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: fontStylesList length =', fontStylesList?.length);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: fontStylesList length > 0 =', fontStylesList && fontStylesList.length > 0);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: Each condition breakdown:');
           console.log('[ProjectLoader] 🎨 🔍 STEP 4:   - fontStylesList truthy =', !!fontStylesList);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4:   - Array.isArray(fontStylesList) =', Array.isArray(fontStylesList));
           console.log('[ProjectLoader] 🎨 🔍 STEP 4:   - fontStylesList.length > 0 =', fontStylesList && fontStylesList.length > 0);
           console.log('[ProjectLoader] 🎨 🔍 STEP 4: Combined condition =', fontStylesList && Array.isArray(fontStylesList) && fontStylesList.length > 0);

           if (fontStylesList && Array.isArray(fontStylesList) && fontStylesList.length > 0) {
               console.log('[ProjectLoader] 🎨 ✅ ===== ENTERING FONT STYLES RESTORATION BLOCK =====');
               console.log('[ProjectLoader] 🎨 ✅ Loading font styles:', fontStylesList.length, 'styles');
               console.log('[ProjectLoader] 🎨 ✅ Font styles data:', fontStylesList);

               console.log('[ProjectLoader] 🎨 🔍 STEP 5: Setting window.fontStylesList...');
               window.fontStylesList = JSON.parse(JSON.stringify(fontStylesList));
               console.log('[ProjectLoader] 🎨 ✅ STEP 5 COMPLETE: window.fontStylesList set to:', window.fontStylesList);

               // 🛡️ CRITICAL: Protect the restored data from being cleared
               if (window._fontStylesProtection) {
                   window._fontStylesProtection.protect(window.fontStylesList);
                   console.log('[ProjectLoader] 🎨 🛡️ Font styles data protected after restoration');
               }

               // 🔍 DEBUG: Add a delayed check to see if data persists
               setTimeout(() => {
                   console.log('[ProjectLoader] 🎨 🔍 DELAYED CHECK (1s): window.fontStylesList still exists:', window.fontStylesList);
                   console.log('[ProjectLoader] 🎨 🔍 DELAYED CHECK (1s): window.fontStylesList length:', window.fontStylesList?.length);
                   if (!window.fontStylesList || window.fontStylesList.length === 0) {
                       console.log('[ProjectLoader] 🎨 ❌ DELAYED CHECK: Font styles data was CLEARED! Attempting restore...');
                       if (window._fontStylesProtection) {
                           const restored = window._fontStylesProtection.restore();
                           if (restored) {
                               console.log('[ProjectLoader] 🎨 🛡️ DELAYED CHECK: Font styles data restored from protection');
                           }
                       }
                   }
               }, 1000);

               // Protect the data (same as template loading)
               if (window._fontStylesProtection) {
                   window._fontStylesProtection.protect(fontStylesList);
                   console.log('[ProjectLoader] 🎨 🛡️ Font styles protected');
               }

               // Update the admin field
               const adminFontStylesField = document.getElementById('adminFontStyles');
               if (adminFontStylesField) {
                   adminFontStylesField.value = JSON.stringify(fontStylesList, null, 2);
                   console.log('[ProjectLoader] 🎨 Updated adminFontStyles field');
               }

               // Update status display
               if (window.updateFontStylesStatus) {
                   window.updateFontStylesStatus();
               }

               // Update admin display (same as template loading)
               if (window.updateAdminFontStylesDisplay) {
                   window.updateAdminFontStylesDisplay();
               }

               console.log('[ProjectLoader] 🎨 Font styles restored successfully');
           } else {
               console.log('[ProjectLoader] 🎨 ❌ ===== FONT STYLES RESTORATION FAILED =====');
               console.log('[ProjectLoader] 🎨 ❌ Condition failed for fontStylesList:', fontStylesList);
               console.log('[ProjectLoader] 🎨 ❌ Reason analysis:');
               if (!fontStylesList) {
                   console.log('[ProjectLoader] 🎨 ❌   - fontStylesList is falsy');
               } else if (!Array.isArray(fontStylesList)) {
                   console.log('[ProjectLoader] 🎨 ❌   - fontStylesList is not an array, type:', typeof fontStylesList);
               } else if (fontStylesList.length === 0) {
                   console.log('[ProjectLoader] 🎨 ❌   - fontStylesList is empty array');
               } else {
                   console.log('[ProjectLoader] 🎨 ❌   - Unknown reason, fontStylesList:', fontStylesList);
               }
               console.log('[ProjectLoader] 🎨 ❌ Setting window.fontStylesList to empty array');
               window.fontStylesList = [];
           }

           // Check both locations for decor styles (same pattern as template loading)
           console.log('[ProjectLoader] 🎨 🔍 DECOR STYLES LOADING - Checking for decor styles...');
           console.log('[ProjectLoader] 🎨 🔍 project.decorStylesList:', project.decorStylesList);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.decorStylesList:', project.adminData?.decorStylesList);

           const decorStylesList = (project.decorStylesList && project.decorStylesList.length > 0)
               ? project.decorStylesList
               : project.adminData?.decorStylesList;

           console.log('[ProjectLoader] 🎨 🔍 Combined decorStylesList:', decorStylesList);

           if (decorStylesList && Array.isArray(decorStylesList) && decorStylesList.length > 0) {
               console.log('[ProjectLoader] 🎨 ✅ Loading decor styles:', decorStylesList.length, 'styles');
               window.decorStylesList = JSON.parse(JSON.stringify(decorStylesList));

               // 🛡️ CRITICAL: Protect the restored data from being cleared
               if (window._decorStylesProtection) {
                   window._decorStylesProtection.protect(window.decorStylesList);
                   console.log('[ProjectLoader] 🎨 🛡️ Decor styles data protected after restoration');
               }

               // 🔍 DEBUG: Add a delayed check to see if data persists
               setTimeout(() => {
                   console.log('[ProjectLoader] 🎨 🔍 DELAYED CHECK (1s): window.decorStylesList still exists:', window.decorStylesList);
                   console.log('[ProjectLoader] 🎨 🔍 DELAYED CHECK (1s): window.decorStylesList length:', window.decorStylesList?.length);
                   if (!window.decorStylesList || window.decorStylesList.length === 0) {
                       console.log('[ProjectLoader] 🎨 ❌ DELAYED CHECK: Decor styles data was CLEARED! Attempting restore...');
                       if (window._decorStylesProtection) {
                           const restored = window._decorStylesProtection.restore();
                           if (restored) {
                               console.log('[ProjectLoader] 🎨 🛡️ DELAYED CHECK: Decor styles data restored from protection');
                           }
                       }
                   }
               }, 1000);

               // Update the admin field
               const adminDecorStylesField = document.getElementById('adminDecorStyles');
               if (adminDecorStylesField) {
                   adminDecorStylesField.value = JSON.stringify(decorStylesList, null, 2);
                   console.log('[ProjectLoader] 🎨 Updated adminDecorStyles field');
               }

               // Update status display
               if (window.updateDecorStylesStatus) {
                   window.updateDecorStylesStatus();
               }

               // Update admin display (same as template loading)
               if (window.updateAdminDecorStylesDisplay) {
                   window.updateAdminDecorStylesDisplay();
               }

               console.log('[ProjectLoader] 🎨 Decor styles restored successfully');
           } else {
               console.log('[ProjectLoader] 🎨 ❌ NO DECOR STYLES FOUND in project');
               window.decorStylesList = [];
           }

           // Sync global references
           syncGlobalReferences();

           // Update canvas
           update();

           // 🎨 CSS FILTER RESTORATION FOR PROJECTS (same pattern as templates)
           console.log('[ProjectLoader] 🎨 ===== CSS FILTER RESTORATION STARTING =====');

           // 🔍 DEBUG: Check what CSS filter data exists in project
           console.log('[ProjectLoader] 🎨 🔍 project.cssFilterState exists:', 'cssFilterState' in project);
           console.log('[ProjectLoader] 🎨 🔍 project.cssFilterState value:', project.cssFilterState);
           console.log('[ProjectLoader] 🎨 🔍 project.cssFilterState type:', typeof project.cssFilterState);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.cssFilterState exists:', 'cssFilterState' in (project.adminData || {}));
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.cssFilterState value:', project.adminData?.cssFilterState);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.cssFilterState type:', typeof project.adminData?.cssFilterState);

           // Check for CSS filter state in project data (same dual location pattern)
           const cssFilterState = project.cssFilterState || project.adminData?.cssFilterState;

           // 🔧 CRITICAL FIX: Don't restore CSS filters during project updates to preserve current changes
           const isProjectUpdate = window._isProjectUpdate || false;
           console.log('[ProjectLoader] 🔧 Project update mode:', isProjectUpdate);

           if (cssFilterState && typeof cssFilterState === 'object' && !isProjectUpdate) {
               console.log('[ProjectLoader] 🎨 Found CSS filter state in project:', cssFilterState);
               console.log('[ProjectLoader] 🎨 Restoring CSS filters AFTER canvas objects are loaded...');

               // Restore CSS filter sliders and display values
               if (typeof window.restoreCSSFilterState === 'function') {
                   window.restoreCSSFilterState(cssFilterState);
               } else {
                   console.log('[ProjectLoader] 🎨 restoreCSSFilterState function not available');
               }

               // 🎯 VERIFICATION AND AUTO-APPLICATION WITH AUTO-SELECTION (same as templates)
               setTimeout(() => {
                   console.log('[ProjectLoader] 🎨 Verifying CSS filter application...');

                   // Check if any image has the restored filters applied
                   let filtersApplied = false;
                   let firstImageIndex = -1;

                   if (window.canvasObjects) {
                       for (let i = 0; i < window.canvasObjects.length; i++) {
                           const obj = window.canvasObjects[i];
                           if (obj.type === 'image') {
                               if (firstImageIndex === -1) firstImageIndex = i; // Remember first image

                               if (obj.cssFilterString && obj.cssFilterString !== 'none') {
                                   filtersApplied = true;
                                   console.log(`[ProjectLoader] 🎨 ✅ Filters already applied to image ${i}:`, obj.cssFilterString);
                                   break;
                               }
                           }
                       }
                   }

                   // CRITICAL FIX: Always initialize pipeline, regardless of CSS filters
                   if (firstImageIndex !== -1) {
                       console.log('[ProjectLoader] 🎨 🔧 PIPELINE FIX: Ensuring pipeline initialization...');

                       // Auto-select the first image to ensure pipeline is initialized
                       if (window.canvasObjects[firstImageIndex]) {
                           // Clear all selections first
                           window.canvasObjects.forEach(obj => obj.isSelected = false);

                           // Select the first image
                           window.canvasObjects[firstImageIndex].isSelected = true;
                           window.selectedObjectIndex = firstImageIndex;

                           console.log('[ProjectLoader] 🎨 Image auto-selected for pipeline initialization');

                           // If CSS filters exist, apply them
                           if (!filtersApplied && cssFilterState && typeof cssFilterState === 'object') {
                               console.log('[ProjectLoader] 🎨 Applying CSS filters to initialize pipeline...');
                               if (typeof window.applyImageFilters === 'function') {
                                   window.applyImageFilters();
                                   console.log('[ProjectLoader] 🎨 ✅ CSS filter application complete');
                               }
                           } else if (filtersApplied) {
                               console.log('[ProjectLoader] 🎨 ✅ CSS filters already applied');
                           } else {
                               console.log('[ProjectLoader] 🎨 🔧 No CSS filters, but pipeline will be initialized by other effects');
                           }

                           // CRITICAL: Trigger pipeline update to ensure it's ready for other effects
                           if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
                               console.log('[ProjectLoader] 🎨 🔧 Triggering pipeline update to ensure initialization...');
                               window.imageEffectsPipeline.triggerPipelineUpdate('project-load-initialization');
                           }
                       }
                   } else {
                       console.log('[ProjectLoader] 🎨 ℹ️ No images found to initialize pipeline');
                   }
               }, 300); // Small delay to ensure everything is fully processed
           } else if (isProjectUpdate) {
               console.log('[ProjectLoader] 🔧 Skipping CSS filter restoration during project update to preserve current changes');
           } else {
               console.log('[ProjectLoader] 🎨 No CSS filter state found in project, using defaults');
           }

           // 🎨 DUOTONE AND GLITCH RESTORATION FOR PROJECTS (same pattern as templates)
           console.log('[ProjectLoader] 🎨 ===== DUOTONE AND GLITCH RESTORATION STARTING =====');

           // 🔍 DEBUG: Check what duotone and glitch data exists in project
           console.log('[ProjectLoader] 🎨 🔍 project.duotoneState exists:', 'duotoneState' in project);
           console.log('[ProjectLoader] 🎨 🔍 project.duotoneState value:', project.duotoneState);
           console.log('[ProjectLoader] 🎨 🔍 project.duotoneState type:', typeof project.duotoneState);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.duotoneState exists:', 'duotoneState' in (project.adminData || {}));
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.duotoneState value:', project.adminData?.duotoneState);
           console.log('[ProjectLoader] 🎨 🔍 project.glitchState exists:', 'glitchState' in project);
           console.log('[ProjectLoader] 🎨 🔍 project.glitchState value:', project.glitchState);
           console.log('[ProjectLoader] 🎨 🔍 project.glitchState type:', typeof project.glitchState);
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.glitchState exists:', 'glitchState' in (project.adminData || {}));
           console.log('[ProjectLoader] 🎨 🔍 project.adminData?.glitchState value:', project.adminData?.glitchState);

           // Check for duotone state in project data (same dual location pattern)
           const duotoneState = project.duotoneState || project.adminData?.duotoneState;
           const glitchState = project.glitchState || project.adminData?.glitchState;

           if (duotoneState && typeof duotoneState === 'object' && Object.keys(duotoneState).length > 0) {
               console.log('[ProjectLoader] 🎨 Found duotone state in project:', duotoneState);
               console.log('[ProjectLoader] 🎨 Restoring duotone effects...');

               // Restore duotone state using existing function
               if (typeof window.restoreDuotoneState === 'function') {
                   setTimeout(() => {
                       window.restoreDuotoneState(duotoneState);
                       console.log('[ProjectLoader] 🎨 Duotone effects restored');
                   }, 400); // Delay to ensure CSS filters are applied first
               } else {
                   console.log('[ProjectLoader] 🎨 restoreDuotoneState function not available');
               }
           } else {
               console.log('[ProjectLoader] 🎨 No duotone state found in project, using defaults');
           }

           if (glitchState && typeof glitchState === 'object' && Object.keys(glitchState).length > 0) {
               console.log('[ProjectLoader] 🎨 Found glitch state in project:', glitchState);
               console.log('[ProjectLoader] 🎨 Restoring glitch effects...');

               // Restore glitch state using existing function
               if (typeof window.restoreGlitchState === 'function') {
                   setTimeout(() => {
                       window.restoreGlitchState(glitchState);
                       console.log('[ProjectLoader] 🎨 Glitch effects restored');
                   }, 500); // Delay to ensure duotone is applied first
               } else {
                   console.log('[ProjectLoader] 🎨 restoreGlitchState function not available');
               }
           } else {
               console.log('[ProjectLoader] 🎨 No glitch state found in project, using defaults');
           }

           // Restore halftone effect state (after glitch)
           const halftoneState = project.halftoneState || project.adminData?.halftoneState;
           if (halftoneState && typeof halftoneState === 'object' && Object.keys(halftoneState).length > 0) {
               console.log('[ProjectLoader] 🎨 Found halftone state in project:', halftoneState);
               console.log('[ProjectLoader] 🎨 Restoring halftone effects...');

               // Restore halftone state using existing function
               if (typeof window.restoreHalftoneState === 'function') {
                   setTimeout(() => {
                       window.restoreHalftoneState(halftoneState);
                       console.log('[ProjectLoader] 🎨 Halftone effects restored');
                   }, 600); // Delay to ensure glitch is applied first
               } else {
                   console.log('[ProjectLoader] 🎨 restoreHalftoneState function not available');
               }
           } else {
               console.log('[ProjectLoader] 🎨 No halftone state found in project, using defaults');
           }

           console.log('[ProjectLoader] 🎨 ===== FONT/DECOR STYLES RESTORATION COMPLETED =====');
           console.log('[ProjectLoader] 🎨 Final window.fontStylesList:', window.fontStylesList);
           console.log('[ProjectLoader] 🎨 Final window.decorStylesList:', window.decorStylesList);

           // Restore guidelines state
           if (project.guidelinesState && typeof window.restoreGuidelinesState === 'function') {
               console.log('[ProjectLoader] 📏 Restoring guidelines state:', project.guidelinesState);
               window.restoreGuidelinesState(project.guidelinesState);
           } else {
               console.log('[ProjectLoader] 📏 No guidelines state found in project or function not available');
           }

           // Restore layout rectangles state
           if (project.layoutRectanglesState && typeof window.restoreLayoutRectanglesState === 'function') {
               console.log('[ProjectLoader] 📐 Restoring layout rectangles state:', project.layoutRectanglesState);
               window.restoreLayoutRectanglesState(project.layoutRectanglesState);
           } else {
               console.log('[ProjectLoader] 📐 No layout rectangles state found in project or function not available');
           }

           console.log('[ProjectLoader] Project loaded successfully');

           // Mark system as fully loaded to stop protection loops
           if (window.markAsFullyLoaded) {
               window.markAsFullyLoaded();
           }

       } catch (error) {
           console.error('[ProjectLoader] Error loading project data:', error);
           throw error;
       }
   }

   async function loadCanvasObjects(objects) {
       console.log('[ProjectLoader] Loading canvas objects:', objects.length);

       // Sort objects by layerOrder to ensure correct loading order
       const sortedObjects = [...objects].sort((a, b) => {
           const orderA = a.layerOrder !== undefined ? a.layerOrder : a.zIndex || 0;
           const orderB = b.layerOrder !== undefined ? b.layerOrder : b.zIndex || 0;
           return orderA - orderB;
       });

       console.log('[ProjectLoader] Loading objects in layer order:', sortedObjects.map(obj => ({
           type: obj.type,
           text: obj.text || obj.imageUrl,
           layerOrder: obj.layerOrder,
           zIndex: obj.zIndex
       })));

       // Pre-allocate array with correct size to preserve order
       const loadedObjects = new Array(sortedObjects.length);

       const loadPromises = sortedObjects.map(async (objData, index) => {
           try {
               if (objData.type === 'text') {
                   console.log('[ProjectLoader] Loading text object at index', index, ':', objData.text);
                   const textObj = createTextObject(objData);
                   loadedObjects[index] = textObj;

               } else if (objData.type === 'image') {
                   console.log('[ProjectLoader] Loading image object at index', index, ':', objData.imageUrl);

                   return new Promise((resolve) => {
                       const img = new Image();
                       img.crossOrigin = 'anonymous';

                       img.onload = () => {
                           const imageObj = createImageObject(img, objData);
                           loadedObjects[index] = imageObj;
                           console.log('[ProjectLoader] Image object loaded at index', index);
                           resolve();
                       };

                       img.onerror = (err) => {
                           console.error('[ProjectLoader] Failed to load image:', objData.imageUrl, err);
                           resolve(); // Continue even if image fails
                       };

                       img.src = objData.imageUrl;
                   });
               }
           } catch (error) {
               console.error('[ProjectLoader] Error loading object:', error);
           }
       });

       // Wait for all objects to load
       await Promise.all(loadPromises.filter(p => p instanceof Promise));

       // Add loaded objects to canvasObjects in the correct order
       loadedObjects.forEach((obj, index) => {
           if (obj) {
               canvasObjects.push(obj);
               console.log('[ProjectLoader] Added object to canvas at position', canvasObjects.length - 1, ':', obj.type, obj.text || obj.imageUrl);
           }
       });

       console.log('[ProjectLoader] All canvas objects loaded in correct layer order');

       // Restore mask relationships after all objects are loaded (SAME AS TEMPLATE LOADING)
       restoreMaskRelationships();

       // Auto-apply masks after restoration (SAME AS TEMPLATE LOADING)
       autoApplyMasksAfterLoad();

       // Apply SVG colors for objects that have svgColor set (SAME AS TEMPLATE LOADING)
       console.log('[ProjectLoader] 🎨 Checking for SVG objects with svgColor to recolor...');
       canvasObjects.forEach(async (obj, index) => {
           if (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg') && obj.svgColor) {
               console.log(`[ProjectLoader] 🎨 Found SVG object with svgColor: ${obj.svgColor}, triggering recoloring...`);
               try {
                   await recolorSVG(obj, obj.svgColor);
                   console.log(`[ProjectLoader] 🎨 Successfully recolored SVG object ${obj.id}`);
               } catch (error) {
                   console.error(`[ProjectLoader] 🎨 Error recoloring SVG object ${obj.id}:`, error);
               }
           }
       });
   }

   // --- Object Factories ---
   function createTextObject(options = {}) {
       console.log('🏭 CREATE TEXT OBJECT: Called with options:', options);
       console.log('🏭 CREATE TEXT OBJECT: Current nextId =', nextId);

       const defaults = {
           id: nextId++,
           type: 'text',
           text: "TEXT",
           x: w / 2,
           y: h / 2,
           color: "#3b82f6",
           gradient: null, // For gradient colors
           fontFamily: "Poppins",
           fontSize: 150,
           bold: true,
           italic: false,
           rotation: 0,
           letterSpacing: 0, // Default letter spacing (0 = normal)
           opacity: 100, // Default opacity (100% = fully opaque)
           isSelected: false,
           effectMode: 'normal',
           decorationMode: 'noDecoration',
           strokeMode: 'noStroke',
           strokeOpacity: 100, // Independent stroke opacity for text
           templateId: null, // Template ID for replacement system
           // Persistent parameter system
           newColorIntensity: 'N/A', // Persistent Color Intensity value
           newTemplateId: 'N/A', // Persistent Template ID value
           shadowMode: 'noShadow', // Always start with no shadow effect
           skewX: 0,
           skewY: 0,
           warpCurve: 100,
           warpOffset: 10,
           warpHeight: 100,
           warpBottom: 150,
           warpTriangle: false,
           warpShiftCenter: 100,
           circleDiameter: 600,
           circleKerning: 0,
           circleFlip: false,
           curveAmount: 40,
           curveKerning: 0,
           curveFlip: false,
           gridDistortCols: 2,
           gridDistortRows: 1,
           gridDistortPadding: 120,
           gridDistortIntensity: 100,

           // Default values for perspective shadow
           perspectiveShadowColor: '#333333',
           perspectiveShadowOpacity: 100,
           perspectiveShadowOffset: 6,
           perspectiveShadowAngle: 105,
           perspectiveShadowBlur: 2,
           perspectiveShadowIntensity: 16,
           gridDistortVerticalOnly: false,
           hLineWeight: 3,
           hLineDist: 7,
           hLineColor: "#0000FF",
           hLineOpacity: 100, // Opacity for horizontal lines
           hLineCoverage: 100, // Coverage for horizontal lines decoration
           ccDist: 50,
           ccColor: "#00FF00",
           ccOpacity: 100, // Opacity for color cut
           ccFillDir: "top",
           ccCoverage: 100, // Coverage for color cut decoration
           oLineWeight: 4,
           oLineDist: 3,
           oLineColor: "#0000FF",
           oOpacity: 100, // Opacity for oblique lines
           oCoverage: 100, // Coverage for oblique lines decoration
           flcDist: 62,
           flcDir: 'top',
           flcColor: '#cccccc',
           flcOpacity: 100, // Opacity for fading lines color
           flcWeight: 3,
           flcSpacing: 10,
           flcCoverage: 100, // Coverage for fading color cut decoration
           strokeWidth: 1,
           strokeColor: '#000000',
           shadowColor: '#000000',
           shadowOffsetX: 5,
           shadowOffsetY: 5,
           shadowBlur: 10,
           blockShadowColor: '#000000',
           blockShadowOpacity: 100,
           blockShadowOffset: 40,
           blockShadowAngle: -58,
           blockShadowBlur: 5,
           blockShadowPerspective: false,
           blockShadowPerspectiveIntensity: 50,

           perspectiveShadowOutlineColor: '#d1d5db',
           perspectiveShadowOutlineOpacity: 100,
           perspectiveShadowOutlineWidth: 3,
           perspectiveShadowOutlineOffsetX: 2,
           perspectiveShadowOutlineOffsetY: -3,
           lineShadowColor: '#AAAAAA',
           lineShadowDist: 15,
           lineShadowAngle: -45,
           lineShadowThickness: 5,
           d3dPrimaryColor: '#000000',
           d3dPrimaryOpacity: 100,
           d3dOffset: 36,
           d3dAngle: -63,
           d3dBlur: 5,
           d3dSecondaryColor: '#00FF00',
           d3dSecondaryOpacity: 100,
           d3dSecondaryWidth: 4, // Changed from 0 to 4 to enable front outline by default
           d3dSecondaryOffsetX: -5,
           d3dSecondaryOffsetY: -5,
           // Text box and alignment properties
           textBoxWidth: 0, // 0 = unlimited, any other value = character limit per line
           textAlign: 'left', // left, center, right, justify
           lineHeight: 1.2, // Line height multiplier
           // Initialize gridDistort object
           gridDistort: {
               gridCols: 3,
               gridRows: 2,
               gridPadding: 120,
               intensity: 1.0,
               showGrid: false, // Always start with grid hidden
               lastText: "TEXT", // Initialize with the default text
               controlPoints: [], // Will be populated by initializeGridPoints only when needed
               relativeControlPoints: [] // Will be populated by storeRelativeControlPoints
           },
           // Initialize mesh warp object
           meshWarp: {
               controlPoints: [], // Current control point positions
               initialControlPoints: [], // Original control point positions
               relativeControlPoints: [], // Relative positions for preserving distortion
               hasCustomDistortion: false, // Track if user has customized the distortion
               showGrid: true, // Grid visibility
               gridRect: null, // Grid bounds
               initialized: false // Whether mesh has been initialized
           }
       };

       const textObj = { ...defaults, ...options };

       // Handle deep merge for gridDistort object if provided in options
       if (options.gridDistort) {
           textObj.gridDistort = {
               ...defaults.gridDistort,
               ...options.gridDistort
           };
           console.log(`[CreateTextObject] Merged Grid Distort data for text "${textObj.text}":`, {
               controlPointsCount: textObj.gridDistort.controlPoints ? textObj.gridDistort.controlPoints.length : 0,
               relativeControlPointsCount: textObj.gridDistort.relativeControlPoints ? textObj.gridDistort.relativeControlPoints.length : 0,
               hasGridBounds: !!textObj.gridDistort.gridBounds
           });
       }

       // Handle deep merge for meshWarp object if provided in options (existing functionality)
       if (options.meshWarp) {
           textObj.meshWarp = {
               ...defaults.meshWarp,
               ...options.meshWarp
           };
           console.log(`[CreateTextObject] Merged Mesh Warp data for text "${textObj.text}":`, {
               controlPointsCount: textObj.meshWarp.controlPoints ? textObj.meshWarp.controlPoints.length : 0,
               hasCustomDistortion: textObj.meshWarp.hasCustomDistortion
           });
       }

       // If the text was changed in options, update the lastText
       if (options.text) {
           textObj.gridDistort.lastText = options.text;
       }

       console.log('🏭 CREATE TEXT OBJECT: Created text object:', {
           id: textObj.id,
           text: textObj.text,
           type: textObj.type
       });
       console.log('🏭 CREATE TEXT OBJECT: New nextId =', nextId);

       // Sync global references to ensure nextId is updated globally
       syncGlobalReferences();
       console.log('🏭 CREATE TEXT OBJECT: Synced global references, window.nextId =', window.nextId);

       return textObj;
   }
   function createImageObject(imgElement, options = {}) {
       console.log('🔧 CREATE IMAGE OBJECT: Called with options:', options);
       console.log('🔧 CREATE IMAGE OBJECT: imgElement dimensions:', imgElement.naturalWidth, 'x', imgElement.naturalHeight);

       const defaults = {
           id: nextId++,
           type: 'image',
           image: imgElement,
           x: w / 2,
           y: h / 2,
           scale: 1.0,
           rotation: 0,
           isSelected: false,
           originalWidth: imgElement.naturalWidth,
           originalHeight: imgElement.naturalHeight,
           imageUrl: options.imageUrl || imgElement.src,
           generationId: null,
           isFromGeneration: false,
           backgroundRemoved: false,
           templateId: null, // Template ID for replacement system
           // Shadow properties
           shadowMode: 'none',
           shadowColor: '#000000',
           shadowOffsetX: 5,
           shadowOffsetY: 5,
           shadowBlur: 10,
           shadowOpacity: 100,
           // Stroke properties
           strokeMode: 'none',
           strokeWidth: 3,
           strokeColor: '#000000',
           strokeOpacity: 100, // Independent stroke opacity
           // Image opacity
           opacity: 100,
           // Masking properties
           isMasked: false,
           maskShapeId: null, // ID of the shape object used as mask
           maskShape: null, // Reference to the mask shape object (not persisted)
           // Color intensity for smart palette colors
           colorIntensity: 'no-change', // Default to no change for new image objects
           // Persistent parameter system
           newColorIntensity: 'N/A', // Persistent Color Intensity value
           newTemplateId: 'N/A' // Persistent Template ID value
       };

       const finalObject = { ...defaults, ...options };
       console.log('🔧 CREATE IMAGE OBJECT: Final object created:', finalObject);
       console.log('🔧 CREATE IMAGE OBJECT: Final scale value:', finalObject.scale);

       // Sync global references to ensure nextId is updated globally
       syncGlobalReferences();
       console.log('🔧 CREATE IMAGE OBJECT: Synced global references, window.nextId =', window.nextId);

       return finalObject;
   }

   // --- Performance Helpers ---
   function debugLog(...args) {
       if (DEBUG_MODE) {
           console.log(...args);
       }
   }

   function performanceLog(...args) {
       if (DEBUG_MODE && !isDuringMovement) {
           console.log(...args);
       }
   }

   function criticalLog(...args) {
       // Always log critical messages
       console.log(...args);
   }

   function checkFontLoaded(fontString) {
       // Use cache to avoid repeated font checks
       if (fontLoadCache.has(fontString)) {
           performanceStats.fontCacheHits++;
           return fontLoadCache.get(fontString);
       }

       performanceStats.fontCacheMisses++;
       const isLoaded = document.fonts.check(fontString);
       fontLoadCache.set(fontString, isLoaded);
       return isLoaded;
   }

   // Performance monitoring
   let performanceStats = {
       totalRenders: 0,
       movementRenders: 0,
       averageRenderTime: 0,
       maxRenderTime: 0,
       fontCacheHits: 0,
       fontCacheMisses: 0,
       lastResetTime: performance.now()
   };

   function updatePerformanceStats(renderTime) {
       performanceStats.totalRenders++;
       if (isDuringMovement) {
           performanceStats.movementRenders++;
       }

       // Update average render time
       performanceStats.averageRenderTime =
           (performanceStats.averageRenderTime * (performanceStats.totalRenders - 1) + renderTime) / performanceStats.totalRenders;

       // Update max render time
       if (renderTime > performanceStats.maxRenderTime) {
           performanceStats.maxRenderTime = renderTime;
       }
   }

   function resetPerformanceStats() {
       performanceStats = {
           totalRenders: 0,
           movementRenders: 0,
           averageRenderTime: 0,
           maxRenderTime: 0,
           fontCacheHits: 0,
           fontCacheMisses: 0,
           lastResetTime: performance.now()
       };
       renderCount = 0;
       criticalLog('Performance stats reset');
   }

   function getPerformanceReport() {
       const uptime = performance.now() - performanceStats.lastResetTime;
       const report = {
           ...performanceStats,
           uptimeMs: uptime,
           rendersPerSecond: (performanceStats.totalRenders / (uptime / 1000)).toFixed(2),
           fontCacheSize: fontLoadCache.size,
           fontCacheHitRate: performanceStats.fontCacheHits + performanceStats.fontCacheMisses > 0
               ? ((performanceStats.fontCacheHits / (performanceStats.fontCacheHits + performanceStats.fontCacheMisses)) * 100).toFixed(1) + '%'
               : 'N/A'
       };
       return report;
   }

   function toggleDebugMode() {
       DEBUG_MODE = !DEBUG_MODE;
       criticalLog(`Debug mode ${DEBUG_MODE ? 'enabled' : 'disabled'}`);
       if (DEBUG_MODE) {
           criticalLog('Performance report:', getPerformanceReport());
       }
   }

   function togglePerformanceMode() {
       PERFORMANCE_MODE = !PERFORMANCE_MODE;
       criticalLog(`Performance mode ${PERFORMANCE_MODE ? 'enabled' : 'disabled'}`);
       if (PERFORMANCE_MODE) {
           criticalLog('Performance optimizations active: reduced shadow steps during movement, render throttling, optimized logging');
       } else {
           criticalLog('Performance optimizations disabled: full quality rendering, all logging enabled');
       }
   }

   // Update performance indicator
   function updatePerformanceIndicator() {
       const indicator = document.getElementById('performanceIndicator');
       const toggleBtn = document.getElementById('performanceToggleBtn');

       if (indicator && toggleBtn) {
           if (PERFORMANCE_MODE) {
               indicator.textContent = '🟢'; // Green for performance mode on
               indicator.title = 'Performance mode ON - Click to view report';
               toggleBtn.classList.add('active');
           } else {
               indicator.textContent = '🔴'; // Red for performance mode off
               indicator.title = 'Performance mode OFF - Click to view report';
               toggleBtn.classList.remove('active');
           }
       }
   }

   // Expose functions to global scope for console access
   window.toggleDebugMode = toggleDebugMode;
   window.togglePerformanceMode = togglePerformanceMode;
   window.getPerformanceReport = getPerformanceReport;
   window.resetPerformanceStats = resetPerformanceStats;
   window.updatePerformanceIndicator = updatePerformanceIndicator;

   // --- Helpers ---
   function hexToRgba(hex, alpha = 1) { let r = 0, g = 0, b = 0; if (hex.length === 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); } else if (hex.length === 7) { r = parseInt(hex[1] + hex[2], 16); g = parseInt(hex[3] + hex[4], 16); b = parseInt(hex[5] + hex[6], 16); } if (isNaN(r) || isNaN(g) || isNaN(b)) { console.warn(`Invalid hex: ${hex}`); return 'rgba(0,0,0,0)'; } return `rgba(${r},${g},${b},${alpha})`; }
   function calculateOffset(distance, angleDegrees) { const angleRadians = angleDegrees * (Math.PI / 180); return { x: distance * Math.cos(angleRadians), y: distance * Math.sin(angleRadians) }; }

   // --- Coordinate Conversion ---
   function getCanvasCoordinates(event) { const rect = canvas.getBoundingClientRect(); let clientX, clientY; if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else { clientX = event.clientX; clientY = event.clientY; } return { x: clientX - rect.left, y: clientY - rect.top }; }
   function canvasToWorld(canvasX, canvasY) { return { x: (canvasX - offsetX) / scale, y: (canvasY - offsetY) / scale }; }
   function worldToCanvas(worldX, worldY) { return { x: worldX * scale + offsetX, y: worldY * scale + offsetY }; }

   // --- Simple Gradient Creation ---
   function createSimpleGradient(targetCtx, textObj, letterIndex = null, totalLetters = null) {
       if (!textObj.gradient || textObj.gradient.type === 'solid') {
           return null;
       }

       console.log('🎨 Creating simple gradient for text:', textObj.text, 'letterIndex:', letterIndex, 'totalLetters:', totalLetters);

       // Determine if we're rendering a single letter for distort effects
       const isRenderingSingleLetter = (letterIndex !== null && totalLetters !== null && totalLetters > 1);

       let textWidth, textHeight;

       if (isRenderingSingleLetter) {
           // For single letter rendering, we need to calculate the gradient based on the full text
           // but position it correctly for this specific letter
           const fullTextMetrics = targetCtx.measureText(textObj.originalText || textObj.text);
           const fullTextWidth = fullTextMetrics.width;
           textWidth = fullTextWidth;
           textHeight = textObj.fontSize;
           console.log('🎨 Single letter gradient - Full text dimensions:', { textWidth, textHeight });
       } else {
           // For normal rendering, use the actual text being rendered
           const textMetrics = targetCtx.measureText(textObj.text);
           textWidth = textMetrics.width;
           textHeight = textObj.fontSize;
           console.log('🎨 Normal gradient - Text dimensions:', { textWidth, textHeight });
       }

       let gradient;

       if (textObj.gradient.type === 'linear') {
           // Extract angle from gradient value (e.g., "linear-gradient(125deg, ...)")
           let angle = 0; // Default to horizontal
           if (textObj.gradient.value) {
               const angleMatch = textObj.gradient.value.match(/linear-gradient\((\d+)deg/);
               if (angleMatch) {
                   angle = parseInt(angleMatch[1]);
               }
           }

           // Convert angle to radians and calculate direction vector
           // CSS gradients: 0deg = top to bottom, 90deg = left to right
           // Canvas gradients: 0deg = left to right, 90deg = top to bottom
           // So we need to adjust by 90 degrees to match CSS convention
           const adjustedAngle = angle + 90;
           const angleRad = (adjustedAngle * Math.PI) / 180;
           const cos = Math.cos(angleRad);
           const sin = Math.sin(angleRad);

           if (isRenderingSingleLetter) {
               // For single letters, create a gradient that spans the letter width with correct angle
               const letterWidth = targetCtx.measureText(textObj.text).width;
               const letterHeight = textHeight;

               // Calculate gradient line length based on letter dimensions and angle
               const diagonal = Math.sqrt(letterWidth * letterWidth + letterHeight * letterHeight);
               const halfLength = diagonal / 2;

               // Calculate gradient endpoints
               const x1 = -halfLength * cos;
               const y1 = -halfLength * sin;
               const x2 = halfLength * cos;
               const y2 = halfLength * sin;

               gradient = targetCtx.createLinearGradient(x1, y1, x2, y2);
               console.log('🎨 Created single letter linear gradient:', {
                   x1, y1, x2, y2, letterWidth, letterIndex, totalLetters, angle, angleRad
               });
           } else {
               // NEW HIGH-RESOLUTION APPROACH: Use same method as canvas-test.html
               console.log('🎨 LINEAR GRADIENT (NEW APPROACH): Creating gradient for full text using canvas-test method');

               // Use text metrics for accurate gradient sizing (same as canvas-test.html)
               const textMetrics = targetCtx.measureText(textObj.text);
               const actualTextWidth = textMetrics.width;

               // Create linear gradient across the text width (same as canvas-test.html)
               gradient = targetCtx.createLinearGradient(
                   -actualTextWidth/2, 0,
                   actualTextWidth/2, 0
               );

               console.log('🎨 LINEAR GRADIENT (NEW APPROACH): Created gradient with text metrics:', {
                   startX: -actualTextWidth/2,
                   startY: 0,
                   endX: actualTextWidth/2,
                   endY: 0,
                   actualTextWidth: actualTextWidth,
                   originalAngle: angle,
                   note: 'Using simplified horizontal gradient like canvas-test.html'
               });
           }

       } else if (textObj.gradient.type === 'radial') {
           // NEW HIGH-RESOLUTION APPROACH: Use same method as canvas-test.html
           console.log('🎨 RADIAL GRADIENT (NEW APPROACH): Creating radial gradient using canvas-test method');

           // Use text metrics for accurate gradient sizing (same as canvas-test.html)
           const textMetrics = targetCtx.measureText(textObj.text);
           const actualTextWidth = textMetrics.width;
           const radius = actualTextWidth / 2;

           const centerX = 0;
           const centerY = 0;

           gradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
           console.log('🎨 RADIAL GRADIENT (NEW APPROACH): Created radial gradient with text metrics:', {
               centerX,
               centerY,
               radius,
               actualTextWidth,
               note: 'Using text-width-based radius like canvas-test.html'
           });
       }

       // Add color stops
       if (gradient && textObj.gradient.gradient.colors) {
           if (isRenderingSingleLetter && letterIndex !== null && totalLetters !== null) {
               // For single letters, calculate which portion of the gradient this letter should show
               const letterSpacing = textObj._effectiveLetterSpacing || 0;

               // Calculate the position of this letter within the full text
               let letterStartX = -textWidth / 2;
               for (let i = 0; i < letterIndex; i++) {
                   const prevLetter = (textObj.originalText || textObj.text)[i];
                   letterStartX += targetCtx.measureText(prevLetter).width + letterSpacing;
               }

               const letterWidth = targetCtx.measureText(textObj.text).width;
               const letterEndX = letterStartX + letterWidth;

               // Convert letter position to percentage of full text width
               const letterStartPercent = ((letterStartX + textWidth / 2) / textWidth) * 100;
               const letterEndPercent = ((letterEndX + textWidth / 2) / textWidth) * 100;

               console.log('🎨 Letter gradient mapping:', {
                   letterIndex, letterStartPercent, letterEndPercent,
                   letterStartX, letterEndX, textWidth, letterWidth
               });

               // Create color stops that represent only this letter's portion of the gradient
               const relevantStops = [];

               // Add color stops that fall within this letter's range
               textObj.gradient.gradient.colors.forEach(colorStop => {
                   const stopPercent = colorStop.position;

                   if (stopPercent >= letterStartPercent && stopPercent <= letterEndPercent) {
                       // This color stop falls within the letter's range
                       const relativePosition = (stopPercent - letterStartPercent) / (letterEndPercent - letterStartPercent);
                       relevantStops.push({
                           position: relativePosition,
                           color: colorStop.color
                       });
                   }
               });

               // If no stops fall within the range, interpolate the color
               if (relevantStops.length === 0) {
                   // Find the color at the letter's center
                   const letterCenterPercent = (letterStartPercent + letterEndPercent) / 2;
                   const interpolatedColor = interpolateGradientColor(textObj.gradient.gradient.colors, letterCenterPercent);
                   relevantStops.push({
                       position: 0,
                       color: interpolatedColor
                   });
                   relevantStops.push({
                       position: 1,
                       color: interpolatedColor
                   });
               } else {
                   // Add boundary colors if needed
                   if (relevantStops[0].position > 0) {
                       const startColor = interpolateGradientColor(textObj.gradient.gradient.colors, letterStartPercent);
                       relevantStops.unshift({
                           position: 0,
                           color: startColor
                       });
                   }
                   if (relevantStops[relevantStops.length - 1].position < 1) {
                       const endColor = interpolateGradientColor(textObj.gradient.gradient.colors, letterEndPercent);
                       relevantStops.push({
                           position: 1,
                           color: endColor
                       });
                   }
               }

               // Apply the calculated color stops
               relevantStops.forEach(stop => {
                   gradient.addColorStop(stop.position, stop.color);
                   console.log('🎨 Added letter color stop:', stop);
               });

           } else {
               // Normal gradient for full text
               textObj.gradient.gradient.colors.forEach(colorStop => {
                   gradient.addColorStop(colorStop.position / 100, colorStop.color);
                   console.log('🎨 Added color stop:', colorStop);
               });
           }
       }

       return gradient;
   }

   // Helper function to interpolate color at a specific position in a gradient
   function interpolateGradientColor(colorStops, targetPercent) {
       // Sort color stops by position
       const sortedStops = [...colorStops].sort((a, b) => a.position - b.position);

       // If target is before first stop, return first color
       if (targetPercent <= sortedStops[0].position) {
           return sortedStops[0].color;
       }

       // If target is after last stop, return last color
       if (targetPercent >= sortedStops[sortedStops.length - 1].position) {
           return sortedStops[sortedStops.length - 1].color;
       }

       // Find the two stops that bracket our target position
       for (let i = 0; i < sortedStops.length - 1; i++) {
           const stop1 = sortedStops[i];
           const stop2 = sortedStops[i + 1];

           if (targetPercent >= stop1.position && targetPercent <= stop2.position) {
               // Interpolate between these two colors
               const ratio = (targetPercent - stop1.position) / (stop2.position - stop1.position);
               return interpolateColors(stop1.color, stop2.color, ratio);
           }
       }

       // Fallback to first color
       return sortedStops[0].color;
   }

   // Helper function to interpolate between two hex colors
   function interpolateColors(color1, color2, ratio) {
       // Convert hex to RGB
       const rgb1 = hexToRgb(color1);
       const rgb2 = hexToRgb(color2);

       if (!rgb1 || !rgb2) return color1; // Fallback if conversion fails

       // Interpolate each channel
       const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio);
       const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio);
       const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio);

       // Convert back to hex
       return rgbToHex(r, g, b);
   }

   // Helper function to convert hex to RGB
   function hexToRgb(hex) {
       const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
       return result ? {
           r: parseInt(result[1], 16),
           g: parseInt(result[2], 16),
           b: parseInt(result[3], 16)
       } : null;
   }

   // Helper function to convert RGB to hex
   function rgbToHex(r, g, b) {
       return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
   }

   // --- Font and Bounds ---
   function setTextContextOn(targetCtx, textObj, letterIndex = null, totalLetters = null) {
       // FONT VARIANT SYSTEM: Use actual font files instead of CSS bold/italic
       let fontFamily = textObj.fontFamily;
       let fontStyle = "normal";
       let fontWeight = "normal";

       // Check if we need to load a font variant (bold/italic)
       if (textObj.bold || textObj.italic) {
           const bold = textObj.bold || false;
           const italic = textObj.italic || false;

           // Determine the variant needed
           let variant = 'regular';
           if (bold && italic) variant = 'boldItalic';
           else if (bold) variant = 'bold';
           else if (italic) variant = 'italic';

           console.log(`🔤 Need font variant: ${fontFamily} ${variant} (bold: ${bold}, italic: ${italic})`);

           // Check if font variant detector is available and variant exists
           if (window.fontVariantDetector &&
               window.fontVariantDetector.initialized &&
               window.fontVariantDetector.isVariantAvailable(fontFamily, variant)) {

               console.log(`🔤 Font variant ${variant} is available for ${fontFamily}`);

               // For variants, use the unique font family name directly
               const uniqueFontFamily = variant === 'regular' ? fontFamily : `${fontFamily}-${variant}`;

               // Check if the unique font family is loaded in the browser
               const loadedFonts = Array.from(document.fonts).map(f => f.family);
               console.log(`🔤 Looking for font: ${uniqueFontFamily}`);
               console.log(`🔤 Available fonts containing "${fontFamily}":`, loadedFonts.filter(f => f.includes(fontFamily)));

               if (loadedFonts.includes(uniqueFontFamily)) {
                   console.log(`✅ Using preloaded font variant: ${uniqueFontFamily}`);
                   fontFamily = uniqueFontFamily;
                   fontStyle = "normal";
                   fontWeight = "normal";
               } else {
                   console.log(`❌ Font variant ${uniqueFontFamily} not found, using regular font`);
                   fontFamily = textObj.fontFamily;
                   fontStyle = "normal";
                   fontWeight = "normal";
               }
           } else {
               // Variant not available or detector not ready - use regular font
               console.log(`🔤 Font variant ${variant} not available for ${fontFamily}, using regular`);
               fontFamily = textObj.fontFamily;
               fontStyle = "normal";
               fontWeight = "normal";
           }
       } else {
           // No bold/italic needed, use regular font
           fontFamily = textObj.fontFamily;
           fontStyle = "normal";
           fontWeight = "normal";
       }

       // Set the font with proper style and weight
       targetCtx.font = `${fontStyle} ${fontWeight} ${textObj.fontSize}px "${fontFamily}"`;

       // Enable high-quality text rendering
       targetCtx.textRenderingOptimization = 'optimizeQuality';
       targetCtx.imageSmoothingEnabled = true;
       targetCtx.imageSmoothingQuality = 'high';

       // Log font rendering details for debugging jagged text
       if (textObj.fontSize < 200) { // Only log for smaller fonts where jagginess is visible
           console.log(`🔤 [FONT-DEBUG] Font size: ${textObj.fontSize}px, Text: "${textObj.text}"`);
           console.log(`🔤 [FONT-DEBUG] Canvas dimensions: ${targetCtx.canvas.width}x${targetCtx.canvas.height}`);
           console.log(`🔤 [FONT-DEBUG] Canvas scaleFactor: ${targetCtx.canvas.scaleFactor}`);
           console.log(`🔤 [FONT-DEBUG] Current transform:`, targetCtx.getTransform());
           console.log(`🔤 [FONT-DEBUG] imageSmoothingEnabled: ${targetCtx.imageSmoothingEnabled}`);
           console.log(`🔤 [FONT-DEBUG] imageSmoothingQuality: ${targetCtx.imageSmoothingQuality}`);
       }

       // Handle gradient or solid color
       performanceLog('🎨 setTextContextOn - textObj.gradient:', textObj.gradient);
       performanceLog('🎨 setTextContextOn - textObj.color:', textObj.color);

       // Only set solid color for actual distort effects that render letter-by-letter
       // Normal text and skew should use the normal gradient system
       const isLetterByLetterEffect = (letterIndex !== null && letterIndex !== undefined);
       if (isLetterByLetterEffect) {
           // For letter-by-letter rendering, use solid color (gradient is handled by normal system)
           targetCtx.fillStyle = textObj.color;
           performanceLog('🎨 Set fillStyle to solid color for letter-by-letter rendering:', textObj.color);
       } else {
           // For normal text, don't interfere with gradient system
           targetCtx.fillStyle = textObj.color; // Default, will be overridden by gradient system if needed
           performanceLog('🎨 Set default fillStyle for normal text:', textObj.color);
       }

       targetCtx.textAlign = "center";
       targetCtx.textBaseline = "middle";

       // Apply letter spacing if specified
       // Note: letterSpacing is not directly supported in Canvas, but we'll store it
       // for use in our custom text rendering functions
       textObj._effectiveLetterSpacing = (textObj.letterSpacing !== undefined) ? textObj.letterSpacing : 0;

       // Note: Opacity is handled individually for text and stroke in rendering functions
       // Do not apply global opacity here as it would affect stroke independence

       // Log the font style for debugging
       performanceLog('Setting text context with font:', targetCtx.font,
                  'letter spacing:', textObj._effectiveLetterSpacing);

       // Check if font is actually loaded (use cache for performance)
       if (document.fonts && document.fonts.check) {
           const fontLoaded = checkFontLoaded(targetCtx.font);
           performanceLog(`🔤 Font check for "${targetCtx.font}": ${fontLoaded ? '✅ LOADED' : '❌ NOT LOADED'}`);

           if (!fontLoaded) {
               debugLog(`⚠️ Font "${textObj.fontFamily}" may not be loaded. Canvas will use fallback font.`);

               // Try to get the font path and check if it exists
               const fontPath = getFontPathForFamily(textObj.fontFamily, textObj.bold, textObj.italic);
               debugLog(`🔍 Expected font path: ${fontPath}`);

               // Try to load the font
               if (fontPath && fontPath !== fontMap['Poppins']['regular']) {
                   debugLog(`🔄 Attempting to load font from: ${fontPath}`);
                   const fontFace = new FontFace(textObj.fontFamily, `url(${fontPath})`);
                   fontFace.load().then(() => {
                       document.fonts.add(fontFace);
                       debugLog(`✅ Font "${textObj.fontFamily}" loaded successfully`);
                       // Update cache
                       fontLoadCache.set(targetCtx.font, true);
                       // Trigger a redraw to apply the newly loaded font
                       setTimeout(() => update(), 100);
                   }).catch(err => {
                       console.error(`❌ Failed to load font "${textObj.fontFamily}":`, err);
                   });
               }
           }
       }
   }
   // NEW: Function to get pixel-perfect text bounds (Method 3 - Ultimate Solution)
   function getPixelPerfectTextBounds(obj) {
       console.log('🎯 PIXEL DEBUG: ===== STARTING PIXEL-PERFECT DETECTION =====');
       console.log('🎯 PIXEL DEBUG: Input object:', {
           text: obj?.text,
           fontSize: obj?.fontSize,
           fontFamily: obj?.fontFamily,
           type: obj?.type
       });

       if (!obj || obj.type !== 'text' || !obj.text) {
           console.log('🎯 PIXEL DEBUG: Invalid object, returning zero dimensions');
           return { width: 0, height: 0 };
       }

       // Create a temporary canvas for pixel detection
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = 800; // Large enough for most text
       tempCanvas.height = 400;
       const tempCtx = tempCanvas.getContext('2d');
       console.log('🎯 PIXEL DEBUG: Created temp canvas:', tempCanvas.width, 'x', tempCanvas.height);

       // Set up the text context exactly as it would be rendered
       console.log('🎯 PIXEL DEBUG: Setting up text context...');
       setTextContextOn(tempCtx, obj);
       tempCtx.textAlign = 'left';
       tempCtx.textBaseline = 'top';
       console.log('🎯 PIXEL DEBUG: Text context font set to:', tempCtx.font);

       // Draw text at a known position with letter spacing support
       const startX = 100;
       const startY = 100;
       tempCtx.fillStyle = '#000000';
       console.log('🎯 PIXEL DEBUG: Drawing text at position:', startX, startY);

       // CRITICAL FIX: Handle letter spacing properly for pixel-perfect bounds calculation
       const letterSpacing = obj.letterSpacing || 0;
       console.log('🎯 PIXEL DEBUG: Letter spacing value:', letterSpacing);

       if (letterSpacing !== 0) {
           console.log('🎯 PIXEL DEBUG: Using letter spacing mode for bounds calculation');
           // Draw each character manually with letter spacing
           const letters = obj.text.split('');
           let totalWidth = 0;

           // Calculate total width with letter spacing
           letters.forEach(letter => {
               totalWidth += tempCtx.measureText(letter).width;
           });
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           console.log('🎯 PIXEL DEBUG: Total width with letter spacing:', totalWidth);

           // Draw each letter with proper spacing
           let currentX = startX;
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = tempCtx.measureText(letter).width;
               tempCtx.fillText(letter, currentX, startY);
               currentX += letterWidth + letterSpacing;
           }
       } else {
           console.log('🎯 PIXEL DEBUG: Using standard fillText (no letter spacing)');
           fillMultiLineText(tempCtx, obj.text, startX, startY, obj);
       }
       console.log('🎯 PIXEL DEBUG: Text drawn successfully');

       // Get image data to analyze pixels
       console.log('🎯 PIXEL DEBUG: Getting image data for pixel analysis...');
       const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
       const data = imageData.data;
       console.log('🎯 PIXEL DEBUG: Image data length:', data.length, 'pixels to analyze:', tempCanvas.width * tempCanvas.height);

       let minX = tempCanvas.width, maxX = 0;
       let minY = tempCanvas.height, maxY = 0;
       let hasPixels = false;
       let pixelCount = 0;

       // Find the actual pixels that contain text
       console.log('🎯 PIXEL DEBUG: Starting pixel analysis...');
       for (let y = 0; y < tempCanvas.height; y++) {
           for (let x = 0; x < tempCanvas.width; x++) {
               const index = (y * tempCanvas.width + x) * 4;
               const alpha = data[index + 3]; // Alpha channel

               if (alpha > 0) { // If pixel is not transparent
                   minX = Math.min(minX, x);
                   maxX = Math.max(maxX, x);
                   minY = Math.min(minY, y);
                   maxY = Math.max(maxY, y);
                   hasPixels = true;
                   pixelCount++;
               }
           }
       }

       console.log('🎯 PIXEL DEBUG: Pixel analysis complete. Found', pixelCount, 'text pixels');
       console.log('🎯 PIXEL DEBUG: Bounds found:', { minX, maxX, minY, maxY, hasPixels });

       if (!hasPixels) {
           console.log('🎯 PIXEL DEBUG: No pixels found! Using fallback calculation');
           const fallbackWidth = obj.fontSize * obj.text.length * 0.6;
           const fallbackHeight = obj.fontSize;
           console.log('🎯 PIXEL DEBUG: Fallback dimensions:', fallbackWidth, 'x', fallbackHeight);
           return { width: fallbackWidth, height: fallbackHeight };
       }

       const pixelWidth = maxX - minX + 1;
       const pixelHeight = maxY - minY + 1;

       // 📏 ENHANCED HEIGHT ANALYSIS: Check for tighter height bounds
       console.log('📏 HEIGHT ANALYSIS: Analyzing height optimization opportunities');
       console.log('📏 HEIGHT ANALYSIS: Font size:', obj.fontSize, 'Pixel height:', pixelHeight);
       console.log('📏 HEIGHT ANALYSIS: Height ratio:', (pixelHeight / obj.fontSize * 100).toFixed(1) + '%');

       // Check if we can find tighter vertical bounds by scanning row by row
       let tightMinY = maxY;
       let tightMaxY = minY;

       // Scan from top to find first row with pixels
       for (let y = minY; y <= maxY; y++) {
           let hasPixelsInRow = false;
           for (let x = minX; x <= maxX; x++) {
               const index = (y * tempCanvas.width + x) * 4;
               if (data[index + 3] > 0) { // Alpha > 0
                   hasPixelsInRow = true;
                   break;
               }
           }
           if (hasPixelsInRow) {
               tightMinY = y;
               break;
           }
       }

       // Scan from bottom to find last row with pixels
       for (let y = maxY; y >= minY; y--) {
           let hasPixelsInRow = false;
           for (let x = minX; x <= maxX; x++) {
               const index = (y * tempCanvas.width + x) * 4;
               if (data[index + 3] > 0) { // Alpha > 0
                   hasPixelsInRow = true;
                   break;
               }
           }
           if (hasPixelsInRow) {
               tightMaxY = y;
               break;
           }
       }

       const tightPixelHeight = tightMaxY - tightMinY + 1;
       const heightReduction = pixelHeight - tightPixelHeight;

       console.log('📏 HEIGHT ANALYSIS: Original bounds: minY=' + minY + ', maxY=' + maxY + ', height=' + pixelHeight);
       console.log('📏 HEIGHT ANALYSIS: Tight bounds: minY=' + tightMinY + ', maxY=' + tightMaxY + ', height=' + tightPixelHeight);
       console.log('📏 HEIGHT ANALYSIS: Height reduction: ' + heightReduction + ' pixels (' + (heightReduction / pixelHeight * 100).toFixed(1) + '%)');

       // Use the tighter height if it provides meaningful improvement
       const finalPixelHeight = (heightReduction > 2) ? tightPixelHeight : pixelHeight;
       console.log('📏 HEIGHT ANALYSIS: Using final height:', finalPixelHeight);

       console.log('🎯 PIXEL DEBUG: Final pixel-perfect dimensions:', pixelWidth, 'x', finalPixelHeight);
       console.log('🎯 PIXEL-PERFECT BOUNDS:', {
           text: obj.text,
           fontSize: obj.fontSize,
           fontFamily: obj.fontFamily,
           pixelBounds: { minX, maxX, minY, maxY },
           tightBounds: { minY: tightMinY, maxY: tightMaxY },
           pixelWidth: pixelWidth,
           pixelHeight: finalPixelHeight,
           heightOptimization: heightReduction + ' pixels saved',
           pixelCount: pixelCount,
           efficiency: 'MAXIMUM - exact text shape with optimized height!'
       });
       console.log('🎯 PIXEL DEBUG: ===== PIXEL-PERFECT DETECTION COMPLETE =====');

       return { width: pixelWidth, height: finalPixelHeight };
   }

   // NEW: Function to get actual visible bounds instead of bounding box
   function getActualVisibleBounds(obj) {
       console.log('📏 BOUNDS DEBUG: ===== getActualVisibleBounds called =====');
       console.log('📏 BOUNDS DEBUG: Input object:', obj);

       if (!obj) {
           console.log('📏 BOUNDS DEBUG: No object provided, returning zero dimensions');
           return { width: 0, height: 0 };
       }

       if (obj.type === 'text') {
           console.log('📏 BOUNDS DEBUG: Text object detected, calling pixel-perfect detection');
           // Use pixel-perfect detection for the most accurate bounds
           const result = getPixelPerfectTextBounds(obj);
           console.log('📏 BOUNDS DEBUG: Pixel-perfect detection returned:', result);
           return result;

       } else if (obj.type === 'image') {
           console.log('📏 BOUNDS DEBUG: Image object detected');
           // For images, the visible bounds are the same as the scaled dimensions
           if (!obj.originalWidth || !obj.originalHeight) {
               console.log('📏 BOUNDS DEBUG: Image missing dimensions, returning zero');
               return { width: 0, height: 0 };
           }

           const scale = obj.scale || 1;
           const result = {
               width: obj.originalWidth * scale,
               height: obj.originalHeight * scale
           };
           console.log('📏 BOUNDS DEBUG: Image bounds calculated:', result);
           return result;
       }

       console.log('📏 BOUNDS DEBUG: Unknown object type, returning zero dimensions');
       return { width: 0, height: 0 };
   }

   // 📦 NEW FEATURE: Function to shrink text box to fit actual visible text using unified pixel-perfect detection
   function shrinkTextBoxToFitText() {
       console.log('📦 SHRINK TEXT BOX: ===== STARTING PIXEL-PERFECT TEXT BOX SHRINKING =====');

       if (selectedObjectIndex === -1 || !canvasObjects[selectedObjectIndex] || canvasObjects[selectedObjectIndex].type !== 'text') {
           console.log('📦 SHRINK TEXT BOX: No text object selected');
           if (window.showToast) window.showToast('Please select a text object first', 'warning');
           return;
       }

       const textObj = canvasObjects[selectedObjectIndex];
       console.log('📦 SHRINK TEXT BOX: Processing text object:', textObj.text);

       // 🎯 USE UNIFIED DETECTION: Get pixel-perfect bounds using the same logic as guidelines
       const pixelBounds = getPixelPerfectObjectBounds(textObj);

       if (!pixelBounds) {
           console.log('📦 SHRINK TEXT BOX: Failed to get pixel-perfect bounds');
           if (window.showToast) window.showToast('No visible text found to shrink to', 'warning');
           return;
       }

       // Store the original bounds for comparison
       const originalBounds = calculateObjectBounds(textObj);

       // 🎯 CHECK: Is this text object already optimized?
       if (textObj.customBounds && textObj.customBounds.isOptimized) {
           console.log('📦 SHRINK TEXT BOX: ⚠️  TEXT ALREADY OPTIMIZED - This text object already has pixel-perfect bounds!');
           console.log('📦 SHRINK TEXT BOX: Current optimized size:', {width: textObj.customBounds.width, height: textObj.customBounds.height});
           console.log('📦 SHRINK TEXT BOX: Original size was:', textObj.customBounds.originalBounds);
           console.log('📦 SHRINK TEXT BOX: Optimized at:', new Date(textObj.customBounds.optimizedAt).toLocaleTimeString());
           if (window.showToast) window.showToast('Text box is already optimized to pixel-perfect size!', 'info');
       } else {
           console.log('📦 SHRINK TEXT BOX: ✅ TEXT NOT YET OPTIMIZED - Will apply pixel-perfect bounds');
       }

       console.log('📦 SHRINK TEXT BOX: Applying EXACT pixel-perfect bounds (same as Test All 4 Sides):', {
           contentWidth: pixelBounds.contentWidth,
           contentHeight: pixelBounds.contentHeight,
           newCenterX: pixelBounds.newCenterX,
           newCenterY: pixelBounds.newCenterY,
           originalBounds: originalBounds,
           originalPosition: {x: textObj.x, y: textObj.y}
       });

       // 🎯 APPLY REAL TEXT BOX SHRINKING: Actually modify the text object properties

       // Calculate how much we need to reduce the font size to fit the pixel-perfect bounds
       const currentFontSize = textObj.fontSize || 100;
       const scaleX = pixelBounds.contentWidth / originalBounds.width;
       const scaleY = pixelBounds.contentHeight / originalBounds.height;

       // Use the smaller scale to ensure text fits within bounds
       const scale = Math.min(scaleX, scaleY);
       const newFontSize = currentFontSize * scale;

       console.log('📦 SHRINK TEXT BOX: Font size adjustment:', {
           currentFontSize,
           scaleX,
           scaleY,
           scale,
           newFontSize
       });

       // Store original properties before modification
       if (!textObj.originalProperties) {
           textObj.originalProperties = {
               fontSize: textObj.fontSize,
               x: textObj.x,
               y: textObj.y,
               width: originalBounds.width,
               height: originalBounds.height
           };
       }

       // 🎯 ACTUALLY MODIFY THE TEXT OBJECT PROPERTIES
       textObj.fontSize = newFontSize;
       textObj.x = pixelBounds.newCenterX;
       textObj.y = pixelBounds.newCenterY;

       // Mark as optimized
       textObj.isOptimized = true;
       textObj.optimizedAt = Date.now();

       console.log('📦 SHRINK TEXT BOX: Text object modified:', {
           newFontSize: textObj.fontSize,
           newPosition: {x: textObj.x, y: textObj.y},
           isOptimized: textObj.isOptimized
       });

       console.log('📦 SHRINK TEXT BOX: ===== DETAILED BEFORE/AFTER COMPARISON =====');
       console.log('📦 SHRINK TEXT BOX: BEFORE - Original position:', textObj.customBounds.originalPosition);
       console.log('📦 SHRINK TEXT BOX: AFTER  - New position:', {x: textObj.x, y: textObj.y});
       console.log('📦 SHRINK TEXT BOX: BEFORE - Original bounds:', originalBounds);
       console.log('📦 SHRINK TEXT BOX: AFTER  - New bounds:', {width: pixelBounds.contentWidth, height: pixelBounds.contentHeight});
       console.log('📦 SHRINK TEXT BOX: REDUCTION - Width:', ((originalBounds.width - pixelBounds.contentWidth) / originalBounds.width * 100).toFixed(1) + '%');
       console.log('📦 SHRINK TEXT BOX: REDUCTION - Height:', ((originalBounds.height - pixelBounds.contentHeight) / originalBounds.height * 100).toFixed(1) + '%');
       console.log('📦 SHRINK TEXT BOX: POSITION SHIFT - X:', (textObj.x - textObj.customBounds.originalPosition.x).toFixed(1) + 'px');
       console.log('📦 SHRINK TEXT BOX: POSITION SHIFT - Y:', (textObj.y - textObj.customBounds.originalPosition.y).toFixed(1) + 'px');

       // Update the display
       update();

       // Show success message
       const widthReduction = ((originalBounds.width - pixelBounds.contentWidth) / originalBounds.width * 100).toFixed(0);
       const heightReduction = ((originalBounds.height - pixelBounds.contentHeight) / originalBounds.height * 100).toFixed(0);
       if (window.showToast) {
           window.showToast(`Text box optimized! Width: ${widthReduction}%, Height: ${heightReduction}%`, 'success');
       }

       console.log('📦 SHRINK TEXT BOX: ===== PIXEL-PERFECT TEXT BOX SHRINKING COMPLETE =====');
   }

   // 📐 DRAW FITTING RECTANGLE: Draw a rectangle that fits exactly around the text
   function drawFittingRectangleAroundText() {
       console.log('📐 DRAW FITTING RECTANGLE: Starting...');

       if (selectedObjectIndex === -1) {
           console.log('📐 DRAW FITTING RECTANGLE: ❌ No object selected');
           if (window.showToast) window.showToast('Please select a text object first', 'error');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       if (selectedObject.type !== 'text') {
           console.log('📐 DRAW FITTING RECTANGLE: ❌ Selected object is not text');
           if (window.showToast) window.showToast('Please select a text object', 'error');
           return;
       }

       console.log('📐 DRAW FITTING RECTANGLE: Analyzing text object:', selectedObject.text);

       // Get pixel-perfect bounds using the same function as guidelines
       const pixelBounds = getPixelPerfectObjectBounds(selectedObject);
       if (!pixelBounds) {
           console.log('📐 DRAW FITTING RECTANGLE: ❌ Failed to detect pixel-perfect bounds');
           if (window.showToast) window.showToast('Failed to detect text bounds', 'error');
           return;
       }

       console.log('📐 DRAW FITTING RECTANGLE: Pixel-perfect bounds detected:', pixelBounds);

       // Calculate the exact rectangle coordinates (same as test page)
       const newCenterX = pixelBounds.newCenterX;
       const newCenterY = pixelBounds.newCenterY;
       const halfWidth = pixelBounds.contentWidth / 2;
       const halfHeight = pixelBounds.contentHeight / 2;

       const rectLeft = newCenterX - halfWidth;
       const rectRight = newCenterX + halfWidth;
       const rectTop = newCenterY - halfHeight;
       const rectBottom = newCenterY + halfHeight;

       console.log('📐 DRAW FITTING RECTANGLE: Rectangle coordinates:', {
           left: rectLeft,
           right: rectRight,
           top: rectTop,
           bottom: rectBottom,
           width: rectRight - rectLeft,
           height: rectBottom - rectTop
       });

       // Create unique group ID for linking the rectangles
       const groupId = `rect-group-${Date.now()}`;

       // 1. CREATE PIXEL-PERFECT FITTING RECTANGLE (GREEN) - This is the master
       const pixelFittingRect = {
           id: `pixel-fitting-rect-${Date.now()}`,
           type: 'rectangle',
           x: newCenterX,
           y: newCenterY,
           width: rectRight - rectLeft,
           height: rectBottom - rectTop,
           rotation: 0,
           color: '#00ff00',
           strokeColor: '#00aa00',
           strokeWidth: 2,
           fillOpacity: 0.1,
           strokeOpacity: 1.0,
           isSelected: false,
           isFittingRectangle: true,
           label: 'Pixel-Perfect Bounds',
           groupId: groupId,
           isMasterRectangle: true, // This rectangle controls the group
           originalWidth: rectRight - rectLeft,
           originalHeight: rectBottom - rectTop
       };

       // 2. CREATE TEXT BOUNDING BOX RECTANGLE (RED) - This follows the master
       const textBounds = calculateObjectBounds(selectedObject);
       const offsetX = textBounds.cx - newCenterX;
       const offsetY = textBounds.cy - newCenterY;

       const textBoundingRect = {
           id: `text-bounds-rect-${Date.now()}`,
           type: 'rectangle',
           x: textBounds.cx,
           y: textBounds.cy,
           width: textBounds.width,
           height: textBounds.height,
           rotation: 0,
           color: '#ff0000',
           strokeColor: '#aa0000',
           strokeWidth: 2,
           fillOpacity: 0.05,
           strokeOpacity: 1.0,
           isSelected: false,
           isTextBoundingBox: true,
           label: 'Text Bounding Box',
           groupId: groupId,
           isMasterRectangle: false,
           masterRectangleId: pixelFittingRect.id,
           offsetX: offsetX, // Relative position to master
           offsetY: offsetY,
           originalWidth: textBounds.width,
           originalHeight: textBounds.height
       };

       console.log('📐 DRAW FITTING RECTANGLE: Created rectangles:', {
           pixelPerfect: {
               center: { x: newCenterX, y: newCenterY },
               size: { width: rectRight - rectLeft, height: rectBottom - rectTop }
           },
           textBounds: {
               center: { x: textBounds.cx, y: textBounds.cy },
               size: { width: textBounds.width, height: textBounds.height }
           }
       });

       // Add both rectangles to the canvas
       canvasObjects.push(pixelFittingRect);
       canvasObjects.push(textBoundingRect);

       console.log('📐 DRAW FITTING RECTANGLE: Both rectangles created and added to canvas');

       // Update the display
       update();

       // 🎯 UPDATE LAYOUT UI: Check if fit button should be shown now that green rectangle exists
       updateLayoutSelectionUI();

       if (window.showToast) {
           window.showToast('Fitting rectangles drawn: Green = Pixel-Perfect, Red = Text Box', 'success');
       }

       console.log('📐 DRAW FITTING RECTANGLE: ===== OPERATION COMPLETED =====');
   }

   // 🔍 HELPER: Detect overall SVG content bounds (not individual components)
   function getSVGContentBounds(svgObj) {
       console.log('🔍 SVG Content Bounds: Analyzing object:', svgObj.id);

       if (!svgObj || svgObj.type !== 'image' || !svgObj.image) {
           console.log('🔍 SVG Content Bounds: ❌ Invalid object for SVG detection');
           return null;
       }

       try {
           // Create temporary canvas for analysis
           const tempCanvas = document.createElement('canvas');
           const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

           // Set canvas size for analysis
           const analysisSize = 800;
           tempCanvas.width = analysisSize;
           tempCanvas.height = analysisSize;

           // Calculate scale to fit image in analysis canvas
           const scale = Math.min(analysisSize / svgObj.image.naturalWidth, analysisSize / svgObj.image.naturalHeight);
           const drawWidth = svgObj.image.naturalWidth * scale;
           const drawHeight = svgObj.image.naturalHeight * scale;
           const offsetX = (analysisSize - drawWidth) / 2;
           const offsetY = (analysisSize - drawHeight) / 2;

           // Draw image to temporary canvas
           tempCtx.drawImage(svgObj.image, offsetX, offsetY, drawWidth, drawHeight);

           // Get image data and find content bounds
           const imageData = tempCtx.getImageData(0, 0, analysisSize, analysisSize);
           const data = imageData.data;

           let minX = analysisSize, maxX = 0, minY = analysisSize, maxY = 0;
           let hasContent = false;

           // Scan all pixels to find content bounds
           for (let y = 0; y < analysisSize; y++) {
               for (let x = 0; x < analysisSize; x++) {
                   const index = (y * analysisSize + x) * 4;
                   const alpha = data[index + 3];

                   // If pixel is not transparent, it's content
                   if (alpha > 10) { // Small threshold for anti-aliasing
                       hasContent = true;
                       minX = Math.min(minX, x);
                       maxX = Math.max(maxX, x);
                       minY = Math.min(minY, y);
                       maxY = Math.max(maxY, y);
                   }
               }
           }

           if (!hasContent) {
               console.log('🔍 SVG Content Bounds: ❌ No content found');
               return null;
           }

           // Convert canvas coordinates back to world coordinates
           const contentWidth = (maxX - minX) / scale;
           const contentHeight = (maxY - minY) / scale;

           // Calculate content center in image coordinates (relative to image origin)
           const contentCenterInImageX = ((minX + maxX) / 2 - offsetX) / scale;
           const contentCenterInImageY = ((minY + maxY) / 2 - offsetY) / scale;

           // Convert to world coordinates (relative to object center)
           const contentCenterX = svgObj.x + contentCenterInImageX - svgObj.image.naturalWidth / 2;
           const contentCenterY = svgObj.y + contentCenterInImageY - svgObj.image.naturalHeight / 2;

           const result = {
               contentWidth: contentWidth,
               contentHeight: contentHeight,
               newCenterX: contentCenterX,
               newCenterY: contentCenterY
           };

           console.log('🔍 SVG Content Bounds: Detected bounds:', {
               canvasBounds: { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY },
               imageCoords: { contentCenterInImageX, contentCenterInImageY },
               objectPosition: { x: svgObj.x, y: svgObj.y },
               imageSize: { naturalWidth: svgObj.image.naturalWidth, naturalHeight: svgObj.image.naturalHeight },
               worldBounds: result,
               scale: scale,
               offset: { offsetX, offsetY }
           });

           return result;

       } catch (error) {
           console.error('🔍 SVG Content Bounds: Error:', error);
           return null;
       }
   }

   // 🔍 HELPER: Detect SVG components for a specific object without affecting global state
   function detectSVGComponentsForObject(svgObj) {
       console.log('🔍 SVG Component Detection Helper: Analyzing object:', svgObj.id);

       if (!svgObj || svgObj.type !== 'image' || !svgObj.image) {
           console.log('🔍 SVG Component Detection Helper: ❌ Invalid object for SVG detection');
           return null;
       }

       try {
           // Create temporary canvas for analysis
           const tempCanvas = document.createElement('canvas');
           const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

           // Set canvas size for analysis
           const analysisSize = 800;
           tempCanvas.width = analysisSize;
           tempCanvas.height = analysisSize;

           // Calculate scale to fit image in analysis canvas
           const scale = Math.min(analysisSize / svgObj.image.naturalWidth, analysisSize / svgObj.image.naturalHeight);
           const drawWidth = svgObj.image.naturalWidth * scale;
           const drawHeight = svgObj.image.naturalHeight * scale;
           const offsetX = (analysisSize - drawWidth) / 2;
           const offsetY = (analysisSize - drawHeight) / 2;

           // Draw image to temporary canvas
           tempCtx.drawImage(svgObj.image, offsetX, offsetY, drawWidth, drawHeight);

           // Run component detection algorithms
           const colorComponents = detectSVGComponentsByColor(tempCanvas, offsetX, offsetY, scale, svgObj);
           const regionComponents = detectSVGComponentsByRegion(tempCanvas, offsetX, offsetY, scale, svgObj);
           const mergedComponents = mergeComponentDetections(colorComponents, regionComponents);

           // Convert screen coordinates to world coordinates for each component
           const worldComponents = mergedComponents.map(component => {
               const bounds = component.bounds;

               // Convert screen coordinates back to world coordinates
               const worldLeft = (bounds.x - offsetX) / scale;
               const worldTop = (bounds.y - offsetY) / scale;
               const worldWidth = bounds.width / scale;
               const worldHeight = bounds.height / scale;

               // Calculate world center coordinates
               const worldCenterX = svgObj.x + worldLeft + worldWidth / 2 - svgObj.image.naturalWidth / 2;
               const worldCenterY = svgObj.y + worldTop + worldHeight / 2 - svgObj.image.naturalHeight / 2;

               return {
                   ...component,
                   worldBounds: {
                       x: worldLeft,
                       y: worldTop,
                       width: worldWidth,
                       height: worldHeight,
                       centerX: worldCenterX,
                       centerY: worldCenterY
                   }
               };
           });

           console.log('🔍 SVG Component Detection Helper: Found', worldComponents.length, 'components with world coordinates');
           return worldComponents;

       } catch (error) {
           console.error('🔍 SVG Component Detection Helper: Error:', error);
           return null;
       }
   }

   // 🖼️ DRAW FITTING RECTANGLE FOR SHAPES: Draw rectangles around shape/image objects
   function drawFittingRectangleAroundShape() {
       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Starting...');

       // 🔧 CRITICAL FIX: Reset drag flags to prevent sync issues
       resetAllDragFlags();

       // 🧹 PERFORMANCE FIX: Clear any existing SVG component bounds to prevent performance issues
       svgComponentsVisible = false;
       svgComponents = [];
       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Cleared SVG component bounds for performance');

       if (selectedObjectIndex === -1) {
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: ❌ No object selected');
           if (window.showToast) window.showToast('Please select a shape or image first', 'error');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       if (selectedObject.type !== 'image') {
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: ❌ Selected object is not an image/shape');
           if (window.showToast) window.showToast('Please select a shape or image object', 'error');
           return;
       }

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Analyzing shape/image object:', selectedObject.imageUrl);

       // 🧹 CLEANUP: Remove any existing fitting rectangles for shapes
       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Cleaning up existing shape fitting rectangles...');
       canvasObjects = canvasObjects.filter(obj => {
           const isShapeFittingRect = obj.isFittingRectangle || obj.isShapeBoundingBox;
           if (isShapeFittingRect) {
               console.log('🖼️ CLEANUP: Removing existing shape fitting rectangle:', obj.id);
           }
           return !isShapeFittingRect;
       });

       // 🎯 USE SVG COMPONENT DETECTION: For SVG images, use the same algorithm as "Detect Components"
       let contentBounds = null;

       // Try SVG content bounds detection first (works better for SVG images)
       if (selectedObject.imageUrl && selectedObject.imageUrl.toLowerCase().includes('.svg')) {
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Using SVG content bounds detection for SVG image');

           // Use simple content bounds detection (detects all content as one area)
           contentBounds = getSVGContentBounds(selectedObject);

           if (contentBounds) {
               console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: SVG content bounds detected:', contentBounds);
           }
       }

       // Fallback to pixel-perfect detection if SVG detection failed
       if (!contentBounds) {
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Falling back to pixel-perfect detection');
           const pixelBounds = getPixelPerfectObjectBounds(selectedObject);
           if (!pixelBounds) {
               console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: ❌ Failed to detect any bounds');
               if (window.showToast) window.showToast('Failed to detect shape bounds', 'error');
               return;
           }
           contentBounds = pixelBounds;
       }

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Content bounds detected:', contentBounds);

       // 🎯 COORDINATE MAPPING: Map content bounds to actual object position
       const actualObjectScale = selectedObject.scale || 1;

       // Get the actual rendered dimensions of the image
       const actualWidth = selectedObject.image ? selectedObject.image.naturalWidth * actualObjectScale : 100;
       const actualHeight = selectedObject.image ? selectedObject.image.naturalHeight * actualObjectScale : 100;

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Object dimensions:', {
           actualWidth, actualHeight, scale: actualObjectScale,
           naturalWidth: selectedObject.image?.naturalWidth,
           naturalHeight: selectedObject.image?.naturalHeight,
           objectPosition: { x: selectedObject.x, y: selectedObject.y }
       });

       // Calculate the content rectangle (green) dimensions and position
       let pixelPerfectWidth, pixelPerfectHeight, greenCenterX, greenCenterY;

       if (contentBounds.newCenterX !== undefined && contentBounds.newCenterY !== undefined) {
           // SVG component detection provides world coordinates
           pixelPerfectWidth = contentBounds.contentWidth;
           pixelPerfectHeight = contentBounds.contentHeight;
           greenCenterX = contentBounds.newCenterX;
           greenCenterY = contentBounds.newCenterY;
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Using SVG component world coordinates');
       } else {
           // Fallback: scale content bounds and center on object
           pixelPerfectWidth = contentBounds.contentWidth * actualObjectScale;
           pixelPerfectHeight = contentBounds.contentHeight * actualObjectScale;
           greenCenterX = selectedObject.x;
           greenCenterY = selectedObject.y;
           console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Using scaled content bounds centered on object');
       }

       // Calculate the shape's current bounding box (red rectangle) - this should match the actual object size
       const shapeBounds = {
           cx: selectedObject.x,
           cy: selectedObject.y,
           width: actualWidth,
           height: actualHeight
       };

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Rectangle coordinates:', {
           pixelPerfect: {
               center: { x: greenCenterX, y: greenCenterY },
               size: { width: pixelPerfectWidth, height: pixelPerfectHeight }
           },
           shapeBounds: shapeBounds
       });

       // Create unique group ID for linking the rectangles
       const groupId = `shape-rect-group-${Date.now()}`;

       // Create the green rectangle (pixel-perfect bounds)
       const pixelFittingRect = {
           type: 'rectangle',
           id: Date.now(),
           x: greenCenterX,
           y: greenCenterY,
           width: pixelPerfectWidth,
           height: pixelPerfectHeight,
           // ✅ FIXED: Use correct property names for rectangle drawing
           color: 'rgba(0, 255, 0, 0.3)', // Fill color with transparency
           fillOpacity: 0.3, // Fill opacity
           strokeColor: '#00ff00', // Border color (green)
           strokeWidth: 2, // Border width
           strokeOpacity: 1.0, // Border opacity
           rotation: 0,
           isSelected: false,
           isFittingRectangle: true,
           isMasterRectangle: true, // This is the master (green) rectangle
           groupId: groupId,
           originalWidth: pixelPerfectWidth,
           originalHeight: pixelPerfectHeight
       };

       // Create the red rectangle (shape bounding box)
       const shapeBoundingRect = {
           type: 'rectangle',
           id: Date.now() + 1,
           x: shapeBounds.cx,
           y: shapeBounds.cy,
           width: shapeBounds.width,
           height: shapeBounds.height,
           // ✅ FIXED: Use correct property names for rectangle drawing
           color: 'rgba(255, 0, 0, 0.3)', // Fill color with transparency
           fillOpacity: 0.3, // Fill opacity
           strokeColor: '#ff0000', // Border color (red)
           strokeWidth: 2, // Border width
           strokeOpacity: 1.0, // Border opacity
           rotation: 0,
           isSelected: false,
           isShapeBoundingBox: true, // Mark as shape bounding box (like isTextBoundingBox for text)
           groupId: groupId,
           masterRectangleId: pixelFittingRect.id,
           originalWidth: shapeBounds.width,
           originalHeight: shapeBounds.height
       };

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Created rectangles:', {
           pixelPerfect: {
               center: { x: greenCenterX, y: greenCenterY },
               size: { width: pixelPerfectWidth, height: pixelPerfectHeight }
           },
           shapeBounds: {
               center: { x: shapeBounds.cx, y: shapeBounds.cy },
               size: { width: shapeBounds.width, height: shapeBounds.height }
           }
       });

       // Add both rectangles to the canvas
       canvasObjects.push(pixelFittingRect);
       canvasObjects.push(shapeBoundingRect);

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Both rectangles created and added to canvas');

       // 🔧 CRITICAL FIX: Sync global references to ensure rectangles are visible
       syncGlobalReferences();
       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: Synced global references');

       // Update the display
       update();

       // Update layout UI to show fit button if needed
       updateLayoutSelectionUI();

       if (window.showToast) {
           window.showToast('Fitting rectangles drawn: Green = Pixel-Perfect, Red = Shape Box', 'success');
       }

       console.log('🖼️ DRAW FITTING RECTANGLE FOR SHAPE: ===== OPERATION COMPLETED =====');
   }

   // 🧹 CLEAN ALL RECTANGLES: Remove all fitting rectangles from canvas
   function cleanAllRectangles() {
       console.log('🧹 CLEAN RECTANGLES: ===== STARTING CLEANUP =====');

       // Find all fitting rectangles (both green pixel-perfect and red text/shape bounding boxes)
       const rectanglesToRemove = canvasObjects.filter(obj =>
           obj.type === 'rectangle' &&
           (obj.isFittingRectangle || obj.isTextBoundingBox || obj.isShapeBoundingBox || obj.groupId)
       );

       console.log('🧹 CLEAN RECTANGLES: Found rectangles to remove:', rectanglesToRemove.length);

       if (rectanglesToRemove.length === 0) {
           console.log('🧹 CLEAN RECTANGLES: No fitting rectangles found');
           if (window.showToast) window.showToast('No fitting rectangles to clean', 'info');
           return;
       }

       // Store the currently selected object (if any) before removal
       const currentlySelected = selectedObjectIndex !== -1 ? canvasObjects[selectedObjectIndex] : null;

       // Remove rectangles from canvasObjects array (go backwards to avoid index issues)
       for (let i = canvasObjects.length - 1; i >= 0; i--) {
           const obj = canvasObjects[i];
           if (obj.type === 'rectangle' &&
               (obj.isFittingRectangle || obj.isTextBoundingBox || obj.groupId)) {
               console.log('🧹 CLEAN RECTANGLES: Removing rectangle:', obj.id, obj.label || 'Unknown');
               canvasObjects.splice(i, 1);
           }
       }

       // Fix selectedObjectIndex after removal
       if (currentlySelected) {
           const newIndex = canvasObjects.indexOf(currentlySelected);
           selectedObjectIndex = newIndex; // Will be -1 if the selected object was removed
       } else {
           selectedObjectIndex = -1;
       }

       // Update UI if selection changed
       if (selectedObjectIndex === -1) {
           updateUIFromSelectedObject();
       }

       // Hide rectangle scale controls since rectangles are gone
       const rectangleScaleGroup = document.getElementById('rectangleScaleGroup');
       if (rectangleScaleGroup) {
           rectangleScaleGroup.style.display = 'none';
       }

       // Update the display
       update();

       if (window.showToast) {
           window.showToast(`🧹 Cleaned ${rectanglesToRemove.length} fitting rectangles`, 'success');
       }

       console.log('🧹 CLEAN RECTANGLES: ===== CLEANUP COMPLETED =====');
   }

   // 🟢🔴 SCALE RECTANGLE GROUP: Scale both rectangles together using slider
   function scaleRectangleGroup(scale) {
       console.log('🟢🔴 SCALE RECTANGLE GROUP: Starting with scale:', scale);

       // Find the selected master rectangle (green)
       if (selectedObjectIndex === -1) {
           console.log('🟢🔴 SCALE RECTANGLE GROUP: No object selected');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       if (!selectedObject.isMasterRectangle || !selectedObject.groupId) {
           console.log('🟢🔴 SCALE RECTANGLE GROUP: Selected object is not a master rectangle');
           return;
       }

       // Find the follower rectangle (red)
       const followerRect = canvasObjects.find(obj =>
           obj.groupId === selectedObject.groupId &&
           !obj.isMasterRectangle &&
           obj.masterRectangleId === selectedObject.id
       );

       if (!followerRect) {
           console.log('🟢🔴 SCALE RECTANGLE GROUP: No follower rectangle found');
           return;
       }

       // Scale the master rectangle (green)
       selectedObject.width = selectedObject.originalWidth * scale;
       selectedObject.height = selectedObject.originalHeight * scale;

       // Scale the follower rectangle (red) proportionally
       followerRect.width = followerRect.originalWidth * scale;
       followerRect.height = followerRect.originalHeight * scale;

       console.log('🟢🔴 SCALE RECTANGLE GROUP: Scaled rectangles:', {
           master: { width: selectedObject.width, height: selectedObject.height },
           follower: { width: followerRect.width, height: followerRect.height },
           scale: scale
       });

       // Update the display
       update();
   }

   // 🎯 FIT GREEN RECTANGLE IN LAYOUT: Move and scale existing green rectangle to fit inside layout
   function fitGreenRectangleInLayout() {
       console.log('🎯 FIT GREEN RECTANGLE: Starting move and scale approach...');

       // Check if a layout rectangle is selected
       const isLayoutSelected = selectedLayoutRectIndex !== -1 &&
                                layoutRectangles &&
                                layoutRectangles[selectedLayoutRectIndex];

       if (!isLayoutSelected) {
           console.log('🎯 FIT GREEN RECTANGLE: ❌ No layout rectangle selected');
           if (window.showToast) window.showToast('Please select a layout rectangle first', 'error');
           return;
       }

       const selectedLayout = layoutRectangles[selectedLayoutRectIndex];

       // Find the green rectangle (master rectangle)
       const greenRect = canvasObjects.find(obj => obj.isMasterRectangle && obj.groupId);
       if (!greenRect) {
           console.log('🎯 FIT GREEN RECTANGLE: ❌ No green rectangle found');
           if (window.showToast) window.showToast('No green rectangle found. Create one first using "Draw Fitting Rectangle"', 'error');
           return;
       }

       // Find the red rectangle (follower) - could be text bounding box or shape bounding box
       const redRect = canvasObjects.find(obj =>
           obj.groupId === greenRect.groupId &&
           (obj.isTextBoundingBox === true || obj.isShapeBoundingBox === true)
       );

       console.log('🎯 FIT GREEN RECTANGLE: Found rectangles:', {
           layout: { x: selectedLayout.x, y: selectedLayout.y, width: selectedLayout.width, height: selectedLayout.height },
           green: { x: greenRect.x, y: greenRect.y, width: greenRect.width, height: greenRect.height },
           red: redRect ? { x: redRect.x, y: redRect.y, width: redRect.width, height: redRect.height } : 'not found'
       });

       // Calculate layout center
       const layoutCenterX = selectedLayout.x + selectedLayout.width / 2;
       const layoutCenterY = selectedLayout.y + selectedLayout.height / 2;

       // Calculate scale to fit green rectangle inside layout (no padding - exact fit)
       const availableWidth = selectedLayout.width;
       const availableHeight = selectedLayout.height;

       // Use original dimensions if available, otherwise current dimensions
       const greenOriginalWidth = greenRect.originalWidth || greenRect.width;
       const greenOriginalHeight = greenRect.originalHeight || greenRect.height;

       const scaleX = availableWidth / greenOriginalWidth;
       const scaleY = availableHeight / greenOriginalHeight;
       const fitScale = Math.min(scaleX, scaleY);

       console.log('🎯 FIT GREEN RECTANGLE: Calculated fitting:', {
           layoutCenter: { x: layoutCenterX, y: layoutCenterY },
           availableSpace: { width: availableWidth, height: availableHeight },
           originalSize: { width: greenOriginalWidth, height: greenOriginalHeight },
           scales: { x: scaleX, y: scaleY, final: fitScale }
       });

       // Store the relative offset between green and red rectangles
       let redOffsetX = 0, redOffsetY = 0;
       if (redRect) {
           // Calculate relative offset between green and red rectangles (same for both text and shapes)
           redOffsetX = redRect.x - greenRect.x;
           redOffsetY = redRect.y - greenRect.y;

           console.log('🎯 FIT GREEN RECTANGLE: Red rectangle relative offset:', {
               x: redOffsetX,
               y: redOffsetY,
               greenPos: { x: greenRect.x, y: greenRect.y },
               redPos: { x: redRect.x, y: redRect.y },
               redType: redRect.isTextBoundingBox ? 'text' : (redRect.isShapeBoundingBox ? 'shape' : 'unknown')
           });
       }

       // Move green rectangle to layout center
       const oldGreenPos = { x: greenRect.x, y: greenRect.y };
       greenRect.x = layoutCenterX;
       greenRect.y = layoutCenterY;

       // Scale green rectangle
       greenRect.width = greenOriginalWidth * fitScale;
       greenRect.height = greenOriginalHeight * fitScale;

       console.log('🎯 FIT GREEN RECTANGLE: Updated green rectangle:', {
           moved: { from: oldGreenPos, to: { x: greenRect.x, y: greenRect.y } },
           scaled: { width: greenRect.width, height: greenRect.height, scale: fitScale }
       });

       // Move and scale red rectangle to maintain relative position (same for both text and shapes)
       if (redRect) {
           const redOriginalWidth = redRect.originalWidth || redRect.width;
           const redOriginalHeight = redRect.originalHeight || redRect.height;

           const oldRedPos = { x: redRect.x, y: redRect.y };

           // 🔧 PROPORTIONAL FIX: Scale the offset by the same factor as the rectangles
           const scaledOffsetX = redOffsetX * fitScale;
           const scaledOffsetY = redOffsetY * fitScale;

           redRect.x = greenRect.x + scaledOffsetX;
           redRect.y = greenRect.y + scaledOffsetY;
           redRect.width = redOriginalWidth * fitScale;
           redRect.height = redOriginalHeight * fitScale;

           console.log('🎯 FIT GREEN RECTANGLE: Updated red rectangle:', {
               moved: { from: oldRedPos, to: { x: redRect.x, y: redRect.y } },
               size: { width: redRect.width, height: redRect.height },
               calculation: {
                   greenNewPos: { x: greenRect.x, y: greenRect.y },
                   originalOffset: { x: redOffsetX, y: redOffsetY },
                   scaledOffset: { x: scaledOffsetX, y: scaledOffsetY },
                   fitScale: fitScale,
                   result: { x: greenRect.x + scaledOffsetX, y: greenRect.y + scaledOffsetY }
               },
               redType: redRect.isTextBoundingBox ? 'text' : (redRect.isShapeBoundingBox ? 'shape' : 'unknown')
           });
       }

       // Force canvas redraw
       update();

       // Update scale slider
       const rectangleScale = document.getElementById('rectangleScale');
       const rectangleScaleValue = document.getElementById('rectangleScaleValue');
       if (rectangleScale && rectangleScaleValue) {
           rectangleScale.value = fitScale.toFixed(1);
           rectangleScaleValue.textContent = fitScale.toFixed(1) + 'x';
       }

       if (window.showToast) {
           window.showToast(`Green rectangle fitted inside layout (scale: ${fitScale.toFixed(1)}x)`, 'success');
       }

       console.log('🎯 FIT GREEN RECTANGLE: ===== MOVE AND SCALE COMPLETED =====');
   }

   // 🎯 UPDATE LAYOUT SELECTION UI: Show/hide fit green rectangle button based on layout selection
   function updateLayoutSelectionUI() {
       const layoutFitGroup = document.getElementById('layoutFitGroup');
       const btnFitGreenRectangle = document.getElementById('btnFitGreenRectangle');
       const clearLayoutBtn = document.getElementById('clearLayoutBtn');

       // Check if a layout rectangle is selected
       const isLayoutSelected = selectedLayoutRectIndex !== -1 &&
                                layoutRectangles &&
                                layoutRectangles[selectedLayoutRectIndex];

       // Check if there's a green rectangle available to fit
       const hasGreenRect = canvasObjects.some(obj => obj.isMasterRectangle && obj.groupId);

       console.log('🎯 LAYOUT UI UPDATE:', {
           isLayoutSelected: isLayoutSelected,
           hasGreenRect: hasGreenRect,
           selectedLayoutRectIndex: selectedLayoutRectIndex
       });

       // Update fit green rectangle button
       if (isLayoutSelected && hasGreenRect) {
           // Show the fit button
           if (layoutFitGroup) layoutFitGroup.style.display = 'block';
           if (btnFitGreenRectangle) btnFitGreenRectangle.disabled = false;
           console.log('🎯 LAYOUT UI: Showing fit green rectangle button');
       } else {
           // Hide the fit button
           if (layoutFitGroup) layoutFitGroup.style.display = 'none';
           if (btnFitGreenRectangle) btnFitGreenRectangle.disabled = true;
           console.log('🎯 LAYOUT UI: Hiding fit green rectangle button');
       }

       // Update clear layout button text and tooltip
       if (clearLayoutBtn) {
           if (isLayoutSelected) {
               clearLayoutBtn.title = 'Delete Selected Layout Rectangle';
               console.log('🎯 LAYOUT UI: Clear button set to delete selected rectangle');
           } else if (layoutRectangles && layoutRectangles.length > 0) {
               clearLayoutBtn.title = 'Clear All Layout Rectangles';
               console.log('🎯 LAYOUT UI: Clear button set to delete all rectangles');
           } else {
               clearLayoutBtn.title = 'No Layout Rectangles to Delete';
               console.log('🎯 LAYOUT UI: Clear button disabled - no rectangles');
           }
       }
   }

   // 🎯 REVOLUTIONARY: Function to draw text with pixel-perfect clipping
   function drawPixelPerfectClippedText(obj, targetCtx) {
       console.log('🎯 CLIPPING: ===== STARTING PIXEL-PERFECT CLIPPED RENDERING =====');

       // Create a temporary canvas for the full text rendering
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = 1200; // Large enough for scaled text
       tempCanvas.height = 600;
       const tempCtx = tempCanvas.getContext('2d');

       // Set up the text context exactly as it would be rendered
       setTextContextOn(tempCtx, obj);
       tempCtx.textAlign = 'left';
       tempCtx.textBaseline = 'top';
       tempCtx.fillStyle = obj.color;

       // Draw text at a known position
       const startX = 200;
       const startY = 200;
       fillMultiLineText(tempCtx, obj.text, startX, startY, obj);

       console.log('🎯 CLIPPING: Text rendered on temp canvas at:', startX, startY);

       // Get image data to find pixel bounds
       const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
       const data = imageData.data;

       let minX = tempCanvas.width, maxX = 0;
       let minY = tempCanvas.height, maxY = 0;
       let hasPixels = false;

       // Find the actual pixels that contain text
       for (let y = 0; y < tempCanvas.height; y++) {
           for (let x = 0; x < tempCanvas.width; x++) {
               const index = (y * tempCanvas.width + x) * 4;
               const alpha = data[index + 3]; // Alpha channel

               if (alpha > 0) { // If pixel is not transparent
                   minX = Math.min(minX, x);
                   maxX = Math.max(maxX, x);
                   minY = Math.min(minY, y);
                   maxY = Math.max(maxY, y);
                   hasPixels = true;
               }
           }
       }

       if (!hasPixels) {
           console.log('🎯 CLIPPING: No pixels found, falling back to normal rendering');
           // Fallback to normal rendering
           setTextContextOn(targetCtx, obj);
           targetCtx.fillStyle = obj.color;
           fillMultiLineText(targetCtx, obj.text, 0, 0, obj);
           return;
       }

       // Calculate the exact text bounds
       const textWidth = maxX - minX + 1;
       const textHeight = maxY - minY + 1;

       console.log('🎯 CLIPPING: Found text bounds:', { minX, maxX, minY, maxY, textWidth, textHeight });

       // Create a clipped canvas with only the text shape
       const clippedCanvas = document.createElement('canvas');
       clippedCanvas.width = textWidth;
       clippedCanvas.height = textHeight;
       const clippedCtx = clippedCanvas.getContext('2d');

       // Copy only the text pixels to the clipped canvas
       const clippedImageData = clippedCtx.createImageData(textWidth, textHeight);
       const clippedData = clippedImageData.data;

       for (let y = 0; y < textHeight; y++) {
           for (let x = 0; x < textWidth; x++) {
               const sourceIndex = ((minY + y) * tempCanvas.width + (minX + x)) * 4;
               const targetIndex = (y * textWidth + x) * 4;

               clippedData[targetIndex] = data[sourceIndex];     // R
               clippedData[targetIndex + 1] = data[sourceIndex + 1]; // G
               clippedData[targetIndex + 2] = data[sourceIndex + 2]; // B
               clippedData[targetIndex + 3] = data[sourceIndex + 3]; // A
           }
       }

       clippedCtx.putImageData(clippedImageData, 0, 0);

       console.log('🎯 CLIPPING: Created clipped canvas:', textWidth, 'x', textHeight);

       // Draw the clipped text to the target canvas, centered
       targetCtx.save();
       targetCtx.drawImage(clippedCanvas, -textWidth / 2, -textHeight / 2);
       targetCtx.restore();

       console.log('🎯 CLIPPING: ===== PIXEL-PERFECT CLIPPED RENDERING COMPLETE =====');
   }

   // 🎯 UNIFIED: Pixel-perfect detection function used by both guidelines and shrink features
   function getPixelPerfectObjectBounds(obj) {
       console.log('🎯 UNIFIED: ===== STARTING UNIFIED PIXEL-PERFECT DETECTION =====');
       console.log('🎯 UNIFIED: Processing object:', obj.type, obj.text || obj.imageUrl || 'object');

       // Create a temporary canvas for pixel-perfect detection
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = 1200;
       tempCanvas.height = 600;
       const tempCtx = tempCanvas.getContext('2d');

       // Draw object at a known position (center of canvas area)
       const startX = 600; // Center of 1200px width
       const startY = 300; // Center of 600px height

       if (obj.type === 'text') {
           // Set up the text context exactly as it would be rendered
           setTextContextOn(tempCtx, obj);
           tempCtx.textAlign = 'center';  // 🎯 SAME: Use same alignment as actual rendering
           tempCtx.textBaseline = 'middle'; // 🎯 SAME: Use same baseline as actual rendering
           tempCtx.fillStyle = '#000000'; // Use black for detection
           fillMultiLineText(tempCtx, obj.text, startX, startY, obj);
           console.log('🎯 UNIFIED: Text rendered for pixel analysis at:', startX, startY);
       } else if (obj.type === 'image' && obj.image) {
           // For regular image objects (including SVGs), draw the image
           const scale = Math.min(400 / obj.image.naturalWidth, 400 / obj.image.naturalHeight); // Scale to fit in analysis area
           const drawWidth = obj.image.naturalWidth * scale;
           const drawHeight = obj.image.naturalHeight * scale;
           tempCtx.drawImage(obj.image, startX - drawWidth/2, startY - drawHeight/2, drawWidth, drawHeight);
           console.log('🎯 UNIFIED: Image rendered for pixel analysis at:', startX, startY, 'size:', drawWidth, 'x', drawHeight);
       } else if (obj.isUngroupedShape && obj.image) {
           // For ungrouped shapes, draw the image
           const scale = Math.min(400 / obj.image.naturalWidth, 400 / obj.image.naturalHeight); // Scale to fit in analysis area
           const drawWidth = obj.image.naturalWidth * scale;
           const drawHeight = obj.image.naturalHeight * scale;
           tempCtx.drawImage(obj.image, startX - drawWidth/2, startY - drawHeight/2, drawWidth, drawHeight);
           console.log('🎯 UNIFIED: Ungrouped shape rendered for pixel analysis at:', startX, startY, 'size:', drawWidth, 'x', drawHeight);
       }

       // Get image data to analyze pixels
       const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
       const data = imageData.data;

       let minX = tempCanvas.width, maxX = 0;
       let minY = tempCanvas.height, maxY = 0;
       let hasPixels = false;

       // Find the actual pixels that contain content
       for (let y = 0; y < tempCanvas.height; y++) {
           for (let x = 0; x < tempCanvas.width; x++) {
               const index = (y * tempCanvas.width + x) * 4;
               const alpha = data[index + 3]; // Alpha channel

               if (alpha > 0) { // If pixel is not transparent
                   minX = Math.min(minX, x);
                   maxX = Math.max(maxX, x);
                   minY = Math.min(minY, y);
                   maxY = Math.max(maxY, y);
                   hasPixels = true;
               }
           }
       }

       if (!hasPixels) {
           console.log('🎯 UNIFIED: No pixels found, cannot detect bounds');
           return null;
       }

       // Calculate the exact bounds relative to the center position
       const contentWidth = maxX - minX + 1;
       const contentHeight = maxY - minY + 1;

       // Calculate offsets from center position
       const contentCenterX = (minX + maxX) / 2;
       const contentCenterY = (minY + maxY) / 2;
       const offsetFromCenterX = contentCenterX - startX;
       const offsetFromCenterY = contentCenterY - startY;

       console.log('🎯 UNIFIED: Pixel-perfect content bounds:', {
           contentWidth, contentHeight, contentCenterX, contentCenterY, offsetFromCenterX, offsetFromCenterY,
           objectType: obj.type, isUngrouped: obj.isUngroupedShape,
           objectScale: obj.scale, objectPosition: {x: obj.x, y: obj.y}
       });

       // Convert to world coordinates based on object position (which is the center)
       // For ungrouped shapes, we need to account for the scaling factor used in rendering
       let scaleAdjustment = 1;
       if (obj.isUngroupedShape && obj.image) {
           const renderScale = Math.min(400 / obj.image.naturalWidth, 400 / obj.image.naturalHeight);
           scaleAdjustment = (obj.scale || 0.1) / renderScale; // Convert from render scale to actual object scale
       }

       const newCenterX = obj.x + (offsetFromCenterX * scaleAdjustment);
       const newCenterY = obj.y + (offsetFromCenterY * scaleAdjustment);
       const finalWidth = contentWidth * scaleAdjustment;
       const finalHeight = contentHeight * scaleAdjustment;

       const worldLeft = newCenterX - (finalWidth / 2);
       const worldRight = newCenterX + (finalWidth / 2);
       const worldTop = newCenterY - (finalHeight / 2);
       const worldBottom = newCenterY + (finalHeight / 2);

       console.log('🎯 UNIFIED: World coordinates calculated:', {
           newCenterX, newCenterY, finalWidth, finalHeight,
           worldLeft, worldRight, worldTop, worldBottom,
           scaleAdjustment: obj.isUngroupedShape ? scaleAdjustment : 'N/A'
       });



       console.log('🎯 UNIFIED: ===== UNIFIED PIXEL-PERFECT DETECTION COMPLETE =====');

       return {
           contentWidth: finalWidth,
           contentHeight: finalHeight,
           newCenterX: newCenterX,
           newCenterY: newCenterY,
           worldLeft: worldLeft,
           worldRight: worldRight,
           worldTop: worldTop,
           worldBottom: worldBottom,
           offsetFromCenterX: offsetFromCenterX * scaleAdjustment,
           offsetFromCenterY: offsetFromCenterY * scaleAdjustment
       };
   }

   // 🎯 REVOLUTIONARY: Function to add guidelines around selected text or shape using unified pixel-perfect detection
   function addGuidelinesAroundSelectedText() {
       console.log('🎯 GUIDELINES: ===== STARTING PIXEL-PERFECT GUIDELINE CREATION =====');

       if (selectedObjectIndex === -1 || !canvasObjects[selectedObjectIndex] ||
           (canvasObjects[selectedObjectIndex].type !== 'text' && canvasObjects[selectedObjectIndex].type !== 'shape' && canvasObjects[selectedObjectIndex].type !== 'image')) {
           console.log('🎯 GUIDELINES: No text, shape, or image object selected');
           return;
       }

       const obj = canvasObjects[selectedObjectIndex];
       console.log('🎯 GUIDELINES: Creating guidelines around', obj.type + ':', obj.text || obj.imageUrl || 'object');

       // Handle shapes and images differently from text
       if (obj.type === 'shape' || obj.type === 'image') {
           // Check if this is an ungrouped SVG shape that needs pixel-perfect detection
           if (obj.isUngroupedShape) {
               console.log('🎯 GUIDELINES: Detected ungrouped SVG shape, using pixel-perfect detection');
               // Use pixel-perfect detection for ungrouped shapes (like text)
               // Fall through to the text pixel detection logic below
           } else {
               // For regular image/shape objects, calculate actual display dimensions using scale
               let actualWidth, actualHeight;

               if (obj.type === 'image') {
                   // Image objects store originalWidth/originalHeight and scale
                   actualWidth = (obj.originalWidth || obj.width || 100) * (obj.scale || 1);
                   actualHeight = (obj.originalHeight || obj.height || 100) * (obj.scale || 1);
               } else {
                   // Shape objects use width/height directly
                   actualWidth = obj.width || 100;
                   actualHeight = obj.height || 100;
               }

               const halfWidth = actualWidth / 2;
               const halfHeight = actualHeight / 2;

               const worldLeft = obj.x - halfWidth;
               const worldRight = obj.x + halfWidth;
               const worldTop = obj.y - halfHeight;
               const worldBottom = obj.y + halfHeight;

               console.log('🎯 GUIDELINES: Object bounds:', {
                   type: obj.type,
                   actualWidth, actualHeight,
                   originalWidth: obj.originalWidth, originalHeight: obj.originalHeight,
                   scale: obj.scale,
                   worldLeft, worldRight, worldTop, worldBottom
               });

               // Create 4 guidelines around the object
               createCanvasGuideline('vertical', worldLeft);     // Left edge
               createCanvasGuideline('vertical', worldRight);    // Right edge
               createCanvasGuideline('horizontal', worldTop);    // Top edge
               createCanvasGuideline('horizontal', worldBottom); // Bottom edge

               console.log('🎯 GUIDELINES: Created 4 guidelines around', obj.type);
               console.log('🎯 GUIDELINES: ===== OBJECT GUIDELINE CREATION COMPLETE =====');

               // Update the canvas to show the new guidelines
               update();
               return;
           }
       }

       // For text objects and ungrouped shapes, use unified pixel-perfect detection
       const pixelBounds = getPixelPerfectObjectBounds(obj);

       if (!pixelBounds) {
           console.log('🎯 GUIDELINES: Failed to get pixel-perfect bounds');
           return;
       }

       // Create 4 guidelines around the pixel-perfect shape using unified bounds
       createCanvasGuideline('vertical', pixelBounds.worldLeft);     // Left edge
       createCanvasGuideline('vertical', pixelBounds.worldRight);    // Right edge
       createCanvasGuideline('horizontal', pixelBounds.worldTop);    // Top edge
       createCanvasGuideline('horizontal', pixelBounds.worldBottom); // Bottom edge

       console.log('🎯 GUIDELINES: Created 4 pixel-perfect guidelines around', obj.type === 'text' ? 'text' : 'ungrouped shape');
       console.log('🎯 GUIDELINES: ===== PIXEL-PERFECT GUIDELINE CREATION COMPLETE =====');

       // Update the canvas to show the new guidelines
       update();
   }

   function calculateObjectBounds(obj) {
       if (!obj) return { x: 0, y: 0, width: 0, height: 0, cx: 0, cy: 0 };

       if (obj.type === 'text') {
           if (!obj.text) return { x: 0, y: 0, width: 0, height: 0, cx: obj.x, cy: obj.y };

           // 📦 CHECK: Use custom bounds if text box has been optimized
           if (obj.customBounds && obj.customBounds.isOptimized) {
               console.log('📦 BOUNDS: Using optimized custom bounds for text:', obj.text);
               const scale = obj.scale || 1;
               const scaledWidth = obj.customBounds.width * scale;
               const scaledHeight = obj.customBounds.height * scale;

               return {
                   x: obj.x - scaledWidth / 2,
                   y: obj.y - scaledHeight / 2,
                   width: scaledWidth,
                   height: scaledHeight,
                   cx: obj.x,
                   cy: obj.y
               };
           }

           const tempCtx = document.createElement('canvas').getContext('2d');
           setTextContextOn(tempCtx, obj);

           // 📦 MULTI-LINE BOUNDS: Check if text is wrapped (textBoxWidth > 0)
           const textBoxWidth = obj.textBoxWidth || 0;
           let width, height;

           if (textBoxWidth > 0) {
               // 📦 WRAPPED TEXT: Calculate dimensions for multi-line text
               const lines = obj.text.split('\n');
               console.log('📦 BOUNDS: Calculating wrapped text bounds for', lines.length, 'lines');

               // Find the widest line
               let maxLineWidth = 0;
               const letterSpacing = obj._effectiveLetterSpacing || 0;

               lines.forEach((line, index) => {
                   let lineWidth;
                   if (letterSpacing === 0) {
                       lineWidth = tempCtx.measureText(line).width;
                   } else {
                       // Calculate width with letter spacing for this line
                       const letters = line.split('');
                       let totalWidth = 0;
                       letters.forEach(letter => {
                           totalWidth += tempCtx.measureText(letter).width;
                       });
                       if (letters.length > 1) {
                           totalWidth += letterSpacing * (letters.length - 1);
                       }
                       lineWidth = totalWidth;
                   }
                   maxLineWidth = Math.max(maxLineWidth, lineWidth);
                   console.log('📦 BOUNDS: Line', index + 1, ':', line, 'width:', lineWidth);
               });

               width = maxLineWidth;

               // Calculate height for multiple lines
               const fontSize = obj.fontSize || 20;
               const lineHeight = fontSize * 1.2; // Standard line height
               height = lines.length * lineHeight;

               console.log('📦 BOUNDS: Wrapped text final dimensions - width:', width, 'height:', height, 'lines:', lines.length);
           } else {
               // 📦 SINGLE LINE: Use existing single-line calculation
               const letterSpacing = obj._effectiveLetterSpacing || 0;

               if (letterSpacing === 0) {
                   // Standard text measurement
                   const metrics = tempCtx.measureText(obj.text);
                   width = metrics.width;
               } else {
                   // Calculate width with letter spacing
                   const letters = obj.text.split('');
                   let totalWidth = 0;

                   // Sum the width of each letter
                   letters.forEach(letter => {
                       totalWidth += tempCtx.measureText(letter).width;
                   });

                   // Add letter spacing between characters
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }

                   width = totalWidth;
               }

               const metrics = tempCtx.measureText(obj.text);
               const ascent = metrics.actualBoundingBoxAscent || obj.fontSize * 0.8;
               const descent = metrics.actualBoundingBoxDescent || obj.fontSize * 0.2;
               height = ascent + descent;

               console.log('📦 BOUNDS: Single line text dimensions - width:', width, 'height:', height);
           }

           // Apply scale to dimensions (like image objects do)
           const objScale = obj.scale || 1;
           const scaledWidth = width * objScale;
           const scaledHeight = height * objScale;

           // 📦 ALIGNMENT BOUNDS: Calculate selection box position based on text alignment
           let selectionX = obj.x - scaledWidth / 2; // Default: center alignment
           const textAlign = obj.textAlign || 'left';

           if (textBoxWidth > 0) {
               console.log('📦 ===== CALCULATE OBJECT BOUNDS FLOW START =====');
               console.log('📦 BOUNDS: Object details:', {
                   id: obj.id,
                   text: obj.text,
                   textAlign: obj.textAlign,
                   textBoxWidth: obj.textBoxWidth,
                   x: obj.x,
                   y: obj.y
               });

               // For wrapped text, calculate text box width based on character limit, not actual text width
               // This must match EXACTLY the logic in fillMultiLineText and renderStyledObjectToOffscreen
               // Use dynamic padding that prevents source rectangle from going out of bounds
               // Canvas width is typically 8192, so we need to ensure text box doesn't exceed ~7000 pixels
               const maxSafePadding = Math.max(1, Math.min(10, Math.floor((7000 - textBoxWidth * 135) / 135)));
               const safePadding = Math.max(1, maxSafePadding);
               const sampleText = 'A'.repeat(textBoxWidth + safePadding);
               const actualTextBoxPixelWidth = tempCtx.measureText(sampleText).width * scale;

               console.log('📦 ALIGNMENT BOUNDS DEBUG: textAlign:', textAlign, 'textBoxWidth:', textBoxWidth, 'safePadding:', safePadding, 'textBoxPixelWidth:', actualTextBoxPixelWidth, 'actualTextWidth:', scaledWidth);

               // Calculate the same way as in renderStyledObjectToOffscreen (line 7841+)
               const textBoxLeft = obj.x - actualTextBoxPixelWidth / 2;
               const textBoxRight = obj.x + actualTextBoxPixelWidth / 2;

               console.log('📦 ALIGNMENT BOUNDS DEBUG: textBoxLeft:', textBoxLeft, 'textBoxRight:', textBoxRight);

               // IMPORTANT: Use the character-limit-based width for the selection box, not the actual text width
               // This ensures the selection box shows the intended text box boundaries
               selectionX = textBoxLeft;

               console.log('📦 ALIGNMENT BOUNDS FINAL: selectionX:', selectionX, 'selectionWidth:', actualTextBoxPixelWidth, 'for alignment:', textAlign);
               console.log('📦 ALIGNMENT BOUNDS: Using character-limit-based width instead of actual text width');

               const bounds = {
                   x: selectionX,
                   y: obj.y - scaledHeight / 2,
                   width: actualTextBoxPixelWidth,
                   height: scaledHeight,
                   cx: obj.x,
                   cy: obj.y
               };

               console.log('📦 BOUNDS: Final bounds result:', bounds);
               console.log('📦 ===== CALCULATE OBJECT BOUNDS FLOW END =====');

               // Return early with the character-limit-based bounds
               return bounds;
           }

           return {
               x: selectionX,
               y: obj.y - scaledHeight / 2,
               width: scaledWidth,
               height: scaledHeight,
               cx: obj.x,
               cy: obj.y
           };
       } else if (obj.type === 'image') {
           if (!obj.image || !obj.originalWidth || !obj.originalHeight)
               return { x: 0, y: 0, width: 0, height: 0, cx: obj.x, cy: obj.y };

           const scaledWidth = obj.originalWidth * obj.scale;
           const scaledHeight = obj.originalHeight * obj.scale;

           // Add stroke width to bounds if stroke is enabled
           let strokePadding = 0;
           if (obj.strokeMode === 'standard' && obj.strokeWidth) {
               // Use maximum padding to ensure proper selection area for thick strokes
               strokePadding = Math.max(obj.strokeWidth * 3, obj.strokeWidth + 20);
           }

           return {
               x: obj.x - scaledWidth / 2 - strokePadding,
               y: obj.y - scaledHeight / 2 - strokePadding,
               width: scaledWidth + strokePadding * 2,
               height: scaledHeight + strokePadding * 2,
               cx: obj.x,
               cy: obj.y
           };
       } else if (obj.type === 'rectangle') {
           // 🔗 RECTANGLE BOUNDS: Handle rectangle object bounds for selection
           const width = obj.width || 100;
           const height = obj.height || 100;

           const bounds = {
               x: obj.x - width / 2,
               y: obj.y - height / 2,
               width: width,
               height: height,
               cx: obj.x,
               cy: obj.y
           };

           console.log('🔗 RECTANGLE BOUNDS: Calculated bounds for rectangle:', obj.id, bounds);
           return bounds;
       }

       return { x: 0, y: 0, width: 0, height: 0, cx: 0, cy: 0 };
   }
   function getRotatedBoundingBox(bounds, angleDeg) { const cx = bounds.cx; const cy = bounds.cy; const w = bounds.width; const h = bounds.height; const x = bounds.x; const y = bounds.y; if (w === 0 || h === 0) return { x: cx, y: cy, width: 0, height: 0 }; const angleRad = angleDeg * Math.PI / 180; const cos = Math.cos(angleRad); const sin = Math.sin(angleRad); const corners = [ { x: x, y: y }, { x: x + w, y: y }, { x: x + w, y: y + h }, { x: x, y: y + h } ]; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; corners.forEach(corner => { const translatedX = corner.x - cx; const translatedY = corner.y - cy; const rotatedX = translatedX * cos - translatedY * sin; const rotatedY = translatedX * sin + translatedY * cos; const finalX = rotatedX + cx; const finalY = rotatedY + cy; minX = Math.min(minX, finalX); minY = Math.min(minY, finalY); maxX = Math.max(maxX, finalX); maxY = Math.max(maxY, finalY); }); return { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; }

   // --- UI Binding ---
   function setControlsDisabled(wrapperElement, isDisabled, keepTextEnabled = false) {
       console.log('🔧 setControlsDisabled called:', {
           isDisabled: isDisabled,
           keepTextEnabled: keepTextEnabled,
           wrapperElement: wrapperElement.id
       });

       wrapperElement.querySelectorAll('input, select, button').forEach(el => {
           // Special handling for #iText based on keepTextEnabled flag
           if (el.id === 'iText') {
               el.disabled = keepTextEnabled ? false : isDisabled;
           } else {
               el.disabled = isDisabled;
           }

           // Log letter spacing control specifically
           if (el.id === 'iLetterSpacing') {
               console.log('🔧 Letter spacing control in setControlsDisabled:', {
                   id: el.id,
                   disabled: el.disabled,
                   isDisabled: isDisabled
               });
           }

           // Log shrink text box button specifically
           if (el.id === 'btnShrinkTextBox') {
               console.log('🔧 Shrink text box button in setControlsDisabled:', {
                   id: el.id,
                   disabled: el.disabled,
                   isDisabled: isDisabled
               });
           }
       });
   }
   function updateUIFromSelectedObject() {
       console.log('🔍 updateUIFromSelectedObject called');
       console.log('🔍 selectedObjectIndex:', selectedObjectIndex);
       console.log('🔍 canvasObjects length:', canvasObjects.length);

       // 🔧 CRITICAL FIX: Bounds check and auto-correction for selectedObjectIndex
       if (selectedObjectIndex >= canvasObjects.length) {
           console.log('🚨 ROTATION BUG: selectedObjectIndex out of bounds during rotation!');
           console.log('🚨 ROTATION BUG: selectedObjectIndex:', selectedObjectIndex, 'canvasObjects.length:', canvasObjects.length);
           console.log('🚨 ROTATION BUG: This is likely causing the auto-selection of different objects during rotation');
           console.log('🚨 ROTATION BUG: Stack trace:', new Error().stack);

           // 🔧 TEMPORARY FIX: Instead of auto-selecting the last object, set to -1 to prevent unwanted selection changes
           console.log('🔧 BOUNDS FIX: Setting selectedObjectIndex to -1 instead of auto-selecting last object');
           selectedObjectIndex = -1;
           syncGlobalReferences(); // Sync the corrected value
           return; // Exit early to prevent further processing
       }

       const selectedObject = selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length ? canvasObjects[selectedObjectIndex] : null;
       console.log('🔍 selectedObject:', selectedObject);

       // Define checks for button state *once* at the beginning
       const canMoveForward = selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length - 1;
       const canMoveBackward = selectedObjectIndex !== -1 && selectedObjectIndex > 0;

       // Auto-switch tabs based on selected object type
       if (selectedObject) {
           const sidebarTabs = document.querySelectorAll('.sidebar-tab');
           const sidebarContents = document.querySelectorAll('.sidebar-content');

           let targetTab = null;
           if (selectedObject.type === 'text') {
               targetTab = document.querySelector('.sidebar-tab[data-tab="text-tab-content"]');
               console.log('💾 Switching to text tab for text object:', selectedObject.id);
           } else if (selectedObject.type === 'image') {
               targetTab = document.querySelector('.sidebar-tab[data-tab="image-tab-content"]');
               console.log('💾 Switching to image tab for image object:', selectedObject.id);
           }

           if (targetTab) {
               console.log('💾 Target tab found:', targetTab.getAttribute('data-tab'));
               // Switch to the appropriate tab
               sidebarTabs.forEach(t => t.classList.remove('active'));
               sidebarContents.forEach(c => c.classList.remove('active'));
               targetTab.classList.add('active');
               document.getElementById(targetTab.getAttribute('data-tab'))?.classList.add('active');
               console.log('💾 Tab switched successfully');
           } else {
               console.log('💾 Target tab not found for object type:', selectedObject.type);
           }
       }

       if (selectedObject) {
           if (selectedObject.type === 'text') {
               setControlsDisabled(textControlsWrapper, false, true); // Enable all text controls, keep #iText enabled
               imageControlsWrapper.classList.remove('visible');
               noImageSelectedMsg.style.display = 'block';
               deleteImageBtn.disabled = true;
               addEditTextBtn.textContent = 'Edit';
               deleteTextBtn.disabled = false;

               // Populate text controls (omitted for brevity - this part is unchanged)
               iText.value = selectedObject.text;
               iTextColor.value = selectedObject.color;

               // Update color intensity control
               if (iTextColorIntensity) {
                   // Initialize colorIntensity if it doesn't exist (for existing objects)
                   if (selectedObject.colorIntensity === undefined) {
                       selectedObject.colorIntensity = 'no-change';
                       console.log('🎨 Initialized colorIntensity for existing text object:', selectedObject.id);
                   }
                   iTextColorIntensity.value = selectedObject.colorIntensity;
                   console.log('🎨 Set text color intensity dropdown to:', selectedObject.colorIntensity);
               }

               // Update gradient picker if it exists
               const textGradientPicker = document.getElementById('textGradientPicker');
               if (textGradientPicker && textGradientPicker.gradientPickerInstance) {
                   if (selectedObject.gradient) {
                       textGradientPicker.gradientPickerInstance.setValue(selectedObject.gradient.value, selectedObject.gradient.type);
                   } else {
                       textGradientPicker.gradientPickerInstance.setValue(selectedObject.color, 'solid');
                   }
               }

               // ===== FONT DROPDOWN SYNC FIX =====
               // Don't set iFontFamily.value directly as it can cause invalid selectedIndex
               // Let the sync function handle it properly
               console.log('🔤 Text object font:', selectedObject.fontFamily);

               // FONT VARIANT SYSTEM: Update Bold/Italic controls when text object is selected
               if (window.fontVariantDetector && window.fontVariantDetector.initialized) {
                   window.fontVariantDetector.updateVariantControls(selectedObject.fontFamily);
               }

               // ===== SYNC FONT NAVIGATION DROPDOWN =====
               if (window.syncFontDropdown && typeof window.syncFontDropdown === 'function') {
                   console.log('🔤 Syncing font dropdown from updateUIFromSelectedObject');
                   window.syncFontDropdown();
               } else {
                   // Fallback: only set value if font exists in dropdown options
                   const fontOptions = Array.from(iFontFamily.options).map(option => option.value);
                   if (fontOptions.includes(selectedObject.fontFamily)) {
                       iFontFamily.value = selectedObject.fontFamily;
                       console.log('🔤 Fallback: Set dropdown to existing font:', selectedObject.fontFamily);
                   } else {
                       console.log('🔤 Fallback: Font not in dropdown, keeping current selection');
                   }
               }

               iBold.checked = selectedObject.bold;
               iItalic.checked = selectedObject.italic;
               iFontSize.value = selectedObject.fontSize; vFontSize.textContent = selectedObject.fontSize + 'px';
               iTextRotation.value = selectedObject.rotation; vTextRotation.textContent = selectedObject.rotation + '°';

               // Update letter spacing control
               const letterSpacing = selectedObject.letterSpacing !== undefined ? selectedObject.letterSpacing : 0;
               const iLetterSpacing = document.getElementById('iLetterSpacing');
               if (iLetterSpacing) {
                   iLetterSpacing.value = letterSpacing;
                   // CRITICAL FIX: Ensure letter spacing control is enabled for all text objects
                   // including those with usePixelPerfectFitting (text in layout rectangles)
                   iLetterSpacing.disabled = false;
                   console.log('🔧 Letter spacing control enabled for text object:', {
                       text: selectedObject.text,
                       letterSpacing: letterSpacing,
                       usePixelPerfectFitting: selectedObject.usePixelPerfectFitting,
                       disabled: iLetterSpacing.disabled
                   });
               }
               document.getElementById('vLetterSpacing').textContent = letterSpacing + 'px';

               // Update text box width control
               // Initialize textBoxWidth if it doesn't exist (for existing objects)
               if (selectedObject.textBoxWidth === undefined) {
                   selectedObject.textBoxWidth = 0;
                   console.log('📦 Initialized textBoxWidth for existing text object:', selectedObject.id);
               }
               const textBoxWidth = selectedObject.textBoxWidth;
               if (iTextBoxWidth && textBoxWidthValue) {
                   iTextBoxWidth.value = textBoxWidth;
                   textBoxWidthValue.textContent = textBoxWidth === 0 ? '0 (unlimited)' : `${textBoxWidth} characters`;
                   console.log('📦 Text box width control updated:', textBoxWidth);
               }

               // Update text alignment controls
               // Initialize textAlign if it doesn't exist (for existing objects)
               if (selectedObject.textAlign === undefined) {
                   selectedObject.textAlign = 'left';
                   console.log('📝 Initialized textAlign for existing text object:', selectedObject.id);
               }
               const textAlign = selectedObject.textAlign;
               const alignmentButtons = document.querySelectorAll('.alignment-btn');
               alignmentButtons.forEach(btn => {
                   btn.classList.remove('active');
                   if (btn.getAttribute('data-align') === textAlign) {
                       btn.classList.add('active');
                   }
               });
               console.log('📝 Text alignment control updated:', textAlign);

               // Update line height control
               // Initialize lineHeight if it doesn't exist (for existing objects)
               if (selectedObject.lineHeight === undefined) {
                   selectedObject.lineHeight = 1.2;
                   console.log('📏 Initialized lineHeight for existing text object:', selectedObject.id);
               }
               const lineHeight = selectedObject.lineHeight;
               if (iLineHeight && lineHeightValue) {
                   iLineHeight.value = lineHeight;
                   lineHeightValue.textContent = `${lineHeight}x`;
                   console.log('📏 Line height control updated:', lineHeight);
               }

               // Enable shrink text box button for text objects
               const btnShrinkTextBox = document.getElementById('btnShrinkTextBox');
               if (btnShrinkTextBox) {
                   btnShrinkTextBox.disabled = false;
                   console.log('🔧 Shrink text box button enabled for text object');
               }

               // Enable draw fitting rectangle button for text objects
               const btnDrawFittingRectangle = document.getElementById('btnDrawFittingRectangle');
               if (btnDrawFittingRectangle) {
                   btnDrawFittingRectangle.disabled = false;
                   console.log('🔧 Draw fitting rectangle button enabled for text object');
               }

               // Update opacity control
               const opacity = selectedObject.opacity !== undefined ? selectedObject.opacity : 100;
               document.getElementById('iOpacity').value = opacity;
               document.getElementById('vOpacity').textContent = opacity + '%';

               // Update template ID control
               const textTemplateId = document.getElementById('textTemplateId');
               if (textTemplateId) {
                   textTemplateId.value = selectedObject.templateId || '';
                   textTemplateId.disabled = false; // Enable the dropdown when text is selected
               }

               // Update persistent parameter displays for text
               const debugNewColorIntensity = document.getElementById('debugNewColorIntensity');
               const debugNewTemplateId = document.getElementById('debugNewTemplateId');
               console.log('💾 === DEBUG ELEMENT CHECK ===');
               console.log('💾 debugNewColorIntensity element:', debugNewColorIntensity);
               console.log('💾 debugNewTemplateId element:', debugNewTemplateId);
               console.log('💾 Selected object:', selectedObject);

               // Force update the debug displays immediately for testing
               if (debugNewColorIntensity) {
                   debugNewColorIntensity.textContent = 'TEST VALUE - WORKING!';
                   debugNewColorIntensity.style.backgroundColor = '#ffff00'; // Yellow background for visibility
                   console.log('💾 Updated debugNewColorIntensity with test value');
               } else {
                   console.log('💾 ERROR: debugNewColorIntensity element not found!');
               }

               if (debugNewTemplateId) {
                   debugNewTemplateId.textContent = 'TEST VALUE - WORKING!';
                   debugNewTemplateId.style.backgroundColor = '#ffff00'; // Yellow background for visibility
                   console.log('💾 Updated debugNewTemplateId with test value');
               } else {
                   console.log('💾 ERROR: debugNewTemplateId element not found!');
               }

               if (debugNewColorIntensity) {
                   // Load persistent values from database if they don't exist or are N/A
                   if (selectedObject.newColorIntensity === undefined || selectedObject.newColorIntensity === 'N/A') {
                       selectedObject.newColorIntensity = 'N/A';
                       console.log('💾 Loading persistent parameters for text object:', selectedObject.id);
                       // Try to load from database
                       loadPersistentParametersForObject(selectedObject).then(() => {
                           console.log('💾 Loaded persistent parameters, updating debug display');
                           if (debugNewColorIntensity) {
                               debugNewColorIntensity.textContent = selectedObject.newColorIntensity || 'N/A';
                           }
                       });
                   }
                   debugNewColorIntensity.textContent = selectedObject.newColorIntensity;
                   console.log('💾 Set debugNewColorIntensity to:', selectedObject.newColorIntensity);
               }
               if (debugNewTemplateId) {
                   // Load persistent values from database if they don't exist or are N/A
                   if (selectedObject.newTemplateId === undefined || selectedObject.newTemplateId === 'N/A') {
                       selectedObject.newTemplateId = 'N/A';
                       console.log('💾 Loading persistent parameters for text object:', selectedObject.id);
                       // Try to load from database
                       loadPersistentParametersForObject(selectedObject).then(() => {
                           console.log('💾 Loaded persistent parameters, updating debug display');
                           if (debugNewTemplateId) {
                               debugNewTemplateId.textContent = selectedObject.newTemplateId || 'N/A';
                           }
                       });
                   }
                   debugNewTemplateId.textContent = selectedObject.newTemplateId;
                   console.log('💾 Set debugNewTemplateId to:', selectedObject.newTemplateId);
               }

               // Update circular rotation slider if it exists
               const iCircleRotation = document.getElementById('iCircleRotation');
               const vCircleRotation = document.getElementById('vCircleRotation');
               if (iCircleRotation && vCircleRotation) {
                   iCircleRotation.value = selectedObject.rotation;
                   vCircleRotation.textContent = selectedObject.rotation + '°';
               }
               effectModeSelect.value = selectedObject.effectMode;
               skewSlider.value = selectedObject.skewX; vSkew.textContent = selectedObject.skewX;
               skewYSlider.value = selectedObject.skewY; vSkewY.textContent = selectedObject.skewY;
               iCurve.value = selectedObject.warpCurve; vCurve.textContent = selectedObject.warpCurve;
               iOffset.value = selectedObject.warpOffset; vOffset.textContent = selectedObject.warpOffset;
               iHeight.value = selectedObject.warpHeight; vHeight.textContent = selectedObject.warpHeight;
               iBottom.value = selectedObject.warpBottom; vBottom.textContent = selectedObject.warpBottom;
               iTriangle.checked = selectedObject.warpTriangle;
               iShiftCenter.value = selectedObject.warpShiftCenter; vShiftCenter.textContent = selectedObject.warpShiftCenter;
               iDiameter.value = selectedObject.circleDiameter; vDiameter.textContent = selectedObject.circleDiameter + 'px';
               iKerning.value = selectedObject.circleKerning; vKerning.textContent = selectedObject.circleKerning + 'px';
               iFlip.checked = selectedObject.circleFlip;
               iCurveAmount.value = selectedObject.curveAmount; vCurveAmount.textContent = selectedObject.curveAmount;
               iCurveKerning.value = selectedObject.curveKerning; vCurveKerning.textContent = selectedObject.curveKerning + 'px';
               iCurveFlip.checked = selectedObject.curveFlip;

               // Grid Distort controls
               if (document.getElementById('iGridDistortCols')) {
                   const iGridDistortCols = document.getElementById('iGridDistortCols');
                   const vGridDistortCols = document.getElementById('vGridDistortCols');
                   const iGridDistortRows = document.getElementById('iGridDistortRows');
                   const vGridDistortRows = document.getElementById('vGridDistortRows');
                   const iGridDistortPadding = document.getElementById('iGridDistortPadding');
                   const vGridDistortPadding = document.getElementById('vGridDistortPadding');
                   const iGridDistortIntensity = document.getElementById('iGridDistortIntensity');
                   const vGridDistortIntensity = document.getElementById('vGridDistortIntensity');
                   const resetGridDistortBtn = document.getElementById('resetGridDistortBtn');
                   const toggleGridDistortBtn = document.getElementById('toggleGridDistortBtn');

                   iGridDistortCols.value = selectedObject.gridDistortCols || 3;
                   vGridDistortCols.textContent = selectedObject.gridDistortCols || 3;

                   iGridDistortRows.value = selectedObject.gridDistortRows || 2;
                   vGridDistortRows.textContent = selectedObject.gridDistortRows || 2;

                   iGridDistortPadding.value = selectedObject.gridDistortPadding || 120;
                   vGridDistortPadding.textContent = (selectedObject.gridDistortPadding || 120) + 'px';

                   iGridDistortIntensity.value = selectedObject.gridDistortIntensity || 100;
                   vGridDistortIntensity.textContent = (selectedObject.gridDistortIntensity || 100) + '%';

                   // Set the direction radio buttons
                   const gridDistortDirectionBoth = document.getElementById('gridDistortDirectionBoth');
                   const gridDistortDirectionVertical = document.getElementById('gridDistortDirectionVertical');

                   if (gridDistortDirectionBoth && gridDistortDirectionVertical) {
                       if (selectedObject.gridDistortVerticalOnly) {
                           gridDistortDirectionVertical.checked = true;
                           gridDistortDirectionBoth.checked = false;
                       } else {
                           gridDistortDirectionBoth.checked = true;
                           gridDistortDirectionVertical.checked = false;
                       }
                   }

                   // Enable Grid Distort buttons when a text object is selected
                   // and when the grid-distort effect is selected
                   if (resetGridDistortBtn) {
                       resetGridDistortBtn.disabled = false;
                   }

                   if (toggleGridDistortBtn) {
                       toggleGridDistortBtn.disabled = false;

                       // Update button text based on current grid visibility state
                       if (selectedObject.gridDistort && selectedObject.gridDistort.showGrid) {
                           toggleGridDistortBtn.textContent = 'Hide Grid';
                       } else {
                           toggleGridDistortBtn.textContent = 'Show Grid';
                       }
                   }

                   // If the effect mode is grid-distort, make sure the buttons are enabled
                   if (selectedObject.effectMode === 'grid-distort') {
                       if (resetGridDistortBtn) resetGridDistortBtn.disabled = false;
                       if (toggleGridDistortBtn) toggleGridDistortBtn.disabled = false;

                       // Enable direction radio buttons
                       if (gridDistortDirectionBoth) gridDistortDirectionBoth.disabled = false;
                       if (gridDistortDirectionVertical) gridDistortDirectionVertical.disabled = false;
                   }
               }

               // Mesh Warp controls
               if (document.getElementById('iMeshCols')) {
                   const iMeshCols = document.getElementById('iMeshCols');
                   const iMeshRows = document.getElementById('iMeshRows');
                   const resetMeshBtn = document.getElementById('resetMeshBtn');
                   const toggleMeshBtn = document.getElementById('toggleMeshBtn');

                   // If we have an active mesh handler for this object, update UI
                   if (typeof activeMeshWarpHandler !== 'undefined' &&
                       activeMeshWarpHandler &&
                       activeMeshWarpHandler.selectedTextObject === selectedObject) {

                       // Update UI with current values from the handler
                       if (iMeshCols) iMeshCols.value = activeMeshWarpHandler.NUM_COLS;
                       if (iMeshRows) iMeshRows.value = activeMeshWarpHandler.NUM_ROWS;

                       // Enable controls
                       if (iMeshCols) iMeshCols.disabled = false;
                       if (iMeshRows) iMeshRows.disabled = false;
                       if (resetMeshBtn) resetMeshBtn.disabled = false;
                       if (toggleMeshBtn) toggleMeshBtn.disabled = false;

                       // Update toggle button text
                       if (toggleMeshBtn) toggleMeshBtn.textContent = activeMeshWarpHandler.showGrid ? 'Hide Grid' : 'Show Grid';
                   } else if (selectedObject.effectMode === 'mesh') {
                       // If effect mode is mesh but no handler exists, create one
                       console.log('Effect mode is mesh but no handler exists, creating one');

                       // Create a new mesh warp handler for this object
                       activeMeshWarpHandler = new MeshWarpHandler(
                           document.getElementById('demo'),
                           selectedObject
                       );

                       // Enable controls
                       if (iMeshCols) iMeshCols.disabled = false;
                       if (iMeshRows) iMeshRows.disabled = false;
                       if (resetMeshBtn) resetMeshBtn.disabled = false;
                       if (toggleMeshBtn) toggleMeshBtn.disabled = false;

                       // Update toggle button text
                       if (toggleMeshBtn) toggleMeshBtn.textContent = activeMeshWarpHandler.showGrid ? 'Hide Grid' : 'Show Grid';
                   } else {
                       // Disable controls if not in mesh mode
                       if (iMeshCols) iMeshCols.disabled = true;
                       if (iMeshRows) iMeshRows.disabled = true;
                       if (resetMeshBtn) resetMeshBtn.disabled = true;
                       if (toggleMeshBtn) toggleMeshBtn.disabled = true;
                   }
               }

               if (shadowSelect) shadowSelect.value = selectedObject.shadowMode;
               if (shadowColorPicker) shadowColorPicker.value = selectedObject.shadowColor;
               if (shadowOffsetXSlider) shadowOffsetXSlider.value = selectedObject.shadowOffsetX;
               if (vShadowOffsetX) vShadowOffsetX.textContent = selectedObject.shadowOffsetX + 'px';
               if (shadowOffsetYSlider) shadowOffsetYSlider.value = selectedObject.shadowOffsetY;
               if (vShadowOffsetY) vShadowOffsetY.textContent = selectedObject.shadowOffsetY + 'px';
               if (shadowBlurSlider) shadowBlurSlider.value = selectedObject.shadowBlur;
               if (vShadowBlur) vShadowBlur.textContent = selectedObject.shadowBlur + 'px';

               // Block Shadow controls
               if (blockShadowColorPicker) blockShadowColorPicker.value = selectedObject.blockShadowColor;
               if (blockShadowOpacitySlider) blockShadowOpacitySlider.value = selectedObject.blockShadowOpacity;
               if (vBlockShadowOpacity) vBlockShadowOpacity.textContent = selectedObject.blockShadowOpacity + '%';
               if (blockShadowOffsetSlider) blockShadowOffsetSlider.value = selectedObject.blockShadowOffset;
               if (vBlockShadowOffset) vBlockShadowOffset.textContent = selectedObject.blockShadowOffset + 'px';
               if (blockShadowAngleSlider) blockShadowAngleSlider.value = selectedObject.blockShadowAngle;
               if (vBlockShadowAngle) vBlockShadowAngle.textContent = selectedObject.blockShadowAngle + '°';
               if (blockShadowBlurSlider) blockShadowBlurSlider.value = selectedObject.blockShadowBlur;
               if (vBlockShadowBlur) vBlockShadowBlur.textContent = selectedObject.blockShadowBlur + 'px';
               if (blockShadowPerspective) blockShadowPerspective.checked = selectedObject.blockShadowPerspective || false;
               // Enable the perspective toggle only if block shadow is selected
               if (blockShadowPerspective) blockShadowPerspective.disabled = (selectedObject.shadowMode !== 'blockShadow');

               // Set perspective intensity slider value
               if (blockShadowPerspectiveIntensity) blockShadowPerspectiveIntensity.value = selectedObject.blockShadowPerspectiveIntensity || 50;
               if (vBlockShadowPerspectiveIntensity) vBlockShadowPerspectiveIntensity.textContent = (selectedObject.blockShadowPerspectiveIntensity || 50) + '%';
               if (blockShadowPerspectiveIntensity) blockShadowPerspectiveIntensity.disabled = (selectedObject.shadowMode !== 'blockShadow' || !selectedObject.blockShadowPerspective);

               // Show/hide the perspective intensity control based on perspective toggle
               const perspectiveControl = document.querySelector('.perspective-control');
               if (perspectiveControl) {
                   perspectiveControl.style.display = (selectedObject.blockShadowPerspective && selectedObject.shadowMode === 'blockShadow') ? 'block' : 'none';
               }

               // Perspective Shadow controls
               const perspectiveShadowColorPicker = document.getElementById('perspectiveShadowColor');
               const perspectiveShadowOpacitySlider = document.getElementById('perspectiveShadowOpacity');
               const perspectiveShadowOffsetSlider = document.getElementById('perspectiveShadowOffset');
               const perspectiveShadowAngleSlider = document.getElementById('perspectiveShadowAngle');
               const perspectiveShadowBlurSlider = document.getElementById('perspectiveShadowBlur');
               const perspectiveShadowIntensitySlider = document.getElementById('perspectiveShadowIntensity');
               const vPerspectiveShadowOpacity = document.getElementById('vPerspectiveShadowOpacity');
               const vPerspectiveShadowOffset = document.getElementById('vPerspectiveShadowOffset');
               const vPerspectiveShadowAngle = document.getElementById('vPerspectiveShadowAngle');
               const vPerspectiveShadowBlur = document.getElementById('vPerspectiveShadowBlur');
               const vPerspectiveShadowIntensity = document.getElementById('vPerspectiveShadowIntensity');

               if (perspectiveShadowColorPicker) perspectiveShadowColorPicker.value = selectedObject.perspectiveShadowColor || '#333333';
               if (perspectiveShadowOpacitySlider) {
                   perspectiveShadowOpacitySlider.value = selectedObject.perspectiveShadowOpacity || 100;
                   if (vPerspectiveShadowOpacity) vPerspectiveShadowOpacity.textContent = (selectedObject.perspectiveShadowOpacity || 100) + '%';
               }
               if (perspectiveShadowOffsetSlider) {
                   perspectiveShadowOffsetSlider.value = selectedObject.perspectiveShadowOffset || 6;
                   if (vPerspectiveShadowOffset) vPerspectiveShadowOffset.textContent = (selectedObject.perspectiveShadowOffset || 6) + 'px';
               }
               if (perspectiveShadowAngleSlider) {
                   perspectiveShadowAngleSlider.value = selectedObject.perspectiveShadowAngle || 105;
                   if (vPerspectiveShadowAngle) vPerspectiveShadowAngle.textContent = (selectedObject.perspectiveShadowAngle || 105) + '°';
               }
               if (perspectiveShadowBlurSlider) {
                   perspectiveShadowBlurSlider.value = selectedObject.perspectiveShadowBlur || 2;
                   if (vPerspectiveShadowBlur) vPerspectiveShadowBlur.textContent = (selectedObject.perspectiveShadowBlur || 2) + 'px';
               }
               if (perspectiveShadowIntensitySlider) {
                   perspectiveShadowIntensitySlider.value = selectedObject.perspectiveShadowIntensity || 16;
                   if (vPerspectiveShadowIntensity) vPerspectiveShadowIntensity.textContent = (selectedObject.perspectiveShadowIntensity || 16) + '%';
               }

               // Perspective Shadow Outline controls
               const perspectiveShadowOutlineColorPicker = document.getElementById('perspectiveShadowOutlineColor');
               const perspectiveShadowOutlineOpacitySlider = document.getElementById('perspectiveShadowOutlineOpacity');
               const perspectiveShadowOutlineWidthSlider = document.getElementById('perspectiveShadowOutlineWidth');
               const perspectiveShadowOutlineOffsetXSlider = document.getElementById('perspectiveShadowOutlineOffsetX');
               const perspectiveShadowOutlineOffsetYSlider = document.getElementById('perspectiveShadowOutlineOffsetY');
               const vPerspectiveShadowOutlineOpacity = document.getElementById('vPerspectiveShadowOutlineOpacity');
               const vPerspectiveShadowOutlineWidth = document.getElementById('vPerspectiveShadowOutlineWidth');
               const vPerspectiveShadowOutlineOffsetX = document.getElementById('vPerspectiveShadowOutlineOffsetX');
               const vPerspectiveShadowOutlineOffsetY = document.getElementById('vPerspectiveShadowOutlineOffsetY');

               if (perspectiveShadowOutlineColorPicker) perspectiveShadowOutlineColorPicker.value = selectedObject.perspectiveShadowOutlineColor || '#d1d5db';
               if (perspectiveShadowOutlineOpacitySlider) {
                   perspectiveShadowOutlineOpacitySlider.value = selectedObject.perspectiveShadowOutlineOpacity || 100;
                   if (vPerspectiveShadowOutlineOpacity) vPerspectiveShadowOutlineOpacity.textContent = (selectedObject.perspectiveShadowOutlineOpacity || 100) + '%';
               }
               if (perspectiveShadowOutlineWidthSlider) {
                   perspectiveShadowOutlineWidthSlider.value = selectedObject.perspectiveShadowOutlineWidth || 3;
                   if (vPerspectiveShadowOutlineWidth) vPerspectiveShadowOutlineWidth.textContent = (selectedObject.perspectiveShadowOutlineWidth || 3) + 'px';
               }
               if (perspectiveShadowOutlineOffsetXSlider) {
                   perspectiveShadowOutlineOffsetXSlider.value = selectedObject.perspectiveShadowOutlineOffsetX || 2;
                   if (vPerspectiveShadowOutlineOffsetX) vPerspectiveShadowOutlineOffsetX.textContent = (selectedObject.perspectiveShadowOutlineOffsetX || 2) + 'px';
               }
               if (perspectiveShadowOutlineOffsetYSlider) {
                   perspectiveShadowOutlineOffsetYSlider.value = selectedObject.perspectiveShadowOutlineOffsetY || -3;
                   if (vPerspectiveShadowOutlineOffsetY) vPerspectiveShadowOutlineOffsetY.textContent = (selectedObject.perspectiveShadowOutlineOffsetY || -3) + 'px';
               }
               if (lineShadowColorPicker) lineShadowColorPicker.value = selectedObject.lineShadowColor;
               if (lineShadowDistanceSlider) lineShadowDistanceSlider.value = selectedObject.lineShadowDist;
               if (vLineShadowDistance) vLineShadowDistance.textContent = selectedObject.lineShadowDist + 'px';
               if (lineShadowAngleSlider) lineShadowAngleSlider.value = selectedObject.lineShadowAngle;
               if (vLineShadowAngle) vLineShadowAngle.textContent = selectedObject.lineShadowAngle + '°';
               if (lineShadowThicknessSlider) lineShadowThicknessSlider.value = selectedObject.lineShadowThickness;
               if (vLineShadowThickness) vLineShadowThickness.textContent = selectedObject.lineShadowThickness + 'px';
               if (detailed3DPrimaryColorPicker) detailed3DPrimaryColorPicker.value = selectedObject.d3dPrimaryColor;
               if (detailed3DPrimaryOpacitySlider) detailed3DPrimaryOpacitySlider.value = selectedObject.d3dPrimaryOpacity;
               if (vDetailed3DPrimaryOpacity) vDetailed3DPrimaryOpacity.textContent = selectedObject.d3dPrimaryOpacity + '%';
               if (detailed3DOffsetSlider) detailed3DOffsetSlider.value = selectedObject.d3dOffset;
               if (vDetailed3DOffset) vDetailed3DOffset.textContent = selectedObject.d3dOffset + 'px';
               if (detailed3DAngleSlider) detailed3DAngleSlider.value = selectedObject.d3dAngle;
               if (vDetailed3DAngle) vDetailed3DAngle.textContent = selectedObject.d3dAngle + '°';
               if (detailed3DBlurSlider) detailed3DBlurSlider.value = selectedObject.d3dBlur;
               if (vDetailed3DBlur) vDetailed3DBlur.textContent = selectedObject.d3dBlur + 'px';
               if (detailed3DSecondaryColorPicker) detailed3DSecondaryColorPicker.value = selectedObject.d3dSecondaryColor;
               if (detailed3DSecondaryOpacitySlider) detailed3DSecondaryOpacitySlider.value = selectedObject.d3dSecondaryOpacity;
               if (vDetailed3DSecondaryOpacity) vDetailed3DSecondaryOpacity.textContent = selectedObject.d3dSecondaryOpacity + '%';
               if (detailed3DSecondaryWidthSlider) detailed3DSecondaryWidthSlider.value = selectedObject.d3dSecondaryWidth;
               if (vDetailed3DSecondaryWidth) vDetailed3DSecondaryWidth.textContent = selectedObject.d3dSecondaryWidth + 'px';
               if (detailed3DSecondaryOffsetXSlider) detailed3DSecondaryOffsetXSlider.value = selectedObject.d3dSecondaryOffsetX;
               if (vDetailed3DSecondaryOffsetX) vDetailed3DSecondaryOffsetX.textContent = selectedObject.d3dSecondaryOffsetX + 'px';
               if (detailed3DSecondaryOffsetYSlider) detailed3DSecondaryOffsetYSlider.value = selectedObject.d3dSecondaryOffsetY;
               if (vDetailed3DSecondaryOffsetY) vDetailed3DSecondaryOffsetY.textContent = selectedObject.d3dSecondaryOffsetY + 'px';
               if (strokeToggle) strokeToggle.value = selectedObject.strokeMode;
               if (strokeWidthSlider) strokeWidthSlider.value = selectedObject.strokeWidth;
               if (vStrokeWidth) vStrokeWidth.textContent = selectedObject.strokeWidth + 'px';
               if (strokeColorPicker) strokeColorPicker.value = selectedObject.strokeColor;
               if (strokeOpacitySlider) strokeOpacitySlider.value = selectedObject.strokeOpacity || 100;
               if (vStrokeOpacity) vStrokeOpacity.textContent = (selectedObject.strokeOpacity || 100) + '%';
               if (linesDecorationSelect) linesDecorationSelect.value = selectedObject.decorationMode;
               if (hWeight) hWeight.value = selectedObject.hLineWeight;
               if (vHWeight) vHWeight.textContent = selectedObject.hLineWeight + 'px';
               if (hDistance) hDistance.value = selectedObject.hLineDist;
               if (vHDistance) vHDistance.textContent = selectedObject.hLineDist + 'px';
               if (hColor) hColor.value = selectedObject.hLineColor;
               if (hOpacity) hOpacity.value = selectedObject.hLineOpacity || 100;
               if (vHOpacity) vHOpacity.textContent = (selectedObject.hLineOpacity || 100) + '%';
               if (ccDistance) ccDistance.value = selectedObject.ccDist;
               if (vCcDistance) vCcDistance.textContent = selectedObject.ccDist + '%';
               if (ccColor) ccColor.value = selectedObject.ccColor;
               if (ccOpacity) ccOpacity.value = selectedObject.ccOpacity || 100;
               if (vCcOpacity) vCcOpacity.textContent = (selectedObject.ccOpacity || 100) + '%';
               if (ccFillTop && ccFillBottom) {
                   if (selectedObject.ccFillDir === 'top') {
                       ccFillTop.checked = true;
                       ccFillBottom.checked = false;
                   } else {
                       ccFillTop.checked = false;
                       ccFillBottom.checked = true;
                   }
               }
               if (oWeight) oWeight.value = selectedObject.oLineWeight;
               if (vOWeight) vOWeight.textContent = selectedObject.oLineWeight + 'px';
               if (oDistance) oDistance.value = selectedObject.oLineDist;
               if (vODistance) vODistance.textContent = selectedObject.oLineDist + 'px';
               if (oColor) oColor.value = selectedObject.oLineColor;
               if (oOpacity) oOpacity.value = selectedObject.oOpacity || 100;
               if (vOOpacity) vOOpacity.textContent = (selectedObject.oOpacity || 100) + '%';
               if (flcDistance) flcDistance.value = selectedObject.flcDist;
               if (vFlcDistance) vFlcDistance.textContent = selectedObject.flcDist + '%';
               if (flcColor) flcColor.value = selectedObject.flcColor;
               if (flcOpacity) flcOpacity.value = selectedObject.flcOpacity || 100;
               if (vFlcOpacity) vFlcOpacity.textContent = (selectedObject.flcOpacity || 100) + '%';
               if (flcMaxWeight) flcMaxWeight.value = selectedObject.flcWeight;
               if (vFlcMaxWeight) vFlcMaxWeight.textContent = selectedObject.flcWeight + 'px';
               if (flcSpacing) flcSpacing.value = selectedObject.flcSpacing;
               if (vFlcSpacing) vFlcSpacing.textContent = selectedObject.flcSpacing + 'px';
               if (flcFillTop && flcFillBottom) {
                   if (selectedObject.flcDir === 'top') {
                       flcFillTop.checked = true;
                       flcFillBottom.checked = false;
                   } else {
                       flcFillTop.checked = false;
                       flcFillBottom.checked = true;
                   }
               }

               updateBodyClass(selectedObject);

           } else if (selectedObject.type === 'image') {
               setControlsDisabled(textControlsWrapper, true, true); // Disable text controls BUT keep #iText enabled
               imageControlsWrapper.classList.add('visible');
               noImageSelectedMsg.style.display = 'none';
               deleteImageBtn.disabled = false;
               addEditTextBtn.textContent = 'Add'; // Keep 'Add' for text when image selected
               deleteTextBtn.disabled = true;

               // Populate image controls
               iImageSize.value = selectedObject.scale; vImageSize.textContent = Math.round(selectedObject.scale * 100) + '%';
               iImageRotation.value = selectedObject.rotation; vImageRotation.textContent = selectedObject.rotation + '°';
               iImageOpacity.value = selectedObject.opacity || 100; vImageOpacity.textContent = (selectedObject.opacity || 100) + '%';

               // Enable draw fitting rectangle button for shape/image objects
               const btnDrawFittingRectangleShape = document.getElementById('btnDrawFittingRectangleShape');
               if (btnDrawFittingRectangleShape) {
                   btnDrawFittingRectangleShape.disabled = false;
                   console.log('🔧 Draw fitting rectangle button enabled for shape/image object');
               }

               // Enable clean rectangles button for shape/image objects
               const btnCleanRectangles = document.getElementById('btnCleanRectangles');
               if (btnCleanRectangles) {
                   btnCleanRectangles.disabled = false;
                   console.log('🔧 Clean rectangles button enabled for shape/image object');
               }

               // Update template ID control
               const imageTemplateId = document.getElementById('imageTemplateId');
               if (imageTemplateId) {
                   imageTemplateId.value = selectedObject.templateId || '';
                   imageTemplateId.disabled = false; // Enable the dropdown when image is selected
               }

               // Update persistent parameter displays for images
               const debugImageNewColorIntensity = document.getElementById('debugImageNewColorIntensity');
               const debugImageNewTemplateId = document.getElementById('debugImageNewTemplateId');
               if (debugImageNewColorIntensity) {
                   // Load persistent values from database if they don't exist or are N/A
                   if (selectedObject.newColorIntensity === undefined || selectedObject.newColorIntensity === 'N/A') {
                       selectedObject.newColorIntensity = 'N/A';
                       // Try to load from database
                       loadPersistentParametersForObject(selectedObject).then(() => {
                           if (debugImageNewColorIntensity) {
                               debugImageNewColorIntensity.textContent = selectedObject.newColorIntensity || 'N/A';
                           }
                       });
                   }
                   debugImageNewColorIntensity.textContent = selectedObject.newColorIntensity;
               }
               if (debugImageNewTemplateId) {
                   // Load persistent values from database if they don't exist or are N/A
                   if (selectedObject.newTemplateId === undefined || selectedObject.newTemplateId === 'N/A') {
                       selectedObject.newTemplateId = 'N/A';
                       // Try to load from database
                       loadPersistentParametersForObject(selectedObject).then(() => {
                           if (debugImageNewTemplateId) {
                               debugImageNewTemplateId.textContent = selectedObject.newTemplateId || 'N/A';
                           }
                       });
                   }
                   debugImageNewTemplateId.textContent = selectedObject.newTemplateId;
               }

               // Populate image stroke controls
               iImageStroke.value = selectedObject.strokeMode || 'none';
               iImageStrokeWidth.value = selectedObject.strokeWidth || 3;
               vImageStrokeWidth.textContent = (selectedObject.strokeWidth || 3) + 'px';
               iImageStrokeColor.value = selectedObject.strokeColor || '#000000';
               iImageStrokeOpacity.value = selectedObject.strokeOpacity || 100;
               vImageStrokeOpacity.textContent = (selectedObject.strokeOpacity || 100) + '%';

               // Show/hide stroke parameter controls
               const imageStrokeParam = document.querySelector('.image-stroke-param');
               if (imageStrokeParam) {
                   imageStrokeParam.style.display = selectedObject.strokeMode === 'standard' ? 'block' : 'none';
               }

               // Populate image shadow controls
               iImageShadow.value = selectedObject.shadowMode || 'none';
               iImageShadowColor.value = selectedObject.shadowColor || '#000000';
               iImageShadowOpacity.value = selectedObject.shadowOpacity || 100;
               vImageShadowOpacity.textContent = (selectedObject.shadowOpacity || 100) + '%';
               iImageShadowOffsetX.value = selectedObject.shadowOffsetX || 5;
               vImageShadowOffsetX.textContent = (selectedObject.shadowOffsetX || 5) + 'px';
               iImageShadowOffsetY.value = selectedObject.shadowOffsetY || 5;
               vImageShadowOffsetY.textContent = (selectedObject.shadowOffsetY || 5) + 'px';
               iImageShadowBlur.value = selectedObject.shadowBlur || 10;
               vImageShadowBlur.textContent = (selectedObject.shadowBlur || 10) + 'px';

               // Show/hide shadow parameter controls
               const imageShadowParam = document.querySelector('.image-shadow-param');
               if (imageShadowParam) {
                   imageShadowParam.style.display = selectedObject.shadowMode === 'standard' ? 'block' : 'none';
               }

               // Populate CSS filter controls
               if (selectedObject.cssFilters) {
                   const filters = selectedObject.cssFilters;

                   // Update filter sliders
                   const iImageBlur = document.getElementById('iImageBlur');
                   const iImageBrightness = document.getElementById('iImageBrightness');
                   const iImageContrast = document.getElementById('iImageContrast');
                   const iImageSaturation = document.getElementById('iImageSaturation');
                   const iImageHue = document.getElementById('iImageHue');
                   const iImageGrayscale = document.getElementById('iImageGrayscale');
                   const iImageSepia = document.getElementById('iImageSepia');
                   const iImageInvert = document.getElementById('iImageInvert');

                   if (iImageBlur) {
                       iImageBlur.value = filters.blur || 0;
                       const vImageBlur = document.getElementById('vImageBlur');
                       if (vImageBlur) vImageBlur.textContent = (filters.blur || 0) + 'px';
                   }
                   if (iImageBrightness) {
                       iImageBrightness.value = filters.brightness || 1;
                       const vImageBrightness = document.getElementById('vImageBrightness');
                       if (vImageBrightness) vImageBrightness.textContent = Math.round((filters.brightness || 1) * 100) + '%';
                   }
                   if (iImageContrast) {
                       iImageContrast.value = filters.contrast || 1;
                       const vImageContrast = document.getElementById('vImageContrast');
                       if (vImageContrast) vImageContrast.textContent = Math.round((filters.contrast || 1) * 100) + '%';
                   }
                   if (iImageSaturation) {
                       iImageSaturation.value = filters.saturate || 1;
                       const vImageSaturation = document.getElementById('vImageSaturation');
                       if (vImageSaturation) vImageSaturation.textContent = Math.round((filters.saturate || 1) * 100) + '%';
                   }
                   if (iImageHue) {
                       iImageHue.value = filters.hueRotate || 0;
                       const vImageHue = document.getElementById('vImageHue');
                       if (vImageHue) vImageHue.textContent = (filters.hueRotate || 0) + 'deg';
                   }
                   if (iImageGrayscale) {
                       iImageGrayscale.value = filters.grayscale || 0;
                       const vImageGrayscale = document.getElementById('vImageGrayscale');
                       if (vImageGrayscale) vImageGrayscale.textContent = Math.round((filters.grayscale || 0) * 100) + '%';
                   }
                   if (iImageSepia) {
                       iImageSepia.value = filters.sepia || 0;
                       const vImageSepia = document.getElementById('vImageSepia');
                       if (vImageSepia) vImageSepia.textContent = Math.round((filters.sepia || 0) * 100) + '%';
                   }
                   if (iImageInvert) {
                       iImageInvert.value = filters.invert || 0;
                       const vImageInvert = document.getElementById('vImageInvert');
                       if (vImageInvert) vImageInvert.textContent = Math.round((filters.invert || 0) * 100) + '%';
                   }
               } else {
                   // Reset filter controls to default values
                   const defaultFilters = {
                       blur: 0, brightness: 1, contrast: 1, saturate: 1,
                       hueRotate: 0, grayscale: 0, sepia: 0, invert: 0
                   };

                   Object.keys(defaultFilters).forEach(filterName => {
                       const controlId = `iImage${filterName.charAt(0).toUpperCase() + filterName.slice(1)}`;
                       const control = document.getElementById(controlId);
                       if (control) {
                           control.value = defaultFilters[filterName];
                           const valueId = `v${controlId.substring(1)}`;
                           const valueDisplay = document.getElementById(valueId);
                           if (valueDisplay) {
                               let displayValue = defaultFilters[filterName];
                               if (filterName === 'blur') displayValue += 'px';
                               else if (filterName === 'hueRotate') displayValue += 'deg';
                               else if (filterName !== 'brightness' && filterName !== 'contrast' && filterName !== 'saturate') {
                                   displayValue = Math.round(displayValue * 100) + '%';
                               } else {
                                   displayValue = Math.round(displayValue * 100) + '%';
                               }
                               valueDisplay.textContent = displayValue;
                           }
                       }
                   });
               }

               // Populate duotone controls
               const duotoneEnabled = document.getElementById('duotoneEnabled');
               const duotoneColorControls = document.getElementById('duotone-color-controls');
               const duotoneColor1 = document.getElementById('duotoneColor1');
               const duotoneColor1Text = document.getElementById('duotoneColor1Text');
               const duotoneColor2 = document.getElementById('duotoneColor2');
               const duotoneColor2Text = document.getElementById('duotoneColor2Text');

               if (duotoneEnabled) {
                   duotoneEnabled.checked = selectedObject.duotoneEnabled || false;
               }

               if (duotoneColorControls) {
                   duotoneColorControls.style.display = selectedObject.duotoneEnabled ? 'block' : 'none';
               }

               if (selectedObject.duotoneEnabled) {
                   if (duotoneColor1 && selectedObject.duotoneColor1) {
                       duotoneColor1.value = selectedObject.duotoneColor1;
                   }
                   if (duotoneColor1Text && selectedObject.duotoneColor1) {
                       duotoneColor1Text.value = selectedObject.duotoneColor1;
                   }
                   if (duotoneColor2 && selectedObject.duotoneColor2) {
                       duotoneColor2.value = selectedObject.duotoneColor2;
                   }
                   if (duotoneColor2Text && selectedObject.duotoneColor2) {
                       duotoneColor2Text.value = selectedObject.duotoneColor2;
                   }
               } else {
                   // Reset to default values
                   if (duotoneColor1) duotoneColor1.value = '#3B82F6';
                   if (duotoneColor1Text) duotoneColor1Text.value = '#3B82F6';
                   if (duotoneColor2) duotoneColor2.value = '#EAB308';
                   if (duotoneColor2Text) duotoneColor2Text.value = '#EAB308';
               }

               // Populate glitch controls
               const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
               const colorShiftEnabled = document.getElementById('colorShiftEnabled');
               const waveDeformEnabled = document.getElementById('waveDeformEnabled');
               const displacementEnabled = document.getElementById('displacementEnabled');
               const pixelSortEnabled = document.getElementById('pixelSortEnabled');

               const paletteReductionControls = document.getElementById('palette-reduction-controls');
               const colorShiftControls = document.getElementById('color-shift-controls');
               const waveDeformControls = document.getElementById('wave-deform-controls');
               const displacementControls = document.getElementById('displacement-controls');
               const pixelSortControls = document.getElementById('pixel-sort-controls');

               if (selectedObject.glinchEnabled && selectedObject.glinchEffects) {
                   const effects = selectedObject.glinchEffects;

                   // Palette Reduction
                   if (paletteReductionEnabled) {
                       paletteReductionEnabled.checked = effects.paletteReduction && effects.paletteReduction.enabled;
                   }
                   if (paletteReductionControls) {
                       paletteReductionControls.style.display = (effects.paletteReduction && effects.paletteReduction.enabled) ? 'block' : 'none';
                   }
                   if (effects.paletteReduction && effects.paletteReduction.enabled) {
                       const paletteSelect = document.getElementById('paletteName');
                       const distanceSelect = document.getElementById('distanceMode');
                       const ditheringCheckbox = document.getElementById('useDithering');
                       if (paletteSelect) paletteSelect.value = effects.paletteReduction.paletteName || 'desert';
                       if (distanceSelect) distanceSelect.value = effects.paletteReduction.distanceMode || 'accurate';
                       if (ditheringCheckbox) ditheringCheckbox.checked = effects.paletteReduction.useDithering !== false;
                   }

                   // Color Shift
                   if (colorShiftEnabled) {
                       colorShiftEnabled.checked = effects.colorShift && effects.colorShift.enabled;
                   }
                   if (colorShiftControls) {
                       colorShiftControls.style.display = (effects.colorShift && effects.colorShift.enabled) ? 'block' : 'none';
                   }
                   if (effects.colorShift && effects.colorShift.enabled) {
                       const intensitySlider = document.getElementById('colorShiftIntensity');
                       const amountSlider = document.getElementById('colorShiftAmount');
                       if (intensitySlider) {
                           intensitySlider.value = effects.colorShift.intensity || 1;
                           const display = document.getElementById('vColorShiftIntensity');
                           if (display) display.textContent = Math.round((effects.colorShift.intensity || 1) * 100) + '%';
                       }
                       if (amountSlider) {
                           amountSlider.value = effects.colorShift.shiftAmount || 20;
                           const display = document.getElementById('vColorShiftAmount');
                           if (display) display.textContent = (effects.colorShift.shiftAmount || 20) + 'px';
                       }
                   }

                   // Wave Deform
                   if (waveDeformEnabled) {
                       waveDeformEnabled.checked = effects.waveDeform && effects.waveDeform.enabled;
                   }
                   if (waveDeformControls) {
                       waveDeformControls.style.display = (effects.waveDeform && effects.waveDeform.enabled) ? 'block' : 'none';
                   }
                   if (effects.waveDeform && effects.waveDeform.enabled) {
                       const directionSelect = document.getElementById('waveDirection');
                       const amplitudeSlider = document.getElementById('waveAmplitude');
                       const frequencySlider = document.getElementById('waveFrequency');
                       if (directionSelect) directionSelect.value = effects.waveDeform.direction || 'horizontal';
                       if (amplitudeSlider) {
                           amplitudeSlider.value = effects.waveDeform.amplitude || 10;
                           const display = document.getElementById('vWaveAmplitude');
                           if (display) display.textContent = (effects.waveDeform.amplitude || 10) + 'px';
                       }
                       if (frequencySlider) {
                           frequencySlider.value = effects.waveDeform.frequency || 0.05;
                           const display = document.getElementById('vWaveFrequency');
                           if (display) display.textContent = (effects.waveDeform.frequency || 0.05).toFixed(2);
                       }
                   }

                   // Displacement
                   if (displacementEnabled) {
                       displacementEnabled.checked = effects.displacement && effects.displacement.enabled;
                   }
                   if (displacementControls) {
                       displacementControls.style.display = (effects.displacement && effects.displacement.enabled) ? 'block' : 'none';
                   }
                   if (effects.displacement && effects.displacement.enabled) {
                       const modeSelect = document.getElementById('displacementMode');
                       const intensitySlider = document.getElementById('displacementIntensity');
                       const sizeSlider = document.getElementById('displacementSize');
                       if (modeSelect) modeSelect.value = effects.displacement.mode || 'horizontal';
                       if (intensitySlider) {
                           intensitySlider.value = effects.displacement.displacementIntensity || 8;
                           const display = document.getElementById('vDisplacementIntensity');
                           if (display) display.textContent = effects.displacement.displacementIntensity || 8;
                       }
                       if (sizeSlider) {
                           sizeSlider.value = effects.displacement.displacementSize || 18;
                           const display = document.getElementById('vDisplacementSize');
                           if (display) display.textContent = effects.displacement.displacementSize || 18;
                       }
                   }

                   // Pixel Sort
                   if (pixelSortEnabled) {
                       pixelSortEnabled.checked = effects.pixelSort && effects.pixelSort.enabled;
                   }
                   if (pixelSortControls) {
                       pixelSortControls.style.display = (effects.pixelSort && effects.pixelSort.enabled) ? 'block' : 'none';
                   }
                   if (effects.pixelSort && effects.pixelSort.enabled) {
                       const directionSelect = document.getElementById('pixelSortDirection');
                       const blockSizeSlider = document.getElementById('pixelSortBlockSize');
                       const frequencySlider = document.getElementById('pixelSortFrequency');
                       if (directionSelect) directionSelect.value = effects.pixelSort.direction || 'horizontal';
                       if (blockSizeSlider) {
                           blockSizeSlider.value = effects.pixelSort.blockSize || 5;
                           const display = document.getElementById('vPixelSortBlockSize');
                           if (display) display.textContent = effects.pixelSort.blockSize || 5;
                       }
                       if (frequencySlider) {
                           frequencySlider.value = effects.pixelSort.frequency || 0.5;
                           const display = document.getElementById('vPixelSortFrequency');
                           if (display) display.textContent = Math.round((effects.pixelSort.frequency || 0.5) * 100) + '%';
                       }
                   }
               } else {
                   // Reset all glitch controls to defaults
                   if (paletteReductionEnabled) paletteReductionEnabled.checked = false;
                   if (colorShiftEnabled) colorShiftEnabled.checked = false;
                   if (waveDeformEnabled) waveDeformEnabled.checked = false;
                   if (displacementEnabled) displacementEnabled.checked = false;
                   if (pixelSortEnabled) pixelSortEnabled.checked = false;

                   if (paletteReductionControls) paletteReductionControls.style.display = 'none';
                   if (colorShiftControls) colorShiftControls.style.display = 'none';
                   if (waveDeformControls) waveDeformControls.style.display = 'none';
                   if (displacementControls) displacementControls.style.display = 'none';
                   if (pixelSortControls) pixelSortControls.style.display = 'none';
               }

               // Show/hide color picker for SVG files
               const imageColorGroup = document.getElementById('imageColorGroup');
               const imageColorIntensityGroup = document.getElementById('imageColorIntensityGroup');
               const iImageColor = document.getElementById('iImageColor');

               if (selectedObject.imageUrl && selectedObject.imageUrl.toLowerCase().endsWith('.svg')) {
                   imageColorGroup.style.display = 'flex';
                   imageColorIntensityGroup.style.display = 'flex';
                   if (iImageColor) {
                       iImageColor.value = selectedObject.svgColor || '#000000';
                   }
                   if (iImageColorIntensity) {
                       // Initialize colorIntensity if it doesn't exist (for existing objects)
                       if (selectedObject.colorIntensity === undefined) {
                           selectedObject.colorIntensity = 'no-change';
                           console.log('🎨 Initialized colorIntensity for existing image object:', selectedObject.id);
                       }
                       iImageColorIntensity.value = selectedObject.colorIntensity;
                       console.log('🎨 Set image color intensity dropdown to:', selectedObject.colorIntensity);
                   }
               } else {
                   imageColorGroup.style.display = 'none';
                   imageColorIntensityGroup.style.display = 'none';
               }

               // Show/hide Remove Background button - always show for images
               const removeBgBtn = document.getElementById('removeBgBtn');
               if (removeBgBtn) {
                   removeBgBtn.style.display = 'block';

                   if (selectedObject.backgroundRemoved) {
                       removeBgBtn.disabled = true;
                       removeBgBtn.textContent = 'Background Removed';
                   } else {
                       removeBgBtn.disabled = false;
                       removeBgBtn.textContent = 'Remove Background';
                   }
               }

               // Show/hide Regenerate button - show for images that have admin data
               const regenerateBtn = document.getElementById('regenerateBtn');
               if (regenerateBtn) {
                   const hasAdminData = checkIfHasAdminData();
                   if (hasAdminData) {
                       regenerateBtn.style.display = 'block';
                       regenerateBtn.disabled = false;
                       regenerateBtn.textContent = 'Regenerate';
                   } else {
                       regenerateBtn.style.display = 'none';
                   }
               }

               // Show/hide Restyle button - show for images that have Original Object data
               const restyleBtn = document.getElementById('restyleBtn');
               if (restyleBtn) {
                   const restyleAvailable = checkIfRestyleAvailable();
                   console.log('🎨 Restyle button visibility check:', {
                       restyleAvailable: restyleAvailable,
                       selectedObjectType: selectedObject.type,
                       selectedObjectIndex: selectedObjectIndex
                   });
                   if (restyleAvailable) {
                       restyleBtn.style.display = 'block';
                       restyleBtn.disabled = false;
                       restyleBtn.textContent = 'Restyle';
                       console.log('🎨 Restyle button shown');
                   } else {
                       restyleBtn.style.display = 'none';
                       console.log('🎨 Restyle button hidden - no original object data');
                   }
               } else {
                   console.error('🎨 Restyle button element not found');
               }

               // Show/hide Replace button - show for all images (no admin data required)
               const replaceBtn = document.getElementById('replaceBtn');
               if (replaceBtn) {
                   console.log('🔄 Replace button visibility check:', {
                       selectedObjectType: selectedObject.type,
                       selectedObjectIndex: selectedObjectIndex
                   });
                   // Replace button is always available for images (no admin data required)
                   replaceBtn.style.display = 'block';
                   replaceBtn.disabled = false;
                   replaceBtn.textContent = 'Replace';
                   console.log('🔄 Replace button shown');
               } else {
                   console.error('🔄 Replace button element not found');
               }

               // Show/hide Image Masking controls
               if (imageMaskingGroup) {
                   imageMaskingGroup.style.display = 'block';

                   if (selectedObject.isMasked) {
                       // Image is masked - show unmask button, hide mask button
                       maskImageBtn.style.display = 'none';
                       unmaskImageBtn.style.display = 'block';
                   } else {
                       // Image is not masked - show mask button, hide unmask button
                       maskImageBtn.style.display = 'block';
                       unmaskImageBtn.style.display = 'none';
                   }
               }

               document.body.className = 'image-selected';
           } else if (selectedObject.type === 'rectangle') {
               // 🔗 RECTANGLE HANDLING: Handle rectangle object selection
               console.log('💾 Rectangle object selected:', selectedObject.id);

               // Disable text and image controls
               setControlsDisabled(textControlsWrapper, true, true); // Disable text controls BUT keep #iText enabled
               iText.value = ''; // Clear text input
               imageControlsWrapper.classList.remove('visible');

               // Enable text box buttons if this rectangle is a text controller
               const btnShrinkTextBox = document.getElementById('btnShrinkTextBox');
               const btnDrawFittingRectangle = document.getElementById('btnDrawFittingRectangle');

               if (selectedObject.isTextController) {
                   console.log('💾 Rectangle is a text controller - enabling text box buttons');
                   if (btnShrinkTextBox) btnShrinkTextBox.disabled = false;
                   if (btnDrawFittingRectangle) btnDrawFittingRectangle.disabled = false;
               } else {
                   console.log('💾 Rectangle is not a text controller - disabling text box buttons');
                   if (btnShrinkTextBox) btnShrinkTextBox.disabled = true;
                   if (btnDrawFittingRectangle) btnDrawFittingRectangle.disabled = true;
               }

               // 🟢🔴 RECTANGLE GROUP: Show/hide scale slider for master rectangles
               const rectangleScaleGroup = document.getElementById('rectangleScaleGroup');
               const rectangleScale = document.getElementById('rectangleScale');
               if (selectedObject.isMasterRectangle && selectedObject.groupId) {
                   console.log('🟢🔴 Rectangle is master - showing scale slider');
                   if (rectangleScaleGroup) rectangleScaleGroup.style.display = 'block';
                   if (rectangleScale) rectangleScale.disabled = false;
               } else {
                   console.log('🟢🔴 Rectangle is not master - hiding scale slider');
                   if (rectangleScaleGroup) rectangleScaleGroup.style.display = 'none';
                   if (rectangleScale) rectangleScale.disabled = true;
               }

               document.body.className = 'rectangle-selected';
           }
       } else {
           // No object selected
           console.log('🔍 updateUIFromSelectedObject: No object selected, clearing text input');
           setControlsDisabled(textControlsWrapper, true, true); // Disable text controls BUT keep #iText enabled
           iText.value = ''; // Clear text input
           console.log('🔍 updateUIFromSelectedObject: Text input cleared, iText.value =', iText.value);
           imageControlsWrapper.classList.remove('visible');
           noImageSelectedMsg.style.display = 'block';
           deleteImageBtn.disabled = true;
           addEditTextBtn.textContent = 'Add';
           deleteTextBtn.disabled = true;

           // Disable template ID controls when nothing is selected
           const textTemplateId = document.getElementById('textTemplateId');
           const imageTemplateId = document.getElementById('imageTemplateId');
           if (textTemplateId) {
               textTemplateId.disabled = true;
               textTemplateId.value = '';
           }
           if (imageTemplateId) {
               imageTemplateId.disabled = true;
               imageTemplateId.value = '';
           }

           // Hide masking controls when no object is selected
           if (imageMaskingGroup) {
               imageMaskingGroup.style.display = 'none';
           }

           // 🟢🔴 RECTANGLE GROUP: Hide scale slider when no object is selected
           const rectangleScaleGroup = document.getElementById('rectangleScaleGroup');
           if (rectangleScaleGroup) {
               rectangleScaleGroup.style.display = 'none';
           }

           // Hide Remove Background, Regenerate, Restyle, and Replace buttons when no object is selected
           const removeBgBtn = document.getElementById('removeBgBtn');
           const regenerateBtn = document.getElementById('regenerateBtn');
           const restyleBtn = document.getElementById('restyleBtn');
           const replaceBtn = document.getElementById('replaceBtn');
           if (removeBgBtn) {
               removeBgBtn.style.display = 'none';
           }
           if (regenerateBtn) {
               regenerateBtn.style.display = 'none';
           }
           if (restyleBtn) {
               restyleBtn.style.display = 'none';
           }
           if (replaceBtn) {
               replaceBtn.style.display = 'none';
           }

           // Don't set move button state here, do it once at the end
           document.body.className = 'normal';
       }
       // Update move button states *once* at the end, based on checks
       moveForwardBtn.disabled = !canMoveForward;
       moveBackwardBtn.disabled = !canMoveBackward;

       // Update lock/hide button states
       const lockObjectBtn = document.getElementById('lockObjectBtn');
       const hideObjectBtn = document.getElementById('hideObjectBtn');
       const unlockAllBtn = document.getElementById('unlockAllBtn');
       const unhideAllBtn = document.getElementById('unhideAllBtn');
       const hasSelection = selectedObjectIndex !== -1;

       // Check if there are any locked or hidden objects
       const hasLockedObjects = canvasObjects.some(obj => obj.isLocked);
       const hasHiddenObjects = canvasObjects.some(obj => obj.isHidden);

       console.log('[UI Update] Lock/Hide buttons - hasSelection:', hasSelection, 'selectedObjectIndex:', selectedObjectIndex);
       console.log('[UI Update] hasLockedObjects:', hasLockedObjects, 'hasHiddenObjects:', hasHiddenObjects);

       if (lockObjectBtn) {
           lockObjectBtn.disabled = !hasSelection;
           console.log('[UI Update] Lock button disabled:', lockObjectBtn.disabled);
       }
       if (hideObjectBtn) {
           hideObjectBtn.disabled = !hasSelection;
           console.log('[UI Update] Hide button disabled:', hideObjectBtn.disabled);
       }
       if (unlockAllBtn) {
           unlockAllBtn.disabled = !hasLockedObjects;
           console.log('[UI Update] Unlock All button disabled:', unlockAllBtn.disabled);
       }
       if (unhideAllBtn) {
           unhideAllBtn.disabled = !hasHiddenObjects;
           console.log('[UI Update] Unhide All button disabled:', unhideAllBtn.disabled);
       }

       // Update copy/paste button states
       updateCopyPasteButtons();

       // Update All Caps checkbox state when text selection changes
       if (selectedObject && selectedObject.type === 'text') {
           if (window.updateAllCapsControlState) {
               window.updateAllCapsControlState();
               console.log('🎯 Updated All Caps control state for selected text:', selectedObject.text);
           }
       }
   }
   function updateSelectedObjectFromUI(property, value) {
       // 🔒 UI INTERACTION LOCK: Start UI interaction to prevent accidental object selection
       startUIInteraction();

       console.log(`🔧 === UPDATE OBJECT PROPERTY DEBUG (${property}) ===`);
       console.log(`🔧 Property: ${property}, Value: ${value}`);
       console.log(`🔧 selectedObjectIndex: ${selectedObjectIndex}`);
       console.log(`🔧 canvasObjects.length: ${canvasObjects.length}`);

       if (selectedObjectIndex === -1) {
           console.error(`🔧 ❌ Cannot update property '${property}': No object selected`);
           console.log('🔧 === END UPDATE OBJECT PROPERTY DEBUG ===');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       console.log(`Updating property '${property}' on object:`, {
           id: selectedObject.id,
           type: selectedObject.type,
           text: selectedObject.text,
           oldValue: selectedObject[property],
           newValue: value
       });

       // Special handling for blockShadowPerspectiveIntensity
       if (property === 'blockShadowPerspectiveIntensity' && selectedObject.type === 'text') {
           console.log('Special handling for blockShadowPerspectiveIntensity');
           console.log('Current shadow state:', {
               shadowMode: selectedObject.shadowMode,
               blockShadowPerspective: selectedObject.blockShadowPerspective,
               blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
           });

           // Make sure perspective mode is enabled when changing intensity
           if (selectedObject.shadowMode === 'blockShadow' && !selectedObject.blockShadowPerspective) {
               console.log('Forcing perspective mode to be enabled');
               selectedObject.blockShadowPerspective = true;

               // Update UI to reflect this change
               if (blockShadowPerspective) {
                   blockShadowPerspective.checked = true;
                   console.log('Updated checkbox state to checked');
               } else {
                   console.error('Could not find blockShadowPerspective checkbox!');
               }

               // Show the perspective control
               const perspectiveControl = document.querySelector('.perspective-control');
               if (perspectiveControl) {
                   perspectiveControl.style.display = 'block';
                   console.log('Perspective control display set to: block');
               } else {
                   console.error('Could not find perspective-control element!');
               }
           }

           // If shadow mode is not blockShadow, force it
           if (selectedObject.shadowMode !== 'blockShadow') {
               console.log('Forcing shadow mode to blockShadow (was:', selectedObject.shadowMode, ')');
               selectedObject.shadowMode = 'blockShadow';

               // Update UI to reflect this change
               if (shadowSelect) {
                   shadowSelect.value = 'blockShadow';
                   console.log('Updated shadow select to blockShadow');
               } else {
                   console.error('Could not find shadowSelect element!');
               }
           }
       }

       if (selectedObject.type === 'text') {
           if (selectedObject.hasOwnProperty(property) || property.startsWith('gridDistort') || property === 'gradient' || property === 'colorIntensity' || property === 'textBoxWidth' || property === 'textAlign' || property === 'lineHeight') {
               // Store old value for logging
               const oldValue = selectedObject[property];

               // Update the property
               selectedObject[property] = value;

               console.log(`Property '${property}' updated:`, {
                   oldValue: oldValue,
                   newValue: value,
                   effectiveValue: selectedObject[property] // Check what was actually stored
               });

               // Special logging for colorIntensity
               if (property === 'colorIntensity') {
                   console.log('🎨 COLOR INTENSITY UPDATE:', {
                       objectId: selectedObject.id,
                       objectType: selectedObject.type,
                       oldValue: oldValue,
                       newValue: value,
                       actualValue: selectedObject.colorIntensity
                   });
               }

               // Special handling for text wrapping
               if (property === 'text' || property === 'textBoxWidth') {
                   console.log('📦 TEXT WRAPPING: Property changed:', property, 'Value:', value);

                   // Store the original text if not already stored
                   if (!selectedObject.originalText) {
                       selectedObject.originalText = selectedObject.text;
                   }

                   // If text property is being updated, update the original text
                   if (property === 'text') {
                       selectedObject.originalText = value;
                   }

                   // Apply text wrapping based on current textBoxWidth
                   const textBoxWidth = selectedObject.textBoxWidth || 0;
                   const originalText = selectedObject.originalText || selectedObject.text;

                   console.log('📦 TEXT WRAPPING: DEBUG - textBoxWidth:', textBoxWidth, 'originalText:', originalText);
                   console.log('📦 TEXT WRAPPING: DEBUG - selectedObject.textBoxWidth:', selectedObject.textBoxWidth);

                   console.log('📦 TEXT WRAPPING: Checking textBoxWidth condition:', textBoxWidth, '> 0 =', textBoxWidth > 0);

                   if (textBoxWidth > 0) {
                       console.log('📦 TEXT WRAPPING: Entering wrapped text branch...');
                       selectedObject.text = wrapText(originalText, textBoxWidth);
                       console.log('📦 TEXT WRAPPING: Applied wrapping. Original:', originalText, 'Wrapped:', selectedObject.text);

                       // 📦 FORCE BOUNDS UPDATE: Trigger bounds recalculation for wrapped text
                       console.log('📦 TEXT WRAPPING: About to calculate bounds for wrapped text...');
                       const newBounds = calculateObjectBounds(selectedObject);
                       console.log('📦 TEXT WRAPPING: Updated bounds after wrapping:', newBounds);
                   } else {
                       console.log('📦 TEXT WRAPPING: Entering single-line text branch...');
                       selectedObject.text = originalText;
                       console.log('📦 TEXT WRAPPING: No wrapping applied. Text:', selectedObject.text);

                       // 📦 FORCE BOUNDS UPDATE: Trigger bounds recalculation for single-line text
                       const newBounds = calculateObjectBounds(selectedObject);
                       console.log('📦 TEXT WRAPPING: Updated bounds for single-line:', newBounds);
                   }
               }

               // Special logging for textAlign changes
               if (property === 'textAlign') {
                   console.log('📝 ===== TEXT ALIGN UPDATE FLOW =====');
                   console.log('📝 ALIGNMENT UPDATE: Object before change:', {
                       id: selectedObject.id,
                       text: selectedObject.text,
                       textAlign: selectedObject.textAlign,
                       textBoxWidth: selectedObject.textBoxWidth,
                       x: selectedObject.x,
                       y: selectedObject.y
                   });
                   console.log('📝 ALIGNMENT UPDATE: New alignment value:', value);
               }
               switch (property) {
                   case 'fontSize': vFontSize.textContent = value + 'px'; break;
                   case 'rotation': vTextRotation.textContent = value + '°'; break;
                   case 'skewX': vSkew.textContent = value; break;
                   case 'skewY': vSkewY.textContent = value; break;
                   case 'warpCurve': vCurve.textContent = value; break;
                   case 'warpOffset': vOffset.textContent = value; break;
                   case 'warpHeight': vHeight.textContent = value; break;
                   case 'warpBottom': vBottom.textContent = value; break;
                   case 'warpShiftCenter': vShiftCenter.textContent = value; break;
                   case 'circleDiameter': vDiameter.textContent = value + 'px'; break;
                   case 'circleKerning': vKerning.textContent = value + 'px'; break;
                   case 'curveAmount': vCurveAmount.textContent = value; break;
                   case 'curveKerning': vCurveKerning.textContent = value + 'px'; break;
                   case 'gridDistortCols':
                       if (document.getElementById('vGridDistortCols')) {
                           document.getElementById('vGridDistortCols').textContent = value;
                       }
                       break;
                   case 'gridDistortRows':
                       if (document.getElementById('vGridDistortRows')) {
                           document.getElementById('vGridDistortRows').textContent = value;
                       }
                       break;
                   case 'gridDistortPadding':
                       if (document.getElementById('vGridDistortPadding')) {
                           document.getElementById('vGridDistortPadding').textContent = value + 'px';
                       }
                       break;
                   case 'gridDistortIntensity':
                       if (document.getElementById('vGridDistortIntensity')) {
                           document.getElementById('vGridDistortIntensity').textContent = value + '%';
                       }
                       break;
                   case 'hLineWeight': vHWeight.textContent = value + 'px'; break;
                   case 'hLineDist': vHDistance.textContent = value + 'px'; break;
                   case 'hLineOpacity': vHOpacity.textContent = value + '%'; break;
                   case 'ccDist': vCcDistance.textContent = value + '%'; break;
                   case 'ccOpacity': vCcOpacity.textContent = value + '%'; break;
                   case 'oLineWeight': vOWeight.textContent = value + 'px'; break;
                   case 'oLineDist': vODistance.textContent = value + 'px'; break;
                   case 'oOpacity': vOOpacity.textContent = value + '%'; break;
                   case 'flcDist': vFlcDistance.textContent = value + '%'; break;
                   case 'flcOpacity': vFlcOpacity.textContent = value + '%'; break;
                   case 'flcWeight': vFlcMaxWeight.textContent = value + 'px'; break;
                   case 'flcSpacing': vFlcSpacing.textContent = value + 'px'; break;
                   case 'strokeWidth': vStrokeWidth.textContent = value + 'px'; break;
                   case 'shadowOffsetX': vShadowOffsetX.textContent = value + 'px'; break;
                   case 'shadowOffsetY': vShadowOffsetY.textContent = value + 'px'; break;
                   case 'shadowBlur': vShadowBlur.textContent = value + 'px'; break;
                   case 'blockShadowOpacity': vBlockShadowOpacity.textContent = value + '%'; break;
                   case 'blockShadowOffset': vBlockShadowOffset.textContent = value + 'px'; break;
                   case 'blockShadowAngle': vBlockShadowAngle.textContent = value + '°'; break;
                   case 'blockShadowBlur': vBlockShadowBlur.textContent = value + 'px'; break;
                   case 'blockShadowPerspectiveIntensity':
                       if (vBlockShadowPerspectiveIntensity) {
                           vBlockShadowPerspectiveIntensity.textContent = value + '%';
                           console.log('Updated perspective intensity display to:', value + '%');
                       } else {
                           console.error('Could not find vBlockShadowPerspectiveIntensity element!');
                       }
                       break;
                   case 'perspectiveShadowColor':
                       if (document.getElementById('perspectiveShadowColor')) {
                           document.getElementById('perspectiveShadowColor').value = value;
                       }
                       break;
                   case 'perspectiveShadowOpacity':
                       if (document.getElementById('vPerspectiveShadowOpacity')) {
                           document.getElementById('vPerspectiveShadowOpacity').textContent = value + '%';
                       }
                       break;
                   case 'perspectiveShadowOffset':
                       if (document.getElementById('vPerspectiveShadowOffset')) {
                           document.getElementById('vPerspectiveShadowOffset').textContent = value + 'px';
                       }
                       break;
                   case 'perspectiveShadowAngle':
                       if (document.getElementById('vPerspectiveShadowAngle')) {
                           document.getElementById('vPerspectiveShadowAngle').textContent = value + '°';
                       }
                       break;
                   case 'perspectiveShadowBlur':
                       if (document.getElementById('vPerspectiveShadowBlur')) {
                           document.getElementById('vPerspectiveShadowBlur').textContent = value + 'px';
                       }
                       break;
                   case 'perspectiveShadowIntensity':
                       if (document.getElementById('vPerspectiveShadowIntensity')) {
                           document.getElementById('vPerspectiveShadowIntensity').textContent = value + '%';
                       }
                       break;
                   case 'perspectiveShadowOutlineColor':
                       if (document.getElementById('perspectiveShadowOutlineColor')) {
                           document.getElementById('perspectiveShadowOutlineColor').value = value;
                       }
                       break;
                   case 'perspectiveShadowOutlineOpacity':
                       if (document.getElementById('vPerspectiveShadowOutlineOpacity')) {
                           document.getElementById('vPerspectiveShadowOutlineOpacity').textContent = value + '%';
                       }
                       break;
                   case 'perspectiveShadowOutlineWidth':
                       if (document.getElementById('vPerspectiveShadowOutlineWidth')) {
                           document.getElementById('vPerspectiveShadowOutlineWidth').textContent = value + 'px';
                       }
                       break;
                   case 'perspectiveShadowOutlineOffsetX':
                       if (document.getElementById('vPerspectiveShadowOutlineOffsetX')) {
                           document.getElementById('vPerspectiveShadowOutlineOffsetX').textContent = value + 'px';
                       }
                       break;
                   case 'perspectiveShadowOutlineOffsetY':
                       if (document.getElementById('vPerspectiveShadowOutlineOffsetY')) {
                           document.getElementById('vPerspectiveShadowOutlineOffsetY').textContent = value + 'px';
                       }
                       break;
                   case 'letterSpacing':
                       if (document.getElementById('vLetterSpacing')) {
                           document.getElementById('vLetterSpacing').textContent = value + 'px';
                       }

                       // 🎯 REMOVED: Pixel-perfect bounds recalculation no longer needed
                       // Now using normal text scaling which handles letter spacing automatically
                       console.log('🎯 LETTER SPACING: Using normal text rendering - no special bounds recalculation needed');
                       break;
                   case 'opacity':
                       if (document.getElementById('vOpacity')) {
                           document.getElementById('vOpacity').textContent = value + '%';
                       }
                       break;
                   case 'lineShadowDist': vLineShadowDistance.textContent = value + 'px'; break;
                   case 'lineShadowAngle': vLineShadowAngle.textContent = value + '°'; break;
                   case 'lineShadowThickness': vLineShadowThickness.textContent = value + 'px'; break;
                   case 'd3dPrimaryOpacity': vDetailed3DPrimaryOpacity.textContent = value + '%'; break;
                   case 'd3dOffset': vDetailed3DOffset.textContent = value + 'px'; break;
                   case 'd3dAngle': vDetailed3DAngle.textContent = value + '°'; break;
                   case 'd3dBlur': vDetailed3DBlur.textContent = value + 'px'; break;
                   case 'd3dSecondaryOpacity': vDetailed3DSecondaryOpacity.textContent = value + '%'; break;
                   case 'd3dSecondaryWidth': vDetailed3DSecondaryWidth.textContent = value + 'px'; break;
                   case 'd3dSecondaryOffsetX': vDetailed3DSecondaryOffsetX.textContent = value + 'px'; break;
                   case 'd3dSecondaryOffsetY': vDetailed3DSecondaryOffsetY.textContent = value + 'px'; break;
                   case 'textBoxWidth':
                       // Update the display value
                       if (textBoxWidthValue) {
                           textBoxWidthValue.textContent = value === 0 ? '0 (unlimited)' : `${value} characters`;
                       }
                       console.log('📦 Text box width updated to:', value);
                       break;
                   case 'textAlign':
                       // Update alignment button states
                       const alignmentButtons = document.querySelectorAll('.alignment-btn');
                       alignmentButtons.forEach(btn => {
                           btn.classList.remove('active');
                           if (btn.getAttribute('data-align') === value) {
                               btn.classList.add('active');
                           }
                       });
                       console.log('📝 Text alignment updated to:', value);
                       break;
                   case 'lineHeight':
                       // Update the display value
                       if (lineHeightValue) {
                           lineHeightValue.textContent = `${value}x`;
                       }
                       console.log('📏 Line height updated to:', value);
                       break;
               }

            // Special handling for text content changes
            if (property === 'text' && selectedObject.gridDistort) {
                console.log('Text changed from', selectedObject.gridDistort.lastText, 'to', value);
                console.log('Has relative control points?',
                    selectedObject.gridDistort.relativeControlPoints ?
                    selectedObject.gridDistort.relativeControlPoints.length : 'No');

                // Don't update lastText here - let initializeGridPoints handle it
                // This ensures the text change is detected properly
                initializeGridPoints(selectedObject);
                console.log('Reinitialized grid due to text content change');

                // Log the state after initialization
                console.log('After init - Has relative control points?',
                    selectedObject.gridDistort.relativeControlPoints ?
                    selectedObject.gridDistort.relativeControlPoints.length : 'No');
            }

            // Special handling for font size changes with grid distortion
            if (property === 'fontSize' && selectedObject.gridDistort) {
                console.log('Font size changed from', selectedObject.gridDistort.lastFontSize, 'to', value);
                console.log('Has relative control points?',
                    selectedObject.gridDistort.relativeControlPoints ?
                    selectedObject.gridDistort.relativeControlPoints.length : 'No');

                // Reinitialize grid points to scale with the new font size
                // while preserving the relative distortion pattern
                initializeGridPoints(selectedObject);
                console.log('Reinitialized grid due to font size change');

                // Log the state after initialization
                console.log('After font size change - Has relative control points?',
                    selectedObject.gridDistort.relativeControlPoints ?
                    selectedObject.gridDistort.relativeControlPoints.length : 'No');
            }

            // Special handling for mesh warp when text content or font size changes
            if ((property === 'text' || property === 'fontSize') &&
                selectedObject.effectMode === 'mesh' &&
                typeof activeMeshWarpHandler !== 'undefined' &&
                activeMeshWarpHandler &&
                activeMeshWarpHandler.selectedTextObject === selectedObject) {

                // The mesh warp handler will handle the grid update in its drawMeshGrid and drawWarpedText methods
                console.log('Text or font size changed for mesh warp object, grid will be updated on next render');
            }

            // Add special case for blockShadowPerspective
            if (property === 'blockShadowPerspective') {
                console.log('Block shadow perspective set to:', value);
            }

            // Add special case for shadowMode
            if (property === 'shadowMode') {
                console.log('Shadow mode set to:', value);

                // Debug: Check current front outline values
                console.log('🔍 FRONT OUTLINE DEBUG: Current values before initialization:', {
                    shadowMode: selectedObject.shadowMode,
                    d3dSecondaryWidth: selectedObject.d3dSecondaryWidth,
                    d3dSecondaryColor: selectedObject.d3dSecondaryColor,
                    perspectiveShadowOutlineWidth: selectedObject.perspectiveShadowOutlineWidth,
                    perspectiveShadowOutlineColor: selectedObject.perspectiveShadowOutlineColor
                });

                // Initialize default properties for shadow modes that have front outlines
                if (value === 'detailed3D') {
                    // Force initialize detailed 3D front outline properties
                    selectedObject.d3dSecondaryWidth = 4;
                    selectedObject.d3dSecondaryColor = '#00FF66';
                    selectedObject.d3dSecondaryOpacity = 100;
                    selectedObject.d3dSecondaryOffsetX = 0;
                    selectedObject.d3dSecondaryOffsetY = 0;
                    console.log('🔍 FRONT OUTLINE: Force initialized detailed 3D front outline properties:', {
                        d3dSecondaryWidth: selectedObject.d3dSecondaryWidth,
                        d3dSecondaryColor: selectedObject.d3dSecondaryColor,
                        d3dSecondaryOpacity: selectedObject.d3dSecondaryOpacity,
                        d3dSecondaryOffsetX: selectedObject.d3dSecondaryOffsetX,
                        d3dSecondaryOffsetY: selectedObject.d3dSecondaryOffsetY
                    });
                } else if (value === 'perspectiveShadow') {
                    // Force initialize perspective shadow front outline properties
                    selectedObject.perspectiveShadowOutlineWidth = 3;
                    selectedObject.perspectiveShadowOutlineColor = '#d1d5db';
                    selectedObject.perspectiveShadowOutlineOpacity = 100;
                    selectedObject.perspectiveShadowOutlineOffsetX = 2;
                    selectedObject.perspectiveShadowOutlineOffsetY = -3;
                    console.log('🔍 FRONT OUTLINE: Force initialized perspective shadow front outline properties:', {
                        perspectiveShadowOutlineWidth: selectedObject.perspectiveShadowOutlineWidth,
                        perspectiveShadowOutlineColor: selectedObject.perspectiveShadowOutlineColor,
                        perspectiveShadowOutlineOpacity: selectedObject.perspectiveShadowOutlineOpacity,
                        perspectiveShadowOutlineOffsetX: selectedObject.perspectiveShadowOutlineOffsetX,
                        perspectiveShadowOutlineOffsetY: selectedObject.perspectiveShadowOutlineOffsetY
                    });
                }
            }

            if (['effectMode', 'decorationMode', 'strokeMode', 'shadowMode', 'warpTriangle'].includes(property)) {
                updateBodyClass(selectedObject);
                console.log(`Updated body class for ${property} change`);
            }

            // Special handling for effect mode changes to mesh
            if (property === 'effectMode' && value === 'mesh' && selectedObject.type === 'text') {
                console.log('[UpdateUI] Effect mode changed to mesh, ensuring handler exists');

                // Create mesh warp handler immediately if it doesn't exist
                if (!selectedObject._meshWarpHandler && typeof window.MeshWarpHandler !== 'undefined') {
                    try {
                        // Prevent the mesh handler constructor from calling update()
                        window.skipMeshUpdate = true;

                        window.activeMeshWarpHandler = new window.MeshWarpHandler(
                            document.getElementById('demo'),
                            selectedObject
                        );
                        selectedObject._meshWarpHandler = window.activeMeshWarpHandler;

                        // Re-enable updates
                        window.skipMeshUpdate = false;

                        console.log('[UpdateUI] Created mesh warp handler for effect mode change');
                    } catch (error) {
                        console.error('[UpdateUI] Error creating mesh warp handler:', error);
                        // Make sure to re-enable updates even if there's an error
                        window.skipMeshUpdate = false;
                    }
                } else if (selectedObject._meshWarpHandler) {
                    // Use existing handler
                    window.activeMeshWarpHandler = selectedObject._meshWarpHandler;
                    window.activeMeshWarpHandler.selectedTextObject = selectedObject;
                    console.log('[UpdateUI] Using existing mesh warp handler');
                }
            }

            console.log('Forcing redraw...');
            update();
            console.log(`Property '${property}' update complete`);
        } else {
            console.warn(`Property "${property}" not found on selected text object.`);
        }
    } else if (selectedObject.type === 'image') {
        if (property === 'scale') {
            selectedObject.scale = parseFloat(value);
            vImageSize.textContent = Math.round(selectedObject.scale * 100) + '%';
            // Invalidate stroke cache when scale changes
            selectedObject.strokeCache = null;
            selectedObject.strokeCacheKey = null;
        } else if (property === 'rotation') {
            selectedObject.rotation = parseInt(value, 10);
            vImageRotation.textContent = selectedObject.rotation + '°';
        } else if (property === 'svgColor') {
            selectedObject.svgColor = value;
            console.log('🎨 Updated SVG color:', value, 'for object:', selectedObject.id, 'imageUrl:', selectedObject.imageUrl);
            // Regenerate the colored SVG
            if (selectedObject.imageUrl && selectedObject.imageUrl.toLowerCase().endsWith('.svg')) {
                console.log('🎨 Recoloring SVG with new color:', value);
                recolorSVG(selectedObject, value);
            } else {
                console.log('🎨 Object is not an SVG, color change may not be visible');
            }
        } else if (property === 'svgGradient') {
            selectedObject.svgGradient = value;
            // Store gradient data directly on the object (like text gradients)
            if (value) {
                selectedObject.gradient = value;
                selectedObject.fillType = 'gradient';
                console.log('🎨 SVG gradient stored:', value);
            } else {
                selectedObject.gradient = null;
                selectedObject.fillType = 'solid';
                console.log('🎨 SVG gradient cleared');
            }
        } else if (property === 'shadowMode') {
            selectedObject.shadowMode = value;
            console.log('🌫️ Updated image shadow mode:', value, 'for object:', selectedObject.id);
        } else if (property === 'shadowColor') {
            selectedObject.shadowColor = value;
        } else if (property === 'shadowOffsetX') {
            selectedObject.shadowOffsetX = parseInt(value, 10);
            vImageShadowOffsetX.textContent = selectedObject.shadowOffsetX + 'px';
        } else if (property === 'shadowOffsetY') {
            selectedObject.shadowOffsetY = parseInt(value, 10);
            vImageShadowOffsetY.textContent = selectedObject.shadowOffsetY + 'px';
        } else if (property === 'shadowBlur') {
            selectedObject.shadowBlur = parseInt(value, 10);
            vImageShadowBlur.textContent = selectedObject.shadowBlur + 'px';
        } else if (property === 'shadowOpacity') {
            selectedObject.shadowOpacity = parseInt(value, 10);
            vImageShadowOpacity.textContent = selectedObject.shadowOpacity + '%';
        } else if (property === 'opacity') {
            selectedObject.opacity = parseInt(value, 10);
            vImageOpacity.textContent = selectedObject.opacity + '%';
            console.log('🎛️ Updated image opacity:', selectedObject.opacity, '% for object:', selectedObject.id);
        } else if (property === 'strokeMode') {
            selectedObject.strokeMode = value;
            // Invalidate stroke cache
            selectedObject.strokeCache = null;
            selectedObject.strokeCacheKey = null;
        } else if (property === 'strokeWidth') {
            selectedObject.strokeWidth = parseInt(value, 10);
            vImageStrokeWidth.textContent = selectedObject.strokeWidth + 'px';
            // Invalidate stroke cache
            selectedObject.strokeCache = null;
            selectedObject.strokeCacheKey = null;
        } else if (property === 'strokeColor') {
            selectedObject.strokeColor = value;
            // Invalidate stroke cache
            selectedObject.strokeCache = null;
            selectedObject.strokeCacheKey = null;
        } else if (property === 'templateId') {
            selectedObject.templateId = value;
            console.log('🏷️ Image template ID updated:', value);
        } else if (property === 'colorIntensity') {
            selectedObject.colorIntensity = value;
            console.log('🎨 COLOR INTENSITY UPDATE (Image):', {
                objectId: selectedObject.id,
                objectType: selectedObject.type,
                newValue: value,
                actualValue: selectedObject.colorIntensity
            });
        } else {
            console.warn(`Property "${property}" not found or not applicable to image object.`);
            console.log('=== END UPDATE OBJECT PROPERTY DEBUG ===');
            return;
        }
        update();
    }

    console.log('=== END UPDATE OBJECT PROPERTY DEBUG ===');

    // Save state for undo/redo (with debouncing to avoid too many saves)
    if (!updateSelectedObjectFromUI.saveTimeout) {
        updateSelectedObjectFromUI.saveTimeout = setTimeout(() => {
            saveState(`Change ${property}`);
            updateSelectedObjectFromUI.saveTimeout = null;
        }, 500); // 500ms delay to group rapid changes
    }
}

   // --- Text Wrapping Function ---
   function wrapText(text, maxCharsPerLine) {
       console.log('📦 WRAP TEXT: Input text:', text, 'Max chars per line:', maxCharsPerLine);

       // If maxCharsPerLine is 0, return original text (unlimited)
       if (maxCharsPerLine === 0) {
           console.log('📦 WRAP TEXT: Unlimited mode, returning original text');
           return text;
       }

       // Split text into words
       const words = text.split(' ');
       const lines = [];
       let currentLine = '';

       for (const word of words) {
           // Check if adding this word would exceed the character limit
           const testLine = currentLine ? `${currentLine} ${word}` : word;

           if (testLine.length <= maxCharsPerLine) {
               // Word fits, add it to current line
               currentLine = testLine;
           } else {
               // Word doesn't fit
               if (currentLine) {
                   // Save current line and start new line with this word
                   lines.push(currentLine);
                   currentLine = word;
               } else {
                   // Single word is longer than limit, add it anyway
                   lines.push(word);
                   currentLine = '';
               }
           }
       }

       // Add the last line if it has content
       if (currentLine) {
           lines.push(currentLine);
       }

       const wrappedText = lines.join('\n');
       console.log('📦 WRAP TEXT: Result:', wrappedText);
       return wrappedText;
   }

   // --- Multi-Line Text Rendering Helper ---
   function fillMultiLineText(ctx, text, x, y, obj) {
       console.log('📦 ===== FILL MULTI LINE TEXT FLOW START =====');
       console.log('📦 MULTI-LINE: *** FUNCTION CALLED *** Rendering text:', text, 'at position:', x, y);
       console.log('📦 MULTI-LINE: Object details:', {
           id: obj?.id,
           textAlign: obj?.textAlign,
           textBoxWidth: obj?.textBoxWidth,
           fontSize: obj?.fontSize,
           lineHeight: obj?.lineHeight
       });
       console.log('🚀 CACHE TEST: fillMultiLineText function loaded with latest changes!');

       // Split text into lines
       const lines = text.split('\n');
       console.log('📦 MULTI-LINE: Split into', lines.length, 'lines:', lines);

       if (lines.length === 1) {
           // Single line, use normal fillText
           console.log('📦 MULTI-LINE: Single line detected, rendering at x:', x, 'y:', y);
           ctx.fillText(text, x, y);
           console.log('📦 MULTI-LINE: Single line rendered');
           console.log('📦 ===== FILL MULTI LINE TEXT FLOW END (SINGLE LINE) =====');
           return;
       }

       // Multi-line text
       const fontSize = obj ? obj.fontSize : 20; // Default font size if obj not provided
       const lineHeightMultiplier = obj && obj.lineHeight ? obj.lineHeight : 1.2; // Use object's line height or default
       const lineHeight = fontSize * lineHeightMultiplier;
       const textAlign = obj && obj.textAlign ? obj.textAlign : 'left'; // Use object's text alignment or default
       const textBoxWidth = obj && obj.textBoxWidth ? obj.textBoxWidth : 0; // Get text box width

       console.log('📦 MULTI-LINE: Rendering', lines.length, 'lines with line height:', lineHeight, 'alignment:', textAlign);
       console.log('📦 MULTI-LINE: textBoxWidth:', textBoxWidth, 'centerX passed:', x);

       // Calculate starting Y position to center the text block
       const totalHeight = (lines.length - 1) * lineHeight;
       const startY = y - totalHeight / 2;

       // Calculate correct X position based on text alignment and text box width
       let renderX = x;
       if (textBoxWidth > 0) {
           // textBoxWidth is a character limit, not pixel width
           // Calculate the pixel width based on the character limit, not the actual text
           // Use dynamic padding that prevents source rectangle from going out of bounds
           // Canvas width is typically 8192, so we need to ensure text box doesn't exceed ~7000 pixels
           const maxSafePadding = Math.max(1, Math.min(10, Math.floor((7000 - textBoxWidth * 135) / 135)));
           const safePadding = Math.max(1, maxSafePadding);
           const sampleText = 'A'.repeat(textBoxWidth + safePadding);
           const actualTextBoxPixelWidth = ctx.measureText(sampleText).width;

           console.log('📦 MULTI-LINE RENDER: Character limit:', textBoxWidth, 'Safe padding:', safePadding, 'Text box pixel width:', actualTextBoxPixelWidth);
           // Also calculate the actual text width for comparison/debugging
           let maxLineWidth = 0;
           lines.forEach(line => {
               const lineWidth = ctx.measureText(line).width;
               if (lineWidth > maxLineWidth) {
                   maxLineWidth = lineWidth;
               }
           });

           console.log('📦 MULTI-LINE: Character limit:', textBoxWidth, 'Text box pixel width:', actualTextBoxPixelWidth, 'Max line pixel width:', maxLineWidth);

           // CRITICAL FIX: The x parameter is already the correctly positioned renderX from renderStyledObjectToOffscreen
           // Do NOT recalculate textBoxLeft/textBoxRight here - that creates a double offset!
           // Just use the x value directly for the appropriate alignment

           console.log('📦 MULTI-LINE: FIXED - Using passed renderX directly (no double calculation):', x);
           renderX = x; // x is already correctly calculated in renderStyledObjectToOffscreen

           if (textAlign === 'left') {
               console.log('📦 MULTI-LINE: LEFT alignment - using passed renderX directly:', renderX, '(no double calculation)');
           } else if (textAlign === 'right') {
               console.log('📦 MULTI-LINE: RIGHT alignment - using passed renderX directly:', renderX, '(no double calculation)');
           } else if (textAlign === 'center') {
               console.log('📦 MULTI-LINE: CENTER alignment - using passed renderX directly:', renderX, '(no double calculation)');
           } else if (textAlign === 'justify') {
               console.log('📦 MULTI-LINE: JUSTIFY alignment - using passed renderX directly:', renderX, '(no double calculation)');
           }
       } else {
           console.log('📦 MULTI-LINE: No textBoxWidth, using original X:', x);
       }

       // Save current text alignment and set new one
       const originalTextAlign = ctx.textAlign;
       ctx.textAlign = textAlign;

       // Render each line
       console.log('📦 MULTI-LINE: About to render', lines.length, 'lines with renderX:', renderX, 'startY:', startY, 'lineHeight:', lineHeight);
       lines.forEach((line, index) => {
           const lineY = startY + (index * lineHeight);
           let lineX = renderX;

           console.log('📦 MULTI-LINE: Rendering line', index + 1, 'of', lines.length, ':', line);
           console.log('📦 MULTI-LINE: Line position - X:', lineX, 'Y:', lineY);

           // For justify alignment, we might need special handling
           if (textAlign === 'justify' && index < lines.length - 1) {
               // For justify, we'll use left alignment but could add word spacing
               ctx.textAlign = 'left';
               lineX = renderX;
               console.log('📦 MULTI-LINE: JUSTIFY mode - using left alignment for line', index + 1);
           }

           console.log('📦 MULTI-LINE: Final render position for line', index + 1, '- X:', lineX, 'Y:', lineY, 'ctx.textAlign:', ctx.textAlign);
           ctx.fillText(line, lineX, lineY);
           console.log('📦 MULTI-LINE: Line', index + 1, ':', line, 'rendered at X:', lineX, 'Y:', lineY, 'align:', ctx.textAlign);
       });

       // Restore original text alignment
       ctx.textAlign = originalTextAlign;

       console.log('📦 MULTI-LINE: All lines rendered successfully');
       console.log('📦 ===== FILL MULTI LINE TEXT FLOW END =====');
   }

   // --- SVG Color Recoloring Function ---
   async function recolorSVG(imageObject, newColor) {
       try {
           console.log('🎨 [RECOLOR-DEBUG] Starting recolorSVG for:', imageObject.imageUrl, 'to color:', newColor);

           // Fetch the original SVG content
           console.log('🎨 [RECOLOR-DEBUG] Fetching SVG content...');
           const response = await fetch(imageObject.imageUrl);
           if (!response.ok) {
               console.error('🎨 [RECOLOR-DEBUG] Fetch failed with status:', response.status);
               throw new Error(`Failed to fetch SVG: ${response.status}`);
           }

           console.log('🎨 [RECOLOR-DEBUG] Fetch successful, reading text...');
           const svgText = await response.text();
           console.log('🎨 [RECOLOR-DEBUG] Original SVG content preview:', svgText.substring(0, 200) + '...');

           // Create a new SVG with the desired color
           console.log('🎨 [RECOLOR-DEBUG] Applying SVG color...');
           const coloredSvgText = applySVGColor(svgText, newColor);
           console.log('🎨 [RECOLOR-DEBUG] Colored SVG content preview:', coloredSvgText.substring(0, 200) + '...');

           // Create a blob URL for the colored SVG
           console.log('🎨 [RECOLOR-DEBUG] Creating blob URL...');
           const blob = new Blob([coloredSvgText], { type: 'image/svg+xml' });
           const coloredUrl = URL.createObjectURL(blob);
           console.log('🎨 [RECOLOR-DEBUG] Blob URL created:', coloredUrl);

           // Create a new image with the colored SVG
           console.log('🎨 [RECOLOR-DEBUG] Creating new Image element...');
           const img = new Image();
           img.onload = () => {
               console.log('🎨 [RECOLOR-DEBUG] Image onload triggered successfully!');
               // Clean up the old blob URL if it exists
               if (imageObject.coloredBlobUrl) {
                   console.log('🎨 [RECOLOR-DEBUG] Cleaning up old blob URL:', imageObject.coloredBlobUrl);
                   URL.revokeObjectURL(imageObject.coloredBlobUrl);
               }

               // Update the image object
               console.log('🎨 [RECOLOR-DEBUG] Updating image object...');
               imageObject.image = img;
               imageObject.coloredBlobUrl = coloredUrl;
               imageObject.svgColor = newColor;

               // Force a redraw
               console.log('🎨 [RECOLOR-DEBUG] Calling update() to redraw canvas...');
               update();

               console.log('🎨 [RECOLOR-DEBUG] SVG recolored successfully!');
           };

           img.onerror = (error) => {
               console.error('🎨 [RECOLOR-DEBUG] Image onerror triggered!');
               console.error('🎨 [RECOLOR-DEBUG] Error loading recolored SVG:', imageObject.imageUrl, error);
               console.error('🎨 [RECOLOR-DEBUG] Error event details:', error);
               console.error('🎨 [RECOLOR-DEBUG] Colored SVG content preview:', coloredSvgText.substring(0, 500) + '...');
               URL.revokeObjectURL(coloredUrl);

               // Fallback: keep the original image
               console.log('🎨 [RECOLOR-DEBUG] Keeping original SVG without color change');
           };

           console.log('🎨 [RECOLOR-DEBUG] Setting img.src to blob URL...');
           img.src = coloredUrl;
           console.log('🎨 [RECOLOR-DEBUG] img.src set, waiting for onload/onerror...');

       } catch (error) {
           console.error('🎨 [RECOLOR-DEBUG] Caught exception in recolorSVG:', error);
           console.error('🎨 [RECOLOR-DEBUG] Error stack:', error.stack);
       }
   }

   // Test function to debug SVG recoloring issues
   window.testSVGRecoloring = function(objectIndex, newColor) {
       console.log('🧪 [TEST] Testing SVG recoloring for object index:', objectIndex, 'color:', newColor);

       if (objectIndex < 0 || objectIndex >= canvasObjects.length) {
           console.error('🧪 [TEST] Invalid object index:', objectIndex);
           return;
       }

       const obj = canvasObjects[objectIndex];
       console.log('🧪 [TEST] Object details:', {
           id: obj.id,
           type: obj.type,
           imageUrl: obj.imageUrl,
           svgColor: obj.svgColor,
           hasImageUrl: !!obj.imageUrl,
           isImageUrlSvg: obj.imageUrl?.toLowerCase().endsWith('.svg')
       });

       if (!obj.imageUrl) {
           console.error('🧪 [TEST] Object has no imageUrl property');
           return;
       }

       if (!obj.imageUrl.toLowerCase().endsWith('.svg')) {
           console.error('🧪 [TEST] Object imageUrl is not an SVG:', obj.imageUrl);
           return;
       }

       console.log('🧪 [TEST] Calling recolorSVG...');
       recolorSVG(obj, newColor);
   };

   // --- SVG Gradient Recoloring Function ---
   async function recolorSVGWithGradient(imageObject, gradientData) {
       try {
           console.log('🎨 Applying gradient to SVG:', imageObject.imageUrl, gradientData);

           // Fetch the original SVG content
           const response = await fetch(imageObject.imageUrl);
           if (!response.ok) {
               throw new Error(`Failed to fetch SVG: ${response.status}`);
           }

           const svgText = await response.text();
           console.log('🎨 Original SVG content preview:', svgText.substring(0, 200) + '...');

           // Create a new SVG with the desired gradient
           const gradientSvgText = applySVGGradient(svgText, gradientData);
           console.log('🎨 Gradient SVG content preview:', gradientSvgText.substring(0, 200) + '...');

           // Create a blob URL for the gradient SVG
           const blob = new Blob([gradientSvgText], { type: 'image/svg+xml' });
           const gradientUrl = URL.createObjectURL(blob);

           // Create a new image with the gradient SVG
           const img = new Image();
           img.onload = () => {
               // Clean up the old blob URL if it exists
               if (imageObject.coloredBlobUrl) {
                   URL.revokeObjectURL(imageObject.coloredBlobUrl);
               }

               // Update the image object
               imageObject.image = img;
               imageObject.coloredBlobUrl = gradientUrl;
               imageObject.svgGradient = gradientData;

               // Force a redraw
               update();

               console.log('🎨 SVG gradient applied successfully');
           };

           img.onerror = (error) => {
               console.error('🎨 Error loading gradient SVG:', imageObject.imageUrl, error);
               console.error('🎨 Gradient SVG content preview:', gradientSvgText.substring(0, 500) + '...');
               URL.revokeObjectURL(gradientUrl);

               // Fallback: keep the original image
               console.log('🎨 Keeping original SVG without gradient change');
           };

           img.src = gradientUrl;

       } catch (error) {
           console.error('🎨 Error applying gradient to SVG:', error);
       }
   }

   function applySVGColor(svgText, color) {
       try {
           // Parse the SVG to ensure it's valid XML
           const parser = new DOMParser();
           const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

           // Check for parsing errors
           const parserError = svgDoc.querySelector('parsererror');
           if (parserError) {
               console.error('SVG parsing error:', parserError.textContent);
               return svgText; // Return original if parsing fails
           }

           const svgElement = svgDoc.documentElement;

           // Remove existing CSS style blocks that define fill/stroke colors
           const styleElements = svgElement.querySelectorAll('style');
           styleElements.forEach(styleElement => {
               console.log('🎨 [APPLYSV] Found CSS style block:', styleElement.textContent);
               // Remove the entire style block since it might contain fill/stroke rules
               // that would override our new color
               styleElement.remove();
               console.log('🎨 [APPLYSV] Removed CSS style block');
           });

           // Remove existing fill and stroke attributes from all elements
           const allElements = svgElement.querySelectorAll('*');
           allElements.forEach(element => {
               element.removeAttribute('fill');
               element.removeAttribute('stroke');
               element.removeAttribute('class'); // Remove class attributes that might reference CSS rules
               // Also remove style-based fills and strokes
               const style = element.getAttribute('style');
               if (style) {
                   const newStyle = style
                       .replace(/fill:[^;]*;?/g, '')
                       .replace(/stroke:[^;]*;?/g, '')
                       .trim();
                   if (newStyle) {
                       element.setAttribute('style', newStyle);
                   } else {
                       element.removeAttribute('style');
                   }
               }
           });

           // Apply the new color to the root SVG element
           svgElement.setAttribute('fill', color);
           console.log('🎨 [APPLYSV] Applied new fill color to root SVG element:', color);

           // Ensure the SVG has proper namespace
           if (!svgElement.hasAttribute('xmlns')) {
               svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
           }

           // Serialize back to string
           const serializer = new XMLSerializer();
           return serializer.serializeToString(svgDoc);

       } catch (error) {
           console.error('🎨 [APPLYSV] Error processing SVG:', error);
           console.log('🎨 [APPLYSV] Falling back to string replacement method');
           // Fallback to simple string replacement if DOM parsing fails
           return applySVGColorFallback(svgText, color);
       }
   }

   function applySVGColorFallback(svgText, color) {
       console.log('🎨 [FALLBACK] Using fallback string replacement method for color:', color);
       // Fallback method using string replacement
       let coloredSvg = svgText;

       // Ensure SVG has proper namespace
       if (!coloredSvg.includes('xmlns=')) {
           coloredSvg = coloredSvg.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
       }

       // Remove existing fill attributes (more conservative approach)
       coloredSvg = coloredSvg.replace(/fill="[^"]*"/g, '');
       coloredSvg = coloredSvg.replace(/fill:[^;]*;?/g, '');

       // Add the new fill color to the root SVG element
       coloredSvg = coloredSvg.replace(/<svg([^>]*?)>/, `<svg$1 fill="${color}">`);

       return coloredSvg;
   }

   function applySVGGradient(svgText, gradientData) {
       try {
           console.log('🎨 Applying SVG gradient:', gradientData);

           // Parse the SVG to ensure it's valid XML
           const parser = new DOMParser();
           const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

           // Check for parsing errors
           const parserError = svgDoc.querySelector('parsererror');
           if (parserError) {
               console.error('SVG parsing error:', parserError.textContent);
               return svgText; // Return original if parsing fails
           }

           const svgElement = svgDoc.documentElement;

           // Create a unique gradient ID
           const gradientId = 'gradient_' + Math.random().toString(36).substring(2, 9);

           // Create defs element if it doesn't exist
           let defsElement = svgElement.querySelector('defs');
           if (!defsElement) {
               defsElement = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'defs');
               svgElement.insertBefore(defsElement, svgElement.firstChild);
           }

           // Create gradient element
           let gradientElement;
           if (gradientData.type === 'radial') {
               gradientElement = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
               gradientElement.setAttribute('cx', '50%');
               gradientElement.setAttribute('cy', '50%');
               gradientElement.setAttribute('r', '50%');
           } else {
               gradientElement = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
               const angle = gradientData.gradient.angle || 0;

               // Convert angle to x1, y1, x2, y2 coordinates
               const angleRad = (angle * Math.PI) / 180;
               const cos = Math.cos(angleRad);
               const sin = Math.sin(angleRad);

               // Calculate gradient endpoints (0-100% coordinates)
               const x1 = 50 - 50 * cos;
               const y1 = 50 - 50 * sin;
               const x2 = 50 + 50 * cos;
               const y2 = 50 + 50 * sin;

               gradientElement.setAttribute('x1', `${x1}%`);
               gradientElement.setAttribute('y1', `${y1}%`);
               gradientElement.setAttribute('x2', `${x2}%`);
               gradientElement.setAttribute('y2', `${y2}%`);
           }

           gradientElement.setAttribute('id', gradientId);

           // Add color stops
           if (gradientData.gradient.colors) {
               gradientData.gradient.colors.forEach(colorStop => {
                   const stopElement = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'stop');
                   stopElement.setAttribute('offset', `${colorStop.position}%`);
                   stopElement.setAttribute('stop-color', colorStop.color);
                   gradientElement.appendChild(stopElement);
               });
           }

           // Add gradient to defs
           defsElement.appendChild(gradientElement);

           // Remove existing fill and stroke attributes from all elements
           const allElements = svgElement.querySelectorAll('*');
           allElements.forEach(element => {
               element.removeAttribute('fill');
               element.removeAttribute('stroke');
               // Also remove style-based fills and strokes
               const style = element.getAttribute('style');
               if (style) {
                   const newStyle = style
                       .replace(/fill:[^;]*;?/g, '')
                       .replace(/stroke:[^;]*;?/g, '')
                       .trim();
                   if (newStyle) {
                       element.setAttribute('style', newStyle);
                   } else {
                       element.removeAttribute('style');
                   }
               }
           });

           // Apply the gradient to the root SVG element
           svgElement.setAttribute('fill', `url(#${gradientId})`);

           // Ensure the SVG has proper namespace
           if (!svgElement.hasAttribute('xmlns')) {
               svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
           }

           // Serialize back to string
           const serializer = new XMLSerializer();
           const result = serializer.serializeToString(svgDoc);

           console.log('🎨 SVG gradient applied successfully');
           return result;

       } catch (error) {
           console.error('Error applying SVG gradient:', error);
           // Fallback to solid color using first color
           const fallbackColor = gradientData.gradient.colors[0].color;
           return applySVGColor(svgText, fallbackColor);
       }
   }

   // SVG Gradient Fill Function (same as text gradients)
   function applySVGGradientFill(ctx, obj, bounds) {
       console.log('🎨 APPLYING SVG GRADIENT FILL');
       console.log('%c🎨 SVG GRADIENT FILL: Starting gradient application', 'background-color: #335; color: #aff;');
       console.log('%c Object:', 'font-weight: bold;', obj);
       console.log('%c Bounds:', 'font-weight: bold;', bounds);

       // Check if we have the necessary data
       if (!obj || !obj.gradient || !obj.gradient.gradient || !obj.gradient.gradient.colors || obj.gradient.gradient.colors.length < 2) {
           console.error('%c🎨 SVG GRADIENT FILL: Missing gradient data!', 'background-color: #500; color: #fee;', {
               obj: obj ? 'Object exists' : 'No object',
               gradient: obj && obj.gradient ? JSON.stringify(obj.gradient) : 'No gradient'
           });

           // Fallback to solid fill
           ctx.fillStyle = obj.svgColor || '#ff0000';
           return false;
       }

       // Sort stops by position to ensure proper gradient rendering
       const sortedStops = [...obj.gradient.gradient.colors].sort((a, b) => a.position - b.position);

       console.log('%c🎨 SVG GRADIENT FILL: Sorted stops', 'background-color: #335; color: #aff;',
           JSON.stringify(sortedStops));

       // Create the appropriate gradient
       let gradient;

       try {
           if (obj.gradient.type === 'radial') {
               // Calculate center and radius for radial gradient
               const centerX = bounds.x + bounds.width / 2;
               const centerY = bounds.y + bounds.height / 2;
               const radius = Math.max(bounds.width, bounds.height) / 2;

               console.log('%c🎨 SVG GRADIENT FILL: Creating radial gradient', 'background-color: #335; color: #aff;', {
                   centerX,
                   centerY,
                   radius
               });

               gradient = ctx.createRadialGradient(
                   centerX, centerY, 0,
                   centerX, centerY, radius
               );
           } else {
               // Default to linear gradient
               const angle = obj.gradient.gradient.angle || 0;

               // Convert angle to gradient coordinates
               const angleRad = (angle * Math.PI) / 180;
               const cos = Math.cos(angleRad);
               const sin = Math.sin(angleRad);

               // Calculate gradient endpoints
               const startX = bounds.x + bounds.width / 2 - (bounds.width / 2) * cos;
               const startY = bounds.y + bounds.height / 2 - (bounds.height / 2) * sin;
               const endX = bounds.x + bounds.width / 2 + (bounds.width / 2) * cos;
               const endY = bounds.y + bounds.height / 2 + (bounds.height / 2) * sin;

               console.log('%c🎨 SVG GRADIENT FILL: Creating linear gradient', 'background-color: #335; color: #aff;', {
                   angle,
                   startX,
                   startY,
                   endX,
                   endY
               });

               gradient = ctx.createLinearGradient(startX, startY, endX, endY);
           }

           // Add color stops
           sortedStops.forEach(stop => {
               const offset = stop.position / 100; // Convert percentage to 0-1
               console.log('%c🎨 SVG GRADIENT FILL: Adding color stop', 'background-color: #335; color: #aff;', {
                   offset,
                   color: stop.color
               });
               gradient.addColorStop(offset, stop.color);
           });

           // Set the gradient as fill style
           ctx.fillStyle = gradient;

           console.log('%c🎨 SVG GRADIENT FILL: Gradient applied successfully!', 'background-color: #050; color: #afa;');
           return true;

       } catch (error) {
           console.error('%c🎨 SVG GRADIENT FILL: Error creating gradient', 'background-color: #500; color: #fee;', error);

           // Fallback to solid color using first color
           const fallbackColor = sortedStops[0].color;
           console.log('%c🎨 SVG GRADIENT FILL: Using fallback color', 'background-color: #550; color: #ffa;', fallbackColor);
           ctx.fillStyle = fallbackColor;
           return false;
       }
   }

   // Initialize gradient color pickers
   function initializeGradientColorPickers() {
       // Wait for GradientColorPicker to be loaded
       if (typeof GradientColorPicker === 'undefined') {
           console.log('GradientColorPicker not loaded yet, retrying...');
           setTimeout(initializeGradientColorPickers, 200);
           return;
       }

       console.log('🎨 Initializing gradient color pickers...');

       // Replace text color picker
       const textColorContainer = document.querySelector('#iTextColor').parentElement;
       if (textColorContainer) {
           const textGradientPicker = document.createElement('div');
           textGradientPicker.id = 'textGradientPicker';
           textColorContainer.appendChild(textGradientPicker);

           // Hide original color input
           document.querySelector('#iTextColor').style.display = 'none';

           const textPickerInstance = new GradientColorPicker(textGradientPicker, {
               defaultColor: '#FF0000',
               onChange: (colorData) => {
                   console.log('🎨 Text color changed:', colorData);
                   if (colorData.type === 'solid') {
                       console.log('🎨 Applying solid color:', colorData.value);
                       console.log('🎨 Selected object index:', selectedObjectIndex);
                       console.log('🎨 Selected object:', selectedObjectIndex !== -1 ? canvasObjects[selectedObjectIndex] : 'none');
                       updateSelectedObjectFromUI('color', colorData.value);
                       updateSelectedObjectFromUI('gradient', null); // Clear gradient when using solid color
                   } else {
                       console.log('🎨 Applying gradient:', colorData);
                       console.log('🎨 Selected object index:', selectedObjectIndex);
                       console.log('🎨 Selected object:', selectedObjectIndex !== -1 ? canvasObjects[selectedObjectIndex] : 'none');
                       // Handle gradient for text
                       updateSelectedObjectFromUI('gradient', colorData);
                       updateSelectedObjectFromUI('color', colorData.gradient.colors[0].color); // Set fallback color
                   }
               }
           });

           // Store instance reference for later access
           textGradientPicker.gradientPickerInstance = textPickerInstance;
       }

       // Replace SVG color picker
       const svgColorContainer = document.querySelector('#iImageColor').parentElement;
       if (svgColorContainer) {
           const svgGradientPicker = document.createElement('div');
           svgGradientPicker.id = 'svgGradientPicker';
           svgColorContainer.appendChild(svgGradientPicker);

           // Hide original color input
           document.querySelector('#iImageColor').style.display = 'none';

           new GradientColorPicker(svgGradientPicker, {
               defaultColor: '#000000',
               onChange: (colorData) => {
                   console.log('SVG color changed:', colorData);
                   if (colorData.type === 'solid') {
                       updateSelectedObjectFromUI('svgColor', colorData.value);
                       updateSelectedObjectFromUI('svgGradient', null); // Clear gradient when using solid color
                   } else {
                       console.log('🎨 Applying SVG gradient:', colorData);
                       updateSelectedObjectFromUI('svgGradient', colorData);
                       updateSelectedObjectFromUI('svgColor', colorData.gradient.colors[0].color); // Set fallback color
                   }
               }
           });
       }
   }

   function updateBodyClass(textObj) {
       if (!textObj || textObj.type !== 'text') {
           document.body.className = document.body.className.replace(/ (normal|warp|skew|circle|curve|grid-distort|horizontalLines|colorCut|obliqueLines|fadingLinesCut|stroke-enabled|shadow|block-shadow|perspective-shadow|line-shadow|detailed-3d|horizontal-skew|vertical-skew|triangle-warp-enabled)/g, '');
           return;
       }

       const effectMode = textObj.effectMode;
       const decorationMode = textObj.decorationMode;
       const shadowMode = textObj.shadowMode;
       const strokeMode = textObj.strokeMode;
       const isTriangleWarp = textObj.warpTriangle;

       let bodyClass = effectMode;

       if (decorationMode === 'horizontalLines') bodyClass += ' horizontalLines';
       else if (decorationMode === 'colorCut') bodyClass += ' colorCut';
       else if (decorationMode === 'obliqueLines') bodyClass += ' obliqueLines';
       else if (decorationMode === 'fadingLinesCut') bodyClass += ' fadingLinesCut';

       if (strokeMode === 'stroke') bodyClass += ' stroke-enabled';

       if (shadowMode === 'shadow') bodyClass += ' shadow';
       else if (shadowMode === 'blockShadow') bodyClass += ' block-shadow';
       else if (shadowMode === 'perspectiveShadow') bodyClass += ' perspective-shadow';
       else if (shadowMode === 'lineShadow') bodyClass += ' line-shadow';
       else if (shadowMode === 'detailed3D') bodyClass += ' detailed-3d';

       if (effectMode === 'warp' || effectMode === 'skew') {
           bodyClass += ' horizontal-skew';
       }

       if (effectMode === 'skew') {
           bodyClass += ' vertical-skew';
       }

       if (effectMode === 'warp' && isTriangleWarp) {
           bodyClass += ' triangle-warp-enabled';
       }

       if (effectMode === 'grid-distort') {
           bodyClass += ' grid-distort';
       }

       document.body.className = bodyClass.trim();
   }

   // --- Layering Functions ---
   function moveObjectForward() {
       if (selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length - 1) {
           const objToMove = canvasObjects.splice(selectedObjectIndex, 1)[0];
           canvasObjects.splice(selectedObjectIndex + 1, 0, objToMove);
           selectedObjectIndex++;
           updateUIFromSelectedObject(); // Update button states
           update();
       }
   }
   function moveObjectBackward() {
       if (selectedObjectIndex !== -1 && selectedObjectIndex > 0) {
           const objToMove = canvasObjects.splice(selectedObjectIndex, 1)[0];
           canvasObjects.splice(selectedObjectIndex - 1, 0, objToMove);
           selectedObjectIndex--;
           updateUIFromSelectedObject(); // Update button states
           update();
       }
   }

   // --- Lock and Hide Functions ---
   function lockSelectedObject() {
       console.log('[Lock] lockSelectedObject called, selectedObjectIndex:', selectedObjectIndex);
       if (selectedObjectIndex !== -1) {
           const selectedObject = canvasObjects[selectedObjectIndex];
           console.log('[Lock] Locking object:', selectedObject.id, selectedObject.type);

           // Ask for a custom name if not already set
           if (!selectedObject.customName) {
               const defaultName = selectedObject.type === 'text' ?
                   (selectedObject.text?.substring(0, 15) + (selectedObject.text?.length > 15 ? '...' : '')) :
                   selectedObject.type;
               const customName = prompt(`Enter a name for this ${selectedObject.type}:`, defaultName);
               if (customName && customName.trim()) {
                   selectedObject.customName = customName.trim();
               }
           }

           selectedObject.isLocked = true;
           selectedObject.isSelected = false;
           selectedObjectIndex = -1;
           updateUIFromSelectedObject();
           update();
       }
   }

   function hideSelectedObject() {
       console.log('[Hide] hideSelectedObject called, selectedObjectIndex:', selectedObjectIndex);
       if (selectedObjectIndex !== -1) {
           const selectedObject = canvasObjects[selectedObjectIndex];
           console.log('[Hide] Hiding object:', selectedObject.id, selectedObject.type);

           // Ask for a custom name if not already set
           if (!selectedObject.customName) {
               const defaultName = selectedObject.type === 'text' ?
                   (selectedObject.text?.substring(0, 15) + (selectedObject.text?.length > 15 ? '...' : '')) :
                   selectedObject.type;
               const customName = prompt(`Enter a name for this ${selectedObject.type}:`, defaultName);
               if (customName && customName.trim()) {
                   selectedObject.customName = customName.trim();
               }
           }

           selectedObject.isHidden = true;
           selectedObject.isSelected = false;
           selectedObjectIndex = -1;
           updateUIFromSelectedObject();
           update();
       }
   }

   // 📐 LAYOUT HIDE FUNCTIONALITY: Hide selected layout or all layouts
   function hideSelectedLayout() {
       console.log('[LayoutHide] hideSelectedLayout called, selectedLayoutRectIndex:', selectedLayoutRectIndex);

       // Check if a specific layout rectangle is selected
       if (selectedLayoutRectIndex !== -1 && layoutRectangles[selectedLayoutRectIndex]) {
           const selectedLayout = layoutRectangles[selectedLayoutRectIndex];
           console.log('[LayoutHide] Hiding selected layout:', selectedLayoutRectIndex);

           // Ask for a custom name if not already set
           if (!selectedLayout.customName) {
               const defaultName = `Layout ${selectedLayoutRectIndex + 1}`;
               const customName = prompt(`Enter a name for this layout:`, defaultName);
               if (customName && customName.trim()) {
                   selectedLayout.customName = customName.trim();
               }
           }

           selectedLayout.isHidden = true;
           selectedLayoutRectIndex = -1;
           window.selectedLayoutRectIndex = -1;
           updateLayoutSelectionUI();
           update();

       } else if (layoutRectangles && layoutRectangles.length > 0) {
           // No specific layout selected - hide all layouts
           if (confirm('Are you sure you want to hide all layout rectangles?')) {
               console.log('[LayoutHide] Hiding all layouts');

               layoutRectangles.forEach((layout, index) => {
                   if (!layout.customName) {
                       layout.customName = `Layout ${index + 1}`;
                   }
                   layout.isHidden = true;
               });

               selectedLayoutRectIndex = -1;
               window.selectedLayoutRectIndex = -1;
               updateLayoutSelectionUI();
               update();
           }
       } else {
           console.log('[LayoutHide] No layout rectangles to hide');
       }
   }

   function unlockObject(objectIndex) {
       console.log('[Lock] 🔓 unlockObject called for index:', objectIndex);
       if (objectIndex >= 0 && objectIndex < canvasObjects.length) {
           const obj = canvasObjects[objectIndex];
           console.log('[Lock] 🔓 Unlocking object:', obj.id, obj.type, 'was locked:', obj.isLocked);
           obj.isLocked = false;
           console.log('[Lock] 🔓 Object unlocked, calling update()');
           update();
           console.log('[Lock] 🔓 Update completed');
       } else {
           console.error('[Lock] ❌ Invalid object index for unlock:', objectIndex, 'total objects:', canvasObjects.length);
       }
   }

   function showObject(objectIndex) {
       console.log('[Hide] 👁️ showObject called for index:', objectIndex);
       if (objectIndex >= 0 && objectIndex < canvasObjects.length) {
           const obj = canvasObjects[objectIndex];
           console.log('[Hide] 👁️ Showing object:', obj.id, obj.type, 'was hidden:', obj.isHidden);
           obj.isHidden = false;
           console.log('[Hide] 👁️ Object shown, calling update()');
           update();
           console.log('[Hide] 👁️ Update completed');
       } else {
           console.error('[Hide] ❌ Invalid object index for show:', objectIndex, 'total objects:', canvasObjects.length);
       }
   }

   function unlockAllObjects() {
       console.log('[Lock] unlockAllObjects called');
       let unlockedCount = 0;
       canvasObjects.forEach(obj => {
           if (obj.isLocked) {
               obj.isLocked = false;
               unlockedCount++;
               console.log('[Lock] Unlocked object:', obj.id, obj.type);
           }
       });
       console.log('[Lock] Total objects unlocked:', unlockedCount);
       if (unlockedCount > 0) {
           update();
       }
   }

   function unhideAllObjects() {
       console.log('[Hide] unhideAllObjects called');
       let unhiddenCount = 0;

       // Unhide canvas objects
       canvasObjects.forEach(obj => {
           if (obj.isHidden) {
               obj.isHidden = false;
               unhiddenCount++;
               console.log('[Hide] Unhidden object:', obj.id, obj.type);
           }
       });

       // Unhide layout rectangles
       let unhiddenLayoutCount = 0;
       if (layoutRectangles && Array.isArray(layoutRectangles)) {
           layoutRectangles.forEach((layout, index) => {
               if (layout.isHidden) {
                   layout.isHidden = false;
                   unhiddenLayoutCount++;
                   console.log('[LayoutHide] Unhidden layout:', index, layout.customName || `Layout ${index + 1}`);
               }
           });
       }

       console.log('[Hide] Total objects unhidden:', unhiddenCount);
       console.log('[LayoutHide] Total layouts unhidden:', unhiddenLayoutCount);

       if (unhiddenCount > 0 || unhiddenLayoutCount > 0) {
           update();
       }
   }

   // --- Test Function ---
   function addTestObject() {
       console.log('[Test] ✅ addTestObject function called!');
       console.log('[Test] Current canvasObjects length:', canvasObjects.length);
       console.log('[Test] Current selectedObjectIndex:', selectedObjectIndex);

       // Create a test text object
       const testText = {
           id: 'test-' + Date.now(),
           type: 'text',
           text: 'Test Object',
           x: 100,
           y: 100,
           fontSize: 48,
           fontFamily: 'Arial',
           color: '#000000',
           isSelected: false,
           isLocked: false,
           isHidden: false
       };

       console.log('[Test] Created test object:', testText);

       // Add to canvas
       canvasObjects.push(testText);
       console.log('[Test] Added to canvas, new length:', canvasObjects.length);

       // Select the new object
       selectedObjectIndex = canvasObjects.length - 1;
       testText.isSelected = true;

       console.log('[Test] Selected test object, selectedObjectIndex:', selectedObjectIndex);
       console.log('[Test] testText.isSelected:', testText.isSelected);

       // Update UI and render
       console.log('[Test] Calling updateUIFromSelectedObject...');
       updateUIFromSelectedObject();
       console.log('[Test] Calling update...');
       update();
       console.log('[Test] ✅ addTestObject completed!');
   }

   // --- Font Preview ---
   function applyFontStylesToOptions() { const selectElement = document.getElementById('iFontFamily'); if (!selectElement) return; const options = selectElement.getElementsByTagName('option'); for (let option of options) { option.style.fontFamily = option.value; option.style.fontFamily += ', sans-serif'; } }

   // --- Shadow/Decoration Helpers --- (Full implementations exist but omitted for brevity)
   function applyBlockShadow(targetCtx, textObj, x, y) {
       // Generate a unique ID for this rendering pass to track in logs
       const renderPassId = Math.random().toString(36).substring(2, 8);

       console.log(`=== BLOCK SHADOW DEBUG START (${renderPassId}) ===`);
       console.log(`[${renderPassId}] Text object:`, textObj.text);
       console.log(`[${renderPassId}] Function called with:`, {
           x,
           y,
           hasPath: arguments.length > 3 && arguments[3] !== undefined,
           targetCtxType: targetCtx ? targetCtx.constructor.name : 'undefined'
       });

       try {
           // Always check if we should be using block shadow mode
           if (textObj.shadowMode !== 'blockShadow') {
               console.warn(`[${renderPassId}] WARNING: Called applyBlockShadow but shadowMode is not 'blockShadow', it's '${textObj.shadowMode}'`);
               // Don't return, continue with rendering anyway for debugging
           }

           // Check if textObj has all required properties
           if (!textObj.blockShadowColor || textObj.blockShadowOpacity === undefined ||
               textObj.blockShadowOffset === undefined || textObj.blockShadowAngle === undefined) {
               console.error(`[${renderPassId}] ERROR: Missing required block shadow properties:`, {
                   hasColor: !!textObj.blockShadowColor,
                   hasOpacity: textObj.blockShadowOpacity !== undefined,
                   hasOffset: textObj.blockShadowOffset !== undefined,
                   hasAngle: textObj.blockShadowAngle !== undefined
               });
           }

           const color = textObj.blockShadowColor || '#000000';
           const opacity = (textObj.blockShadowOpacity !== undefined) ? textObj.blockShadowOpacity / 100 : 1;
           const offset = textObj.blockShadowOffset || 40;
           const angleDeg = textObj.blockShadowAngle || -45;
           const blur = textObj.blockShadowBlur || 0;

           // IMPORTANT: Always check the perspective flag directly from the object
           let isPerspective = textObj.blockShadowPerspective || false;

           // Force perspective mode if it should be enabled
           if (textObj.shadowMode === 'blockShadow' && textObj.blockShadowPerspective) {
               console.log(`[${renderPassId}] FORCING PERSPECTIVE MODE - was:`, isPerspective);
               isPerspective = true;
           }

           const offsetCoords = calculateOffset(offset, angleDeg);

           console.log(`[${renderPassId}] Shadow properties:`, {
               color,
               opacity,
               offset,
               angleDeg,
               blur,
               isPerspective,
               perspectiveIntensity: textObj.blockShadowPerspectiveIntensity,
               shadowMode: textObj.shadowMode,
               offsetCoords
           });

           // Log the final state of the shadow properties
           console.log(`[${renderPassId}] Final shadow properties:`, {
               shadowMode: textObj.shadowMode,
               isPerspective: isPerspective,
               perspectiveIntensity: textObj.blockShadowPerspectiveIntensity
           });
       } catch (error) {
           console.error(`[${renderPassId}] ERROR in applyBlockShadow initial setup:`, error);
       }

       try {
           // Get shadow properties from the try block above
           const color = textObj.blockShadowColor || '#000000';
           const opacity = (textObj.blockShadowOpacity !== undefined) ? textObj.blockShadowOpacity / 100 : 1;
           const offset = textObj.blockShadowOffset || 40;
           const angleDeg = textObj.blockShadowAngle || -45;
           const blur = textObj.blockShadowBlur || 0;
           const offsetCoords = calculateOffset(offset, angleDeg);
           const isPerspective = textObj.blockShadowPerspective || false;

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);
           targetCtx.fillStyle = hexToRgba(color, opacity);

           console.log(`[${renderPassId}] Canvas context state:`, {
               fillStyle: targetCtx.fillStyle,
               font: targetCtx.font,
               globalAlpha: targetCtx.globalAlpha
           });

           if (blur > 0) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               targetCtx.shadowBlur = blur;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
               console.log(`[${renderPassId}] Shadow blur applied:`, {
                   shadowColor: targetCtx.shadowColor,
                   shadowBlur: targetCtx.shadowBlur
               });
           }

           // Calculate number of steps based on offset
           // More steps for larger offsets to maintain smoothness
           const steps = Math.max(10, Math.floor(offset / 1.5));
           console.log(`[${renderPassId}] Number of shadow steps:`, steps);
       } catch (error) {
           console.error(`[${renderPassId}] ERROR in applyBlockShadow context setup:`, error);
       }

       try {
           // Get shadow properties again to ensure they're in scope
           const color = textObj.blockShadowColor || '#000000';
           const opacity = (textObj.blockShadowOpacity !== undefined) ? textObj.blockShadowOpacity / 100 : 1;
           const offset = textObj.blockShadowOffset || 40;
           const angleDeg = textObj.blockShadowAngle || -45;
           const blur = textObj.blockShadowBlur || 0;
           const offsetCoords = calculateOffset(offset, angleDeg);
           const isPerspective = textObj.blockShadowPerspective || false;
           const steps = Math.max(10, Math.floor(offset / 1.5));

           if (isPerspective) {
               console.log(`[${renderPassId}] Using PERSPECTIVE shadow mode`);
               // Completely redesigned perspective shadow effect
               // Get the perspective intensity (0-100) and convert to a scaling factor
               // Higher values create more dramatic perspective effects
               const perspectiveIntensity = (textObj.blockShadowPerspectiveIntensity || 50) / 100;

               // Calculate the minimum scale factor for the farthest shadow
               // This ensures that at maximum intensity, the farthest shadow can be very small
               // More dramatic scaling for higher intensity values
               const minScaleFactor = Math.max(0.02, 0.5 - (perspectiveIntensity * 0.48));

               console.log(`[${renderPassId}] Perspective intensity:`, textObj.blockShadowPerspectiveIntensity,
                          'Calculated factor:', perspectiveIntensity,
                          'Min scale factor:', minScaleFactor);

               // Draw shadows from back to front (important for proper layering)
               for (let i = steps; i >= 1; i--) {
                   const progress = i / steps;

                   // Calculate a more dramatic scaling factor that decreases as the shadow extends
                   // This creates a true perspective effect where distant shadows are much smaller
                   const distanceRatio = i / steps; // 1.0 at the start, approaching 0 at the end

                   // Apply a non-linear scaling based on the perspective intensity
                   // Higher intensity = more dramatic scaling at distance
                   // Use a much more aggressive scaling formula for a true perspective effect
                   // The exponent controls how quickly the shadow shrinks with distance
                   // Higher exponent values create more dramatic scaling (smaller distant shadows)

                   // Calculate the scale factor with a non-linear curve
                   // This creates a more dramatic perspective effect where distant shadows get much smaller
                   // Higher exponent values create more dramatic scaling (smaller distant shadows)
                   const exponent = 1 + perspectiveIntensity * 10;
                   let scaleProgress = Math.pow(distanceRatio, exponent);

                   // Apply the minimum scale factor to ensure the farthest shadow isn't too small
                   // This creates a smooth transition from 1.0 (closest) to minScaleFactor (farthest)
                   if (i === 1) { // For the farthest shadow
                       scaleProgress = minScaleFactor;
                   } else if (i < steps / 3) { // For shadows in the far third
                       // Blend between calculated scale and minimum scale for smoother transition
                       const blendFactor = (i - 1) / (steps / 3 - 1);
                       scaleProgress = minScaleFactor + (scaleProgress - minScaleFactor) * blendFactor;
                   }

                   if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                       debugLog(`[${renderPassId}] Shadow step ${i}/${steps}: distanceRatio=${distanceRatio.toFixed(2)}, scaleProgress=${scaleProgress.toFixed(3)}`);
                   }

                   // Calculate position for this shadow layer
                   // Multiply by offset to get the full distance
                   const posX = x + offsetCoords.x * progress * offset;
                   const posY = y + offsetCoords.y * progress * offset;

                   if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                       debugLog(`[${renderPassId}] Shadow position: (${posX.toFixed(1)}, ${posY.toFixed(1)}), scale: ${scaleProgress.toFixed(3)}`);
                   }

                   try {
                       // Save state before transformations
                       targetCtx.save();

                       // Move to the position where we'll draw this shadow layer
                       targetCtx.translate(posX, posY);

                       // Apply scaling for perspective effect
                       targetCtx.scale(scaleProgress, scaleProgress);

                       // Handle shadow blur
                       if (blur > 5 && i < steps) {
                           targetCtx.shadowColor = 'transparent';
                       }

                       // Draw the text at origin (0,0) since we've already translated
                       // Handle letter spacing for shadows
                       const text = (textObj.text || '');
                       const letterSpacing = textObj._effectiveLetterSpacing || 0;
                       if (letterSpacing !== 0) {
                           // Draw each character manually with letter spacing
                           const letters = text.split('');
                           let totalWidth = 0;

                           // Calculate total width with letter spacing
                           letters.forEach(letter => {
                               totalWidth += targetCtx.measureText(letter).width;
                           });
                           if (letters.length > 1) {
                               totalWidth += letterSpacing * (letters.length - 1);
                           }

                           // Draw each letter with proper spacing
                           let currentX = -totalWidth / 2;
                           for (let i = 0; i < letters.length; i++) {
                               const letter = letters[i];
                               const letterWidth = targetCtx.measureText(letter).width;
                               targetCtx.fillText(letter, currentX + letterWidth / 2, 0);
                               currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
                           }
                       } else {
                           // No letter spacing, use standard fillText
                           targetCtx.fillText(text, 0, 0);
                       }

                       // Restore shadow if needed
                       if (blur > 5 && i < steps) {
                           targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
                       }

                       // Restore the context state
                       targetCtx.restore();
                   } catch (error) {
                       console.error(`[${renderPassId}] ERROR in perspective shadow step ${i}:`, error);
                   }
               }
               console.log(`[${renderPassId}] === PERSPECTIVE SHADOW DEBUG END ===`);
           } else {
               // Standard block shadow mode
               console.log(`[${renderPassId}] Using STANDARD shadow mode (no perspective)`);

               try {
                   // Standard block shadow - uniform size
                   for (let i = steps; i >= 1; i--) {
                       const progress = i / steps;
                       // Multiply by offset to get the full distance
                       const currentX = x + offsetCoords.x * progress * offset;
                       const currentY = y + offsetCoords.y * progress * offset;

                       if (i % 5 === 0 || i === 1 || i === steps) {
                           console.log(`[${renderPassId}] Standard shadow step ${i}/${steps}: position=(${currentX.toFixed(1)}, ${currentY.toFixed(1)})`);
                       }

                       try {
                           if (blur > 5 && i < steps) {
                               targetCtx.shadowColor = 'transparent';
                           }

                           // Handle letter spacing for standard shadows
                           const text = (textObj.text || '');
                           const letterSpacing = textObj._effectiveLetterSpacing || 0;
                           if (letterSpacing !== 0) {
                               // Draw each character manually with letter spacing
                               const letters = text.split('');
                               let totalWidth = 0;

                               // Calculate total width with letter spacing
                               letters.forEach(letter => {
                                   totalWidth += targetCtx.measureText(letter).width;
                               });
                               if (letters.length > 1) {
                                   totalWidth += letterSpacing * (letters.length - 1);
                               }

                               // Draw each letter with proper spacing
                               let startX = currentX - totalWidth / 2;
                               for (let i = 0; i < letters.length; i++) {
                                   const letter = letters[i];
                                   const letterWidth = targetCtx.measureText(letter).width;
                                   targetCtx.fillText(letter, startX + letterWidth / 2, currentY);
                                   startX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
                               }
                           } else {
                               // No letter spacing, use standard fillText
                               targetCtx.fillText(text, currentX, currentY);
                           }

                           if (blur > 5 && i < steps) {
                               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
                           }
                       } catch (error) {
                           console.error(`[${renderPassId}] ERROR in standard shadow step ${i}:`, error);
                       }
                   }
                   console.log(`[${renderPassId}] === STANDARD SHADOW DEBUG END ===`);
               } catch (error) {
                   console.error(`[${renderPassId}] ERROR in standard shadow mode:`, error);
               }
           }
       } catch (error) {
           console.error(`[${renderPassId}] ERROR in shadow rendering:`, error);
       }

       // Always restore the context state
       try {
           targetCtx.restore();
           console.log(`[${renderPassId}] Context restored successfully`);
       } catch (error) {
           console.error(`[${renderPassId}] ERROR restoring context:`, error);
       }

       console.log(`[${renderPassId}] === BLOCK SHADOW FUNCTION END ===`);
   }
   function applyLineShadow(targetCtx, textObj, x, y) {
       try {
           console.log('🔍 LINE SHADOW ENTRY: Function called');
           const color = textObj.lineShadowColor;
           const distance = textObj.lineShadowDist;
           const angleDeg = textObj.lineShadowAngle;
           const thickness = Math.max(1, textObj.lineShadowThickness);
           const fullOffset = calculateOffset(distance, angleDeg);
           const cutterDistance = Math.max(0, distance - thickness);
           const cutterOffset = calculateOffset(cutterDistance, angleDeg);

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);
           targetCtx.fillStyle = color;

           // Handle letter spacing for line shadow
           const text = (textObj.text || '');
           const letterSpacing = textObj._effectiveLetterSpacing || 0;
           console.log('🔍 LINE SHADOW DEBUG: text="' + text + '", letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + textObj._effectiveLetterSpacing);
       } catch (error) {
           console.error('🔍 LINE SHADOW ERROR:', error);
           return;
       }

       try {
           console.log('🔍 LINE SHADOW RENDERING: Starting shadow rendering with letterSpacing=' + letterSpacing);

           // Draw the full shadow
           if (letterSpacing !== 0) {
               console.log('🔍 LINE SHADOW: Using letter spacing mode');
               // Draw each character manually with letter spacing
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               console.log('🔍 LINE SHADOW: totalWidth=' + totalWidth + ', letters=' + letters.length);

               // Draw each letter with proper spacing for full shadow
               let currentX = x + fullOffset.x - totalWidth / 2;
               for (let i = 0; i < letters.length; i++) {
                   const letter = letters[i];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + fullOffset.y);
                   currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               console.log('🔍 LINE SHADOW: Using standard mode (no letter spacing)');
               targetCtx.fillText(text, x + fullOffset.x, y + fullOffset.y);
           }

           // Cut out the inner part
           targetCtx.globalCompositeOperation = 'destination-out';
           targetCtx.fillStyle = 'black';

           if (letterSpacing !== 0) {
               // Draw each character manually with letter spacing for cutter
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter with proper spacing for cutter
               let currentX = x + cutterOffset.x - totalWidth / 2;
               for (let i = 0; i < letters.length; i++) {
                   const letter = letters[i];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + cutterOffset.y);
                   currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               targetCtx.fillText(text, x + cutterOffset.x, y + cutterOffset.y);
           }

           console.log('🔍 LINE SHADOW: Rendering complete');
           targetCtx.restore();
       } catch (error) {
           console.error('🔍 LINE SHADOW RENDERING ERROR:', error);
           targetCtx.restore();
       }
   }

   // Apply perspective shadow to a path
   function applyPerspectiveShadow(targetCtx, textObj, x, y, path) {
       // Generate a unique ID for this rendering pass to track in logs
       const renderPassId = Math.random().toString(36).substring(2, 8);

       console.log(`=== PERSPECTIVE SHADOW START (${renderPassId}) ===`);
       console.log(`[${renderPassId}] Text object:`, textObj.text);
       console.log(`[${renderPassId}] Function called with:`, {
           x,
           y,
           hasPath: arguments.length > 3 && arguments[3] !== undefined,
           targetCtxType: targetCtx ? targetCtx.constructor.name : 'undefined'
       });

       try {
           // If no path is provided, use the standard text-based function
           if (!path) {
               // Use the original function for text objects
               const color = textObj.perspectiveShadowColor || '#000000';
               const opacity = (textObj.perspectiveShadowOpacity !== undefined) ? textObj.perspectiveShadowOpacity / 100 : 1;
               const offset = textObj.perspectiveShadowOffset || 40;
               const angleDeg = textObj.perspectiveShadowAngle || -58;
               const blur = textObj.perspectiveShadowBlur || 5;
               const perspectiveIntensity = (textObj.perspectiveShadowIntensity || 60) / 100;
               const offsetCoords = calculateOffset(offset, angleDeg);

               console.log(`[${renderPassId}] Perspective Shadow properties:`, {
                   color,
                   opacity,
                   offset,
                   angleDeg,
                   blur,
                   perspectiveIntensity,
                   shadowMode: textObj.shadowMode,
                   offsetCoords
               });

               targetCtx.save();
               setTextContextOn(targetCtx, textObj);
               targetCtx.fillStyle = hexToRgba(color, opacity);

               if (blur > 0) {
                   targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
                   targetCtx.shadowBlur = blur;
                   targetCtx.shadowOffsetX = 0;
                   targetCtx.shadowOffsetY = 0;
               }

               // Calculate number of steps based on offset
               // More steps for larger offsets to maintain smoothness
               const steps = Math.max(10, Math.floor(offset / 1.5));
               console.log(`[${renderPassId}] Number of shadow steps:`, steps);

               // Draw shadows from back to front (important for proper layering)
               for (let i = steps; i >= 1; i--) {
                   const progress = i / steps;

                   // Calculate a more dramatic scaling factor that decreases as the shadow extends
                   // This creates a true perspective effect where distant shadows are much smaller
                   const distanceRatio = i / steps; // 1.0 at the start, approaching 0 at the end

                   // Apply a non-linear scaling based on the perspective intensity
                   // Higher intensity = more dramatic scaling at distance
                   // The exponent controls how quickly the shadow shrinks with distance
                   const scaleProgress = Math.pow(distanceRatio, 1 + perspectiveIntensity * 6);

                   if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                       debugLog(`[${renderPassId}] Shadow step ${i}/${steps}: distanceRatio=${distanceRatio.toFixed(2)}, scaleProgress=${scaleProgress.toFixed(3)}`);
                   }

                   // Calculate position for this shadow layer
                   const posX = x + offsetCoords.x * progress * offset;
                   const posY = y + offsetCoords.y * progress * offset;

                   if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                       debugLog(`[${renderPassId}] Shadow position: (${posX.toFixed(1)}, ${posY.toFixed(1)}), scale: ${scaleProgress.toFixed(3)}`);
                   }

                   // Save state before transformations
                   targetCtx.save();

                   // Move to the position where we'll draw this shadow layer
                   targetCtx.translate(posX, posY);

                   // Apply scaling for perspective effect
                   targetCtx.scale(scaleProgress, scaleProgress);

                   // Handle shadow blur
                   if (blur > 5 && i < steps) {
                       targetCtx.shadowColor = 'transparent';
                   }

                   // Draw the text at origin (0,0) since we've already translated
                   // Handle letter spacing for perspective shadows
                   const text = (textObj.text || '');
                   const letterSpacing = textObj._effectiveLetterSpacing || 0;
                   if (letterSpacing !== 0) {
                       // Draw each character manually with letter spacing
                       const letters = text.split('');
                       let totalWidth = 0;

                       // Calculate total width with letter spacing
                       letters.forEach(letter => {
                           totalWidth += targetCtx.measureText(letter).width;
                       });
                       if (letters.length > 1) {
                           totalWidth += letterSpacing * (letters.length - 1);
                       }

                       // Draw each letter with proper spacing
                       let currentX = -totalWidth / 2;
                       for (let i = 0; i < letters.length; i++) {
                           const letter = letters[i];
                           const letterWidth = targetCtx.measureText(letter).width;
                           targetCtx.fillText(letter, currentX + letterWidth / 2, 0);
                           currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
                       }
                   } else {
                       // No letter spacing, use standard fillText
                       targetCtx.fillText(text, 0, 0);
                   }

                   // Restore shadow if needed
                   if (blur > 5 && i < steps) {
                       targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
                   }

                   // Restore the context state
                   targetCtx.restore();
               }

               targetCtx.restore();
               console.log(`[${renderPassId}] === PERSPECTIVE SHADOW TEXT END ===`);
               return;
           }

           // Path-based perspective shadow implementation
           const color = textObj.perspectiveShadowColor || '#000000';
           const opacity = (textObj.perspectiveShadowOpacity !== undefined) ? textObj.perspectiveShadowOpacity / 100 : 1;
           const offset = textObj.perspectiveShadowOffset || 40;
           const angleDeg = textObj.perspectiveShadowAngle || -58;
           const blur = textObj.perspectiveShadowBlur || 5;
           const perspectiveIntensity = (textObj.perspectiveShadowIntensity || 60) / 100;
           const offsetCoords = calculateOffset(offset, angleDeg);

           console.log(`[${renderPassId}] Path-based perspective shadow properties:`, {
               color,
               opacity,
               offset,
               angleDeg,
               blur,
               perspectiveIntensity,
               shadowMode: textObj.shadowMode,
               offsetCoords
           });

           targetCtx.save();
           targetCtx.fillStyle = hexToRgba(color, opacity);

           if (blur > 0) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               targetCtx.shadowBlur = blur;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
           }

           // Calculate number of steps based on offset
           const steps = Math.max(10, Math.floor(offset / 1.5));

           // Create a Path2D object from the OpenType.js path if needed
           const shadowPath = path instanceof Path2D ? path : new Path2D();

           for (let i = steps; i >= 1; i--) {
               const progress = i / steps;
               const distanceRatio = i / steps;
               const scaleProgress = Math.pow(distanceRatio, 1 + perspectiveIntensity * 6);

               if (i % 5 === 0 || i === 1 || i === steps) {
                   console.log(`[${renderPassId}] Path shadow step ${i}/${steps}: scale=${scaleProgress.toFixed(3)}`);
               }

               targetCtx.save();

               // Invert the progress to get the correct offset
               // Farthest shadow (i=1) should have the largest offset
               // Closest shadow (i=steps) should have the smallest offset
               const offsetProgress = 1 - progress;

               // Apply both translation and scaling for perspective effect
               targetCtx.translate(offsetCoords.x * offsetProgress * offset, offsetCoords.y * offsetProgress * offset);
               targetCtx.scale(scaleProgress, scaleProgress);

               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = 'transparent';
               }

               targetCtx.fill(shadowPath);

               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               }

               targetCtx.restore();
           }

           targetCtx.restore();
           console.log(`[${renderPassId}] === PERSPECTIVE SHADOW PATH END ===`);
       } catch (error) {
           console.error(`[${renderPassId}] ERROR in perspective shadow:`, error);
       }
   }
   function applyDetailed3D_ExtrusionOnly(targetCtx, textObj, x, y) {
       const primaryColorRgba = hexToRgba(textObj.d3dPrimaryColor, textObj.d3dPrimaryOpacity / 100);
       const offset = textObj.d3dOffset;
       const angle = textObj.d3dAngle;
       const blur = textObj.d3dBlur;

       targetCtx.save();
       setTextContextOn(targetCtx, textObj);

       const totalOffset = calculateOffset(offset, angle);
       const steps = Math.max(30, Math.floor(offset));

       // Handle letter spacing for detailed 3D
       const text = (textObj.text || '').toUpperCase();
       const letterSpacing = textObj._effectiveLetterSpacing || 0;

       for (let i = steps; i >= 1; i--) {
           const progress = i / steps;
           const currentOffset = {
               x: totalOffset.x * progress,
               y: totalOffset.y * progress
           };

           targetCtx.fillStyle = primaryColorRgba;

           if (letterSpacing !== 0) {
               // Draw each character manually with letter spacing
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter with proper spacing
               let currentX = x + currentOffset.x - totalWidth / 2;
               for (let j = 0; j < letters.length; j++) {
                   const letter = letters[j];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + currentOffset.y);
                   currentX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               targetCtx.fillText(text, x + currentOffset.x, y + currentOffset.y);
           }
       }

       if (blur > 0) {
           targetCtx.save();
           targetCtx.shadowColor = primaryColorRgba;
           targetCtx.shadowBlur = blur;
           targetCtx.shadowOffsetX = 0;
           targetCtx.shadowOffsetY = 0;
           targetCtx.fillStyle = primaryColorRgba;

           if (letterSpacing !== 0) {
               // Draw each character manually with letter spacing for blur
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter with proper spacing
               let currentX = x + totalOffset.x - totalWidth / 2;
               for (let j = 0; j < letters.length; j++) {
                   const letter = letters[j];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + totalOffset.y);
                   currentX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               targetCtx.fillText(text, x + totalOffset.x, y + totalOffset.y);
           }

           targetCtx.restore();
       }

       targetCtx.restore();
   }
   function applyDetailed3D_FrontOutline(targetCtx, textObj, x, y) {
       if (textObj.d3dSecondaryWidth <= 0) return;

       const secondaryColorRgba = hexToRgba(textObj.d3dSecondaryColor, textObj.d3dSecondaryOpacity / 100);
       targetCtx.save();
       setTextContextOn(targetCtx, textObj);
       targetCtx.lineWidth = textObj.d3dSecondaryWidth;
       targetCtx.strokeStyle = secondaryColorRgba;
       targetCtx.lineJoin = 'round';

       const text = (textObj.text || '');
       const outlineX = x + textObj.d3dSecondaryOffsetX;
       const outlineY = y + textObj.d3dSecondaryOffsetY;

       // Handle letter spacing for front outline
       const letterSpacing = textObj._effectiveLetterSpacing || 0;
       if (letterSpacing !== 0) {
           // Draw each character manually with letter spacing
           const letters = text.split('');
           let totalWidth = 0;

           // Calculate total width with letter spacing
           letters.forEach(letter => {
               totalWidth += targetCtx.measureText(letter).width;
           });
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           // Draw each letter stroke with proper spacing
           let currentX = outlineX - totalWidth / 2;
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = targetCtx.measureText(letter).width;
               targetCtx.strokeText(letter, currentX + letterWidth / 2, outlineY);
               currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
           }
       } else {
           // No letter spacing, use standard strokeText
           targetCtx.strokeText(text, outlineX, outlineY);
       }

       targetCtx.restore();
   }



   // Apply perspective shadow front outline
   function applyPerspectiveShadow_FrontOutline(targetCtx, textObj, x, y, path) {
       console.log('🔍 FRONT OUTLINE SOURCE #3: applyPerspectiveShadow_FrontOutline called');
       console.log('🔍 FRONT OUTLINE #3 DETAILS:', {
           outlineWidth: textObj.perspectiveShadowOutlineWidth,
           effectMode: textObj.effectMode,
           shadowMode: textObj.shadowMode,
           hasGradient: textObj.gradient && textObj.gradient.type !== 'solid',
           hasPath: !!path
       });

       // Skip if outline width is 0 or not set
       if (!textObj.perspectiveShadowOutlineWidth || textObj.perspectiveShadowOutlineWidth <= 0) {
           console.log('🔍 FRONT OUTLINE #3: Skipping - no outline width');
           return;
       }

       // Skip if we're using gradient masking (front outline handled separately)
       const isCircularWithGradient = (textObj.distortType === 'circular' || textObj.effectMode === 'circle') && textObj.gradient && textObj.gradient.type !== 'solid';
       const isGridDistortWithGradient = (textObj.effectMode === 'gridDistort') && textObj.gradient && textObj.gradient.type !== 'solid';
       const isCurvedWithGradient = (textObj.effectMode === 'curve') && textObj.gradient && textObj.gradient.type !== 'solid';
       const isMeshWarpWithGradient = (textObj.effectMode === 'meshWarp') && textObj.gradient && textObj.gradient.type !== 'solid';

       const usesGradientMasking = isCircularWithGradient || isGridDistortWithGradient || isCurvedWithGradient || isMeshWarpWithGradient;

       if (usesGradientMasking) {
           console.log('🔍 FRONT OUTLINE #3: Skipping applyPerspectiveShadow_FrontOutline (using gradient masking)');
           return;
       }

       console.log('🔍 FRONT OUTLINE #3: Proceeding with applyPerspectiveShadow_FrontOutline');

       // For grid distorted text, we need to draw the outline even if _outlineDrawn is true
       // because the grid distortion is rendered differently
       if (textObj._outlineDrawn && !path) {
           console.log("Skipping duplicate outline drawing for regular text");
           return;
       }

       // If this is a grid distorted text (path is provided), reset the flag to ensure it's drawn
       if (path) {
           textObj._outlineDrawn = false;
       }

       // Get outline properties
       const outlineColor = textObj.perspectiveShadowOutlineColor || '#00FF00';
       const outlineOpacity = (textObj.perspectiveShadowOutlineOpacity !== undefined) ?
           textObj.perspectiveShadowOutlineOpacity / 100 : 1.0;
       const outlineWidth = textObj.perspectiveShadowOutlineWidth || 4;
       const outlineOffsetX = textObj.perspectiveShadowOutlineOffsetX || -5;
       const outlineOffsetY = textObj.perspectiveShadowOutlineOffsetY || -5;

       // Add a debug ID to track this function call
       const debugId = Math.random().toString(36).substring(2, 8);
       console.log(`[${debugId}] Drawing perspective shadow outline: width=${outlineWidth}, color=${outlineColor}`);

       // Save context state
       targetCtx.save();

       // If a path is provided (for grid distorted text), use it
       if (path) {
           console.log(`[${debugId}] Using path-based approach for perspective shadow outline`);

           // Check if the path is an OpenType.js path or a Path2D object
           if (path.commands) {
               // It's an OpenType.js path
               console.log(`[${debugId}] Path is an OpenType.js path with ${path.commands.length} commands`);

               // First create a copy of the path with offset
               const offsetPath = new opentype.Path();

               // Apply the offset to each command
               for (let i = 0; i < path.commands.length; i++) {
                   const cmd = path.commands[i];
                   switch (cmd.type) {
                       case 'M':
                           offsetPath.moveTo(cmd.x + outlineOffsetX, cmd.y + outlineOffsetY);
                           break;
                       case 'L':
                           offsetPath.lineTo(cmd.x + outlineOffsetX, cmd.y + outlineOffsetY);
                           break;
                       case 'C':
                           // OpenType.js uses 'curveTo' for bezier curves
                           offsetPath.curveTo(
                               cmd.x1 + outlineOffsetX, cmd.y1 + outlineOffsetY,
                               cmd.x2 + outlineOffsetX, cmd.y2 + outlineOffsetY,
                               cmd.x + outlineOffsetX, cmd.y + outlineOffsetY
                           );
                           break;
                       case 'Q':
                           // OpenType.js uses 'quadTo' for quadratic curves
                           offsetPath.quadTo(
                               cmd.x1 + outlineOffsetX, cmd.y1 + outlineOffsetY,
                               cmd.x + outlineOffsetX, cmd.y + outlineOffsetY
                           );
                           break;
                       case 'Z':
                           offsetPath.closePath();
                           break;
                   }
               }

               // Now convert the OpenType.js path to a Canvas Path2D
               const outlinePath = new Path2D();
               for (let i = 0; i < offsetPath.commands.length; i++) {
                   const cmd = offsetPath.commands[i];
                   switch (cmd.type) {
                       case 'M':
                           outlinePath.moveTo(cmd.x, cmd.y);
                           break;
                       case 'L':
                           outlinePath.lineTo(cmd.x, cmd.y);
                           break;
                       case 'C':
                           outlinePath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                           break;
                       case 'Q':
                           outlinePath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                           break;
                       case 'Z':
                           outlinePath.closePath();
                           break;
                   }
               }

               // Set up the stroke style for the outline
               targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
               targetCtx.lineWidth = outlineWidth;
               targetCtx.lineJoin = 'round';
               targetCtx.lineCap = 'round';

               // Draw the outline
               targetCtx.stroke(outlinePath);
           } else {
               // It's a Path2D object or something else
               console.log(`[${debugId}] Path is not an OpenType.js path, trying direct approach`);

               // Create a Path2D object for the outline
               const outlinePath = new Path2D();
               for (let i = 0; i < path.commands.length; i++) {
                   const cmd = path.commands[i];
                   switch (cmd.type) {
                       case 'M':
                           outlinePath.moveTo(cmd.x + outlineOffsetX, cmd.y + outlineOffsetY);
                           break;
                       case 'L':
                           outlinePath.lineTo(cmd.x + outlineOffsetX, cmd.y + outlineOffsetY);
                           break;
                       case 'C':
                           outlinePath.bezierCurveTo(
                               cmd.x1 + outlineOffsetX, cmd.y1 + outlineOffsetY,
                               cmd.x2 + outlineOffsetX, cmd.y2 + outlineOffsetY,
                               cmd.x + outlineOffsetX, cmd.y + outlineOffsetY
                           );
                           break;
                       case 'Q':
                           outlinePath.quadraticCurveTo(
                               cmd.x1 + outlineOffsetX, cmd.y1 + outlineOffsetY,
                               cmd.x + outlineOffsetX, cmd.y + outlineOffsetY
                           );
                           break;
                       case 'Z':
                           outlinePath.closePath();
                           break;
                   }
               }

               // Set up the stroke style for the outline
               targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
               targetCtx.lineWidth = outlineWidth;
               targetCtx.lineJoin = 'round';
               targetCtx.lineCap = 'round';

               // Draw the outline
               targetCtx.stroke(outlinePath);
           }
       } else {
           // For regular text, use the standard text-based approach
           // Set up text context
           setTextContextOn(targetCtx, textObj);

           // Set up the stroke style for the outline
           targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
           targetCtx.lineWidth = outlineWidth;
           targetCtx.lineJoin = 'round';
           targetCtx.lineCap = 'round';

           // Draw the text outline with offsets and letter spacing support
           const text = (textObj.text || '');
           const outlineX = x + outlineOffsetX;
           const outlineY = y + outlineOffsetY;

           // Handle letter spacing for perspective shadow front outline
           const letterSpacing = textObj._effectiveLetterSpacing || 0;
           if (letterSpacing !== 0) {
               // Draw each character manually with letter spacing
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter stroke with proper spacing
               let currentX = outlineX - totalWidth / 2;
               for (let i = 0; i < letters.length; i++) {
                   const letter = letters[i];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.strokeText(letter, currentX + letterWidth / 2, outlineY);
                   currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               // No letter spacing, use standard strokeText
               targetCtx.strokeText(text, outlineX, outlineY);
           }
       }

       // Mark this outline as drawn
       textObj._outlineDrawn = true;

       // Restore context state
       targetCtx.restore();
       console.log('🔍 FRONT OUTLINE SOURCE #3: applyPerspectiveShadow_FrontOutline COMPLETED');
   }

   // --- Master Styling Functions ---
   // **** REMOVED DEBUG LOG ****
   function renderStyledObjectToOffscreen(obj, targetCtx, targetCanvasWidth, targetCanvasHeight) {
       console.log('🚀 CACHE TEST: renderStyledObjectToOffscreen function loaded with latest changes!');
       const renderCallId = Math.random().toString(36).substring(2, 8);
       console.log(`🔍 RENDER CALL [${renderCallId}]: Starting renderStyledObjectToOffscreen for text "${obj.text}"`);
       console.log(`🔍 RENDER CALL [${renderCallId}]: obj.decorationMode:`, obj.decorationMode);
       console.log(`🔍 RENDER CALL [${renderCallId}]: obj._decorationApplied:`, obj._decorationApplied);

       // Clear the entire canvas with high-DPI scaling preservation
       targetCtx.save();

       // Get the current scale factor (preserve high-DPI scaling)
       const renderTransform = targetCtx.getTransform();
       const renderScaleFactor = renderTransform.a; // Get the current scale factor

       // Reset transform to clear properly, but maintain the scale
       targetCtx.setTransform(renderScaleFactor, 0, 0, renderScaleFactor, 0, 0);

       // Clear the canvas (targetCanvasWidth/Height are already logical dimensions)
       targetCtx.clearRect(0, 0, targetCanvasWidth, targetCanvasHeight);

       targetCtx.restore();

       // Reset the outline drawn flag at the start of each render cycle
       obj._outlineDrawn = false;

       targetCtx.save();

       // Calculate center position
       const centerX = targetCanvasWidth / 2;
       const centerY = targetCanvasHeight / 2;

       // Set font and measure text
       setTextContextOn(targetCtx, obj);
       const text = (obj.text || '');

       // 📦 MULTI-LINE METRICS: Calculate correct dimensions for wrapped text
       const textBoxWidth = obj.textBoxWidth || 0;
       let textWidth, textHeight, ascent, descent;

       if (textBoxWidth > 0) {
           // 📦 WRAPPED TEXT: Calculate dimensions for multi-line text
           const lines = text.split('\n');
           console.log('📦 RENDER METRICS: Calculating wrapped text dimensions for', lines.length, 'lines');

           // Find the widest line
           let maxLineWidth = 0;
           const letterSpacing = obj._effectiveLetterSpacing || 0;

           lines.forEach((line, index) => {
               let lineWidth;
               if (letterSpacing === 0) {
                   lineWidth = targetCtx.measureText(line).width;
               } else {
                   // Calculate width with letter spacing for this line
                   const letters = line.split('');
                   let totalWidth = 0;
                   letters.forEach(letter => {
                       totalWidth += targetCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }
                   lineWidth = totalWidth;
               }
               maxLineWidth = Math.max(maxLineWidth, lineWidth);
               console.log('📦 RENDER METRICS: Line', index + 1, ':', line, 'width:', lineWidth);
           });

           textWidth = maxLineWidth;

           // Calculate height for multiple lines
           const fontSize = obj.fontSize || 20;
           const lineHeight = fontSize * 1.2; // Standard line height
           textHeight = lines.length * lineHeight;

           // Calculate ascent/descent for multi-line text
           const singleLineMetrics = targetCtx.measureText('M');
           ascent = singleLineMetrics.actualBoundingBoxAscent || obj.fontSize * 1.0;
           descent = singleLineMetrics.actualBoundingBoxDescent || obj.fontSize * 0.4;

           console.log('📦 RENDER METRICS: Wrapped text final dimensions - width:', textWidth, 'height:', textHeight, 'lines:', lines.length);
       } else {
           // 📦 SINGLE LINE: Use existing single-line calculation
           const metrics = targetCtx.measureText(text);
           textWidth = metrics.width;

           // Calculate text dimensions with extra padding for effects
           // Use more generous estimates for ascent/descent to prevent clipping
           ascent = metrics.actualBoundingBoxAscent || obj.fontSize * 1.0;
           descent = metrics.actualBoundingBoxDescent || obj.fontSize * 0.4;
           textHeight = ascent + descent;

           console.log('📦 RENDER METRICS: Single line text dimensions - width:', textWidth, 'height:', textHeight);
       }

       // Calculate top edge with extra padding
       const topEdgeY = centerY - textHeight / 2;

       // Apply opacity if specified (default is 100%)
       const opacity = (obj.opacity !== undefined) ? obj.opacity / 100 : 1;

       // Get the current fill style (which may be a gradient set by setTextContextOn)
       let mainFillStyle = targetCtx.fillStyle;

       // If opacity is less than 100%, apply it via globalAlpha instead of converting gradients to colors
       if (opacity < 1) {
           // Check if fillStyle is a gradient object (CanvasGradient)
           if (mainFillStyle && typeof mainFillStyle === 'object' && mainFillStyle.constructor.name === 'CanvasGradient') {
               // For gradients, use globalAlpha to preserve the gradient
               console.log('🎨 Preserving gradient with opacity:', opacity);
               // Don't modify mainFillStyle, just apply opacity via globalAlpha later
           } else {
               // For solid colors, convert to rgba
               if (mainFillStyle.startsWith('#')) {
                   mainFillStyle = hexToRgba(mainFillStyle, opacity);
               }
               // If it's already rgba, modify the alpha
               else if (mainFillStyle.startsWith('rgba')) {
                   const rgbaMatch = mainFillStyle.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([.\d]+)\)/);
                   if (rgbaMatch) {
                       const [_, r, g, b] = rgbaMatch;
                       mainFillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                   }
               }
               // If it's rgb, convert to rgba
               else if (mainFillStyle.startsWith('rgb')) {
                   const rgbMatch = mainFillStyle.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                   if (rgbMatch) {
                       const [_, r, g, b] = rgbMatch;
                       mainFillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                   }
               }
           }
       }
        if (obj.decorationMode === "fadingLinesCut") {
            console.log('🎨 FADING LINES: Creating fading lines pattern');
            const distancePercent = obj.flcDist / 100; // Use flcDist to match UI controls
            const direction = obj.flcDir || 'top';
            const baseLineColor = obj.flcColor || '#0000FF';
            const lineOpacity = (obj.flcOpacity || 100) / 100; // Convert percentage to decimal
            const maxWeight = obj.flcWeight || 3; // Maximum line thickness (use flcWeight to match UI)
            const spacing = obj.flcSpacing || 10; // Spacing between lines

            // Convert hex color to rgba with opacity
            let lineColor;
            if (baseLineColor.startsWith('#')) {
                const hex = baseLineColor.slice(1);
                const r = parseInt(hex.slice(0, 2), 16);
                const g = parseInt(hex.slice(2, 4), 16);
                const b = parseInt(hex.slice(4, 6), 16);
                lineColor = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`;
            } else {
                lineColor = baseLineColor; // Use as is if not hex
            }

            console.log('🎨 FADING LINES: Direction detected:', direction, 'Distance:', distancePercent, 'MaxWeight:', maxWeight, 'Spacing:', spacing, 'Opacity:', lineOpacity);
            const baseTextColor = obj.color;

            // Create pattern based on Asset 1.svg structure
            const patternCanvas = document.createElement("canvas");
            const patternWidth = 20;
            // Increase pattern height to ensure coverage of very tall fonts like Rammetto One
            const totalPatternHeight = Math.max(150, Math.ceil(textHeight) * 5);
            patternCanvas.width = patternWidth;
            patternCanvas.height = totalPatternHeight;
            const pCtx = patternCanvas.getContext("2d");

            // Fill canvas with base text color first
            pCtx.fillStyle = baseTextColor;
            pCtx.fillRect(0, 0, patternWidth, totalPatternHeight);

            // Calculate the cut line position
            const cutLineY = totalPatternHeight * distancePercent;

            // Define the 5 progressive line thicknesses (based on Asset 1.svg)
            const baseThickness = maxWeight * 0.2; // Thinnest line
            const lineThicknesses = [
                baseThickness,                    // 2.22 equivalent
                baseThickness * 2,               // 4.4 equivalent
                baseThickness * 3,               // 6.38 equivalent
                baseThickness * 4,               // 8.74 equivalent
                baseThickness * 5                // 10.68 equivalent
            ];

            console.log('🎨 FADING LINES: Line thicknesses:', lineThicknesses);
            console.log('🎨 FADING LINES: Direction:', direction, 'Cut at:', cutLineY);

            if (direction === 'top') {
                // SOLID TOP: Solid block at top, then fading lines going down
                pCtx.fillStyle = lineColor;
                pCtx.fillRect(0, 0, patternWidth, cutLineY);

                // The area below cutLineY keeps the base text color (already filled)
                // Draw 5 progressively thinner lines going down from cut line
                let currentY = cutLineY + spacing;
                for (let i = lineThicknesses.length - 1; i >= 0; i--) {
                    const thickness = lineThicknesses[i];
                    pCtx.fillStyle = lineColor;
                    pCtx.fillRect(0, currentY, patternWidth, thickness);
                    currentY += thickness + spacing;
                    if (currentY >= totalPatternHeight) break;
                }
                console.log('🎨 FADING LINES: Applied SOLID TOP direction');
            } else {
                // SOLID BOTTOM: Solid block at bottom, then fading lines going up
                // Solid block from cut line to bottom
                pCtx.fillStyle = lineColor;
                pCtx.fillRect(0, cutLineY, patternWidth, totalPatternHeight - cutLineY);

                // Draw 5 progressively thinner lines going up from cut line
                // Start with thickest (connected to solid block) and get progressively thinner
                let currentY = cutLineY - spacing;
                for (let i = lineThicknesses.length - 1; i >= 0; i--) {
                    const thickness = lineThicknesses[i];
                    if (currentY - thickness >= 0) {
                        pCtx.fillStyle = lineColor;
                        pCtx.fillRect(0, currentY - thickness, patternWidth, thickness);
                        currentY -= thickness + spacing;
                    } else {
                        break;
                    }
                }
                console.log('🎨 FADING LINES: Applied SOLID BOTTOM direction (lines fade UP from solid block)');
            }

            try {
                mainFillStyle = targetCtx.createPattern(patternCanvas, "repeat");
                const patternTransform = new DOMMatrix();
                // Position pattern to start from the very top of the text bounds
                // Use a larger negative offset to ensure coverage of very tall fonts like Rammetto One
                const topOffset = topEdgeY - (textHeight * 0.4); // Start 40% above the calculated top
                patternTransform.translateSelf(0, topOffset);
                mainFillStyle.setTransform(patternTransform);
                console.log('🎨 FADING LINES: Pattern created successfully, topOffset:', topOffset);
            } catch (e) {
                console.error("Error creating FLC pattern:", e);
                mainFillStyle = obj.color;
            }
        }
        else if (obj.decorationMode === "horizontalLines") { const weight = obj.hLineWeight; const distance = obj.hLineDist; const baseLineColor = obj.hLineColor; const lineOpacity = (obj.hLineOpacity || 100) / 100; const baseColor = obj.color; const totalHeight = weight + distance; const patternCanvas = document.createElement("canvas"); patternCanvas.width = 10; patternCanvas.height = totalHeight; const pCtx = patternCanvas.getContext("2d"); pCtx.fillStyle = baseColor; pCtx.fillRect(0, 0, 10, totalHeight); let color; if (baseLineColor.startsWith('#')) { const hex = baseLineColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`; } else { color = baseLineColor; } pCtx.fillStyle = color; pCtx.fillRect(0, 0, 10, weight); try { mainFillStyle = targetCtx.createPattern(patternCanvas, "repeat"); const patternTransform = new DOMMatrix(); patternTransform.translateSelf(0, topEdgeY); mainFillStyle.setTransform(patternTransform); } catch (e) { console.error("Error creating HLines pattern:", e); mainFillStyle = obj.color; } }
        else if (obj.decorationMode === "colorCut") { const distancePercent = obj.ccDist / 100; const baseColor = obj.ccColor; const colorOpacity = (obj.ccOpacity || 100) / 100; const textBaseColor = obj.color; const fillDirection = obj.ccFillDir; const gradStartY = topEdgeY; const gradEndY = topEdgeY + textHeight; let gradient = targetCtx.createLinearGradient(0, gradStartY, 0, gradEndY); let color; if (baseColor.startsWith('#')) { const hex = baseColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${colorOpacity})`; } else { color = baseColor; } if (fillDirection === 'top') { gradient.addColorStop(0, color); gradient.addColorStop(distancePercent, color); gradient.addColorStop(Math.min(1, distancePercent + 0.001), textBaseColor); gradient.addColorStop(1, textBaseColor); } else { gradient.addColorStop(0, textBaseColor); gradient.addColorStop(Math.max(0, 1 - distancePercent - 0.001), textBaseColor); gradient.addColorStop(1 - distancePercent, color); gradient.addColorStop(1, color); } mainFillStyle = gradient; }
        else if (obj.decorationMode === "obliqueLines") { const weight = obj.oLineWeight; const distance = obj.oLineDist; const baseLineColor = obj.oLineColor; const lineOpacity = (obj.oOpacity || 100) / 100; const baseColor = obj.color; const size = weight + distance; const patternCanvas = document.createElement("canvas"); patternCanvas.width = size; patternCanvas.height = size; const pCtx = patternCanvas.getContext("2d"); pCtx.fillStyle = baseColor; pCtx.fillRect(0, 0, size, size); let color; if (baseLineColor.startsWith('#')) { const hex = baseLineColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`; } else { color = baseLineColor; } pCtx.strokeStyle = color; pCtx.lineWidth = weight; pCtx.beginPath(); for (let i = -size; i < size * 2; i += size) { pCtx.moveTo(i - distance, -distance); pCtx.lineTo(i + size + distance, size + distance); } pCtx.stroke(); try { mainFillStyle = targetCtx.createPattern(patternCanvas, "repeat"); const patternTransform = new DOMMatrix(); patternTransform.translateSelf(0, topEdgeY); mainFillStyle.setTransform(patternTransform); } catch (e) { console.error("Error creating OLines pattern:", e); mainFillStyle = obj.color; } }
       // Apply shadows with letter spacing information (letter spacing is set by setTextContextOn)
       console.log('🔍 SHADOW DEBUG: shadowMode=' + obj.shadowMode + ', _effectiveLetterSpacing=' + obj._effectiveLetterSpacing);
       if (obj.shadowMode === "blockShadow") {
           console.log('🔍 SHADOW DEBUG: Calling applyBlockShadow');
           applyBlockShadow(targetCtx, obj, centerX, centerY);
       } else if (obj.shadowMode === "perspectiveShadow") {
           console.log("🔍 SHADOW DEBUG: Applying perspective shadow in renderStyledObjectToOffscreen");
           applyPerspectiveShadow(targetCtx, obj, centerX, centerY);
       } else if (obj.shadowMode === "lineShadow") {
           console.log('🔍 SHADOW DEBUG: Calling applyLineShadow with letterSpacing=' + obj._effectiveLetterSpacing);
           applyLineShadow(targetCtx, obj, centerX, centerY);
       } else if (obj.shadowMode === "detailed3D") {
           console.log('🔍 SHADOW DEBUG: Calling applyDetailed3D_ExtrusionOnly');
           applyDetailed3D_ExtrusionOnly(targetCtx, obj, centerX, centerY);
       }
       targetCtx.save(); if (obj.shadowMode === "shadow") { targetCtx.shadowColor = obj.shadowColor; targetCtx.shadowOffsetX = obj.shadowOffsetX; targetCtx.shadowOffsetY = obj.shadowOffsetY; targetCtx.shadowBlur = obj.shadowBlur; }

       // Apply opacity for gradients via globalAlpha
       if (opacity < 1 && mainFillStyle && typeof mainFillStyle === 'object' && mainFillStyle.constructor.name === 'CanvasGradient') {
           targetCtx.globalAlpha = opacity;
           console.log('🎨 Applied globalAlpha for gradient:', opacity);
       }

       // GRADIENT TEST: Create a simple test gradient to verify coordinates
       if (obj.gradient && obj.gradient.type !== 'solid') {
           console.log('🎨 GRADIENT TEST: Text position and size details');
           console.log('🎨 GRADIENT TEST: centerX:', centerX, 'centerY:', centerY);
           console.log('🎨 GRADIENT TEST: text:', text);
           console.log('🎨 GRADIENT TEST: obj.x:', obj.x, 'obj.y:', obj.y);
           console.log('🎨 GRADIENT TEST: obj.fontSize:', obj.fontSize);

           // Measure text to understand its bounds
           const metrics = targetCtx.measureText(text);
           console.log('🎨 GRADIENT TEST: text metrics:', {
               width: metrics.width,
               actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,
               actualBoundingBoxRight: metrics.actualBoundingBoxRight,
               actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
               actualBoundingBoxDescent: metrics.actualBoundingBoxDescent
           });

           // Calculate text bounds relative to drawing position
           const textLeft = centerX - metrics.width / 2;
           const textRight = centerX + metrics.width / 2;
           const textTop = centerY - obj.fontSize / 2;
           const textBottom = centerY + obj.fontSize / 2;

           console.log('🎨 GRADIENT TEST: calculated text bounds:', {
               left: textLeft,
               right: textRight,
               top: textTop,
               bottom: textBottom,
               width: textRight - textLeft,
               height: textBottom - textTop
           });

           // Create the actual user gradient based on type
           const gradientType = obj.gradient.type;
           console.log('🎨 GRADIENT: Type:', gradientType);

           // Calculate text bounds for gradient positioning
           const textWidth = textRight - textLeft;
           const textHeight = textBottom - textTop;
           const centerTextX = (textLeft + textRight) / 2;
           const centerTextY = (textTop + textBottom) / 2;

           let userGradient;

           if (gradientType === 'radial') {
               console.log('🎨 GRADIENT: Creating radial gradient');

               // For radial gradients, create a circle that covers the text
               const maxDimension = Math.max(textWidth, textHeight);
               const radius = maxDimension * 0.6; // Smaller radius for better effect

               console.log('🎨 GRADIENT: Radial parameters:', {
                   centerX: centerTextX,
                   centerY: centerTextY,
                   radius: radius,
                   textWidth: textWidth,
                   textHeight: textHeight
               });

               // Create radial gradient from center outward
               userGradient = targetCtx.createRadialGradient(
                   centerTextX, centerTextY, 0,        // Inner circle (center, radius 0)
                   centerTextX, centerTextY, radius    // Outer circle (center, calculated radius)
               );

           } else {
               console.log('🎨 GRADIENT: Creating linear gradient');

               // Linear gradient with angle support
               const uiAngle = obj.gradient.gradient.angle || 0;
               console.log('🎨 GRADIENT: UI angle:', uiAngle);

               // Convert UI angle to radians (0° = horizontal left-to-right, 90° = vertical top-to-bottom)
               const angleRad = (uiAngle * Math.PI) / 180;
               const cos = Math.cos(angleRad);
               const sin = Math.sin(angleRad);

               console.log('🎨 GRADIENT: angle calculations:', { angleRad, cos, sin });

               // Calculate gradient line length to ensure it covers the entire text
               const maxDimension = Math.max(textWidth, textHeight);
               const gradientLength = maxDimension * 1.5; // Extra length to ensure full coverage

               // Calculate gradient endpoints
               const x1 = centerTextX - (gradientLength / 2) * cos;
               const y1 = centerTextY - (gradientLength / 2) * sin;
               const x2 = centerTextX + (gradientLength / 2) * cos;
               const y2 = centerTextY + (gradientLength / 2) * sin;

               console.log('🎨 GRADIENT: final coordinates:', { x1, y1, x2, y2 });

               userGradient = targetCtx.createLinearGradient(x1, y1, x2, y2);
           }

           // Add user color stops
           if (obj.gradient.gradient.colors) {
               obj.gradient.gradient.colors.forEach(colorStop => {
                   userGradient.addColorStop(colorStop.position / 100, colorStop.color);
                   console.log('🎨 GRADIENT: Added user color stop:', colorStop);
               });
           }

           targetCtx.fillStyle = userGradient;
           console.log('🎨 GRADIENT: Applied', gradientType, 'gradient');
       } else {
           targetCtx.fillStyle = mainFillStyle; // Set the determined fill style
       }

       // DEBUG: Log what we're actually drawing with
       // Draw stroke first if enabled (before text fill) - outward only
       if (obj.strokeMode === 'stroke' && obj.strokeWidth > 0) {
           // Apply stroke with independent opacity - outward only like shapes
           const strokeOpacity = (obj.strokeOpacity !== undefined) ? obj.strokeOpacity / 100 : 1;
           const strokeColor = hexToRgba(obj.strokeColor, strokeOpacity);

           // Create a temporary canvas for outward-only stroke
           const strokeCanvas = document.createElement('canvas');
           strokeCanvas.width = targetCtx.canvas.width;
           strokeCanvas.height = targetCtx.canvas.height;
           const strokeCtx = strokeCanvas.getContext('2d');

           // Disable image smoothing for sharp strokes
           strokeCtx.imageSmoothingEnabled = false;

           // Set up stroke context to match the main text exactly
           strokeCtx.font = targetCtx.font; // Use the exact same font as the main text
           strokeCtx.textAlign = targetCtx.textAlign;
           strokeCtx.textBaseline = targetCtx.textBaseline;
           strokeCtx.globalAlpha = 1;
           strokeCtx.strokeStyle = strokeColor;
           // Use a much thicker stroke that will be partially cut out
           const effectiveStrokeWidth = Math.max(obj.strokeWidth * 8, 20); // 8x multiplier with 20px minimum
           console.log('🎨 STROKE DEBUG - Original width:', obj.strokeWidth, 'Effective width:', effectiveStrokeWidth);
           console.log('🎨 STROKE DEBUG - Font used:', strokeCtx.font);
           strokeCtx.lineWidth = effectiveStrokeWidth;
           strokeCtx.lineJoin = 'round';
           strokeCtx.lineCap = 'round';

           // Draw the thick stroke
           strokeCtx.strokeText(text, centerX, centerY);

           // Use destination-out to cut out a much smaller interior area
           strokeCtx.globalCompositeOperation = 'destination-out';
           strokeCtx.fillStyle = 'black'; // Color doesn't matter for destination-out

           // Use the same font size for the cutout to create proper outline
           strokeCtx.fillText(text, centerX, centerY);

           // Draw the outward-only stroke to the target canvas with independent opacity
           targetCtx.save();
           // Save current globalAlpha and reset it for stroke rendering
           const currentGlobalAlpha = targetCtx.globalAlpha;
           targetCtx.globalAlpha = 1; // Use full opacity for stroke (stroke already has its own opacity applied)
           targetCtx.drawImage(strokeCanvas, 0, 0);
           // Restore the original globalAlpha for text rendering
           targetCtx.globalAlpha = currentGlobalAlpha;
           targetCtx.restore();
       }

       console.log('🎨 About to draw text with fillStyle:', typeof targetCtx.fillStyle, targetCtx.fillStyle);

       // Handle letter spacing properly for effects and shadows
       const letterSpacing = obj._effectiveLetterSpacing || 0;
       if (letterSpacing !== 0) {
           // Draw each character manually with letter spacing
           const letters = text.split('');
           let totalWidth = 0;

           // Calculate total width with letter spacing
           letters.forEach(letter => {
               totalWidth += targetCtx.measureText(letter).width;
           });
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           // Draw each letter with proper spacing
           // Calculate starting X position based on text alignment and text box width
           let startX = centerX - totalWidth / 2; // Default: center the text

           if (textBoxWidth > 0) {
               // textBoxWidth is a character limit, not pixel width
               // For letter spacing, use the total width of the text as the actual width
               const actualTextBoxPixelWidth = totalWidth;
               const textAlign = obj.textAlign || 'left';
               const textBoxLeft = centerX - actualTextBoxPixelWidth / 2;
               const textBoxRight = centerX + actualTextBoxPixelWidth / 2;

               if (textAlign === 'left') {
                   startX = textBoxLeft;
               } else if (textAlign === 'right') {
                   startX = textBoxRight - totalWidth;
               } else if (textAlign === 'center') {
                   startX = centerX - totalWidth / 2; // Already correct for center
               } else if (textAlign === 'justify') {
                   startX = textBoxLeft; // Start from left for justify
               }

               console.log('📦 LETTER SPACING X-POSITION: textAlign:', textAlign, 'character limit:', textBoxWidth, 'pixel width:', actualTextBoxPixelWidth, 'startX:', startX, 'totalWidth:', totalWidth);
           }

           let currentX = startX;
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = targetCtx.measureText(letter).width;
               fillMultiLineText(targetCtx, letter, currentX + letterWidth / 2, centerY, obj);
               currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
           }
       } else {
           // No letter spacing, use multi-line text rendering
           // Calculate correct X position based on text alignment and text box width
           let renderX = centerX;

           console.log('📦 ===== RENDER STYLED OBJECT FLOW START =====');
           console.log('📦 MULTI-LINE X-POSITION DEBUG: textBoxWidth:', textBoxWidth, 'centerX:', centerX, 'textAlign:', obj.textAlign);
           console.log('📦 RENDER OBJECT: Object details:', {
               id: obj.id,
               text: obj.text,
               textAlign: obj.textAlign,
               textBoxWidth: obj.textBoxWidth,
               x: obj.x,
               y: obj.y
           });

           if (textBoxWidth > 0) {
               // textBoxWidth is a character limit, not pixel width
               // Calculate the pixel width based on the character limit, not the actual text
               // Use dynamic padding that prevents source rectangle from going out of bounds
               // Canvas width is typically 8192, so we need to ensure text box doesn't exceed ~7000 pixels
               const maxSafePadding = Math.max(1, Math.min(10, Math.floor((7000 - textBoxWidth * 135) / 135)));
               const safePadding = Math.max(1, maxSafePadding);
               const sampleText = 'A'.repeat(textBoxWidth + safePadding);
               const actualTextBoxPixelWidth = targetCtx.measureText(sampleText).width;

               console.log('📦 MULTI-LINE X-POSITION DEBUG: textBoxWidth:', textBoxWidth, 'centerX:', centerX, 'textAlign:', obj.textAlign || 'left');
               console.log('📦 MULTI-LINE X-POSITION: Character limit:', textBoxWidth, 'Safe padding:', safePadding, 'Text box pixel width:', actualTextBoxPixelWidth);

               const textAlign = obj.textAlign || 'left';
               const textBoxLeft = centerX - actualTextBoxPixelWidth / 2;
               const textBoxRight = centerX + actualTextBoxPixelWidth / 2;

               console.log('📦 RENDER CALCULATION: textBoxLeft:', textBoxLeft, 'textBoxRight:', textBoxRight, 'centerX:', centerX);

               if (textAlign === 'left') {
                   renderX = textBoxLeft;
                   console.log('📦 RENDER LEFT: Setting renderX to textBoxLeft:', renderX);
               } else if (textAlign === 'right') {
                   renderX = textBoxRight;
                   console.log('📦 RENDER RIGHT: Setting renderX to textBoxRight:', renderX);
               } else if (textAlign === 'center') {
                   renderX = centerX; // Already correct for center
                   console.log('📦 RENDER CENTER: Setting renderX to centerX:', renderX);
               } else if (textAlign === 'justify') {
                   renderX = textBoxLeft; // Start from left for justify
                   console.log('📦 RENDER JUSTIFY: Setting renderX to textBoxLeft:', renderX);
               }

               console.log('📦 MULTI-LINE X-POSITION: textAlign:', textAlign, 'character limit:', textBoxWidth, 'text box pixel width:', actualTextBoxPixelWidth, 'renderX:', renderX, 'centerX:', centerX);
           } else {
               console.log('📦 MULTI-LINE X-POSITION: No textBoxWidth, using centerX:', centerX);
           }

           console.log('📦 RENDER: About to call fillMultiLineText with renderX:', renderX, 'centerY:', centerY);
           fillMultiLineText(targetCtx, text, renderX, centerY, obj);
           console.log('📦 ===== RENDER STYLED OBJECT FLOW END =====');
       }
       targetCtx.restore();

       // REMOVED: All old front outline logic from renderStyledObjectToOffscreen
       // Front outlines are now ONLY handled by the gradient masking system for ALL effects
       console.log('🔍 OLD FRONT OUTLINE: All old front outline systems removed - handled by gradient masking only');
       targetCtx.restore();

       // 📦 CRITICAL FIX: Return the text box width instead of actual text width for clipping calculations
       let returnWidth = textWidth;
       let actualTextBoxPixelWidth = 0; // Store the calculated text box width for reuse

       if (textBoxWidth > 0) {
           // IMPORTANT: Use the SAME calculation that was done during rendering
           // This ensures consistency between rendering and clipping calculations
           // Reduced padding from +20 to +10 to prevent source rectangle going out of bounds
           const sampleText = 'A'.repeat(textBoxWidth + 10);

           // Make sure we have the correct font context set
           setTextContextOn(targetCtx, obj);
           actualTextBoxPixelWidth = targetCtx.measureText(sampleText).width;
           returnWidth = actualTextBoxPixelWidth;

           console.log('📦 RETURN METRICS: Using text box width:', returnWidth, 'instead of actual text width:', textWidth);
           console.log('📦 RETURN METRICS: Character limit:', textBoxWidth, 'Sample text length:', sampleText.length);
       } else {
           console.log('📦 RETURN METRICS: Using actual text width:', returnWidth);
       }

       // Return calculated metrics (using text box dimensions when available)
       return {
           width: returnWidth,   // Text box width (when available) or actual text width
           height: textHeight,   // Multi-line height (all lines)
           ascent: ascent,
           descent: descent,
           centerX: centerX,     // Center X on the offscreen canvas
           centerY: centerY      // Center Y on the offscreen canvas
       };
   }
   function renderSingleStyledLetter(obj, letter, targetCtx, targetCanvasWidth, targetCanvasHeight, letterIndex = null, totalLetters = null) {
       // Clear the entire canvas with high-DPI scaling preservation
       targetCtx.save();

       // Get the current scale factor (preserve high-DPI scaling)
       const letterTransform = targetCtx.getTransform();
       const letterScaleFactor = letterTransform.a; // Get the current scale factor

       // Reset transform to clear properly, but maintain the scale
       targetCtx.setTransform(letterScaleFactor, 0, 0, letterScaleFactor, 0, 0);

       // Clear the canvas (targetCanvasWidth/Height are already logical dimensions)
       targetCtx.clearRect(0, 0, targetCanvasWidth, targetCanvasHeight);

       targetCtx.restore();

       // Reset the outline drawn flag at the start of each render cycle
       obj._outlineDrawn = false;

       targetCtx.save();

       // Calculate center position
       const centerX = targetCanvasWidth / 2;
       const centerY = targetCanvasHeight / 2;

       // Set font and measure text, passing letter index for gradient calculation
       setTextContextOn(targetCtx, obj, letterIndex, totalLetters);
       const metrics = targetCtx.measureText(letter);

       // Use more generous estimates for ascent/descent to prevent clipping
       const ascent = metrics.actualBoundingBoxAscent || obj.fontSize * 1.0;
       const descent = metrics.actualBoundingBoxDescent || obj.fontSize * 0.4;
       const textHeight = ascent + descent;

       // Calculate top edge with extra padding
       const topEdgeY = centerY - textHeight / 2;

       // Apply opacity if specified (default is 100%)
       const opacity = (obj.opacity !== undefined) ? obj.opacity / 100 : 1;

       // Get the current fill style (which may be a gradient set by setTextContextOn)
       let letterFillStyle = targetCtx.fillStyle;

       // If opacity is less than 100%, apply it via globalAlpha instead of converting gradients to colors
       if (opacity < 1) {
           // Check if fillStyle is a gradient object (CanvasGradient)
           if (letterFillStyle && typeof letterFillStyle === 'object' && letterFillStyle.constructor.name === 'CanvasGradient') {
               // For gradients, use globalAlpha to preserve the gradient
               console.log('🎨 Preserving letter gradient with opacity:', opacity);
               // Don't modify letterFillStyle, just apply opacity via globalAlpha later
           } else {
               // For solid colors, convert to rgba
               if (letterFillStyle.startsWith('#')) {
                   letterFillStyle = hexToRgba(letterFillStyle, opacity);
               }
               // If it's already rgba, modify the alpha
               else if (letterFillStyle.startsWith('rgba')) {
                   const rgbaMatch = letterFillStyle.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([.\d]+)\)/);
                   if (rgbaMatch) {
                       const [_, r, g, b] = rgbaMatch;
                       letterFillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                   }
               }
               // If it's rgb, convert to rgba
               else if (letterFillStyle.startsWith('rgb')) {
                   const rgbMatch = letterFillStyle.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                   if (rgbMatch) {
                       const [_, r, g, b] = rgbMatch;
                       letterFillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                   }
               }
           }
       } if (obj.decorationMode === "fadingLinesCut") {
            const distancePercent = obj.flcDist / 100; // Use flcDist to match UI controls
            const direction = obj.flcDir || 'top';
            const baseLineColor = obj.flcColor || '#0000FF';
            const lineOpacity = (obj.flcOpacity || 100) / 100; // Convert percentage to decimal
            const maxWeight = obj.flcWeight || 3; // Use flcWeight to match UI
            const spacing = obj.flcSpacing || 10;
            const coverage = (obj.flcCoverage || 100) / 100;
            const baseTextColor = obj.color;

            // Convert hex color to rgba with opacity
            let lineColor;
            if (baseLineColor.startsWith('#')) {
                const hex = baseLineColor.slice(1);
                const r = parseInt(hex.slice(0, 2), 16);
                const g = parseInt(hex.slice(2, 4), 16);
                const b = parseInt(hex.slice(4, 6), 16);
                lineColor = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`;
            } else {
                lineColor = baseLineColor; // Use as is if not hex
            }

            // Create pattern based on Asset 1.svg structure for letter rendering
            const patternCanvas = document.createElement("canvas");
            const patternWidth = 20;
            // Increase pattern height to ensure coverage of very tall fonts like Rammetto One
            const totalPatternHeight = Math.max(150, Math.ceil(textHeight * coverage) * 5);
            patternCanvas.width = patternWidth;
            patternCanvas.height = totalPatternHeight;
            const pCtx = patternCanvas.getContext("2d");

            // Fill canvas with base text color first
            pCtx.fillStyle = baseTextColor;
            pCtx.fillRect(0, 0, patternWidth, totalPatternHeight);

            // Calculate the cut line position
            const cutLineY = totalPatternHeight * distancePercent;

            // Define the 5 progressive line thicknesses (based on Asset 1.svg)
            const baseThickness = maxWeight * 0.2;
            const lineThicknesses = [
                baseThickness,
                baseThickness * 2,
                baseThickness * 3,
                baseThickness * 4,
                baseThickness * 5
            ];

            if (direction === 'top') {
                // SOLID TOP: Solid block at top, then fading lines going down
                pCtx.fillStyle = lineColor;
                pCtx.fillRect(0, 0, patternWidth, cutLineY);

                // The area below cutLineY keeps the base text color (already filled)
                // Draw 5 progressively thinner lines going down from cut line
                let currentY = cutLineY + spacing;
                for (let i = lineThicknesses.length - 1; i >= 0; i--) {
                    const thickness = lineThicknesses[i];
                    pCtx.fillStyle = lineColor;
                    pCtx.fillRect(0, currentY, patternWidth, thickness);
                    currentY += thickness + spacing;
                    if (currentY >= totalPatternHeight) break;
                }
            } else {
                // SOLID BOTTOM: Solid block at bottom, then fading lines going up
                // Solid block from cut line to bottom
                pCtx.fillStyle = lineColor;
                pCtx.fillRect(0, cutLineY, patternWidth, totalPatternHeight - cutLineY);

                // Draw 5 progressively thinner lines going up from cut line
                // Start with thickest (connected to solid block) and get progressively thinner
                let currentY = cutLineY - spacing;
                for (let i = lineThicknesses.length - 1; i >= 0; i--) {
                    const thickness = lineThicknesses[i];
                    if (currentY - thickness >= 0) {
                        pCtx.fillStyle = lineColor;
                        pCtx.fillRect(0, currentY - thickness, patternWidth, thickness);
                        currentY -= thickness + spacing;
                    } else {
                        break;
                    }
                }
            }

            try {
                letterFillStyle = targetCtx.createPattern(patternCanvas, "repeat");
                const patternTransform = new DOMMatrix();
                // Position pattern to start from the very top of the text bounds for letters
                // Use a larger negative offset to ensure coverage of very tall fonts like Rammetto One
                const letterTopOffset = topEdgeY - (textHeight * coverage - textHeight) / 2 - (textHeight * 0.4);
                patternTransform.translateSelf(0, letterTopOffset);
                letterFillStyle.setTransform(patternTransform);
            } catch (e) {
                console.error("Error creating FLC pattern for letter:", e);
                letterFillStyle = obj.color;
            }
        } else if (obj.decorationMode === "horizontalLines") { const weight = obj.hLineWeight; const distance = obj.hLineDist; const baseLineColor = obj.hLineColor; const lineOpacity = (obj.hLineOpacity || 100) / 100; const coverage = (obj.hLineCoverage || 100) / 100; const baseColor = obj.color; const totalHeight = weight + distance; const patternCanvas = document.createElement("canvas"); patternCanvas.width = 10; patternCanvas.height = totalHeight; const pCtx = patternCanvas.getContext("2d"); pCtx.fillStyle = baseColor; pCtx.fillRect(0, 0, 10, totalHeight); let color; if (baseLineColor.startsWith('#')) { const hex = baseLineColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`; } else { color = baseLineColor; } pCtx.fillStyle = color; pCtx.fillRect(0, 0, 10, weight); try { letterFillStyle = targetCtx.createPattern(patternCanvas, "repeat"); const patternTransform = new DOMMatrix(); patternTransform.translateSelf(0, topEdgeY - (textHeight * coverage - textHeight) / 2); letterFillStyle.setTransform(patternTransform); } catch (e) { letterFillStyle = obj.color; } } else if (obj.decorationMode === "colorCut") { const distancePercent = obj.ccDist / 100; const baseColor = obj.ccColor; const colorOpacity = (obj.ccOpacity || 100) / 100; const coverage = (obj.ccCoverage || 100) / 100; const textBaseColor = obj.color; const fillDirection = obj.ccFillDir; const expandedHeight = textHeight * coverage; const gradStartY = topEdgeY - (expandedHeight - textHeight) / 2; const gradEndY = gradStartY + expandedHeight; let gradient = targetCtx.createLinearGradient(0, gradStartY, 0, gradEndY); let color; if (baseColor.startsWith('#')) { const hex = baseColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${colorOpacity})`; } else { color = baseColor; } if (fillDirection === 'top') { gradient.addColorStop(0, color); gradient.addColorStop(distancePercent, color); gradient.addColorStop(Math.min(1, distancePercent + 0.001), textBaseColor); gradient.addColorStop(1, textBaseColor); } else { gradient.addColorStop(0, textBaseColor); gradient.addColorStop(Math.max(0, 1 - distancePercent - 0.001), textBaseColor); gradient.addColorStop(1 - distancePercent, color); gradient.addColorStop(1, color); } letterFillStyle = gradient; } else if (obj.decorationMode === "obliqueLines") { const weight = obj.oLineWeight; const distance = obj.oLineDist; const baseLineColor = obj.oLineColor; const lineOpacity = (obj.oOpacity || 100) / 100; const coverage = (obj.oCoverage || 100) / 100; const baseColor = obj.color; const size = weight + distance; const patternCanvas = document.createElement("canvas"); patternCanvas.width = size; patternCanvas.height = size; const pCtx = patternCanvas.getContext("2d"); pCtx.fillStyle = baseColor; pCtx.fillRect(0, 0, size, size); let color; if (baseLineColor.startsWith('#')) { const hex = baseLineColor.slice(1); const r = parseInt(hex.slice(0, 2), 16); const g = parseInt(hex.slice(2, 4), 16); const b = parseInt(hex.slice(4, 6), 16); color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`; } else { color = baseLineColor; } pCtx.strokeStyle = color; pCtx.lineWidth = weight; pCtx.beginPath(); for (let i = -size; i < size * 2; i += size) { pCtx.moveTo(i - distance, -distance); pCtx.lineTo(i + size + distance, size + distance); } pCtx.stroke(); try { letterFillStyle = targetCtx.createPattern(patternCanvas, "repeat"); const patternTransform = new DOMMatrix(); patternTransform.translateSelf(0, topEdgeY - (textHeight * coverage - textHeight) / 2); letterFillStyle.setTransform(patternTransform); } catch (e) { letterFillStyle = obj.color; } } const letterObj = { ...obj, text: letter };
       if (obj.shadowMode === "blockShadow") applyBlockShadow(targetCtx, letterObj, centerX, centerY);
       if (obj.shadowMode === "perspectiveShadow") applyPerspectiveShadow(targetCtx, letterObj, centerX, centerY);
       if (obj.shadowMode === "lineShadow") applyLineShadow(targetCtx, letterObj, centerX, centerY);
       if (obj.shadowMode === "detailed3D") applyDetailed3D_ExtrusionOnly(targetCtx, letterObj, centerX, centerY);

       targetCtx.save();
       if (obj.shadowMode === "shadow") {
           targetCtx.shadowColor = obj.shadowColor;
           targetCtx.shadowOffsetX = obj.shadowOffsetX;
           targetCtx.shadowOffsetY = obj.shadowOffsetY;
           targetCtx.shadowBlur = obj.shadowBlur;
       }

       // Apply opacity for gradients via globalAlpha
       if (opacity < 1 && letterFillStyle && typeof letterFillStyle === 'object' && letterFillStyle.constructor.name === 'CanvasGradient') {
           targetCtx.globalAlpha = opacity;
           console.log('🎨 Applied globalAlpha for letter gradient:', opacity);
       }

       // Draw stroke first if enabled (before letter fill) - outward only
       if (obj.strokeMode === 'stroke' && obj.strokeWidth > 0) {
           // Apply stroke with independent opacity - outward only like shapes
           const strokeOpacity = (obj.strokeOpacity !== undefined) ? obj.strokeOpacity / 100 : 1;
           const strokeColor = hexToRgba(obj.strokeColor, strokeOpacity);

           // Create a temporary canvas for outward-only stroke
           const strokeCanvas = document.createElement('canvas');
           strokeCanvas.width = targetCtx.canvas.width;
           strokeCanvas.height = targetCtx.canvas.height;
           const strokeCtx = strokeCanvas.getContext('2d');

           // Disable image smoothing for sharp strokes
           strokeCtx.imageSmoothingEnabled = false;

           // Set up stroke context to match the main text exactly
           strokeCtx.font = targetCtx.font; // Use the exact same font as the main text
           strokeCtx.textAlign = targetCtx.textAlign;
           strokeCtx.textBaseline = targetCtx.textBaseline;
           strokeCtx.globalAlpha = 1;
           strokeCtx.strokeStyle = strokeColor;
           // Use a much thicker stroke that will be partially cut out
           const effectiveStrokeWidth = Math.max(obj.strokeWidth * 8, 20); // 8x multiplier with 20px minimum
           strokeCtx.lineWidth = effectiveStrokeWidth;
           strokeCtx.lineJoin = 'round';
           strokeCtx.lineCap = 'round';

           // Draw the thick stroke
           strokeCtx.strokeText(letter, centerX, centerY);

           // Use destination-out to cut out a much smaller interior area
           strokeCtx.globalCompositeOperation = 'destination-out';
           strokeCtx.fillStyle = 'black'; // Color doesn't matter for destination-out

           // Use the same font size for the cutout to create proper outline
           strokeCtx.fillText(letter, centerX, centerY);

           // Draw the outward-only stroke to the target canvas with independent opacity
           targetCtx.save();
           // Save current globalAlpha and reset it for stroke rendering
           const currentGlobalAlpha = targetCtx.globalAlpha;
           targetCtx.globalAlpha = 1; // Use full opacity for stroke (stroke already has its own opacity applied)
           targetCtx.drawImage(strokeCanvas, 0, 0);
           // Restore the original globalAlpha for text rendering
           targetCtx.globalAlpha = currentGlobalAlpha;
           targetCtx.restore();
       }

       targetCtx.fillStyle = letterFillStyle;
       targetCtx.fillText(letter, centerX, centerY);
       targetCtx.restore();

       // Apply front outlines for different shadow modes
       // Skip front outlines for effects with gradients that use gradient masking
       const isCircularWithGradient = (obj.distortType === 'circular' || obj.effectMode === 'circle') && obj.gradient && obj.gradient.type !== 'solid';
       const isGridDistortWithGradient = (obj.effectMode === 'gridDistort') && obj.gradient && obj.gradient.type !== 'solid';
       const isCurvedWithGradient = (obj.effectMode === 'curve') && obj.gradient && obj.gradient.type !== 'solid';
       const isMeshWarpWithGradient = (obj.effectMode === 'meshWarp') && obj.gradient && obj.gradient.type !== 'solid';

       // REMOVED: All front outline logic from renderSingleStyledLetter
       // Front outlines are now ONLY handled by the gradient masking system
       console.log('🔍 OLD FRONT OUTLINE: All front outline systems removed from letter rendering - handled by gradient masking only');

       targetCtx.restore();
       return {
           width: metrics.width,
           height: textHeight,
           ascent: ascent,
           descent: descent,
           centerX: centerX,
           centerY: centerY
       }; }

   // --- Text Effect Rendering Logic ---
   // Draw text with normal or skew effect - NEW APPROACH: ALWAYS USE CANVAS-TEST METHOD
   function drawNormalOrSkewObject(obj, targetCtx) {
       const drawCallId = Math.random().toString(36).substring(2, 8);
       console.log(`🔍 DRAW CALL [${drawCallId}]: drawNormalOrSkewObject called for text "${obj.text}"`);
       console.log(`🔍 DRAW CALL [${drawCallId}]: obj.letterSpacing: ${obj.letterSpacing}, obj._effectiveLetterSpacing: ${obj._effectiveLetterSpacing}`);

       // CRITICAL FIX: Synchronize letter spacing values BEFORE any rendering
       if (obj.letterSpacing !== obj._effectiveLetterSpacing) {
           console.log(`🔍 LETTER SPACING SYNC [${drawCallId}]: Synchronizing _effectiveLetterSpacing from ${obj._effectiveLetterSpacing} to ${obj.letterSpacing}`);
           obj._effectiveLetterSpacing = obj.letterSpacing;
       }

       // 🎯 DISABLED: Pixel-perfect clipping mode (breaks text effects)
       // Now using normal text scaling to preserve shadows, decorations, gradients, etc.
       if (obj.usePixelPerfectFitting && obj.pixelPerfectBounds) {
           console.log('🎯 DISABLED: Pixel-perfect clipping mode disabled - using normal rendering to preserve text effects');
           console.log('🎯 DISABLED: Text will render with normal scaling instead of custom clipping');
           // Continue with normal rendering instead of returning early
       }

       // PNG EXPORT DETAILED LOGGING
       console.log(`[PNG Export] drawNormalOrSkewObject ENTRY - Object position:`, {
           x: obj.x, y: obj.y, text: obj.text, fontSize: obj.fontSize
       });
       console.log(`[PNG Export] drawNormalOrSkewObject - Target context transform:`, targetCtx.getTransform());

       console.log(`🔍 DRAW CALL [${drawCallId}]: obj._decorationApplied: ${obj._decorationApplied}`);
       console.log(`🔍 NEW GRADIENT SYSTEM: Bypassing old gradient check - using canvas-test.html approach`);
       console.log(`🔍 NEW GRADIENT SYSTEM: obj.gradient:`, obj.gradient);
       console.log(`🔍 NEW GRADIENT SYSTEM: Will render using new high-resolution method regardless of gradient state`);

       // Check if we should use gradient rendering
       const shouldUseGradient = obj.gradient && obj.gradient.type !== 'solid';
       console.log(`🔍 NEW GRADIENT SYSTEM: Should use gradient:`, shouldUseGradient);
       console.log(`🔍 NEW GRADIENT SYSTEM: obj.gradient:`, obj.gradient);

       // CRITICAL FIX: If text has gradient, use gradient masking system instead of normal rendering
       // This prevents double decoration application
       if (shouldUseGradient) {
           console.log('🔍 NEW GRADIENT SYSTEM: Using gradient masking system for gradient text');
           drawNormalObjectWithGradientMask(obj, targetCtx);
           return;
       }

       // REMOVED OLD GRADIENT CHECK - Always use the new approach for non-gradient text
       // This ensures we get the same high-quality rendering as canvas-test.html

       // CRITICAL FIX: Set up text context first to ensure _effectiveLetterSpacing is available
       // Create a temporary context to set up the text properties
       const tempCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(tempCtx, obj);  // This sets obj._effectiveLetterSpacing

       // Get the letter spacing value for use in outline rendering
       const letterSpacing = obj._effectiveLetterSpacing || 0;
       console.log('🔍 LETTER SPACING DEBUG: letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + obj._effectiveLetterSpacing);

       // Use standard rendering approach for all cases (including letter spacing)
       // Letter spacing is handled by the shadow/effect functions, not by letter-by-letter rendering
       console.log('🔍 LETTER SPACING DEBUG: Using standard rendering for all cases (letter spacing handled by effects)');
       // Render the text to the offscreen canvas
       console.log(`🔍 CALLING renderStyledObjectToOffscreen from NORMAL RENDERING PATH for text "${obj.text}"`);
           const metrics = renderStyledObjectToOffscreen(obj, octx, os.width / offscreenScaleFactor, os.height / offscreenScaleFactor);

           try {
               // Calculate source and destination rectangles based on metrics
               // Use much larger padding to accommodate shadows, strokes, and italic text
               // that might extend beyond the measured text bounds
               const effectsPadding = Math.max(
                   letterSourcePadding * 4,                // Base padding
                   obj.fontSize * 0.5,                     // Scale with font size
                   obj.shadowOffsetX + obj.shadowBlur * 2, // Account for shadow
                   obj.d3dOffset + obj.d3dBlur * 2,        // Account for 3D effects
                   obj.blockShadowOffset * 1.5,            // Account for block shadow
                   obj.strokeWidth * 3                     // Account for stroke
               );

               // Calculate source rectangle with generous padding
               const sw = metrics.width + effectsPadding * 2;
               const sh = metrics.height + effectsPadding * 2;
               const sx = metrics.centerX - sw / 2;
               const sy = metrics.centerY - sh / 2;

               // Destination rectangle matches source size
               const dw = sw;
               const dh = sh;
               const dx = -dw / 2; // Draw centered in the target context
               const dy = -dh / 2;

               // Ensure source rect is within bounds of the offscreen canvas (accounting for scaling)
               const osLogicalWidth = os.width / offscreenScaleFactor;
               const osLogicalHeight = os.height / offscreenScaleFactor;
               if (sx >= 0 && sy >= 0 && sx + sw <= osLogicalWidth && sy + sh <= osLogicalHeight && sw > 0 && sh > 0) {
                   // PNG EXPORT CRITICAL LOGGING - EXPANDED DETAILS
                   console.log(`[PNG Export] FINAL DRAW - About to call targetCtx.drawImage():`);
                   console.log(`[PNG Export] Source rect: sx=${sx * offscreenScaleFactor}, sy=${sy * offscreenScaleFactor}, sw=${sw * offscreenScaleFactor}, sh=${sh * offscreenScaleFactor}`);
                   console.log(`[PNG Export] Dest rect: dx=${dx}, dy=${dy}, dw=${dw}, dh=${dh}`);
                   console.log(`[PNG Export] Target transform:`, targetCtx.getTransform());
                   console.log(`[PNG Export] CRITICAL: Final absolute position = translate(${targetCtx.getTransform().e}, ${targetCtx.getTransform().f}) + relative(${dx}, ${dy})`);
                   console.log(`[PNG Export] CRITICAL: Calculated final position = (${targetCtx.getTransform().e + dx}, ${targetCtx.getTransform().f + dy})`);

                   // Draw the text from offscreen canvas to the target canvas (scale coordinates for high-DPI)
                   targetCtx.drawImage(os, sx * offscreenScaleFactor, sy * offscreenScaleFactor, sw * offscreenScaleFactor, sh * offscreenScaleFactor, dx, dy, dw, dh);

                   console.log(`[PNG Export] FINAL DRAW - drawImage completed successfully`);
               } else {
                   console.warn("Source rectangle out of bounds, using fallback drawing method.",
                       {sx, sy, sw, sh, osWidth: osLogicalWidth, osHeight: osLogicalHeight});

                   // Fallback: Use a centered portion of the offscreen canvas
                   // This ensures we at least get the center of the text
                   const safeWidth = Math.min(osLogicalWidth * 0.8, sw);
                   const safeHeight = Math.min(osLogicalHeight * 0.8, sh);
                   const safeSx = (osLogicalWidth - safeWidth) / 2;
                   const safeSy = (osLogicalHeight - safeHeight) / 2;

                   targetCtx.drawImage(os, safeSx * offscreenScaleFactor, safeSy * offscreenScaleFactor, safeWidth * offscreenScaleFactor, safeHeight * offscreenScaleFactor,
                       -safeWidth/2, -safeHeight/2, safeWidth, safeHeight);
               }
           } catch (e) {
               console.error("Error drawing text from offscreen canvas:", e);
           }

       // Draw front outlines on top for normal text (non-gradient)
       // For letter spacing, we need to draw the outline with the same spacing as the text
       if (obj.shadowMode === 'perspectiveShadow' && obj.perspectiveShadowOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for normal text (non-gradient)');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = obj.perspectiveShadowOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;

           // Use the same letter spacing logic as the main text rendering
           if (letterSpacing !== 0) {
               // Draw outline with letter spacing
               drawNormalFrontOutlineWithSpacing(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY, letterSpacing);
           } else {
               // Draw outline without letter spacing
               drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
           }
       }
       if (obj.shadowMode === 'detailed3D' && obj.d3dSecondaryWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for normal text (non-gradient)');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = obj.d3dSecondaryWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;

           // Use the same letter spacing logic as the main text rendering
           if (letterSpacing !== 0) {
               // Draw outline with letter spacing
               drawNormalFrontOutlineWithSpacing(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY, letterSpacing);
           } else {
               // Draw outline without letter spacing
               drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
           }
       }

       // Step 7: Apply decoration effects on top of text (NEW GRADIENT SYSTEM)
       console.log('🔍 NEW GRADIENT SYSTEM: Step 7 - Applying decoration effects on top of text');
       console.log(`🔍 DECORATION CHECK: Text "${obj.text}" - decorationMode: ${obj.decorationMode}`);
       if (obj.decorationMode && obj.decorationMode !== 'noDecoration' && window.decorationModule) {
           // CRITICAL FIX: Use state-based decoration tracking to prevent multiple applications
           const decorationHash = `${obj.decorationMode}_${obj.letterSpacing || 0}_${obj._effectiveLetterSpacing || 0}`;
           const currentDecoration = window._decorationState?.currentDecorations.get(obj.id);

           if (currentDecoration === decorationHash) {
               console.log(`🔍 DECORATION STATE: ❌ SKIPPING - Text "${obj.text}" decoration unchanged (${decorationHash})`);
               return targetCtx;
           }

           // CRITICAL FIX: Clear canvas before applying new decoration to prevent double lines
           if (currentDecoration && currentDecoration !== decorationHash) {
               console.log(`🔍 DECORATION STATE: 🧹 CLEARING CANVAS - Text "${obj.text}" decoration changing from (${currentDecoration}) to (${decorationHash})`);
               targetCtx.clearRect(0, 0, targetCtx.canvas.width, targetCtx.canvas.height);
           }

           // Update decoration state for this object
           if (window._decorationState) {
               window._decorationState.currentDecorations.set(obj.id, decorationHash);
               console.log(`🔍 DECORATION STATE: ✅ PROCEEDING - Text "${obj.text}" decoration changed to (${decorationHash})`);
           }

           // Calculate expanded bounds for normal text decoration
           const tempCtx = document.createElement('canvas').getContext('2d');
           tempCtx.font = `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`;
           const metrics = tempCtx.measureText(obj.text || 'TEXT');
           const baseWidth = metrics.width;
           const baseHeight = (obj.fontSize || 100) * 1.2;

           // Use expanded bounds to ensure decorations cover the full text area
           const expandedWidth = baseWidth * 1.5;
           const expandedHeight = baseHeight * 1.5;

           // Create decoration canvas with proper size (not fixed 2000x2000)
           const decorationCanvas = document.createElement('canvas');
           decorationCanvas.width = Math.ceil(expandedWidth);
           decorationCanvas.height = Math.ceil(expandedHeight);
           const decorationCtx = decorationCanvas.getContext('2d');

           // Set decoration type and apply
           console.log('🔍 NEW GRADIENT SYSTEM: Setting decoration type:', obj.decorationMode);
           window.decorationModule.setActiveDecorationType(obj.decorationMode);
           decorationCtx.save();
           decorationCtx.translate(decorationCanvas.width / 2, decorationCanvas.height / 2);

           // Create decoration-compatible text object with expanded bounds
           const decorationTextObj = {
               text: obj.text || 'TEXT',
               font: `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`,
               customBounds: {
                   width: expandedWidth,
                   height: expandedHeight,
                   isNormal: true
               }
           };

           console.log('🔍 NEW GRADIENT SYSTEM: Applying decoration with bounds:', {
               width: expandedWidth,
               height: expandedHeight,
               decorationMode: obj.decorationMode
           });

           // Apply decoration pattern
           window.decorationModule.applyDecoration(decorationCtx, decorationTextObj, 0, 0, obj);

           // CORRECT MASKING APPROACH: Use destination-in to mask decorations with text shape
           decorationCtx.restore();

           // Create a text mask canvas
           const textMaskCanvas = document.createElement('canvas');
           textMaskCanvas.width = decorationCanvas.width;
           textMaskCanvas.height = decorationCanvas.height;
           const textMaskCtx = textMaskCanvas.getContext('2d');

           // Draw text shape to mask canvas using logical dimensions (not high-DPI scaled)
           textMaskCtx.save();
           textMaskCtx.translate(textMaskCanvas.width / 2, textMaskCanvas.height / 2);

           // Use logical font size to match the decoration canvas dimensions
           const fontSize = obj.fontSize || 100;
           const fontFamily = obj.fontFamily || 'Arial';
           // Don't scale the font - use logical size to match decoration canvas
           textMaskCtx.font = `${fontSize}px "${fontFamily}"`;
           textMaskCtx.textAlign = 'center';
           textMaskCtx.textBaseline = 'middle';
           textMaskCtx.fillStyle = 'white'; // Color doesn't matter, just the shape

           console.log('🔍 TEXT MASK: Drawing text mask with font:', textMaskCtx.font, 'text:', obj.text);
           console.log('🔍 TEXT MASK: Mask canvas size:', textMaskCanvas.width, 'x', textMaskCanvas.height);
           console.log('🔍 TEXT MASK: Decoration canvas size:', decorationCanvas.width, 'x', decorationCanvas.height);
           console.log('🔍 TEXT MASK: Text bounds - width:', expandedWidth, 'height:', expandedHeight);
           textMaskCtx.fillText(obj.text, 0, 0);
           textMaskCtx.restore();

           // Apply text mask to decorations using destination-in
           decorationCtx.globalCompositeOperation = 'destination-in';
           decorationCtx.drawImage(textMaskCanvas, 0, 0);
           decorationCtx.globalCompositeOperation = 'source-over'; // Reset

           // Draw masked decorations to target (centered properly)
           targetCtx.save();
           targetCtx.drawImage(decorationCanvas, -decorationCanvas.width / 2, -decorationCanvas.height / 2);
           targetCtx.restore();

           console.log('🔍 NEW GRADIENT SYSTEM: ✅ DECORATION APPLICATION COMPLETE');
       } else {
           console.log('🔍 NEW GRADIENT SYSTEM: ❌ NO DECORATION TO APPLY', {
               decorationMode: obj.decorationMode,
               decorationModuleAvailable: !!window.decorationModule
           });
       }
   }
   function drawWarpedObject(obj, targetCtx) { // Added targetCtx
       console.log(`🔍 CALLING renderStyledObjectToOffscreen from WARPED RENDERING PATH for text "${obj.text}"`);
       renderStyledObjectToOffscreen(obj, octx, os.width / offscreenScaleFactor, os.height / offscreenScaleFactor);

       // Clear with high-DPI scaling preservation
       tempWarpCtx.save();
       const warpTransform = tempWarpCtx.getTransform();
       const warpScaleFactor = warpTransform.a;
       tempWarpCtx.setTransform(warpScaleFactor, 0, 0, warpScaleFactor, 0, 0);
       tempWarpCtx.clearRect(0, 0, tempWarpCanvas.width / warpScaleFactor, tempWarpCanvas.height / warpScaleFactor);
       tempWarpCtx.restore();
       tempWarpCtx.save();
       setTextContextOn(tempWarpCtx, obj);
       const metrics = tempWarpCtx.measureText((obj.text || ''));
       const ascent = metrics.actualBoundingBoxAscent || obj.fontSize * 0.8;
       const textHeight = ascent + (metrics.actualBoundingBoxDescent || obj.fontSize * 0.2);
       const sourceCenterY = (os.height / offscreenScaleFactor) / 2;
       const sourceTopY = sourceCenterY - textHeight / 2;
       const curve = obj.warpCurve;
       const sourceOffsetY = obj.warpOffset;
       const sourceSampleHeight = obj.warpHeight;
       const bottom = obj.warpBottom;
       const isTri = obj.warpTriangle;
       const shiftCenterValue = obj.warpShiftCenter;
       const angleSteps = Math.PI / tempWarpCanvas.width;
       const peak = tempWarpCanvas.width * (shiftCenterValue / 200.0);
       for (let i = 0; i < tempWarpCanvas.width; i++) {
           let destHeight;
           if (isTri) {
               const distFromPeak = Math.abs(i - peak);
               const maxDist = Math.max(peak, tempWarpCanvas.width - peak);
               const factor = (maxDist > 0) ? (distFromPeak / maxDist) : 0;
               destHeight = bottom - (curve * factor);
           } else {
               destHeight = bottom - curve * Math.sin(i * angleSteps);
           }
           destHeight = Math.max(1, destHeight);
           const destY = -destHeight / 2;
           try {
               const sy = sourceTopY + sourceOffsetY;
               const sh = sourceSampleHeight;
               const osLogicalHeight = os.height / offscreenScaleFactor;
               if (sy >= 0 && sh > 0 && sy + sh <= osLogicalHeight) {
                   const osLogicalWidth = os.width / offscreenScaleFactor;
                   const tempWarpLogicalWidth = tempWarpCanvas.width / offscreenScaleFactor;
                   const tempWarpLogicalHeight = tempWarpCanvas.height / offscreenScaleFactor;
                   tempWarpCtx.drawImage(os,
                       (i * (osLogicalWidth / tempWarpLogicalWidth)) * offscreenScaleFactor,
                       sy * offscreenScaleFactor,
                       (osLogicalWidth / tempWarpLogicalWidth) * offscreenScaleFactor,
                       sh * offscreenScaleFactor,
                       i, destY + tempWarpLogicalHeight / 2, 1, destHeight);
               }
           } catch (e) { /* ignore */ }
       }
       tempWarpCtx.restore();
       targetCtx.drawImage(tempWarpCanvas, -tempWarpCanvas.width / 2, -tempWarpCanvas.height / 2); // Use targetCtx
   }

   // Gradient throttling to prevent excessive redraws
   let lastGradientRender = 0;
   const GRADIENT_THROTTLE_MS = 100; // Only render gradients every 100ms max

   // New gradient masking function for circular text
   function drawCircularObjectWithGradientMask(obj, targetCtx) {
       // Throttle gradient rendering to prevent excessive redraws
       const now = Date.now();
       if (now - lastGradientRender < GRADIENT_THROTTLE_MS) {
           console.log('🚀 GRADIENT THROTTLE: Skipping gradient render - too frequent');
           return;
       }
       lastGradientRender = now;

       console.log('🎨 GRADIENT MASK: Drawing circular text with gradient mask');

       // Save original gradient
       const originalGradient = obj.gradient;

       // 🔧 SHADOW FIX: Apply shadows directly to target canvas using the same approach as solid color text
       // This ensures shadows render correctly at all quality levels without scaling issues
       console.log('🔧 SHADOW FIX: Applying shadows directly to target canvas for gradient text');

       // Apply shadows using the same per-letter approach as solid color text
       const diameter = obj.circleDiameter;
       const kerning = obj.circleKerning;
       const flipped = obj.circleFlip;
       const text = (obj.text || '');
       if (text) {
           const radius = diameter / 2;
           const contentArr = text.split('');
           const letterAngles = [];
           let totalAngle = 0;

           // Set up context for shadow rendering
           targetCtx.save();
           setTextContextOn(targetCtx, obj);

           // Calculate letter angles using the target context for accurate measurements
           contentArr.forEach((letter) => {
               const letterWidth = targetCtx.measureText(letter).width + kerning;
               const letterAngle = radius > 0 ? (letterWidth / radius) * (180 / Math.PI) : 0;
               letterAngles.push(letterAngle);
               totalAngle += letterAngle;
           });

           // Start angle to center the text
           let currentAngleRad = (-totalAngle / 2) * Math.PI / 180;

           // Render shadows for each letter directly to target canvas
           for (let i = 0; i < contentArr.length; i++) {
               const letter = contentArr[i];
               const letterAngleDeg = letterAngles[i];
               const letterAngleRad = letterAngleDeg * Math.PI / 180;
               const halfAngleRad = letterAngleRad / 2;

               currentAngleRad += halfAngleRad;

               // Calculate position
               const angleToDraw = flipped ? currentAngleRad + Math.PI : currentAngleRad;
               const x = radius * Math.cos(angleToDraw);
               const y = radius * Math.sin(angleToDraw);

               // Save context and apply transforms
               targetCtx.save();
               targetCtx.translate(x, y);
               let rot = angleToDraw + Math.PI / 2;
               if (flipped) { rot += Math.PI; }
               targetCtx.rotate(rot);

               // Apply shadow effects BEFORE drawing the letter (same as solid color text)
               const letterObj = { ...obj, text: letter };
               if (obj.shadowMode === 'blockShadow') {
                   applyBlockShadow(targetCtx, letterObj, 0, 0);
               } else if (obj.shadowMode === 'perspectiveShadow') {
                   applyPerspectiveShadow(targetCtx, letterObj, 0, 0);
               } else if (obj.shadowMode === 'lineShadow') {
                   applyLineShadow(targetCtx, letterObj, 0, 0);
               } else if (obj.shadowMode === 'detailed3D') {
                   applyDetailed3D_ExtrusionOnly(targetCtx, letterObj, 0, 0);
               } else if (obj.shadowMode === 'shadow') {
                   // Standard shadow using canvas properties
                   targetCtx.shadowColor = obj.shadowColor || '#000000';
                   targetCtx.shadowOffsetX = obj.shadowOffsetX || 5;
                   targetCtx.shadowOffsetY = obj.shadowOffsetY || 5;
                   targetCtx.shadowBlur = obj.shadowBlur || 10;
               }

               targetCtx.restore();
               currentAngleRad += halfAngleRad;
           }

           targetCtx.restore();
           console.log('🔧 SHADOW FIX: Completed shadow rendering for gradient circular text');
       }

       // Setup canvas parameters for gradient rendering
       const scaleFactor = targetCtx.canvas.scaleFactor || 1; // Use same scale as main canvas
       const logicalWidth = 2000;
       const logicalHeight = 2000;

       console.log('🔍 GRADIENT DEBUG: Canvas setup');
       console.log('  - scaleFactor:', scaleFactor);
       console.log('  - logicalWidth:', logicalWidth);
       console.log('  - logicalHeight:', logicalHeight);
       console.log('  - targetCtx.canvas.scaleFactor:', targetCtx.canvas.scaleFactor);
       console.log('  - targetCtx.canvas.width:', targetCtx.canvas.width);
       console.log('  - targetCtx.canvas.height:', targetCtx.canvas.height);

       // Step 2: Create text mask (only main text, no effects) with high-DPI scaling
       const textCanvas = document.createElement('canvas');
       textCanvas.width = logicalWidth * scaleFactor;
       textCanvas.height = logicalHeight * scaleFactor;
       console.log('🔍 GRADIENT DEBUG: Text canvas setup');
       console.log('  - textCanvas.width:', textCanvas.width);
       console.log('  - textCanvas.height:', textCanvas.height);

       const textCtx = textCanvas.getContext('2d');
       // textCtx.scale(scaleFactor, scaleFactor); // REMOVED: Canvas already sized with scaleFactor
       console.log('  - textCtx scale: REMOVED to prevent double-scaling');
       textCtx.imageSmoothingEnabled = true;
       textCtx.imageSmoothingQuality = 'high';

       // Draw circular text in white on transparent background (for masking)
       textCtx.save();
       textCtx.translate(logicalWidth / 2, logicalHeight / 2);
       textCtx.fillStyle = 'white';
       // FIXED: Use setTextContextOn to get the correct font variant (bold/italic)
       setTextContextOn(textCtx, obj);
       textCtx.textAlign = "center";
       textCtx.textBaseline = "middle";

       // Use the same variables already declared above for shadow rendering
       const radius = diameter / 2;

       const maskContentArr = text.split('');
       const maskLetterAngles = [];
       let maskTotalAngle = 0;
       maskContentArr.forEach((letter) => {
           const letterWidth = textCtx.measureText(letter).width + kerning;
           const letterAngle = radius > 0 ? (letterWidth / radius) * (180 / Math.PI) : 0;
           maskLetterAngles.push(letterAngle);
           maskTotalAngle += letterAngle;
       });

       let maskCurrentAngleRad = (-maskTotalAngle / 2) * Math.PI / 180;
       for (let i = 0; i < maskContentArr.length; i++) {
           const letter = maskContentArr[i];
           const letterAngleDeg = maskLetterAngles[i];
           const letterAngleRad = letterAngleDeg * Math.PI / 180;
           const halfAngleRad = letterAngleRad / 2;
           maskCurrentAngleRad += halfAngleRad;

           const angleToDraw = flipped ? maskCurrentAngleRad + Math.PI : maskCurrentAngleRad;
           const x = radius * Math.cos(angleToDraw);
           const y = radius * Math.sin(angleToDraw);

           textCtx.save();
           textCtx.translate(x, y);
           let rot = angleToDraw + Math.PI / 2;
           if (flipped) { rot += Math.PI; }
           textCtx.rotate(rot);

           textCtx.fillText(letter, 0, 0);
           textCtx.restore();

           maskCurrentAngleRad += halfAngleRad;
       }
       textCtx.restore();

       // Step 2: Create gradient canvas (NO additional scaling - main canvas is already scaled)
       const gradientCanvas = document.createElement('canvas');
       gradientCanvas.width = logicalWidth;
       gradientCanvas.height = logicalHeight;
       console.log('🔍 GRADIENT DEBUG: Gradient canvas setup (no double-scaling)');
       console.log('  - gradientCanvas.width:', gradientCanvas.width);
       console.log('  - gradientCanvas.height:', gradientCanvas.height);

       const gradientCtx = gradientCanvas.getContext('2d');
       // NO gradientCtx.scale() - main canvas is already scaled by high-DPI system
       console.log('  - gradientCtx scale: REMOVED to prevent double-scaling');
       gradientCtx.imageSmoothingEnabled = true;
       gradientCtx.imageSmoothingQuality = 'high';

       // Create the gradient
       console.log('🔍 GRADIENT DEBUG: Original gradient object:', originalGradient);

       // Handle both old and new gradient object structures
       let gradientType, gradientColors, gradientAngle;

       if (originalGradient.type) {
           // New structure: { type: 'linear', colors: [...], angle: 90 }
           gradientType = originalGradient.type;
           gradientColors = originalGradient.colors;
           gradientAngle = originalGradient.angle;
           console.log('🔍 GRADIENT DEBUG: Using new gradient structure');
       } else if (originalGradient.gradient) {
           // Old structure: { gradient: { type: 'linear', colors: [...], angle: 90 } }
           gradientType = originalGradient.gradient.type;
           gradientColors = originalGradient.gradient.colors;
           gradientAngle = originalGradient.gradient.angle;
           console.log('🔍 GRADIENT DEBUG: Using old gradient structure');
       } else {
           // Fallback - assume it's the gradient object itself
           gradientType = originalGradient.gradientType || 'linear';
           gradientColors = originalGradient.gradientStops;
           gradientAngle = originalGradient.gradientAngle || 90;
           console.log('🔍 GRADIENT DEBUG: Using fallback gradient structure');
       }

       console.log('🔍 GRADIENT DEBUG: Parsed gradient:', {
           type: gradientType,
           colors: gradientColors,
           angle: gradientAngle
       });

       let gradient;

       if (gradientType === 'radial') {
           const centerX = logicalWidth / 2;
           const centerY = logicalHeight / 2;
           const radius = Math.max(logicalWidth, logicalHeight) / 3;
           console.log('🔍 GRADIENT DEBUG: Radial gradient');
           console.log('  - centerX:', centerX, 'centerY:', centerY, 'radius:', radius);
           gradient = gradientCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
       } else {
           // Linear gradient
           const angle = (gradientAngle || 0) * Math.PI / 180;
           const cos = Math.cos(angle);
           const sin = Math.sin(angle);
           const centerX = logicalWidth / 2;
           const centerY = logicalHeight / 2;
           const length = Math.max(logicalWidth, logicalHeight);

           const x1 = centerX - (length / 2) * cos;
           const y1 = centerY - (length / 2) * sin;
           const x2 = centerX + (length / 2) * cos;
           const y2 = centerY + (length / 2) * sin;

           console.log('🔍 GRADIENT DEBUG: Linear gradient coordinates');
           console.log('  - angle:', gradientAngle || 0, 'degrees');
           console.log('  - centerX:', centerX, 'centerY:', centerY);
           console.log('  - length:', length);
           console.log('  - x1:', x1, 'y1:', y1);
           console.log('  - x2:', x2, 'y2:', y2);
           console.log('  - gradientCtx canvas size:', gradientCtx.canvas.width, 'x', gradientCtx.canvas.height);
           console.log('  - gradientCtx scale:', gradientCtx.getTransform());

           gradient = gradientCtx.createLinearGradient(x1, y1, x2, y2);
       }

       // Add color stops
       if (gradientColors && gradientColors.length > 0) {
           console.log('🔍 GRADIENT DEBUG: Adding color stops');
           gradientColors.forEach(colorStop => {
               // Handle both structures: { position, color } and { offset, color }
               let position = colorStop.position !== undefined ? colorStop.position / 100 : colorStop.offset;
               let color = colorStop.color;

               console.log(`  - Stop: position=${position}, color=${color}`);
               gradient.addColorStop(position, color);
           });
       } else {
           console.log('🔍 GRADIENT DEBUG: No colors found in gradient, using fallback');
           // Fallback to red-blue gradient
           gradient.addColorStop(0, '#ff0000');
           gradient.addColorStop(1, '#0000ff');
       }

       // Fill with gradient
       gradientCtx.fillStyle = gradient;
       console.log('🔍 GRADIENT DEBUG: Filling gradient');
       console.log('  - fillRect(0, 0,', logicalWidth, logicalHeight, ')');
       gradientCtx.fillRect(0, 0, logicalWidth, logicalHeight);

       // Apply text as mask to gradient
       gradientCtx.globalCompositeOperation = 'destination-in';
       console.log('🔍 GRADIENT DEBUG: Applying text mask');
       console.log('  - textCanvas size:', textCanvas.width, 'x', textCanvas.height);
       console.log('  - drawing textCanvas at (0, 0)');
       gradientCtx.drawImage(textCanvas, 0, 0);

       // Step 3: Draw gradient text on top (shadows already applied directly to target canvas)
       console.log('🔍 RENDER ORDER: Step 3 - Drawing gradient text');
       console.log('🔍 GRADIENT DEBUG: Drawing gradientCanvas to target');
       console.log('  - gradientCanvas size:', gradientCanvas.width, 'x', gradientCanvas.height);
       console.log('  - drawing at position:', -logicalWidth / 2, -logicalHeight / 2, 'with size:', logicalWidth, 'x', logicalHeight);
       targetCtx.drawImage(gradientCanvas, 0, 0, gradientCanvas.width, gradientCanvas.height, -logicalWidth / 2, -logicalHeight / 2, logicalWidth, logicalHeight);

       // Step 4: Apply decoration effects on top of gradient text
       console.log('🔍 RENDER ORDER: Step 4 - Applying decoration effects on top of gradient');
       if (obj.decorationMode && obj.decorationMode !== 'noDecoration' && window.decorationModule) {
           // Create decoration canvas
           const decorationCanvas = document.createElement('canvas');
           decorationCanvas.width = 2000;
           decorationCanvas.height = 2000;
           const decorationCtx = decorationCanvas.getContext('2d');

           // Set decoration type and apply
           window.decorationModule.setActiveDecorationType(obj.decorationMode);
           decorationCtx.save();
           decorationCtx.translate(decorationCanvas.width / 2, decorationCanvas.height / 2);

           // Calculate expanded bounds for circular text decoration
           const diameter = obj.circleDiameter || 600;
           const radius = diameter / 2;
           const expandedSize = diameter * 1.2; // Expand to cover the full circular area

           // Create decoration-compatible text object with expanded bounds
           const decorationTextObj = {
               text: obj.text || 'TEXT',
               font: `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`,
               // Add custom bounds for circular distortion
               customBounds: {
                   width: expandedSize,
                   height: expandedSize,
                   isCircular: true,
                   radius: radius
               }
           };

           // Apply decoration pattern with expanded bounds
           window.decorationModule.applyDecoration(decorationCtx, decorationTextObj, 0, 0);
           decorationCtx.restore();

           console.log('🎨 DECORATION: Applied decoration pattern for circular text:', obj.decorationMode);

           // Create a precise text mask using the SAME circular distorted text shape
           const textMaskCanvas = document.createElement('canvas');
           textMaskCanvas.width = 2000;
           textMaskCanvas.height = 2000;
           const textMaskCtx = textMaskCanvas.getContext('2d');

           // Draw the EXACT same circular text shape as the main rendering for precise masking
           textMaskCtx.save();
           textMaskCtx.translate(textMaskCanvas.width / 2, textMaskCanvas.height / 2);
           textMaskCtx.fillStyle = 'white';
           createCircularTextMask(obj, textMaskCtx);
           textMaskCtx.restore();

           // Apply text mask to decoration canvas
           decorationCtx.globalCompositeOperation = 'destination-in';
           decorationCtx.drawImage(textMaskCanvas, 0, 0);

           // Apply masked decoration to target
           targetCtx.drawImage(decorationCanvas, -decorationCanvas.width / 2, -decorationCanvas.height / 2);

           console.log('🎨 DECORATION: Applied decoration effects on top of circular gradient text');
       }

       // Step 5: Draw front outlines on top of everything (using original circular system)
       console.log('🔍 RENDER ORDER: Step 5 - Drawing front outlines on top');

       // Store original outline widths for front outline rendering
       const originalOutlineWidth = obj.perspectiveShadowOutlineWidth;
       const originalD3dWidth = obj.d3dSecondaryWidth;

       if (obj.shadowMode === 'perspectiveShadow' && originalOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = originalOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
       if (obj.shadowMode === 'detailed3D' && originalD3dWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = originalD3dWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }

       // Restore original gradient
       obj.gradient = originalGradient;

       console.log('🎨 GRADIENT MASK: Circular text with gradient mask complete');
   }

   // New gradient masking function for normal text
   function drawNormalObjectWithGradientMask(obj, targetCtx) {
       console.log('🎨 GRADIENT MASK: Drawing normal text with gradient mask');
       console.log('🔍 GRADIENT FLOW: Starting normal text gradient rendering');
       console.log('🔍 GRADIENT FLOW: Target canvas info:');
       console.log('  - targetCtx.canvas.width:', targetCtx.canvas.width);
       console.log('  - targetCtx.canvas.height:', targetCtx.canvas.height);
       console.log('  - targetCtx.canvas.style.width:', targetCtx.canvas.style.width);
       console.log('  - targetCtx.canvas.style.height:', targetCtx.canvas.style.height);
       console.log('  - targetCtx.canvas.scaleFactor:', targetCtx.canvas.scaleFactor);
       console.log('  - targetCtx current transform:', targetCtx.getTransform());

       // Save original gradient
       const originalGradient = obj.gradient;

       // Create a temporary canvas for the complete rendering with high-DPI scaling
       const tempCanvas = document.createElement('canvas');
       const scaleFactor = targetCtx.canvas.scaleFactor || 1; // Use same scale as main canvas
       const logicalWidth = 2000;
       const logicalHeight = 2000;
       tempCanvas.width = logicalWidth * scaleFactor;
       tempCanvas.height = logicalHeight * scaleFactor;
       const tempCtx = tempCanvas.getContext('2d');
       // tempCtx.scale(scaleFactor, scaleFactor); // REMOVED: Canvas already sized with scaleFactor
       tempCtx.imageSmoothingEnabled = true;
       tempCtx.imageSmoothingQuality = 'high';

       // Step 1: Draw effects and text with solid color to temp canvas (WITHOUT front outlines)
       tempCtx.save();
       tempCtx.translate(logicalWidth / 2, logicalHeight / 2);
       console.log('🔍 GRADIENT FLOW: Step 1 - Drawing effects and text');
       console.log('  - tempCanvas size:', tempCanvas.width, 'x', tempCanvas.height);
       console.log('  - logical size:', logicalWidth, 'x', logicalHeight);
       console.log('  - scaleFactor:', scaleFactor);
       console.log('  - translate to:', logicalWidth / 2, logicalHeight / 2);
       console.log('  - obj.fontSize before rendering:', obj.fontSize);
       obj.gradient = { type: 'solid' };
       // Temporarily disable front outline to prevent it from being drawn in shadow effects
       const originalOutlineWidth = obj.perspectiveShadowOutlineWidth;
       const originalD3dWidth = obj.d3dSecondaryWidth;
       obj.perspectiveShadowOutlineWidth = 0;
       obj.d3dSecondaryWidth = 0;

       // Create offscreen canvas for rendering with high-DPI scaling
       const offscreenCanvas = document.createElement('canvas');
       offscreenCanvas.width = 2000 * scaleFactor;
       offscreenCanvas.height = 2000 * scaleFactor;
       const offscreenCtx = offscreenCanvas.getContext('2d');
       offscreenCtx.scale(scaleFactor, scaleFactor);
       offscreenCtx.imageSmoothingEnabled = true;
       offscreenCtx.imageSmoothingQuality = 'high';

       // CRITICAL FIX: Set up text context first to ensure _effectiveLetterSpacing is available for shadow functions
       offscreenCtx.save();
       offscreenCtx.translate(offscreenCanvas.width / 2, offscreenCanvas.height / 2);
       setTextContextOn(offscreenCtx, obj);  // This sets obj._effectiveLetterSpacing
       offscreenCtx.restore();

       // Render the text with effects but no front outlines
       console.log(`🔍 CALLING renderStyledObjectToOffscreen from GRADIENT MASKING PATH for text "${obj.text}"`);
       const metrics = renderStyledObjectToOffscreen(obj, offscreenCtx, offscreenCanvas.width, offscreenCanvas.height);
       try {
           const effectsPadding = Math.max(
               100, // letterSourcePadding * 4,
               obj.fontSize * 0.5,
               (obj.shadowOffsetX || 0) + (obj.shadowBlur || 0) * 2,
               (obj.d3dOffset || 0) + (obj.d3dBlur || 0) * 2,
               (obj.blockShadowOffset || 0) * 1.5,
               (obj.strokeWidth || 0) * 3
           );
           const sw = metrics.width + effectsPadding * 2;
           const sh = metrics.height + effectsPadding * 2;
           const sx = metrics.centerX - sw / 2;
           const sy = metrics.centerY - sh / 2;
           const dx = -sw / 2;
           const dy = -sh / 2;

           if (sx >= 0 && sy >= 0 && sx + sw <= offscreenCanvas.width && sy + sh <= offscreenCanvas.height && sw > 0 && sh > 0) {
               tempCtx.drawImage(offscreenCanvas, sx, sy, sw, sh, dx, dy, sw, sh);
           }
       } catch (e) {
           console.error("Error drawing normal text in gradient mask:", e);
       }

       // Restore outline settings
       obj.perspectiveShadowOutlineWidth = originalOutlineWidth;
       obj.d3dSecondaryWidth = originalD3dWidth;
       tempCtx.restore();

       // Step 2: Create text mask (only main text, no effects)
       const textCanvas = document.createElement('canvas');
       textCanvas.width = logicalWidth * scaleFactor;
       textCanvas.height = logicalHeight * scaleFactor;
       const textCtx = textCanvas.getContext('2d');
       // textCtx.scale(scaleFactor, scaleFactor); // REMOVED: Canvas already sized with scaleFactor
       console.log('🔍 GRADIENT FLOW: Step 2 - Creating text mask');
       console.log('  - textCanvas size:', textCanvas.width, 'x', textCanvas.height);
       console.log('  - textCtx scale: REMOVED to prevent double-scaling');

       // Draw normal text in white on transparent background (for masking)
       textCtx.save();
       textCtx.translate(logicalWidth / 2, logicalHeight / 2);
       console.log('🔍 GRADIENT FLOW: Drawing text mask at logical center:', logicalWidth / 2, logicalHeight / 2);
       textCtx.fillStyle = 'white';
       setTextContextOn(textCtx, obj);
       const text = (obj.text || '');

       // Handle letter spacing properly for gradient mask
       const letterSpacing = obj._effectiveLetterSpacing || 0;
       if (letterSpacing !== 0) {
           // Draw each character manually with letter spacing
           const letters = text.split('');
           let totalWidth = 0;

           // Calculate total width with letter spacing
           letters.forEach(letter => {
               totalWidth += textCtx.measureText(letter).width;
           });
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           // Draw each letter with proper spacing
           let currentX = -totalWidth / 2;
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = textCtx.measureText(letter).width;
               textCtx.fillText(letter, currentX + letterWidth / 2, 0);
               currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
           }
       } else {
           // No letter spacing, use standard fillText
           textCtx.fillText(text, 0, 0);
       }
       textCtx.restore();

       // Step 3: Cut out text areas from the effects canvas using destination-out
       console.log('🔍 GRADIENT FLOW: Step 3 - Cutting out text from effects canvas using destination-out');
       tempCtx.globalCompositeOperation = 'destination-out';
       tempCtx.drawImage(textCanvas, 0, 0);
       tempCtx.globalCompositeOperation = 'source-over'; // Reset composite operation
       console.log('🔍 GRADIENT FLOW: Step 3 complete - Text cutout applied, composite operation reset');

       // Step 4: Create gradient canvas (NO additional scaling - main canvas is already scaled)
       const gradientCanvas = document.createElement('canvas');
       gradientCanvas.width = logicalWidth;
       gradientCanvas.height = logicalHeight;
       const gradientCtx = gradientCanvas.getContext('2d');
       // NO gradientCtx.scale() - main canvas is already scaled by high-DPI system
       console.log('🔍 GRADIENT FLOW: Step 4 - Creating gradient canvas (no double-scaling)');
       console.log('  - gradientCanvas size:', gradientCanvas.width, 'x', gradientCanvas.height);
       console.log('  - gradientCtx scale: REMOVED to prevent double-scaling');
       gradientCtx.imageSmoothingEnabled = true;
       gradientCtx.imageSmoothingQuality = 'high';

       // Create the gradient
       const gradientType = originalGradient.type;
       let gradient;

       if (gradientType === 'radial') {
           const centerX = logicalWidth / 2;
           const centerY = logicalHeight / 2;
           const radius = Math.max(logicalWidth, logicalHeight) / 3;
           console.log('🔍 GRADIENT FLOW: Creating radial gradient at logical coords:', centerX, centerY, 'radius:', radius);
           gradient = gradientCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
       } else {
           // Linear gradient
           const angle = (originalGradient.gradient.angle || 0) * Math.PI / 180;
           const cos = Math.cos(angle);
           const sin = Math.sin(angle);
           const centerX = logicalWidth / 2;
           const centerY = logicalHeight / 2;
           const length = Math.max(logicalWidth, logicalHeight);
           console.log('🔍 GRADIENT FLOW: Creating linear gradient at logical coords:', centerX, centerY, 'length:', length);

           const x1 = centerX - (length / 2) * cos;
           const y1 = centerY - (length / 2) * sin;
           const x2 = centerX + (length / 2) * cos;
           const y2 = centerY + (length / 2) * sin;

           gradient = gradientCtx.createLinearGradient(x1, y1, x2, y2);
       }

       // Add color stops
       if (originalGradient.gradient.colors) {
           originalGradient.gradient.colors.forEach(colorStop => {
               gradient.addColorStop(colorStop.position / 100, colorStop.color);
           });
       }

       // Fill with gradient
       gradientCtx.fillStyle = gradient;
       console.log('🔍 GRADIENT FLOW: Filling gradient at logical size:', logicalWidth, 'x', logicalHeight);
       gradientCtx.fillRect(0, 0, logicalWidth, logicalHeight);

       // Apply text as mask to gradient
       gradientCtx.globalCompositeOperation = 'destination-in';
       gradientCtx.drawImage(textCanvas, 0, 0);

       // Step 5: Draw effects (with text cut out) to target canvas
       console.log('🔍 RENDER ORDER: Step 5 - Drawing shadow effects for normal text');
       console.log('🔍 GRADIENT FLOW: Drawing tempCanvas - source size:', tempCanvas.width, 'x', tempCanvas.height);
       console.log('🔍 GRADIENT FLOW: Drawing tempCanvas at position 0,0 with size:', logicalWidth, 'x', logicalHeight);
       targetCtx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, -logicalWidth / 2, -logicalHeight / 2, logicalWidth, logicalHeight);

       // Step 6: Draw gradient text on top
       console.log('🔍 RENDER ORDER: Step 6 - Drawing gradient text for normal text');
       console.log('🔍 GRADIENT FLOW: Drawing gradientCanvas - source size:', gradientCanvas.width, 'x', gradientCanvas.height);
       console.log('🔍 GRADIENT FLOW: Drawing gradientCanvas at position 0,0 with size:', logicalWidth, 'x', logicalHeight);
       targetCtx.drawImage(gradientCanvas, 0, 0, gradientCanvas.width, gradientCanvas.height, -logicalWidth / 2, -logicalHeight / 2, logicalWidth, logicalHeight);

       // Step 7: Apply decoration effects on top of gradient text
       console.log('🔍 RENDER ORDER: Step 7 - Applying decoration effects on top of gradient for normal text');
       if (obj.decorationMode && obj.decorationMode !== 'noDecoration' && window.decorationModule) {
           // Create decoration canvas
           const decorationCanvas = document.createElement('canvas');
           decorationCanvas.width = 2000;
           decorationCanvas.height = 2000;
           const decorationCtx = decorationCanvas.getContext('2d');

           // Set decoration type and apply
           window.decorationModule.setActiveDecorationType(obj.decorationMode);
           decorationCtx.save();
           decorationCtx.translate(decorationCanvas.width / 2, decorationCanvas.height / 2);

           // Calculate expanded bounds for normal text decoration (to match solid color behavior)
           const tempCtx = document.createElement('canvas').getContext('2d');
           tempCtx.font = `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`;
           const metrics = tempCtx.measureText(obj.text || 'TEXT');
           const baseWidth = metrics.width;
           const baseHeight = (obj.fontSize || 100) * 1.2;

           // Use expanded bounds to ensure decorations cover the full text area
           const expandedWidth = baseWidth * 1.5; // Expand width for better coverage
           const expandedHeight = baseHeight * 1.5; // Expand height for better coverage

           // Create decoration-compatible text object with expanded bounds
           const decorationTextObj = {
               text: obj.text || 'TEXT',
               font: `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`,
               // Add custom bounds for better decoration coverage
               customBounds: {
                   width: expandedWidth,
                   height: expandedHeight,
                   isCircular: false
               }
           };

           // Apply decoration pattern with expanded bounds
           // IMPORTANT: Pass the actual text object (obj) as 5th parameter to get current UI settings
           window.decorationModule.applyDecoration(decorationCtx, decorationTextObj, 0, 0, obj);
           decorationCtx.restore();

           console.log('🎨 DECORATION: Applied decoration pattern for normal text:', obj.decorationMode);

           // Create a precise text mask for decoration clipping
           const textMaskCanvas = document.createElement('canvas');
           textMaskCanvas.width = 2000;
           textMaskCanvas.height = 2000;
           const textMaskCtx = textMaskCanvas.getContext('2d');

           // Draw text shape in white for masking (normal text)
           textMaskCtx.save();
           textMaskCtx.translate(textMaskCanvas.width / 2, textMaskCanvas.height / 2);
           textMaskCtx.fillStyle = 'white';
           setTextContextOn(textMaskCtx, obj);
           textMaskCtx.textAlign = 'center';
           textMaskCtx.textBaseline = 'middle';

           // Handle letter spacing for decoration mask too
           const maskText = (obj.text || 'TEXT');
           const maskLetterSpacing = obj._effectiveLetterSpacing || 0;
           if (maskLetterSpacing !== 0) {
               // Draw each character manually with letter spacing
               const maskLetters = maskText.split('');
               let maskTotalWidth = 0;

               // Calculate total width with letter spacing
               maskLetters.forEach(letter => {
                   maskTotalWidth += textMaskCtx.measureText(letter).width;
               });
               if (maskLetters.length > 1) {
                   maskTotalWidth += maskLetterSpacing * (maskLetters.length - 1);
               }

               // Draw each letter with proper spacing
               let maskCurrentX = -maskTotalWidth / 2;
               for (let i = 0; i < maskLetters.length; i++) {
                   const letter = maskLetters[i];
                   const letterWidth = textMaskCtx.measureText(letter).width;
                   textMaskCtx.fillText(letter, maskCurrentX + letterWidth / 2, 0);
                   maskCurrentX += letterWidth + (i < maskLetters.length - 1 ? maskLetterSpacing : 0);
               }
           } else {
               // No letter spacing, use standard fillText
               textMaskCtx.fillText(maskText, 0, 0);
           }
           textMaskCtx.restore();

           // Apply text mask to decoration canvas
           decorationCtx.globalCompositeOperation = 'destination-in';
           decorationCtx.drawImage(textMaskCanvas, 0, 0);

           // For gradient text decorations, we need to apply them more prominently
           // First, apply the decoration with higher opacity to make it more visible over gradients
           targetCtx.save();

           // Apply decoration with multiply to darken the gradient where decoration exists
           targetCtx.globalCompositeOperation = 'multiply';
           targetCtx.drawImage(decorationCanvas, -decorationCanvas.width / 2, -decorationCanvas.height / 2);

           // Then apply the decoration again with source-atop to add the decoration color
           targetCtx.globalCompositeOperation = 'source-atop';
           targetCtx.globalAlpha = 0.7; // Make decoration more prominent
           targetCtx.drawImage(decorationCanvas, -decorationCanvas.width / 2, -decorationCanvas.height / 2);

           targetCtx.restore();

           console.log('🎨 DECORATION: Applied decoration with dual-layer blending for gradient text');

           console.log('🎨 DECORATION: Applied decoration effects on top of normal gradient text');
       }

       // Step 5: Draw front outlines on top of everything
       console.log('🔍 RENDER ORDER: Step 5 - Drawing front outlines on top for normal text');

       // Use the original outline widths that were stored earlier in the function
       if (obj.shadowMode === 'perspectiveShadow' && originalOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for normal text');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = originalOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;
           drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
       if (obj.shadowMode === 'detailed3D' && originalD3dWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for normal text');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = originalD3dWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;
           drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }

       // Restore original gradient
       obj.gradient = originalGradient;

       console.log('🎨 GRADIENT MASK: Normal text with gradient mask complete');
   }

   // Normal front outline drawing function for gradient masking
   function drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY) {
       console.log('🔍 FRONT OUTLINE: Drawing normal front outline with letter spacing support');

       targetCtx.save();

       // Apply offset to the entire context, not per letter
       targetCtx.translate(outlineOffsetX, outlineOffsetY);

       setTextContextOn(targetCtx, obj);
       targetCtx.lineWidth = outlineWidth;
       targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
       targetCtx.lineJoin = 'round';

       const text = (obj.text || '');
       const letterSpacing = obj._effectiveLetterSpacing || 0;

       if (letterSpacing !== 0) {
           // Draw each character manually with letter spacing
           const letters = text.split('');
           let totalWidth = 0;

           // Calculate total width with letter spacing
           letters.forEach(letter => {
               totalWidth += targetCtx.measureText(letter).width;
           });
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           // Draw each letter with proper spacing (offset already applied via translate)
           let currentX = -totalWidth / 2;
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = targetCtx.measureText(letter).width;
               targetCtx.strokeText(letter, currentX + letterWidth / 2, 0);
               currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
           }
       } else {
           // No letter spacing, use standard strokeText (offset already applied via translate)
           targetCtx.strokeText(text, 0, 0);
       }

       targetCtx.restore();
       console.log('🎨 GRADIENT MASK: Drew normal front outline');
   }

   // Function to create Grid Distort path with letter spacing support
   function createGridDistortPathWithLetterSpacing(font, text, fontSize, letterSpacing) {
       console.log('🔍 GRID DISTORT PATH: Creating path with letter spacing:', letterSpacing);

       const letters = text.split('');
       const combinedPath = new opentype.Path();
       let currentX = 0;
       let totalWidth = 0;

       // First pass: calculate total width with letter spacing
       letters.forEach(letter => {
           const letterPath = font.getPath(letter, 0, 0, fontSize);
           const bounds = letterPath.getBoundingBox();
           totalWidth += (bounds.x2 - bounds.x1);
       });
       if (letters.length > 1) {
           totalWidth += letterSpacing * (letters.length - 1);
       }

       // Second pass: create combined path with proper positioning
       currentX = -totalWidth / 2;
       for (let i = 0; i < letters.length; i++) {
           const letter = letters[i];
           const letterPath = font.getPath(letter, currentX, 0, fontSize);
           const bounds = letterPath.getBoundingBox();
           const letterWidth = bounds.x2 - bounds.x1;

           // Add all commands from this letter's path to the combined path
           letterPath.commands.forEach(cmd => {
               combinedPath.commands.push(cmd);
           });

           // Advance position with letter spacing
           currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
       }

       console.log('🔍 GRID DISTORT PATH: Created combined path with', combinedPath.commands.length, 'commands');
       return combinedPath;
   }

   // Normal front outline drawing function with letter spacing support for non-gradient text
   function drawNormalFrontOutlineWithSpacing(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY, letterSpacing) {
       console.log('🎨 NORMAL FRONT OUTLINE: Drawing normal text front outline with letter spacing:', letterSpacing);

       targetCtx.save();

       // Apply offset to the entire context
       targetCtx.translate(outlineOffsetX, outlineOffsetY);

       setTextContextOn(targetCtx, obj);
       targetCtx.lineWidth = outlineWidth;
       targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
       targetCtx.lineJoin = 'round';

       const text = (obj.text || '');
       const letters = text.split('');
       let totalWidth = 0;

       // Calculate total width with letter spacing
       letters.forEach(letter => {
           totalWidth += targetCtx.measureText(letter).width;
       });
       if (letters.length > 1) {
           totalWidth += letterSpacing * (letters.length - 1);
       }

       // Draw each letter with proper spacing (offset already applied via translate)
       let currentX = -totalWidth / 2;
       for (let i = 0; i < letters.length; i++) {
           const letter = letters[i];
           const letterWidth = targetCtx.measureText(letter).width;
           targetCtx.strokeText(letter, currentX + letterWidth / 2, 0);
           currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
       }

       targetCtx.restore();
       console.log('🎨 NORMAL FRONT OUTLINE: Drew normal text front outline with letter spacing');
   }

   // Standalone front outline drawing functions for gradient masking
   function drawPerspectiveFrontOutline(obj, targetCtx) {
       if (!obj.perspectiveShadowOutlineWidth || obj.perspectiveShadowOutlineWidth <= 0) return;

       const outlineColor = obj.perspectiveShadowOutlineColor || '#d1d5db';
       const outlineOpacity = (obj.perspectiveShadowOutlineOpacity !== undefined) ? obj.perspectiveShadowOutlineOpacity / 100 : 1.0;
       const outlineWidth = obj.perspectiveShadowOutlineWidth || 3;
       const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 2;
       const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || -3;

       console.log('🔍 FRONT OUTLINE DEBUG: drawPerspectiveFrontOutline called', {
           distortType: obj.distortType,
           effectMode: obj.effectMode,
           outlineWidth,
           outlineColor,
           text: obj.text,
           hasDistortType: !!obj.distortType,
           hasEffectMode: !!obj.effectMode
       });

       // For circular text, we need to draw the outline following the circular path
       if (obj.distortType === 'circular' || obj.effectMode === 'circle') {
           console.log('🔍 FRONT OUTLINE: Drawing circular front outline');
           // For circular text, use no offset to align with text path
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, 0, 0);
       } else {
           console.log('🔍 FRONT OUTLINE: Drawing straight front outline');
           // For non-circular text, draw straight outline
           targetCtx.save();
           setTextContextOn(targetCtx, obj);
           targetCtx.lineWidth = outlineWidth;
           targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
           targetCtx.lineJoin = 'round';
           targetCtx.strokeText((obj.text || ''), outlineOffsetX, outlineOffsetY);
           targetCtx.restore();
       }

       console.log('🎨 GRADIENT MASK: Drew perspective front outline on top');
   }

   function drawDetailed3DFrontOutline(obj, targetCtx) {
       if (!obj.d3dSecondaryWidth || obj.d3dSecondaryWidth <= 0) return;

       const secondaryColorRgba = hexToRgba(obj.d3dSecondaryColor, obj.d3dSecondaryOpacity / 100);

       console.log('🔍 FRONT OUTLINE DEBUG: drawDetailed3DFrontOutline called', {
           distortType: obj.distortType,
           effectMode: obj.effectMode,
           outlineWidth: obj.d3dSecondaryWidth,
           outlineColor: obj.d3dSecondaryColor,
           text: obj.text
       });

       // For circular text, we need to draw the outline following the circular path
       if (obj.distortType === 'circular' || obj.effectMode === 'circle') {
           console.log('🔍 FRONT OUTLINE: Drawing circular detailed 3D front outline');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = obj.d3dSecondaryWidth;
           // For circular text, use no offset to align with text path
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, 0, 0);
       } else {
           console.log('🔍 FRONT OUTLINE: Drawing straight detailed 3D front outline');
           // For non-circular text, draw straight outline
           targetCtx.save();
           setTextContextOn(targetCtx, obj);
           targetCtx.lineWidth = obj.d3dSecondaryWidth;
           targetCtx.strokeStyle = secondaryColorRgba;
           targetCtx.lineJoin = 'round';
           targetCtx.strokeText((obj.text || ''), obj.d3dSecondaryOffsetX, obj.d3dSecondaryOffsetY);
           targetCtx.restore();
       }

       console.log('🎨 GRADIENT MASK: Drew detailed 3D front outline on top');
   }

   // Draw front outline following circular path
   function drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY) {
       console.log('🔍 CIRCULAR OUTLINE: drawCircularFrontOutline called', {
           text: obj.text,
           outlineColor,
           outlineOpacity,
           outlineWidth,
           outlineOffsetX,
           outlineOffsetY,
           circleDiameter: obj.circleDiameter,
           circleKerning: obj.circleKerning,
           circleFlip: obj.circleFlip
       });

       // Use the SAME circular parameters as the main text
       const diameter = obj.circleDiameter;
       const kerning = obj.circleKerning;
       const flipped = obj.circleFlip;
       const text = (obj.text || '');
       if (!text) return;

       const radius = diameter / 2;
       const letterSpacing = obj._effectiveLetterSpacing || obj.letterSpacing || 0;

       targetCtx.save();
       // FIXED: Use setTextContextOn to get the correct font variant (bold/italic) for outline
       setTextContextOn(targetCtx, obj);
       targetCtx.lineWidth = outlineWidth;
       targetCtx.strokeStyle = hexToRgba(outlineColor, outlineOpacity);
       targetCtx.lineJoin = 'round';

       // Use the SAME angle calculation as drawCircularObjectInternal
       const contentArr = text.split('');
       const letterAngles = [];
       let totalAngle = 0;
       contentArr.forEach((letter) => {
           const letterWidth = targetCtx.measureText(letter).width + kerning;
           const letterAngle = radius > 0 ? (letterWidth / radius) * (180 / Math.PI) : 0;
           letterAngles.push(letterAngle);
           totalAngle += letterAngle;
       });

       // Use the SAME starting angle calculation as main text
       let currentAngleRad = (-totalAngle / 2) * Math.PI / 180;

       // Draw each character with the SAME positioning logic
       for (let i = 0; i < contentArr.length; i++) {
           const letter = contentArr[i];
           const letterAngleDeg = letterAngles[i];
           const letterAngleRad = letterAngleDeg * Math.PI / 180;
           const halfAngleRad = letterAngleRad / 2;
           currentAngleRad += halfAngleRad;

           // Use the SAME angle calculation as main text
           const angleToDraw = flipped ? currentAngleRad + Math.PI : currentAngleRad;
           const x = radius * Math.cos(angleToDraw) + outlineOffsetX;
           const y = radius * Math.sin(angleToDraw) + outlineOffsetY;

           targetCtx.save();
           targetCtx.translate(x, y);
           let rot = angleToDraw + Math.PI / 2;
           if (flipped) { rot += Math.PI; }
           targetCtx.rotate(rot);
           targetCtx.strokeText(letter, 0, 0);
           targetCtx.restore();

           currentAngleRad += halfAngleRad;
       }

       targetCtx.restore();
       console.log('🎨 GRADIENT MASK: Drew circular front outline');
   }

   // Create distorted text masks for decoration clipping
   function createCircularTextMask(obj, maskCtx) {
       console.log('🎨 MASK: Creating circular text mask for decorations');

       const diameter = obj.circleDiameter;
       const kerning = obj.circleKerning;
       const flipped = obj.circleFlip;
       const text = (obj.text || '');
       if (!text) return;

       const radius = diameter / 2;
       setTextContextOn(maskCtx, obj);

       const contentArr = text.split('');
       const letterAngles = [];
       let totalAngle = 0;
       contentArr.forEach((letter) => {
           const letterWidth = maskCtx.measureText(letter).width + kerning;
           const letterAngle = radius > 0 ? (letterWidth / radius) * (180 / Math.PI) : 0;
           letterAngles.push(letterAngle);
           totalAngle += letterAngle;
       });

       let currentAngleRad = (-totalAngle / 2) * Math.PI / 180;
       for (let i = 0; i < contentArr.length; i++) {
           const letter = contentArr[i];
           const letterAngleDeg = letterAngles[i];
           const letterAngleRad = letterAngleDeg * Math.PI / 180;
           const halfAngleRad = letterAngleRad / 2;
           currentAngleRad += halfAngleRad;

           const angleToDraw = flipped ? currentAngleRad + Math.PI : currentAngleRad;
           const x = radius * Math.cos(angleToDraw);
           const y = radius * Math.sin(angleToDraw);

           maskCtx.save();
           maskCtx.translate(x, y);
           let rot = angleToDraw + Math.PI / 2;
           if (flipped) { rot += Math.PI; }
           maskCtx.rotate(rot);
           maskCtx.fillText(letter, 0, 0);
           maskCtx.restore();

           currentAngleRad += halfAngleRad;
       }

       console.log('🎨 MASK: Created circular text mask');
   }

   function createCurvedTextMask(obj, maskCtx) {
       console.log('🎨 MASK: Creating curved text mask for decorations');

       const curveAmount = obj.curveAmount;
       const kerning = obj.curveKerning;
       const flip = obj.curveFlip;
       const text = (obj.text || '');
       if (!text || curveAmount === 0) {
           // Fallback to normal text
           setTextContextOn(maskCtx, obj);
           maskCtx.fillText(text, 0, 0);
           return;
       }

       setTextContextOn(maskCtx, obj);
       const direction = flip ? -1 : 1;
       const curveFactor = Math.max(0.1, Math.abs(curveAmount) / 10);
       const tempMeasureCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(tempMeasureCtx, obj);
       const textWidthEst = tempMeasureCtx.measureText(text).width;
       const curveRadius = (Math.max(2000, textWidthEst * 1.5) / curveFactor);
       const chars = text.split('');
       let totalWidth = 0;
       const charWidths = chars.map(char => {
           const width = maskCtx.measureText(char).width + kerning;
           totalWidth += width;
           return width;
       });
       let currentX = -totalWidth / 2;

       for (let i = 0; i < chars.length; i++) {
           const letter = chars[i];
           const displayWidth = charWidths[i];
           const charCenterX = currentX + displayWidth / 2;
           const angleOffset = (charCenterX / curveRadius) * direction;
           const yOffset = curveRadius * (Math.cos(angleOffset) - 1) * direction;
           const rot = angleOffset * direction;

           maskCtx.save();
           maskCtx.translate(charCenterX, yOffset);
           maskCtx.rotate(rot);
           maskCtx.fillText(letter, 0, 0);
           maskCtx.restore();

           currentX += displayWidth;
       }

       console.log('🎨 MASK: Created curved text mask');
   }

   function createGridDistortTextMask(obj, maskCtx) {
       console.log('🎨 MASK: Creating grid distort text mask for decorations');

       if (!obj.gridDistort || !window.loadedFonts) {
           // Fallback to normal text
           setTextContextOn(maskCtx, obj);
           maskCtx.fillText(obj.text, 0, 0);
           return;
       }

       // Get the font for the text object
       const fontFamily = obj.fontFamily || 'Arial';
       const isBold = obj.bold || false;
       const isItalic = obj.italic || false;
       const fontKey = `${fontFamily}_${isBold ? 'bold' : 'regular'}_${isItalic ? 'italic' : 'normal'}`;
       const font = window.loadedFonts[fontKey];

       if (!font) {
           // Fallback to normal text
           setTextContextOn(maskCtx, obj);
           maskCtx.fillText(obj.text, 0, 0);
           return;
       }

       // Use the same grid distort logic as the main rendering
       const text = obj.text;
       const fontSize = obj.fontSize || 100;
       const letterSpacing = obj._effectiveLetterSpacing || obj.letterSpacing || 0;

       // Handle letter spacing for mask creation (same as main rendering)
       let path;
       if (letterSpacing !== 0) {
           console.log('🎨 MASK: Creating grid distort mask with letter spacing:', letterSpacing);
           // Create individual paths for each letter with spacing
           path = createGridDistortPathWithLetterSpacing(font, text, fontSize, letterSpacing);
       } else {
           // Create a path for the entire text using OpenType.js (only when letterSpacing is exactly 0)
           console.log('🎨 MASK: Creating grid distort mask without letter spacing');
           path = font.getPath(text, 0, 0, fontSize);
       }

       const bounds = path.getBoundingBox();
       const textWidth = obj.measuredWidth || (bounds.x2 - bounds.x1);
       const textHeight = obj.measuredHeight || (bounds.y2 - bounds.y1);

       // Calculate grid bounds (same as main rendering)
       const paddingScale = 0.5;
       const basePadding = obj.gridDistort.gridPadding;
       const scaledPadding = Math.max(basePadding, fontSize * paddingScale);
       const gridLeft = -textWidth/2 - scaledPadding;
       const gridTop = -textHeight/2 - scaledPadding;
       const gridWidth = textWidth + scaledPadding * 2;
       const gridHeight = textHeight + scaledPadding * 2;
       const centerX = -textWidth / 2 - bounds.x1;
       const centerY = -textHeight / 2 - bounds.y1;

       // Create warped path
       const warpedPath = new opentype.Path();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
               case 'L':
                   const x = cmd.x + centerX;
                   const y = cmd.y + centerY;
                   const warped = getWarpedPosition(
                       x, y,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   if (cmd.type === 'M') {
                       warpedPath.moveTo(warped.x, warped.y);
                   } else {
                       warpedPath.lineTo(warped.x, warped.y);
                   }
                   break;
               case 'C':
                   const x1 = cmd.x1 + centerX;
                   const y1 = cmd.y1 + centerY;
                   const x2 = cmd.x2 + centerX;
                   const y2 = cmd.y2 + centerY;
                   const x3 = cmd.x + centerX;
                   const y3 = cmd.y + centerY;
                   const warped1 = getWarpedPosition(x1, y1, obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows, gridLeft, gridTop, gridWidth, gridHeight, obj.gridDistort.intensity, obj.gridDistort.verticalOnly);
                   const warped2 = getWarpedPosition(x2, y2, obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows, gridLeft, gridTop, gridWidth, gridHeight, obj.gridDistort.intensity, obj.gridDistort.verticalOnly);
                   const warped3 = getWarpedPosition(x3, y3, obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows, gridLeft, gridTop, gridWidth, gridHeight, obj.gridDistort.intensity, obj.gridDistort.verticalOnly);
                   warpedPath.curveTo(warped1.x, warped1.y, warped2.x, warped2.y, warped3.x, warped3.y);
                   break;
               case 'Q':
                   const xQ1 = cmd.x1 + centerX;
                   const yQ1 = cmd.y1 + centerY;
                   const xQ2 = cmd.x + centerX;
                   const yQ2 = cmd.y + centerY;
                   const warpedQ1 = getWarpedPosition(xQ1, yQ1, obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows, gridLeft, gridTop, gridWidth, gridHeight, obj.gridDistort.intensity, obj.gridDistort.verticalOnly);
                   const warpedQ2 = getWarpedPosition(xQ2, yQ2, obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows, gridLeft, gridTop, gridWidth, gridHeight, obj.gridDistort.intensity, obj.gridDistort.verticalOnly);
                   warpedPath.quadraticCurveTo(warpedQ1.x, warpedQ1.y, warpedQ2.x, warpedQ2.y);
                   break;
               case 'Z':
                   warpedPath.close();
                   break;
           }
       }

       // Convert to Canvas Path2D and fill
       const canvasPath = new Path2D();
       for (let i = 0; i < warpedPath.commands.length; i++) {
           const cmd = warpedPath.commands[i];
           switch (cmd.type) {
               case 'M':
                   canvasPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   canvasPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   canvasPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   canvasPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   canvasPath.closePath();
                   break;
           }
       }

       maskCtx.fill(canvasPath);
       console.log('🎨 MASK: Created grid distort text mask');
   }

   function createMeshWarpTextMask(obj, maskCtx) {
       console.log('🎨 MASK: Creating mesh warp text mask for decorations');

       // Use the mesh warp handler if available
       if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler && activeMeshWarpHandler.selectedTextObject === obj) {
           // Create a temporary canvas for mesh warp rendering
           const tempCanvas = document.createElement('canvas');
           tempCanvas.width = 2000;
           tempCanvas.height = 2000;
           const tempCtx = tempCanvas.getContext('2d');
           tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);

           // Save original gradient and set to solid for mask
           const originalGradient = obj.gradient;
           obj.gradient = { type: 'solid' };

           // Draw mesh warped text
           activeMeshWarpHandler.drawWarpedTextInternal(tempCtx);

           // Restore gradient
           obj.gradient = originalGradient;

           // Copy to mask canvas
           maskCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);
       } else {
           // Fallback to normal text
           setTextContextOn(maskCtx, obj);
           maskCtx.fillText(obj.text, 0, 0);
       }

       console.log('🎨 MASK: Created mesh warp text mask');
   }

   // Function to create OpenType.js path with letter spacing for Grid Distort front outlines
   function createGridDistortPathWithLetterSpacing(font, text, fontSize, letterSpacing) {
       console.log('🔍 CREATING GRID DISTORT PATH WITH LETTER SPACING:', letterSpacing);

       // Create a composite path with letter spacing (same logic as main grid distort rendering)
       const path = new opentype.Path();
       let currentX = 0;

       // Process each character with letter spacing
       for (let i = 0; i < text.length; i++) {
           const char = text[i];
           // Get path for this character
           const charPath = font.getPath(char, currentX, 0, fontSize);

           // Add this character's path commands to the composite path
           if (charPath && charPath.commands) {
               for (const cmd of charPath.commands) {
                   path.commands.push(Object.assign({}, cmd));
               }
           }

           // Calculate character width for positioning the next character
           const charWidth = font.getAdvanceWidth(char, fontSize);

           // Move to the next character position with letter spacing
           currentX += charWidth + letterSpacing;  // ✅ Same as main rendering
       }

       console.log('🔍 CREATED GRID DISTORT PATH WITH', text.length, 'characters, final width:', currentX);
       return path;
   }

   // Function to draw front outline for Grid Distort effects
   function drawGridDistortFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, offsetX, offsetY, font) {
       console.log('🔍 FRONT OUTLINE SOURCE #1: drawGridDistortFrontOutline called from gradient masking system');
       console.log('🔍 FRONT OUTLINE #1 DETAILS:', {
           outlineColor,
           outlineOpacity,
           outlineWidth,
           offsetX,
           offsetY,
           effectMode: obj.effectMode,
           shadowMode: obj.shadowMode,
           hasGradient: obj.gradient && obj.gradient.type !== 'solid'
       });

       if (!font || !obj.gridDistort) {
           console.warn('Font or grid distort not available for front outline');
           return;
       }

       targetCtx.save();

       // Apply offset
       targetCtx.translate(offsetX, offsetY);

       // Set outline properties
       targetCtx.strokeStyle = outlineColor;
       targetCtx.globalAlpha = outlineOpacity;
       targetCtx.lineWidth = outlineWidth;

       // Use path-based approach for proper distortion (same as main grid distort rendering)
       targetCtx.lineJoin = 'round';
       targetCtx.lineCap = 'round';

       // Get text properties
       const text = obj.text;
       const fontSize = obj.fontSize || 100;
       const letterSpacing = obj._effectiveLetterSpacing || 0;

       // Handle letter spacing for Grid Distort front outlines
       let path;
       if (letterSpacing !== 0) {  // Handle both positive AND negative letter spacing
           console.log('🔍 GRID DISTORT FRONT OUTLINE: Using letter spacing:', letterSpacing);
           // Create individual paths for each letter with spacing
           path = createGridDistortPathWithLetterSpacing(font, text, fontSize, letterSpacing);
       } else {
           // Create a path for the entire text using OpenType.js (only when letterSpacing is exactly 0)
           console.log('🔍 GRID DISTORT FRONT OUTLINE: Using standard path (no letter spacing)');
           path = font.getPath(text, 0, 0, fontSize);
       }

       // Calculate grid bounds (same as main grid distort rendering)
       const tempMeasureCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(tempMeasureCtx, obj);

       // Calculate center offset (CRITICAL: same as main grid distort rendering)
       const bounds = path.getBoundingBox();

       // Use the same text dimensions calculation as main rendering
       const textWidth = obj.measuredWidth || (bounds.x2 - bounds.x1);
       const textHeight = obj.measuredHeight || (bounds.y2 - bounds.y1);

       // Calculate grid bounds with padding that scales with font size and accounts for stroke
       // CRITICAL: Use EXACT same padding calculation as main Grid Distort rendering
       const paddingScale = 0.5; // 50% of font size
       const basePadding = obj.gridDistort.gridPadding;
       const scaledPadding = Math.max(basePadding, fontSize * paddingScale);

       // Add extra padding for stroke to prevent clipping
       const strokePadding = (obj.strokeMode === "stroke" && obj.strokeWidth) ?
           Math.max(obj.strokeWidth * 30, 150) : 0; // 30x stroke width with 150px minimum

       // Add extra padding based on distortion intensity to account for extreme distortions
       // Use a more generous multiplier to ensure we capture all possible distortions
       const intensityPadding = (obj.gridDistort.intensity / 100) * Math.max(textWidth, textHeight) * 0.5;

       const totalPadding = scaledPadding + strokePadding + intensityPadding;

       const gridLeft = -textWidth/2 - totalPadding;
       const gridTop = -textHeight/2 - totalPadding;
       const gridWidth = textWidth + totalPadding * 2;
       const gridHeight = textHeight + totalPadding * 2;

       // Calculate center offset using the bounds we already have
       const centerX = -textWidth / 2 - bounds.x1;
       const centerY = -textHeight / 2 - bounds.y1;

       // Create warped path using the same logic as main grid distort rendering
       const warpedPath = new opentype.Path();

       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           let warpedX, warpedY;

           switch (cmd.type) {
               case 'M':
               case 'L':
                   const x = cmd.x + centerX;
                   const y = cmd.y + centerY;
                   const warped = getWarpedPosition(
                       x, y,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   warpedX = warped.x;
                   warpedY = warped.y;
                   if (cmd.type === 'M') {
                       warpedPath.moveTo(warpedX, warpedY);
                   } else {
                       warpedPath.lineTo(warpedX, warpedY);
                   }
                   break;
               case 'C':
                   const x1 = cmd.x1 + centerX;
                   const y1 = cmd.y1 + centerY;
                   const x2 = cmd.x2 + centerX;
                   const y2 = cmd.y2 + centerY;
                   const x3 = cmd.x + centerX;
                   const y3 = cmd.y + centerY;

                   const warped1 = getWarpedPosition(
                       x1, y1,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   const warped2 = getWarpedPosition(
                       x2, y2,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   const warped3 = getWarpedPosition(
                       x3, y3,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   warpedPath.curveTo(warped1.x, warped1.y, warped2.x, warped2.y, warped3.x, warped3.y);
                   break;
               case 'Q':
                   const xQ1 = cmd.x1 + centerX;
                   const yQ1 = cmd.y1 + centerY;
                   const xQ2 = cmd.x + centerX;
                   const yQ2 = cmd.y + centerY;

                   const warpedQ1 = getWarpedPosition(
                       xQ1, yQ1,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   const warpedQ2 = getWarpedPosition(
                       xQ2, yQ2,
                       obj.gridDistort.controlPoints, obj.gridDistort.gridCols, obj.gridDistort.gridRows,
                       gridLeft, gridTop, gridWidth, gridHeight,
                       obj.gridDistort.intensity, obj.gridDistort.verticalOnly
                   );
                   warpedPath.quadraticCurveTo(warpedQ1.x, warpedQ1.y, warpedQ2.x, warpedQ2.y);
                   break;
               case 'Z':
                   warpedPath.close();
                   break;
           }
       }

       // Convert OpenType.js path to Canvas Path2D and stroke it
       const canvasPath = new Path2D();
       for (let i = 0; i < warpedPath.commands.length; i++) {
           const cmd = warpedPath.commands[i];
           switch (cmd.type) {
               case 'M':
                   canvasPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   canvasPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   canvasPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   canvasPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   canvasPath.closePath();
                   break;
           }
       }

       // Draw the warped outline
       targetCtx.stroke(canvasPath);

       targetCtx.restore();
       console.log('🔍 FRONT OUTLINE SOURCE #1: drawGridDistortFrontOutline COMPLETED (gradient masking system)');
   }

   // Function to draw front outline for Curved text effects
   function drawCurvedFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, offsetX, offsetY) {
       console.log('🎨 GRADIENT MASK: Drawing Curved text front outline');

       targetCtx.save();

       // Apply offset
       targetCtx.translate(offsetX, offsetY);

       // Set outline properties
       targetCtx.strokeStyle = outlineColor;
       targetCtx.globalAlpha = outlineOpacity;
       targetCtx.lineWidth = outlineWidth;
       targetCtx.fillStyle = 'transparent';

       // Use the same curved text logic as the main curved text rendering
       const curveAmount = obj.curveAmount;
       const kerning = obj.curveKerning;
       const flip = obj.curveFlip;
       const text = (obj.text || '');

       setTextContextOn(targetCtx, obj);
       const direction = flip ? -1 : 1;
       const curveFactor = Math.max(0.1, Math.abs(curveAmount) / 10);
       const tempMeasureCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(tempMeasureCtx, obj);
       const textWidthEst = tempMeasureCtx.measureText(text).width;
       const curveRadius = (Math.max(2000, textWidthEst * 1.5) / curveFactor);
       const chars = text.split('');
       let totalWidth = 0;
       const charWidths = chars.map(char => {
           const width = targetCtx.measureText(char).width + kerning;
           totalWidth += width;
           return width;
       });
       let currentX = -totalWidth / 2;

       // Draw each character with stroke only
       for (let i = 0; i < chars.length; i++) {
           const letter = chars[i];
           const displayWidth = charWidths[i];
           const charCenterX = currentX + displayWidth / 2;
           const angleOffset = (charCenterX / curveRadius) * direction;
           const yOffset = curveRadius * (Math.cos(angleOffset) - 1) * direction;
           const rot = angleOffset * direction;

           targetCtx.save();
           targetCtx.translate(charCenterX, yOffset);
           targetCtx.rotate(rot);

           // Draw only the stroke (outline)
           targetCtx.strokeText(letter, 0, 0);

           targetCtx.restore();
           currentX += displayWidth;
       }

       targetCtx.restore();
       console.log('🎨 GRADIENT MASK: Drew Curved text front outline');
   }

   // Function to draw front outline for normal text effects
   function drawNormalFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, offsetX, offsetY) {
       console.log('🎨 NORMAL FRONT OUTLINE: Drawing normal text front outline with letter spacing:', obj.letterSpacing);

       targetCtx.save();

       // Apply offset
       targetCtx.translate(offsetX, offsetY);

       // Set outline properties
       targetCtx.strokeStyle = outlineColor;
       targetCtx.globalAlpha = outlineOpacity;
       targetCtx.lineWidth = outlineWidth;
       targetCtx.lineJoin = 'round';
       targetCtx.lineCap = 'round';

       // Set text properties
       setTextContextOn(targetCtx, obj);
       const text = (obj.text || '');
       const letterSpacing = obj.letterSpacing || 0;

       if (letterSpacing === 0) {
           // No letter spacing - use simple strokeText
           targetCtx.strokeText(text, 0, 0);
       } else {
           // Letter spacing - render character by character
           console.log('🔍 NORMAL FRONT OUTLINE: Using letter-by-letter rendering for letter spacing:', letterSpacing);

           // Calculate text width with letter spacing
           const letters = text.split('');
           let totalWidth = 0;

           // Sum the width of each letter
           letters.forEach(letter => {
               totalWidth += targetCtx.measureText(letter).width;
           });

           // Add letter spacing between characters
           if (letters.length > 1) {
               totalWidth += letterSpacing * (letters.length - 1);
           }

           // Start from the left edge of the text
           let currentX = -totalWidth / 2;

           // Draw each character with proper spacing
           for (let i = 0; i < letters.length; i++) {
               const letter = letters[i];
               const letterWidth = targetCtx.measureText(letter).width;

               // Draw the letter outline
               targetCtx.strokeText(letter, currentX + letterWidth / 2, 0);

               // Move to next character position
               currentX += letterWidth + letterSpacing;
           }
       }

       targetCtx.restore();
       console.log('🎨 NORMAL FRONT OUTLINE: Drew normal text front outline');
   }

   // Function to draw front outline for normal text effects with letter spacing
   function drawNormalFrontOutlineWithSpacing(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, offsetX, offsetY, letterSpacing) {
       console.log('🎨 NORMAL FRONT OUTLINE WITH SPACING: Drawing normal text front outline with letter spacing:', letterSpacing);

       targetCtx.save();

       // Apply offset
       targetCtx.translate(offsetX, offsetY);

       // Set outline properties
       targetCtx.strokeStyle = outlineColor;
       targetCtx.globalAlpha = outlineOpacity;
       targetCtx.lineWidth = outlineWidth;
       targetCtx.lineJoin = 'round';
       targetCtx.lineCap = 'round';

       // Set text properties
       setTextContextOn(targetCtx, obj);
       const text = (obj.text || '');

       // Letter spacing - render character by character
       console.log('🔍 NORMAL FRONT OUTLINE WITH SPACING: Using letter-by-letter rendering for letter spacing:', letterSpacing);

       // Calculate text width with letter spacing
       const letters = text.split('');
       let totalWidth = 0;

       // Sum the width of each letter
       letters.forEach(letter => {
           totalWidth += targetCtx.measureText(letter).width;
       });

       // Add letter spacing between characters
       if (letters.length > 1) {
           totalWidth += letterSpacing * (letters.length - 1);
       }

       // Start from the left edge of the text
       let currentX = -totalWidth / 2;

       // Draw each character with proper spacing
       for (let i = 0; i < letters.length; i++) {
           const letter = letters[i];
           const letterWidth = targetCtx.measureText(letter).width;

           // Draw the letter outline
           targetCtx.strokeText(letter, currentX + letterWidth / 2, 0);

           // Move to next character position
           currentX += letterWidth + letterSpacing;
       }

       targetCtx.restore();
       console.log('🎨 NORMAL FRONT OUTLINE WITH SPACING: Drew normal text front outline with spacing');
   }

   function drawCircularObject(obj, targetCtx) { // Added targetCtx
       console.log('🔄 CIRCULAR MAIN: drawCircularObject called', {
           text: obj.text,
           hasGradient: !!(obj.gradient && obj.gradient.type !== 'solid'),
           gradientType: obj.gradient?.type,
           targetCtxExists: !!targetCtx,
           targetCanvasWidth: targetCtx?.canvas?.width,
           targetCanvasHeight: targetCtx?.canvas?.height,
           targetCanvasId: targetCtx?.canvas?.id || 'no-id',
           isMainCanvas: targetCtx?.canvas === canvas
       });

       // Check if we need to apply gradient masking
       if (obj.gradient && obj.gradient.type !== 'solid') {
           console.log('🔄 CIRCULAR MAIN: Using gradient masking path');
           drawCircularObjectWithGradientMask(obj, targetCtx);
           return;
       }

       // Otherwise draw normally
       console.log('🔄 CIRCULAR MAIN: Using normal rendering path');
       drawCircularObjectInternal(obj, targetCtx);
   }

   function drawCircularObjectInternal(obj, targetCtx) { // Added targetCtx
       console.log('🔄 CIRCULAR START: High-quality direct rendering circular text', {
           text: obj.text,
           diameter: obj.circleDiameter,
           kerning: obj.circleKerning,
           flipped: obj.circleFlip
       });

       const diameter = obj.circleDiameter;
       const kerning = obj.circleKerning;
       const flipped = obj.circleFlip;
       const text = (obj.text || '');
       if (!text) {
           console.log('🔄 CIRCULAR ABORT: No text to render');
           return;
       }

       const radius = diameter / 2;
       const contentArr = text.split('');
       const letterAngles = [];
       let totalAngle = 0;

       // Set up high-quality rendering context
       targetCtx.save();
       setTextContextOn(targetCtx, obj);
       targetCtx.textRenderingOptimization = 'optimizeQuality';
       targetCtx.imageSmoothingEnabled = true;
       targetCtx.imageSmoothingQuality = 'high';

       console.log('🔄 CIRCULAR SETUP: High-quality context configured');

       // Calculate letter angles using the target context for accurate measurements
       contentArr.forEach((letter, index) => {
           const letterWidth = targetCtx.measureText(letter).width + kerning;
           const letterAngle = radius > 0 ? (letterWidth / radius) * (180 / Math.PI) : 0;
           letterAngles.push(letterAngle);
           totalAngle += letterAngle;
           console.log(`🔄 CIRCULAR LETTER ${index}: "${letter}" width=${letterWidth.toFixed(2)} angle=${letterAngle.toFixed(2)}`);
       });

       console.log('🔄 CIRCULAR ANGLES: Total angle calculated', {
           totalAngle: totalAngle.toFixed(2),
           letterCount: contentArr.length,
           averageAngle: (totalAngle / contentArr.length).toFixed(2)
       });

       // Start angle to center the text
       let currentAngleRad = (-totalAngle / 2) * Math.PI / 180;
       console.log('🔄 CIRCULAR LOOP: Starting direct letter rendering', {
           startAngleRad: currentAngleRad.toFixed(4),
           startAngleDeg: (currentAngleRad * 180 / Math.PI).toFixed(2),
           totalLetters: contentArr.length
       });

       // Render each letter directly (no offscreen canvas)
       for (let i = 0; i < contentArr.length; i++) {
           const letter = contentArr[i];
           const letterAngleDeg = letterAngles[i];
           const letterAngleRad = letterAngleDeg * Math.PI / 180;
           const halfAngleRad = letterAngleRad / 2;

           currentAngleRad += halfAngleRad;

           // Calculate position
           const angleToDraw = flipped ? currentAngleRad + Math.PI : currentAngleRad;
           const x = radius * Math.cos(angleToDraw);
           const y = radius * Math.sin(angleToDraw);

           console.log(`🔄 CIRCULAR ${i}: Letter "${letter}" at position (${x.toFixed(2)}, ${y.toFixed(2)}), angle: ${(angleToDraw * 180 / Math.PI).toFixed(2)}°`);

           // Save context and apply transforms
           targetCtx.save();
           targetCtx.translate(x, y);
           let rot = angleToDraw + Math.PI / 2;
           if (flipped) { rot += Math.PI; }
           targetCtx.rotate(rot);

           // Apply complex shadow effects BEFORE drawing the letter
           const letterObj = { ...obj, text: letter };
           if (obj.shadowMode === 'blockShadow') {
               applyBlockShadow(targetCtx, letterObj, 0, 0);
           } else if (obj.shadowMode === 'perspectiveShadow') {
               applyPerspectiveShadow(targetCtx, letterObj, 0, 0);
           } else if (obj.shadowMode === 'lineShadow') {
               applyLineShadow(targetCtx, letterObj, 0, 0);
           } else if (obj.shadowMode === 'detailed3D') {
               applyDetailed3D_ExtrusionOnly(targetCtx, letterObj, 0, 0);
           } else if (obj.shadowMode === 'shadow') {
               // Standard shadow using canvas properties
               targetCtx.shadowColor = obj.shadowColor || '#000000';
               targetCtx.shadowOffsetX = obj.shadowOffsetX || 5;
               targetCtx.shadowOffsetY = obj.shadowOffsetY || 5;
               targetCtx.shadowBlur = obj.shadowBlur || 10;
           } else {
               // Clear any existing shadow
               targetCtx.shadowColor = 'transparent';
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
               targetCtx.shadowBlur = 0;
           }

           // Apply decoration effects using inline logic (similar to existing code)
           let letterFillStyle = obj.color;

           // 🔍 CIRCULAR GRADIENT FIX: Check for gradient and apply it per letter
           console.log(`🔄 CIRCULAR GRADIENT ${i}: Checking for gradient on letter "${letter}"`);
           const shouldUseGradient = obj.gradient && obj.gradient.type !== 'solid';
           console.log(`🔄 CIRCULAR GRADIENT ${i}: Should use gradient:`, shouldUseGradient);
           console.log(`🔄 CIRCULAR GRADIENT ${i}: obj.gradient:`, obj.gradient);

           if (shouldUseGradient) {
               console.log(`🔄 CIRCULAR GRADIENT ${i}: Applying gradient to letter "${letter}"`);

               if (obj.gradient.type === 'linear') {
                   const angle = obj.gradient.gradient.angle || 0;
                   const angleRad = (angle * Math.PI) / 180;

                   // 🔧 HIGH-DPI FIX: Scale gradient coordinates for high-resolution canvas
                   const transform = targetCtx.getTransform();
                   const scaleFactor = transform.a; // Current scale factor from high-DPI setup
                   console.log(`🔄 CIRCULAR GRADIENT SCALE ${i}: Current scale factor: ${scaleFactor}`);

                   // Create gradient for this letter's coordinate system with proper scaling
                   const gradientLength = diameter * scaleFactor;
                   console.log(`🔄 CIRCULAR GRADIENT SCALE ${i}: Original diameter=${diameter}, scaled gradientLength=${gradientLength}`);

                   const startX = -gradientLength / 2 * Math.cos(angleRad);
                   const startY = -gradientLength / 2 * Math.sin(angleRad);
                   const endX = gradientLength / 2 * Math.cos(angleRad);
                   const endY = gradientLength / 2 * Math.sin(angleRad);

                   console.log(`🔄 CIRCULAR GRADIENT COORDS ${i}: startX=${startX.toFixed(2)}, startY=${startY.toFixed(2)}, endX=${endX.toFixed(2)}, endY=${endY.toFixed(2)}`);

                   const gradient = targetCtx.createLinearGradient(startX, startY, endX, endY);

                   // Add color stops
                   obj.gradient.gradient.colors.forEach(colorStop => {
                       const position = colorStop.position / 100;
                       gradient.addColorStop(position, colorStop.color);
                   });

                   letterFillStyle = gradient;
                   console.log(`🔄 CIRCULAR GRADIENT ${i}: Applied linear gradient to letter "${letter}"`);

               } else if (obj.gradient.type === 'radial') {
                   // 🔧 HIGH-DPI FIX: Scale radial gradient radius for high-resolution canvas
                   const transform = targetCtx.getTransform();
                   const scaleFactor = transform.a; // Current scale factor from high-DPI setup
                   const scaledRadius = radius * scaleFactor;
                   console.log(`🔄 CIRCULAR GRADIENT SCALE ${i}: Original radius=${radius}, scaled radius=${scaledRadius}`);

                   const gradient = targetCtx.createRadialGradient(0, 0, 0, 0, 0, scaledRadius);

                   // Add color stops
                   obj.gradient.gradient.colors.forEach(colorStop => {
                       const position = colorStop.position / 100;
                       gradient.addColorStop(position, colorStop.color);
                   });

                   letterFillStyle = gradient;
                   console.log(`🔄 CIRCULAR GRADIENT ${i}: Applied radial gradient to letter "${letter}" with scaled radius=${scaledRadius}`);
               }
           } else {
               console.log(`🔄 CIRCULAR GRADIENT ${i}: Using solid color for letter "${letter}":`, obj.color);
           }

           if (obj.decorationMode === 'horizontalLines') {
               const weight = obj.hLineWeight || 3;
               const distance = obj.hLineDist || 7;
               const baseLineColor = obj.hLineColor || '#0000FF';
               const lineOpacity = (obj.hLineOpacity || 100) / 100;
               const baseColor = obj.color;
               const totalHeight = weight + distance;
               const patternCanvas = document.createElement("canvas");
               patternCanvas.width = 10;
               patternCanvas.height = totalHeight;
               const pCtx = patternCanvas.getContext("2d");
               pCtx.fillStyle = baseColor;
               pCtx.fillRect(0, 0, 10, totalHeight);
               let color;
               if (baseLineColor.startsWith('#')) {
                   const hex = baseLineColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`;
               } else {
                   color = baseLineColor;
               }
               pCtx.fillStyle = color;
               pCtx.fillRect(0, 0, 10, weight);
               try {
                   letterFillStyle = targetCtx.createPattern(patternCanvas, "repeat");
               } catch (e) {
                   console.error("Error creating HLines pattern for circular text:", e);
                   letterFillStyle = obj.color;
               }
           } else if (obj.decorationMode === 'colorCut') {
               // Create proper color cut effect for circular text
               const distancePercent = (obj.ccDist || 50) / 100;
               const baseColor = obj.ccColor || '#0000FF';
               const colorOpacity = (obj.ccOpacity || 100) / 100;
               const textBaseColor = obj.color;
               const fillDirection = obj.ccFillDir || 'top';

               // Create a vertical gradient for the letter
               const letterHeight = obj.fontSize || 50;
               const gradStartY = -letterHeight / 2;
               const gradEndY = letterHeight / 2;

               let gradient = targetCtx.createLinearGradient(0, gradStartY, 0, gradEndY);

               // Parse base color and text color
               let decorColor, textColor;
               if (baseColor.startsWith('#')) {
                   const hex = baseColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   decorColor = {r, g, b};
               } else {
                   decorColor = {r: 0, g: 0, b: 255}; // Default blue
               }

               if (textBaseColor.startsWith('#')) {
                   const hex = textBaseColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   textColor = {r, g, b};
               } else {
                   textColor = {r: 0, g: 0, b: 0}; // Default black
               }

               // Blend colors based on opacity
               const blendedR = Math.round(decorColor.r * colorOpacity + textColor.r * (1 - colorOpacity));
               const blendedG = Math.round(decorColor.g * colorOpacity + textColor.g * (1 - colorOpacity));
               const blendedB = Math.round(decorColor.b * colorOpacity + textColor.b * (1 - colorOpacity));
               const blendedColor = `rgb(${blendedR}, ${blendedG}, ${blendedB})`;

               if (fillDirection === 'top') {
                   gradient.addColorStop(0, blendedColor);
                   gradient.addColorStop(distancePercent, blendedColor);
                   gradient.addColorStop(Math.min(1, distancePercent + 0.001), textBaseColor);
                   gradient.addColorStop(1, textBaseColor);
               } else {
                   gradient.addColorStop(0, textBaseColor);
                   gradient.addColorStop(Math.max(0, 1 - distancePercent - 0.001), textBaseColor);
                   gradient.addColorStop(1 - distancePercent, blendedColor);
                   gradient.addColorStop(1, blendedColor);
               }
               letterFillStyle = gradient;
           } else if (obj.decorationMode === 'obliqueLines') {
               // Create oblique lines pattern
               const weight = obj.oLineWeight || 4;
               const distance = obj.oLineDist || 3;
               const baseLineColor = obj.oLineColor || '#0000FF';
               const lineOpacity = (obj.oOpacity || 100) / 100;
               const baseColor = obj.color;
               const size = weight + distance;
               const patternCanvas = document.createElement("canvas");
               patternCanvas.width = size;
               patternCanvas.height = size;
               const pCtx = patternCanvas.getContext("2d");
               pCtx.fillStyle = baseColor;
               pCtx.fillRect(0, 0, size, size);
               let color;
               if (baseLineColor.startsWith('#')) {
                   const hex = baseLineColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   color = `rgba(${r}, ${g}, ${b}, ${lineOpacity})`;
               } else {
                   color = baseLineColor;
               }
               pCtx.strokeStyle = color;
               pCtx.lineWidth = weight;
               pCtx.beginPath();
               for (let i = -size; i < size * 2; i += size) {
                   pCtx.moveTo(i - distance, -distance);
                   pCtx.lineTo(i + size + distance, size + distance);
               }
               pCtx.stroke();
               try {
                   letterFillStyle = targetCtx.createPattern(patternCanvas, "repeat");
               } catch (e) {
                   console.error("Error creating OLines pattern for circular text:", e);
                   letterFillStyle = obj.color;
               }
           } else if (obj.decorationMode === 'fadingLinesCut') {
               // Create proper fading lines cut effect for circular text
               console.log('🎨 CIRCULAR FADING LINES: Applying fading lines decoration to letter:', letter);
               const distancePercent = (obj.flcDist || 50) / 100;
               const direction = obj.flcDir || 'top';
               const baseLineColor = obj.flcColor || '#0000FF';
               const lineOpacity = (obj.flcOpacity || 100) / 100;
               const weight = obj.flcWeight || 5;
               const spacing = obj.flcSpacing || 10; // Add spacing parameter
               const baseColor = obj.color;
               console.log('🎨 CIRCULAR FADING LINES: Parameters:', {
                   distancePercent, direction, baseLineColor, lineOpacity, weight, spacing, baseColor
               });

               // Parse colors for blending
               let decorColor, textColor;
               if (baseLineColor.startsWith('#')) {
                   const hex = baseLineColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   decorColor = {r, g, b};
               } else {
                   decorColor = {r: 0, g: 0, b: 255}; // Default blue
               }

               if (baseColor.startsWith('#')) {
                   const hex = baseColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   textColor = {r, g, b};
               } else {
                   textColor = {r: 0, g: 0, b: 0}; // Default black
               }

               // Create solid color for the main block
               const solidBlendedR = Math.round(decorColor.r * lineOpacity + textColor.r * (1 - lineOpacity));
               const solidBlendedG = Math.round(decorColor.g * lineOpacity + textColor.g * (1 - lineOpacity));
               const solidBlendedB = Math.round(decorColor.b * lineOpacity + textColor.b * (1 - lineOpacity));
               const solidBlendedColor = `rgb(${solidBlendedR}, ${solidBlendedG}, ${solidBlendedB})`;

               // Create a gradient with solid block + fading lines
               const letterHeight = obj.fontSize || 50;
               const gradStartY = -letterHeight / 2;
               const gradEndY = letterHeight / 2;

               let gradient = targetCtx.createLinearGradient(0, gradStartY, 0, gradEndY);

               const isBottomToTop = direction === 'bottom-to-top';
               const lineWidth = Math.max(1, weight) / letterHeight; // Convert weight to relative size
               const lineSpacing = Math.max(1, spacing) / letterHeight; // Convert spacing to relative size
               const totalLineStep = lineWidth + lineSpacing;
               console.log('🎨 CIRCULAR FADING LINES: Calculated values:', {
                   lineWidth, lineSpacing, totalLineStep, letterHeight, weight, spacing
               });

               // Split the distance: 70% solid block, 30% fading lines
               const solidBlockPercent = distancePercent * 0.7;
               const fadingLinesPercent = distancePercent * 0.3;

               if (isBottomToTop) {
                   const startPos = 1 - distancePercent;
                   const solidBlockStart = 1 - solidBlockPercent;

                   gradient.addColorStop(0, baseColor);
                   gradient.addColorStop(Math.max(0, startPos - 0.001), baseColor);

                   // Solid block area - ensure it's visible
                   gradient.addColorStop(startPos, solidBlendedColor);
                   gradient.addColorStop(solidBlockStart, solidBlendedColor);

                   // Fading lines area
                   const numLines = Math.floor(fadingLinesPercent / totalLineStep);
                   for (let i = 0; i < numLines; i++) {
                       const linePos = solidBlockStart + (i * totalLineStep);
                       const fadeAmount = 1 - (i / Math.max(1, numLines - 1)); // Fade as we go up
                       const currentOpacity = lineOpacity * fadeAmount;

                       // Blend colors for this line
                       const blendedR = Math.round(decorColor.r * currentOpacity + textColor.r * (1 - currentOpacity));
                       const blendedG = Math.round(decorColor.g * currentOpacity + textColor.g * (1 - currentOpacity));
                       const blendedB = Math.round(decorColor.b * currentOpacity + textColor.b * (1 - currentOpacity));
                       const blendedColor = `rgb(${blendedR}, ${blendedG}, ${blendedB})`;

                       if (linePos < 1) {
                           gradient.addColorStop(linePos, baseColor);
                           gradient.addColorStop(Math.min(1, linePos + lineWidth), blendedColor);
                           if (linePos + lineWidth + lineSpacing < 1) {
                               gradient.addColorStop(Math.min(1, linePos + lineWidth + lineSpacing), baseColor);
                           }
                       }
                   }
                   gradient.addColorStop(1, baseColor);
               } else {
                   // Top to bottom - ensure solid block is visible
                   gradient.addColorStop(0, solidBlendedColor);
                   gradient.addColorStop(solidBlockPercent, solidBlendedColor);
                   gradient.addColorStop(Math.min(1, solidBlockPercent + 0.001), baseColor);

                   // Fading lines area
                   const numLines = Math.floor(fadingLinesPercent / totalLineStep);
                   for (let i = 0; i < numLines; i++) {
                       const linePos = solidBlockPercent + (i * totalLineStep);
                       const fadeAmount = 1 - (i / Math.max(1, numLines - 1)); // Fade as we go down
                       const currentOpacity = lineOpacity * fadeAmount;

                       // Blend colors for this line
                       const blendedR = Math.round(decorColor.r * currentOpacity + textColor.r * (1 - currentOpacity));
                       const blendedG = Math.round(decorColor.g * currentOpacity + textColor.g * (1 - currentOpacity));
                       const blendedB = Math.round(decorColor.b * currentOpacity + textColor.b * (1 - currentOpacity));
                       const blendedColor = `rgb(${blendedR}, ${blendedG}, ${blendedB})`;

                       if (linePos < distancePercent) {
                           gradient.addColorStop(linePos, baseColor);
                           gradient.addColorStop(Math.min(distancePercent, linePos + lineWidth), blendedColor);
                           if (linePos + lineWidth + lineSpacing < distancePercent) {
                               gradient.addColorStop(Math.min(distancePercent, linePos + lineWidth + lineSpacing), baseColor);
                           }
                       }
                   }
                   gradient.addColorStop(distancePercent, baseColor);
                   gradient.addColorStop(1, baseColor);
               }

               letterFillStyle = gradient;
           } else if (obj.decorationMode === 'diagonalLines') {
               // Similar to oblique lines but different angle
               letterFillStyle = obj.color; // Simplified for now
           }

           // Set the fill style (either solid color or decoration pattern)
           targetCtx.fillStyle = letterFillStyle;

           // Apply stroke if needed (check both strokeMode and strokeWidth)
           if (obj.strokeMode === 'stroke' && obj.strokeWidth && obj.strokeWidth > 0) {
               targetCtx.lineWidth = obj.strokeWidth;
               targetCtx.strokeStyle = obj.strokeColor;
               targetCtx.strokeText(letter, 0, 0);
           }

           // Draw the letter
           targetCtx.fillText(letter, 0, 0);

           targetCtx.restore();

           currentAngleRad += halfAngleRad;
           console.log(`🔄 CIRCULAR COMPLETE ${i}: Finished rendering "${letter}"`);
       }

       targetCtx.restore();

       console.log('🔄 CIRCULAR COMPLETE: Finished rendering all letters for circular text', {
           totalLettersRendered: contentArr.length,
           text: obj.text
       });

       // Debug: Check if anything is on the canvas after circular text rendering
       // Check the center area where circular text is likely positioned
       const centerX = targetCtx.canvas.width / 2;
       const centerY = targetCtx.canvas.height / 2;
       const checkSize = 200; // Check a larger area around center
       const checkX = Math.max(0, centerX - checkSize / 2);
       const checkY = Math.max(0, centerY - checkSize / 2);
       const checkW = Math.min(checkSize, targetCtx.canvas.width - checkX);
       const checkH = Math.min(checkSize, targetCtx.canvas.height - checkY);

       const imageData = targetCtx.getImageData(checkX, checkY, checkW, checkH);
       const hasPixels = Array.from(imageData.data).some((value, index) => index % 4 === 3 && value > 0);
       console.log('🔄 CIRCULAR DEBUG: Canvas state after rendering', {
           canvasWidth: targetCtx.canvas.width,
           canvasHeight: targetCtx.canvas.height,
           checkArea: { x: checkX, y: checkY, w: checkW, h: checkH },
           hasVisiblePixels: hasPixels,
           sampleAlphaValues: Array.from(imageData.data).filter((_, i) => i % 4 === 3).slice(0, 10)
       });

       // Add front outlines for circular text without gradients
       console.log('🔍 RENDER ORDER: Step 8 - Drawing front outlines on top for Circular text (no gradient)');
       if (obj.shadowMode === 'perspectiveShadow' && obj.perspectiveShadowOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for Circular text (no gradient)');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = obj.perspectiveShadowOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
       if (obj.shadowMode === 'detailed3D' && obj.d3dSecondaryWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for Circular text (no gradient)');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = obj.d3dSecondaryWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;
           drawCircularFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
   }
   function drawCurvedObject(obj, targetCtx) { // Added targetCtx
       const curveAmount = obj.curveAmount;
       const kerning = obj.curveKerning;
       const flip = obj.curveFlip;
       const text = (obj.text || '');
       if (!text || curveAmount === 0) {
           drawNormalOrSkewObject(obj, targetCtx); // Pass targetCtx
           return;
       }

       // Check if we need to apply gradient masking
       if (obj.gradient && obj.gradient.type !== 'solid') {
           drawCurvedObjectWithGradientMask(obj, targetCtx);
           return;
       }
       setTextContextOn(targetCtx, obj); // Use targetCtx
       const direction = flip ? -1 : 1;
       const curveFactor = Math.max(0.1, Math.abs(curveAmount) / 10);
       const tempMeasureCtx = document.createElement('canvas').getContext('2d'); // Use separate context for measurement
       setTextContextOn(tempMeasureCtx, obj);
       const textWidthEst = tempMeasureCtx.measureText(text).width;
       const curveRadius = (Math.max(w, textWidthEst * 1.5) / curveFactor); // w is global canvas width, maybe use targetCtx.canvas.width? Needs check.
       const chars = text.split('');
       let totalWidth = 0;
       const charWidths = chars.map(char => {
           const width = targetCtx.measureText(char).width + kerning; // Use targetCtx
           totalWidth += width;
           return width;
       });
       let currentX = -totalWidth / 2;
       for (let i = 0; i < chars.length; i++) {
           const letter = chars[i];
           const displayWidth = charWidths[i];

           // Create letter object with original text for gradient calculation
           const letterObj = { ...obj, text: letter, originalText: obj.text };
           const letterInfo = renderSingleStyledLetter(letterObj, letter, letterCtx, letterCanvas.width / offscreenScaleFactor, letterCanvas.height / offscreenScaleFactor, i, chars.length);
           const charCenterX = currentX + displayWidth / 2;
           const angleOffset = (charCenterX / curveRadius) * direction;
           const yOffset = curveRadius * (Math.cos(angleOffset) - 1) * direction;
           const rot = angleOffset * direction;
           targetCtx.save(); // Use targetCtx
           targetCtx.translate(charCenterX, yOffset); // Use targetCtx
           targetCtx.rotate(rot); // Use targetCtx
           try {
               // Calculate source rectangle with generous padding for effects
               const effectsPadding = Math.max(
                   letterSourcePadding * 2,                // Base padding
                   obj.fontSize * 0.5,                     // Scale with font size
                   obj.shadowOffsetX + obj.shadowBlur * 2, // Account for shadow
                   obj.d3dOffset + obj.d3dBlur * 2,        // Account for 3D effects
                   obj.blockShadowOffset * 1.5,            // Account for block shadow
                   obj.strokeWidth * 3                     // Account for stroke
               );

               const sourceW = letterInfo.width + effectsPadding * 2;
               const sourceH = letterInfo.height + effectsPadding * 2;
               const sourceX = letterInfo.centerX - sourceW / 2;
               const sourceY = letterInfo.centerY - sourceH / 2;
               const destX = -sourceW / 2;
               const destY = -sourceH / 2;

               if (sourceX >= 0 && sourceY >= 0 && sourceW > 0 && sourceH > 0 &&
                   sourceX + sourceW <= letterCanvas.width && sourceY + sourceH <= letterCanvas.height) {
                   // Draw the letter from offscreen canvas to the target canvas
                   targetCtx.drawImage(letterCanvas, sourceX, sourceY, sourceW, sourceH, destX, destY, sourceW, sourceH);
               } else {
                   // Fallback: Use a centered portion of the letter canvas
                   const safeWidth = Math.min(letterCanvas.width * 0.8, sourceW);
                   const safeHeight = Math.min(letterCanvas.height * 0.8, sourceH);
                   const safeSx = (letterCanvas.width - safeWidth) / 2;
                   const safeSy = (letterCanvas.height - safeHeight) / 2;

                   targetCtx.drawImage(letterCanvas, safeSx, safeSy, safeWidth, safeHeight,
                       -safeWidth/2, -safeHeight/2, safeWidth, safeHeight);
               }
           } catch(e) { console.error("DrawImage error in curve:", e); }
           targetCtx.restore(); // Use targetCtx
           currentX += displayWidth;
       }

       // Add front outlines for curved text without gradients
       console.log('🔍 RENDER ORDER: Step 8 - Drawing front outlines on top for Curved text (no gradient)');
       if (obj.shadowMode === 'perspectiveShadow' && obj.perspectiveShadowOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for Curved text (no gradient)');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = obj.perspectiveShadowOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;
           drawCurvedFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
       if (obj.shadowMode === 'detailed3D' && obj.d3dSecondaryWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for Curved text (no gradient)');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = obj.d3dSecondaryWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;
           drawCurvedFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
   }

   // Gradient masking function for curved text
   function drawCurvedObjectWithGradientMask(obj, targetCtx) {
       console.log('🎨 GRADIENT MASK: Drawing curved text with gradient mask');

       // Save original gradient
       const originalGradient = obj.gradient;

       // Step 1: Create a temporary canvas for effects and text with solid color with high-DPI scaling
       const tempCanvas = document.createElement('canvas');
       const scaleFactor = targetCtx.canvas.scaleFactor || 4; // Use same scale as main canvas
       tempCanvas.width = 2000 * scaleFactor;
       tempCanvas.height = 2000 * scaleFactor;
       const tempCtx = tempCanvas.getContext('2d');
       // tempCtx.scale(scaleFactor, scaleFactor); // REMOVED: Canvas already sized with scaleFactor
       tempCtx.imageSmoothingEnabled = true;
       tempCtx.imageSmoothingQuality = 'high';

       // Step 2: Draw effects and text with solid color to temp canvas
       tempCtx.save();
       tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
       obj.gradient = { type: 'solid' };

       // Draw curved text with effects using the same logic as the main function
       const curveAmount = obj.curveAmount;
       const kerning = obj.curveKerning;
       const flip = obj.curveFlip;
       const text = (obj.text || '');

       setTextContextOn(tempCtx, obj);
       const direction = flip ? -1 : 1;
       const curveFactor = Math.max(0.1, Math.abs(curveAmount) / 10);
       const tempMeasureCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(tempMeasureCtx, obj);
       const textWidthEst = tempMeasureCtx.measureText(text).width;
       const curveRadius = (Math.max(2000, textWidthEst * 1.5) / curveFactor);
       const chars = text.split('');
       let totalWidth = 0;
       const charWidths = chars.map(char => {
           const width = tempCtx.measureText(char).width + kerning;
           totalWidth += width;
           return width;
       });
       let currentX = -totalWidth / 2;

       for (let i = 0; i < chars.length; i++) {
           const letter = chars[i];
           const displayWidth = charWidths[i];

           const letterObj = { ...obj, text: letter, originalText: obj.text };
           const letterInfo = renderSingleStyledLetter(letterObj, letter, letterCtx, letterCanvas.width / offscreenScaleFactor, letterCanvas.height / offscreenScaleFactor, i, chars.length);
           const charCenterX = currentX + displayWidth / 2;
           const angleOffset = (charCenterX / curveRadius) * direction;
           const yOffset = curveRadius * (Math.cos(angleOffset) - 1) * direction;
           const rot = angleOffset * direction;

           tempCtx.save();
           tempCtx.translate(charCenterX, yOffset);
           tempCtx.rotate(rot);

           try {
               const effectsPadding = Math.max(
                   letterSourcePadding * 2,
                   obj.fontSize * 0.5,
                   obj.shadowOffsetX + obj.shadowBlur * 2,
                   obj.d3dOffset + obj.d3dBlur * 2,
                   obj.blockShadowOffset * 1.5,
                   obj.strokeWidth * 3
               );

               const sourceW = letterInfo.width + effectsPadding * 2;
               const sourceH = letterInfo.height + effectsPadding * 2;
               const sourceX = letterInfo.centerX - sourceW / 2;
               const sourceY = letterInfo.centerY - sourceH / 2;
               const destX = -sourceW / 2;
               const destY = -sourceH / 2;

               if (sourceX >= 0 && sourceY >= 0 && sourceW > 0 && sourceH > 0 &&
                   sourceX + sourceW <= letterCanvas.width && sourceY + sourceH <= letterCanvas.height) {
                   tempCtx.drawImage(letterCanvas, sourceX, sourceY, sourceW, sourceH, destX, destY, sourceW, sourceH);
               } else {
                   const safeWidth = Math.min(letterCanvas.width * 0.8, sourceW);
                   const safeHeight = Math.min(letterCanvas.height * 0.8, sourceH);
                   const safeSx = (letterCanvas.width - safeWidth) / 2;
                   const safeSy = (letterCanvas.height - safeHeight) / 2;

                   tempCtx.drawImage(letterCanvas, safeSx, safeSy, safeWidth, safeHeight,
                       -safeWidth/2, -safeHeight/2, safeWidth, safeHeight);
               }
           } catch(e) {
               console.error("DrawImage error in curved temp:", e);
           }

           tempCtx.restore();
           currentX += displayWidth;
       }

       tempCtx.restore();

       // Step 3: Create text-only canvas for masking with high-DPI scaling
       const textCanvas = document.createElement('canvas');
       textCanvas.width = 2000 * scaleFactor;
       textCanvas.height = 2000 * scaleFactor;
       const textCtx = textCanvas.getContext('2d');
       // textCtx.scale(scaleFactor, scaleFactor); // REMOVED: Canvas already sized with scaleFactor
       textCtx.imageSmoothingEnabled = true;
       textCtx.imageSmoothingQuality = 'high';

       // Draw curved text in white on transparent background (text only, no effects)
       textCtx.save();
       textCtx.translate(textCanvas.width / 2, textCanvas.height / 2);
       textCtx.fillStyle = 'white';

       // Create a temporary object without gradient and effects for shape rendering
       const tempObj = {
           ...obj,
           gradient: { type: 'solid' },
           shadowMode: 'none',
           strokeWidth: 0
       };

       // Use the existing curved text logic but with solid color
       const maskCurveAmount = tempObj.curveAmount;
       const maskKerning = tempObj.curveKerning;
       const maskFlip = tempObj.curveFlip;
       const maskText = (tempObj.text || '');

       setTextContextOn(textCtx, tempObj);
       const maskDirection = maskFlip ? -1 : 1;
       const maskCurveFactor = Math.max(0.1, Math.abs(maskCurveAmount) / 10);
       const maskMeasureCtx = document.createElement('canvas').getContext('2d');
       setTextContextOn(maskMeasureCtx, tempObj);
       const maskTextWidthEst = maskMeasureCtx.measureText(maskText).width;
       const maskCurveRadius = (Math.max(2000, maskTextWidthEst * 1.5) / maskCurveFactor); // Use canvas width instead of global w
       const maskChars = maskText.split('');
       let maskTotalWidth = 0;
       const maskCharWidths = maskChars.map(char => {
           const width = textCtx.measureText(char).width + maskKerning;
           maskTotalWidth += width;
           return width;
       });
       let maskCurrentX = -maskTotalWidth / 2;

       for (let i = 0; i < maskChars.length; i++) {
           const letter = maskChars[i];
           const displayWidth = maskCharWidths[i];

           const letterObj = { ...tempObj, text: letter, originalText: tempObj.text };
           const letterInfo = renderSingleStyledLetter(letterObj, letter, letterCtx, letterCanvas.width / offscreenScaleFactor, letterCanvas.height / offscreenScaleFactor, i, maskChars.length);
           const charCenterX = maskCurrentX + displayWidth / 2;
           const angleOffset = (charCenterX / maskCurveRadius) * maskDirection;
           const yOffset = maskCurveRadius * (Math.cos(angleOffset) - 1) * maskDirection;
           const rot = angleOffset * maskDirection;

           textCtx.save();
           textCtx.translate(charCenterX, yOffset);
           textCtx.rotate(rot);

           try {
               const effectsPadding = Math.max(
                   letterSourcePadding * 2,
                   tempObj.fontSize * 0.5,
                   tempObj.shadowOffsetX + tempObj.shadowBlur * 2,
                   tempObj.d3dOffset + tempObj.d3dBlur * 2,
                   tempObj.blockShadowOffset * 1.5,
                   tempObj.strokeWidth * 3
               );

               const sourceW = letterInfo.width + effectsPadding * 2;
               const sourceH = letterInfo.height + effectsPadding * 2;
               const sourceX = letterInfo.centerX - sourceW / 2;
               const sourceY = letterInfo.centerY - sourceH / 2;
               const destX = -sourceW / 2;
               const destY = -sourceH / 2;

               if (sourceX >= 0 && sourceY >= 0 && sourceW > 0 && sourceH > 0 &&
                   sourceX + sourceW <= letterCanvas.width && sourceY + sourceH <= letterCanvas.height) {
                   textCtx.drawImage(letterCanvas, sourceX, sourceY, sourceW, sourceH, destX, destY, sourceW, sourceH);
               } else {
                   const safeWidth = Math.min(letterCanvas.width * 0.8, sourceW);
                   const safeHeight = Math.min(letterCanvas.height * 0.8, sourceH);
                   const safeSx = (letterCanvas.width - safeWidth) / 2;
                   const safeSy = (letterCanvas.height - safeHeight) / 2;

                   textCtx.drawImage(letterCanvas, safeSx, safeSy, safeWidth, safeHeight,
                       -safeWidth/2, -safeHeight/2, safeWidth, safeHeight);
               }
           } catch(e) {
               console.error("DrawImage error in curved mask:", e);
           }

           textCtx.restore();
           maskCurrentX += displayWidth;
       }

       textCtx.restore();

       // Step 4: Create gradient canvas (NO additional scaling - main canvas is already scaled)
       const gradientCanvas = document.createElement('canvas');
       gradientCanvas.width = 2000;
       gradientCanvas.height = 2000;
       const gradientCtx = gradientCanvas.getContext('2d');
       // NO gradientCtx.scale() - main canvas is already scaled by high-DPI system
       gradientCtx.imageSmoothingEnabled = true;
       gradientCtx.imageSmoothingQuality = 'high';

       // Create the gradient
       const gradientType = originalGradient.type;
       let gradient;

       if (gradientType === 'radial') {
           const centerX = gradientCanvas.width / 2;
           const centerY = gradientCanvas.height / 2;
           const radius = Math.max(gradientCanvas.width, gradientCanvas.height) / 3;
           gradient = gradientCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
       } else {
           // Linear gradient
           const angle = (originalGradient.gradient.angle || 0) * Math.PI / 180;
           const cos = Math.cos(angle);
           const sin = Math.sin(angle);
           const centerX = gradientCanvas.width / 2;
           const centerY = gradientCanvas.height / 2;
           const length = Math.max(gradientCanvas.width, gradientCanvas.height);

           const x1 = centerX - (length / 2) * cos;
           const y1 = centerY - (length / 2) * sin;
           const x2 = centerX + (length / 2) * cos;
           const y2 = centerY + (length / 2) * sin;

           gradient = gradientCtx.createLinearGradient(x1, y1, x2, y2);
       }

       // Add color stops
       if (originalGradient.gradient.colors) {
           originalGradient.gradient.colors.forEach(colorStop => {
               gradient.addColorStop(colorStop.position / 100, colorStop.color);
           });
       }

       // Fill with gradient
       gradientCtx.fillStyle = gradient;
       gradientCtx.fillRect(0, 0, gradientCanvas.width, gradientCanvas.height);

       // Apply text as mask to gradient
       gradientCtx.globalCompositeOperation = 'destination-in';
       gradientCtx.drawImage(textCanvas, 0, 0);

       // Step 5: Draw effects (with text cut out) to target canvas
       tempCtx.globalCompositeOperation = 'destination-out';
       tempCtx.drawImage(textCanvas, 0, 0);
       targetCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);

       // Step 6: Draw gradient text on top
       targetCtx.drawImage(gradientCanvas, -gradientCanvas.width / 2, -gradientCanvas.height / 2);

       // Step 7: Apply decoration effects on top of gradient text
       console.log('🔍 RENDER ORDER: Step 7 - Applying decoration effects on top of gradient for Curved text');
       if (obj.decorationMode && obj.decorationMode !== 'noDecoration' && window.decorationModule) {
           // Create decoration canvas
           const decorationCanvas = document.createElement('canvas');
           decorationCanvas.width = 2000;
           decorationCanvas.height = 2000;
           const decorationCtx = decorationCanvas.getContext('2d');

           // Set decoration type and apply
           window.decorationModule.setActiveDecorationType(obj.decorationMode);
           decorationCtx.save();
           decorationCtx.translate(decorationCanvas.width / 2, decorationCanvas.height / 2);

           // Calculate expanded bounds for curved text decoration
           const tempCtx = document.createElement('canvas').getContext('2d');
           tempCtx.font = `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`;
           const metrics = tempCtx.measureText(obj.text || 'TEXT');
           const baseWidth = metrics.width;
           const baseHeight = (obj.fontSize || 100) * 1.2;

           // For curved text, expand bounds based on curve amount to cover the curved path
           const curveAmount = Math.abs(obj.curveAmount || 0);
           const curveFactor = Math.max(1.5, 1 + (curveAmount / 100)); // Scale expansion with curve amount
           const expandedWidth = baseWidth * curveFactor;
           const expandedHeight = baseHeight * curveFactor;

           // Create decoration-compatible text object with expanded bounds
           const decorationTextObj = {
               text: obj.text || 'TEXT',
               font: `${obj.fontSize || 100}px ${obj.fontFamily || 'Arial'}`,
               // Add custom bounds for curved text distortion
               customBounds: {
                   width: expandedWidth,
                   height: expandedHeight,
                   isCurved: true,
                   curveAmount: curveAmount
               }
           };

           // Apply decoration pattern with expanded bounds
           window.decorationModule.applyDecoration(decorationCtx, decorationTextObj, 0, 0);
           decorationCtx.restore();

           console.log('🎨 DECORATION: Applied decoration pattern for curved text:', obj.decorationMode);

           // Create a precise text mask using the SAME curved distorted text shape
           const textMaskCanvas = document.createElement('canvas');
           textMaskCanvas.width = 2000;
           textMaskCanvas.height = 2000;
           const textMaskCtx = textMaskCanvas.getContext('2d');

           // Draw the EXACT same curved text shape as the main rendering for precise masking
           textMaskCtx.save();
           textMaskCtx.translate(textMaskCanvas.width / 2, textMaskCanvas.height / 2);
           textMaskCtx.fillStyle = 'white';
           createCurvedTextMask(obj, textMaskCtx);
           textMaskCtx.restore();

           // Apply text mask to decoration canvas
           decorationCtx.globalCompositeOperation = 'destination-in';
           decorationCtx.drawImage(textMaskCanvas, 0, 0);

           // Apply masked decoration to target
           targetCtx.drawImage(decorationCanvas, -decorationCanvas.width / 2, -decorationCanvas.height / 2);

           console.log('🎨 DECORATION: Applied decoration effects on top of curved gradient text');
       }

       // Step 8: Draw front outlines on top of everything (for shadow effects)
       console.log('🔍 RENDER ORDER: Step 8 - Drawing front outlines on top for Curved text');

       // Store original outline widths
       const originalOutlineWidth = obj.perspectiveShadowOutlineWidth;
       const originalD3dWidth = obj.d3dSecondaryWidth;

       if (obj.shadowMode === 'perspectiveShadow' && originalOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for Curved text');
           const outlineColor = obj.perspectiveShadowOutlineColor;
           const outlineOpacity = obj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = originalOutlineWidth;
           const outlineOffsetX = obj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = obj.perspectiveShadowOutlineOffsetY || 0;
           drawCurvedFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }
       if (obj.shadowMode === 'detailed3D' && originalD3dWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for Curved text');
           const outlineColor = obj.d3dSecondaryColor;
           const outlineOpacity = obj.d3dSecondaryOpacity / 100;
           const outlineWidth = originalD3dWidth;
           const outlineOffsetX = obj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = obj.d3dSecondaryOffsetY || 0;
           drawCurvedFrontOutline(obj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY);
       }

       // Restore original gradient
       obj.gradient = originalGradient;

       console.log('🎨 GRADIENT MASK: Curved text with gradient mask complete');
   }

   // Helper function to get shadow color based on shadow mode
   function getShadowColor(textObj) {
       switch (textObj.shadowMode) {
           case 'blockShadow':
               return textObj.blockShadowColor || '#000000';
           case 'lineShadow':
               return textObj.lineShadowColor || '#000000';
           case 'perspectiveShadow':
               return textObj.perspectiveShadowColor || '#000000';
           case 'detailed3d':
               return textObj.d3dColor || '#000000';
           case 'standardShadow':
               return textObj.standardShadowColor || '#000000';
           default:
               return '#000000';
       }
   }

   // Helper function to apply shadow transform based on shadow mode
   function applyShadowTransform(ctx, textObj) {
       switch (textObj.shadowMode) {
           case 'blockShadow':
               const blockOffset = textObj.blockShadowOffset || 10;
               ctx.translate(blockOffset, blockOffset);
               break;
           case 'lineShadow':
               const lineOffset = textObj.lineShadowOffset || 5;
               ctx.translate(lineOffset, lineOffset);
               break;
           case 'perspectiveShadow':
               const perspectiveOffsetX = textObj.perspectiveShadowOffsetX || 10;
               const perspectiveOffsetY = textObj.perspectiveShadowOffsetY || 10;
               ctx.translate(perspectiveOffsetX, perspectiveOffsetY);
               break;
           case 'detailed3d':
               const d3dOffset = textObj.d3dOffset || 5;
               ctx.translate(d3dOffset, d3dOffset);
               break;
           case 'standardShadow':
               const standardOffsetX = textObj.standardShadowOffsetX || 5;
               const standardOffsetY = textObj.standardShadowOffsetY || 5;
               ctx.translate(standardOffsetX, standardOffsetY);
               break;
       }
   }

   // Gradient masking function for grid distorted text (based on working Mesh Warp approach)
   function drawGridDistortedTextWithGradientMask(textObj, targetCtx, font) {
       console.log('🎨 GRID DISTORT GRADIENT: Using proven Mesh Warp masking approach with shadows');

       // Save original gradient
       const originalGradient = textObj.gradient;

       // Create a temporary canvas for the complete rendering (like Mesh Warp)
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = 2000;
       tempCanvas.height = 2000;
       const tempCtx = tempCanvas.getContext('2d');

       // Step 1: Draw effects (shadows) with text cut out to temp canvas
       tempCtx.save();
       tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
       textObj.gradient = { type: 'solid' };
       drawGridDistortedText(textObj, tempCtx, font);
       tempCtx.restore();

       // Step 2: Create text canvas for masking
       const textCanvas = document.createElement('canvas');
       textCanvas.width = 2000;
       textCanvas.height = 2000;
       const textCtx = textCanvas.getContext('2d');

       // Draw text in white for masking (DISABLE SHADOWS AND DECORATIONS for clean mask)
       textCtx.save();
       textCtx.translate(textCanvas.width / 2, textCanvas.height / 2);
       const maskObj = { ...textObj };
       maskObj.color = '#ffffff';
       maskObj.gradient = { type: 'solid' };
       // CRITICAL: Disable all shadow effects and decorations for the mask
       const originalShadowMode = maskObj.shadowMode;
       const originalDecorationMode = maskObj.decorationMode;
       maskObj.shadowMode = 'noShadow';
       maskObj.decorationMode = 'noDecoration';
       drawGridDistortedText(maskObj, textCtx, font);
       // Restore original modes (though we don't use maskObj after this)
       maskObj.shadowMode = originalShadowMode;
       maskObj.decorationMode = originalDecorationMode;
       textCtx.restore();

       // Step 3: Create gradient canvas
       const gradientCanvas = document.createElement('canvas');
       gradientCanvas.width = 2000;
       gradientCanvas.height = 2000;
       const gradientCtx = gradientCanvas.getContext('2d');

       // Step 4: Create and apply gradient
       gradientCtx.save();
       gradientCtx.translate(gradientCanvas.width / 2, gradientCanvas.height / 2);

       let gradient;
       if (originalGradient.type === 'radial') {
           const centerX = 0;
           const centerY = 0;
           const radius = 300;
           gradient = gradientCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
       } else {
           // Linear gradient
           const angle = (originalGradient.gradient.angle || 0) * Math.PI / 180;
           const cos = Math.cos(angle);
           const sin = Math.sin(angle);
           const length = 600;
           const x1 = -(length / 2) * cos;
           const y1 = -(length / 2) * sin;
           const x2 = (length / 2) * cos;
           const y2 = (length / 2) * sin;
           gradient = gradientCtx.createLinearGradient(x1, y1, x2, y2);
       }

       // Add color stops
       if (originalGradient.gradient.colors) {
           originalGradient.gradient.colors.forEach(colorStop => {
               const position = colorStop.position / 100;
               gradient.addColorStop(position, colorStop.color);
           });
       }

       // Fill with gradient
       gradientCtx.fillStyle = gradient;
       gradientCtx.fillRect(-gradientCanvas.width / 2, -gradientCanvas.height / 2,
                           gradientCanvas.width, gradientCanvas.height);
       gradientCtx.restore();

       // Step 5: Apply text as mask to gradient
       gradientCtx.globalCompositeOperation = 'destination-in';
       gradientCtx.drawImage(textCanvas, 0, 0);

       // Step 6: Draw effects (shadows) to target canvas
       targetCtx.drawImage(tempCanvas, -tempCanvas.width / 2, -tempCanvas.height / 2);

       // Step 7: Draw gradient text on top
       targetCtx.drawImage(gradientCanvas, -gradientCanvas.width / 2, -gradientCanvas.height / 2);

       // Step 8: Apply decorations using the same per-letter approach as solid color Grid Distort
       if (textObj.decorationMode && textObj.decorationMode !== 'noDecoration') {
           console.log('🎨 GRID DISTORT GRADIENT: Using solid color Grid Distort approach for decorations');

           // Temporarily disable gradient for decoration rendering
           const originalGradient = textObj.gradient;
           textObj.gradient = { type: 'solid' };

           // Use the same solid color Grid Distort rendering that works perfectly with decorations
           drawGridDistortedText(textObj, targetCtx, font);

           // Restore original gradient
           textObj.gradient = originalGradient;
       }

       // Restore original gradient
       textObj.gradient = originalGradient;

       console.log('🎨 GRID DISTORT GRADIENT: Proven masking approach with shadows and decorations complete');
   }

   // Draw text with Grid Distort effect
   function drawGridDistortObject(obj, targetCtx) {
       const drawCallId = Math.random().toString(36).substring(2, 8);
       console.log(`🔍 GRID DISTORT CALL [${drawCallId}]: drawGridDistortObject called for text: "${obj.text}"`);
       // Check if OpenType.js is loaded
       if (typeof opentype === 'undefined') {
           console.error('OpenType.js is required for Grid Distort effect');
           drawNormalOrSkewObject(obj, targetCtx);
           return;
       }

       // Initialize grid distort for this object if not already initialized
       if (!obj.gridDistort) {
           console.log('Creating gridDistort object for text:', obj.text);
           obj.gridDistort = {
               gridCols: obj.gridDistortCols || 2,
               gridRows: obj.gridDistortRows || 1,
               gridPadding: obj.gridDistortPadding || 120,
               intensity: (obj.gridDistortIntensity || 100) / 100,
               controlPoints: [],
               showGrid: true,
               lastFontSize: obj.fontSize,
               lastText: obj.text,
               relativeControlPoints: [],
               verticalOnly: obj.gridDistortVerticalOnly !== undefined ? obj.gridDistortVerticalOnly : true
           };

           // Initialize grid points
           initializeGridPoints(obj);
       }

       // Get the font for the text object
       const fontFamily = obj.fontFamily || 'Arial';
       const isBold = obj.bold || false;
       const isItalic = obj.italic || false;

       // Create a unique key for this font variant
       const fontKey = `${fontFamily}_${isBold ? 'bold' : 'regular'}_${isItalic ? 'italic' : 'normal'}`;

       // Get the appropriate font path based on style
       const fontPath = getFontPathForFamily(fontFamily, isBold, isItalic);

       // Load the font if not already loaded
       if (!window.loadedFonts || !window.loadedFonts[fontKey]) {
           if (!window.loadedFonts) window.loadedFonts = {};

           // Fallback to normal rendering while font loads
           drawNormalOrSkewObject(obj, targetCtx);

           try {
               // Load the font
               console.log('Loading font from:', fontPath, 'for', fontKey);
               opentype.load(fontPath, (err, font) => {
                   if (err) {
                       console.error('Could not load font: ' + fontPath, err);
                       // Try to load the regular variant as fallback
                       const fallbackPath = getFontPathForFamily(fontFamily, false, false);
                       if (fallbackPath !== fontPath) {
                           console.log('Trying fallback font:', fallbackPath);
                           opentype.load(fallbackPath, (fallbackErr, fallbackFont) => {
                               if (fallbackErr) {
                                   console.error('Could not load fallback font:', fallbackErr);
                                   // Continue with normal rendering on error
                                   drawNormalOrSkewObject(obj, targetCtx);
                                   return;
                               }

                               console.log('Fallback font loaded successfully:', fontFamily);

                               // Store the loaded font
                               window.loadedFonts[fontKey] = fallbackFont;

                               // Redraw the canvas to show the effect
                               update();
                           });
                           return;
                       }

                       // Continue with normal rendering on error
                       drawNormalOrSkewObject(obj, targetCtx);
                       return;
                   }

                   console.log('Font loaded successfully:', fontKey);

                   // Store the loaded font
                   window.loadedFonts[fontKey] = font;

                   // Redraw the canvas to show the effect
                   update();
               });
           } catch (e) {
               console.error('Error in font loading process:', e);
               // Fallback to normal rendering on exception
               drawNormalOrSkewObject(obj, targetCtx);
           }

           return;
       }

       // Update grid parameters if they've changed
       if (obj.gridDistort) {
           console.log('drawGridDistortObject check:', {
               currentText: obj.text,
               lastText: obj.gridDistort.lastText,
               currentFontSize: obj.fontSize,
               lastFontSize: obj.gridDistort.lastFontSize,
               hasRelativePoints: obj.gridDistort.relativeControlPoints ?
                                 obj.gridDistort.relativeControlPoints.length : 'No'
           });

           // Always check if text content has changed first
           if (!obj.gridDistort.lastText || obj.gridDistort.lastText !== obj.text) {
               console.log('Text content changed in drawGridDistortObject, reinitializing grid');
               // Don't update lastText here - let initializeGridPoints handle it
               // This ensures the text change is detected properly
               initializeGridPoints(obj);
           }
           // Then check other parameters
           else if (obj.gridDistort.gridCols !== obj.gridDistortCols ||
               obj.gridDistort.gridRows !== obj.gridDistortRows ||
               obj.gridDistort.gridPadding !== obj.gridDistortPadding ||
               !obj.gridDistort.lastFontSize || // Check if font size has changed
               obj.gridDistort.lastFontSize !== obj.fontSize) {

               obj.gridDistort.gridCols = obj.gridDistortCols || 2;
               obj.gridDistort.gridRows = obj.gridDistortRows || 1;
               obj.gridDistort.gridPadding = obj.gridDistortPadding || 120;
               obj.gridDistort.verticalOnly = obj.gridDistortVerticalOnly !== undefined ? obj.gridDistortVerticalOnly : true;

               // Don't update lastFontSize here - let initializeGridPoints handle it
               // This ensures the font size change is detected properly and distortion is preserved

               // Reinitialize grid points while preserving distortion
               initializeGridPoints(obj);
           }

           // Update intensity if it's changed
           obj.gridDistort.intensity = (obj.gridDistortIntensity || 100) / 100;
       }

       // Draw the grid distorted text using the fontKey created earlier
       const font = window.loadedFonts[fontKey];

       if (font) {
           console.log(`🔍 GRID DISTORT CALL [${drawCallId}]: Using main font: ${fontKey} - SINGLE RENDER`);
           // Check if we need to apply gradient masking
           if (obj.gradient && obj.gradient.type !== 'solid') {
               drawGridDistortedTextWithGradientMask(obj, targetCtx, font);
           } else {
               // Draw the text with grid distortion
               drawGridDistortedText(obj, targetCtx, font);
           }

           // Draw grid only if visibility is enabled AND the object is selected
           console.log('Grid visibility:', obj.gridDistort.showGrid, 'Selected:', obj === canvasObjects[selectedObjectIndex]);
           if (obj.gridDistort && obj.gridDistort.showGrid && obj === canvasObjects[selectedObjectIndex]) {
               console.log('Drawing grid...');
               drawGrid(obj, targetCtx);
           }

           // IMPORTANT: Return early to prevent fallback font rendering
           console.log(`🔍 GRID DISTORT CALL [${drawCallId}]: Main font successful - skipping fallback`);
           return;
       }

       // Only try fallback if main font completely failed to load
       console.warn(`🔍 GRID DISTORT CALL [${drawCallId}]: Font not loaded for ${fontKey}, trying regular variant`);
       const regularFontKey = `${fontFamily}_regular_normal`;
       const regularFont = window.loadedFonts[regularFontKey];

       if (regularFont) {
           console.log(`🔍 GRID DISTORT CALL [${drawCallId}]: Using fallback font: ${regularFontKey} - FALLBACK RENDER`);
           // Check if we need to apply gradient masking for fallback font too
           if (obj.gradient && obj.gradient.type !== 'solid') {
               drawGridDistortedTextWithGradientMask(obj, targetCtx, regularFont);
           } else {
               // Draw with regular font as fallback
               drawGridDistortedText(obj, targetCtx, regularFont);
           }

           // Draw grid if needed AND the object is selected
           if (obj.gridDistort && obj.gridDistort.showGrid && obj === canvasObjects[selectedObjectIndex]) {
               drawGrid(obj, targetCtx);
           }
       } else {
           console.warn(`🔍 GRID DISTORT CALL [${drawCallId}]: No fonts available, using normal rendering`);
           // Fallback to normal rendering if no font is loaded
           drawNormalOrSkewObject(obj, targetCtx);
       }
   }

   // Global font map - moved outside function so it's accessible everywhere
const fontMap = {
    '8bit Tiny Retro': {
        regular: '/fonts/8bit-tiny-retro.ttf'
    },
    'Abril Fatface': {
        regular: '/fonts/AbrilFatface-Regular.ttf'
    },
    'Acme': {
        regular: '/fonts/Acme-Regular.ttf'
    },
    'Afacad Flux': {
        regular: '/fonts/AfacadFlux.ttf'
    },
    'Alfa Slab One': {
        regular: '/fonts/AlfaSlabOne-Regular.ttf'
    },
    'Aleo': {
        bold: '/fonts/aleo-bold-webfont.ttf',
        boldItalic: '/fonts/aleo-bolditalic-webfont.ttf',
        italic: '/fonts/aleo-italic-webfont.ttf',
        light: '/fonts/aleo-light-webfont.ttf',
        lightItalic: '/fonts/aleo-lightitalic-webfont.ttf',
        regular: '/fonts/aleo-regular-webfont.ttf'
    },
    'Allen Sans': {
        bold: '/fonts/AllenSans-Bold.ttf',
        regular: '/fonts/AllenSans-Regular.ttf'
    },
    'Alumni Sans SC': {
        regular: '/fonts/AlumniSansSC.ttf',
        bold: '/fonts/AlumniSansSC-Bold.ttf',
        boldItalic: '/fonts/AlumniSansSC-BoldItalic.ttf',
        italic: '/fonts/AlumniSansSC-Italic.ttf'
    },
    'Amaranth': {
        bold: '/fonts/Amaranth-Bold.ttf',
        boldItalic: '/fonts/Amaranth-BoldItalic.ttf',
        italic: '/fonts/Amaranth-Italic.ttf',
        regular: '/fonts/Amaranth-Regular.ttf'
    },
    'Amatic SC': {
        bold: '/fonts/AmaticSC-Bold.ttf',
        regular: '/fonts/AmaticSC-Regular.ttf'
    },
    'Anek Latin': {
        regular: '/fonts/AnekLatin.ttf',
        bold: '/fonts/AnekLatin-Bold.ttf'
    },
    'Anton': {
        regular: '/fonts/Anton-Regular.ttf'
    },
    'Aquifer': {
        regular: '/fonts/Aquifer.ttf'
    },
    'Are You Serious': {
        regular: '/fonts/AreYouSerious-Regular.ttf'
    },
    'Arial': {
        bold: '/fonts/ArialBold.ttf',
        regular: '/fonts/Arial.ttf',
        boldItalic: '/fonts/ArialBoldItalic.ttf',
        italic: '/fonts/ArialItalic.ttf'
    },
    'Audex': {
        italic: '/fonts/Audex-Italic.ttf',
        regular: '/fonts/Audex-Regular.ttf'
    },
    'Audiowide': {
        regular: '/fonts/Audiowide-Regular.ttf'
    },
    'Autobahn': {
        regular: '/fonts/Autobahn.ttf'
    },
    'Aventi': {
        bold: '/fonts/AventiBold.ttf'
    },
    'Averia Gruesa Libre': {
        regular: '/fonts/AveriaGruesaLibre-Regular.ttf'
    },
    'Averia Sans Libre': {
        bold: '/fonts/AveriaSansLibre-Bold.ttf',
        boldItalic: '/fonts/AveriaSansLibre-BoldItalic.ttf',
        italic: '/fonts/AveriaSansLibre-Italic.ttf',
        regular: '/fonts/AveriaSansLibre-Regular.ttf'
    },
    'Averia Serif Libre': {
        bold: '/fonts/AveriaSerifLibre-Bold.ttf',
        boldItalic: '/fonts/AveriaSerifLibre-BoldItalic.ttf',
        italic: '/fonts/AveriaSerifLibre-Italic.ttf',
        regular: '/fonts/AveriaSerifLibre-Regular.ttf'
    },
    'BStyle': {
        bold: '/fonts/BStyle_B.ttf',
        regular: '/fonts/BStyle_R.ttf'
    },
    'Bacasime Antique': {
        regular: '/fonts/BacasimeAntique-Regular.ttf'
    },
    'Badeen Display': {
        regular: '/fonts/BadeenDisplay-Regular.ttf'
    },
    'Bagel Fat One': {
        regular: '/fonts/BagelFatOne-Regular.ttf'
    },
    'Balhattan': {
        italic: '/fonts/Balhattan-Italic.ttf',
        regular: '/fonts/Balhattan-Regular.ttf'
    },
    'Bangers': {
        regular: '/fonts/Bangers-Regular.ttf'
    },
    'Barlow Condensed': {
        bold: '/fonts/BarlowCondensed-Bold.ttf',
        boldItalic: '/fonts/BarlowCondensed-BoldItalic.ttf',
        italic: '/fonts/BarlowCondensed-Italic.ttf',
        regular: '/fonts/BarlowCondensed-Regular.ttf'
    },
    'Barloesius Schrift': {
        regular: '/fonts/BarloesiusSchrift.ttf'
    },
    'Baskerville': {
        italic: '/fonts/Baskervville-Italic.ttf',
        regular: '/fonts/Baskervville-Regular.ttf'
    },
    'Bauhaus Homenaje': {
        regular: '/fonts/BAUHAUSHOMENAJE.ttf'
    },
    'Bazar': {
        regular: '/fonts/Bazar.ttf'
    },
    'Beatstreet': {
        regular: '/fonts/beatstreet.ttf'
    },
    'Bebas Neue': {
        regular: '/fonts/BebasNeue-Regular.ttf'
    },
    'Beirut': {
        ht: '/fonts/Beirut[ht].ttf'
    },
    'Belanosima': {
        bold: '/fonts/Belanosima-Bold.ttf',
        regular: '/fonts/Belanosima-Regular.ttf'
    },
    'Bertholdr Mainzer Fraktur': {
        regular: '/fonts/BertholdrMainzerFraktur.ttf'
    },
    'Beth Ellen': {
        regular: '/fonts/BethEllen-Regular.ttf'
    },
    'Bevan': {
        italic: '/fonts/Bevan-Italic.ttf',
        regular: '/fonts/Bevan-Regular.ttf'
    },
    'Bigelow Rules': {
        regular: '/fonts/BigelowRules-Regular.ttf'
    },
    'Bilbo': {
        regular: '/fonts/Bilbo-Regular.ttf'
    },
    'Bilbo Swash Caps': {
        regular: '/fonts/BilboSwashCaps-Regular.ttf'
    },
    'Birthstone Bounce': {
        regular: '/fonts/BirthstoneBounce-Regular.ttf'
    },
    'Bladerounded': {
        regular: '/fonts/Bladerounded-Regular.ttf'
    },
    'Block Mono': {
        bold: '/fonts/BlockMono-Bold.ttf',
        regular: '/fonts/BlockMono-Regular.ttf'
    },
    'Bodoni Moda': {
        regular: '/fonts/BodoniModa.ttf',
        '9ptBold': '/fonts/BodoniModa_9pt-Bold.ttf',
        ht: '/fonts/BodoniModaht.ttf',
        italic: '/fonts/BodoniModa-Italic.ttf'
    },
    'Bonbon': {
        regular: '/fonts/Bonbon-Regular.ttf'
    },
    'BoonTook': {
        italic: '/fonts/BoonTook-Italic.ttf',
        regular: '/fonts/BoonTook-Regular.ttf'
    },
    'BoonTook Mon': {
        italic: '/fonts/BoonTookMon-Italic.ttf',
        regular: '/fonts/BoonTookMon-Regular.ttf'
    },
    'Boogaloo': {
        regular: '/fonts/Boogaloo-Regular.ttf'
    },
    'Bowlby One SC': {
        regular: '/fonts/BowlbyOneSC-Regular.ttf'
    },
    'Brawler': {
        bold: '/fonts/Brawler-Bold.ttf',
        regular: '/fonts/Brawler-Regular.ttf'
    },
    'Bruno Ace SC': {
        regular: '/fonts/BrunoAceSC-Regular.ttf'
    },
    'Bubblegum Sans': {
        regular: '/fonts/BubblegumSans-Regular.ttf'
    },
    'Bungee': {
        regular: '/fonts/Bungee-Regular.ttf'
    },
    'CAT Engravers': {
        regular: '/fonts/CATEngravers.ttf'
    },
    'Cabin': {
        bold: '/fonts/Cabin-Bold-TTF.ttf',
        boldItalic: '/fonts/Cabin-BoldItalic-TTF.ttf',
        italic: '/fonts/Cabin-Italic-TTF.ttf',
        regular: '/fonts/Cabin-Regular-TTF.ttf'
    },
    'Cabin Condensed': {
        bold: '/fonts/CabinCondensed-Bold.ttf',
        regular: '/fonts/CabinCondensed-Regular.ttf'
    },
    'Caesar Dressing': {
        regular: '/fonts/CaesarDressing-Regular.ttf'
    },
    'Cagliostro': {
        regular: '/fonts/Cagliostro-Regular.ttf'
    },
    'Cal Sans': {
        regular: '/fonts/CalSans-Regular.ttf'
    },
    'Carter One': {
        regular: '/fonts/CarterOne-Regular.ttf'
    },
    'Castoro Titling': {
        regular: '/fonts/CastoroTitling-Regular.ttf'
    },
    'Catenary Stamp': {
        regular: '/fonts/Catenary-Stamp.ttf'
    },
    'Caveat Brush': {
        regular: '/fonts/CaveatBrush-Regular.ttf'
    },
    'Cello Sans': {
        bold: '/fonts/hinted-CelloSans-Bold.ttf',
        boldItalic: '/fonts/hinted-CelloSans-BoldItalic.ttf',
        italic: '/fonts/hinted-CelloSans-Italic.ttf',
        regular: '/fonts/hinted-CelloSans-Regular.ttf'
    },
    'Changa': {
        regular: '/fonts/Changa.ttf',
        bold: '/fonts/Changa-Bold.ttf'
    },
    'Chango': {
        regular: '/fonts/Chango-Regular.ttf'
    },
    'Chau Philomene One': {
        italic: '/fonts/ChauPhilomeneOne-Italic.ttf',
        regular: '/fonts/ChauPhilomeneOne-Regular.ttf'
    },
    'Cherry Bomb One': {
        regular: '/fonts/CherryBombOne-Regular.ttf'
    },
    'Cherry Cream Soda': {
        regular: '/fonts/CherryCreamSoda.ttf'
    },
    'Chewy': {
        regular: '/fonts/Chewy-Regular.ttf'
    },
    'Chicle': {
        regular: '/fonts/Chicle-Regular.ttf'
    },
    'Chisato': {
        regular: '/fonts/chisato.ttf'
    },
    'Cinzel': {
        bold: '/fonts/Cinzel-Bold.ttf',
        regular: '/fonts/Cinzel-Regular.ttf'
    },
    'Cinzel Decorative': {
        bold: '/fonts/CinzelDecorative-Bold.ttf',
        regular: '/fonts/CinzelDecorative-Regular.ttf'
    },
    'Climate Crisis': {
        regular: '/fonts/ClimateCrisis-Regular.ttf'
    },
    'Comforter': {
        regular: '/fonts/Comforter-Regular.ttf'
    },
    'Comforter Brush': {
        regular: '/fonts/ComforterBrush-Regular.ttf'
    },
    'Comic Sans MS': {
        regular: '/fonts/ComicSansMS.ttf',
        bold: '/fonts/ComicSansMSBold.ttf'
    },
    'Concert One': {
        regular: '/fonts/ConcertOne-Regular.ttf'
    },
    'Cookie': {
        regular: '/fonts/Cookie-Regular.ttf'
    },
    'Copilot': {
        regular: '/fonts/copilot.ttf'
    },
    'Copse': {
        regular: '/fonts/Copse-Regular.ttf'
    },
    'Corben': {
        bold: '/fonts/Corben-Bold.ttf',
        regular: '/fonts/Corben-Regular.ttf'
    },
    'Courier New': {
        regular: '/fonts/CourierNew.ttf',
        bold: '/fonts/CourierNewBold.ttf',
        boldItalic: '/fonts/CourierNewBoldItalic.ttf',
        italic: '/fonts/CourierNewItalic.ttf'
    },
    'Cramaten': {
        regular: '/fonts/Cramaten.ttf'
    },
    'Creepster': {
        regular: '/fonts/Creepster-Regular.ttf'
    },
    'Croissant One': {
        regular: '/fonts/CroissantOne-Regular.ttf'
    },
    'Crosterian': {
        regular: '/fonts/Crosterian.ttf'
    },
    'Crossterian 513mZ': {
        regular: '/fonts/Crosterian-513mZ.ttf'
    },
    'Crushed': {
        regular: '/fonts/Crushed-Regular.ttf'
    },
    'CuteFont': {
        regular: '/fonts/CuteFont-Regular.ttf'
    },
    'Dancing Script': {
        regular: '/fonts/DancingScript.ttf',
        bold: '/fonts/DancingScript-Bold.ttf'
    },
    'Danfo': {
        claw: '/fonts/Danfo-Claw.ttf',
        comb: '/fonts/Danfo-Comb.ttf',
        regular: '/fonts/Danfo-Regular.ttf'
    },
    'Dangrek': {
        regular: '/fonts/Dangrek-Regular.ttf'
    },
    'Dashboard': {
        regular: '/fonts/Dashboard-Regular.ttf'
    },
    'Dashicons': {
        regular: '/fonts/dashicons.ttf'
    },
    'Days One': {
        regular: '/fonts/DaysOne-Regular.ttf'
    },
    'Delicious Handrawn': {
        regular: '/fonts/DeliciousHandrawn-Regular.ttf'
    },
    'Denk One': {
        regular: '/fonts/DenkOne-Regular.ttf'
    },
    'Diplomata SC': {
        regular: '/fonts/DiplomataSC-Regular.ttf'
    },
    'Durendal And Oliphant': {
        regular: '/fonts/DurendalAndOliphantRegular.ttf'
    },
    'DynaPuff': {
        regular: '/fonts/DynaPuff.ttf',
        condensedBold: '/fonts/DynaPuff_Condensed-Bold.ttf',
        condensedRegular: '/fonts/DynaPuff_Condensed-Regular.ttf',
        bold: '/fonts/DynaPuff-Bold.ttf'
    },
    'East Sea Dokdo': {
        regular: '/fonts/EastSeaDokdo-Regular.ttf'
    },
    'EB Garamond': {
        regular: '/fonts/EBGaramond.ttf',
        bold: '/fonts/EBGaramond-Bold.ttf',
        boldItalic: '/fonts/EBGaramond-BoldItalic.ttf',
        italic: '/fonts/EBGaramond-Italic.ttf'
    },
    'Economica': {
        boldItalic: '/fonts/Economica-BoldItalic.ttf',
        italic: '/fonts/Economica-Italic.ttf',
        regular: '/fonts/Economica-Regular.ttf'
    },
    'Eleventh Square': {
        regular: '/fonts/Eleventh-Square.ttf'
    },
    'Emilio 19': {
        regular: '/fonts/Emilio-19.ttf'
    },
    'Encode Sans SC': {
        regular: '/fonts/EncodeSansSC.ttf',
        bold: '/fonts/EncodeSansSC-Bold.ttf'
    },
    'Engagement': {
        regular: '/fonts/Engagement-Regular.ttf'
    },
    'Englebert': {
        regular: '/fonts/Englebert-Regular.ttf'
    },
    'Exetegue': {
        bold: '/fonts/Exetegue-Bold.ttf',
        regular: '/fonts/Exetegue-Regular.ttf'
    },
    'Exile': {
        regular: '/fonts/Exile-Regular.ttf'
    },
    'Exo': {
        bold: '/fonts/Exo-Bold.ttf',
        boldItalic: '/fonts/Exo-BoldItalic.ttf',
        italic: '/fonts/Exo-Italic.ttf',
        regular: '/fonts/Exo-Regular.ttf'
    },
    'Exo 2': {
        regular: '/fonts/Exo2.ttf',
        bold: '/fonts/Exo2-Bold.ttf',
        boldItalic: '/fonts/Exo2-BoldItalic.ttf',
        italic: '/fonts/Exo2-Italic.ttf'
    },
    'Fascinate': {
        regular: '/fonts/Fascinate-Regular.ttf'
    },
    'Festive': {
        regular: '/fonts/Festive-Regular.ttf'
    },
    'Fette National Fraktur': {
        regular: '/fonts/FetteNationalFraktur.ttf'
    },
    'Fjalla One': {
        regular: '/fonts/FjallaOne-Regular.ttf'
    },
    'Flavors': {
        regular: '/fonts/Flavors-Regular.ttf'
    },
    'Fontdiner Swanky': {
        regular: '/fonts/FontdinerSwanky-Regular.ttf'
    },
    'Fortzilla': {
        italic: '/fonts/Fortzilla-Italic.ttf',
        regular: '/fonts/Fortzilla-Regular.ttf'
    },
    'Francois One': {
        regular: '/fonts/FrancoisOne.ttf'
    },
    'Freckle Face': {
        regular: '/fonts/FreckleFace-Regular.ttf'
    },
    'Fredoka One': {
        regular: '/fonts/FredokaOne-Regular.ttf'
    },
    'Freeman': {
        regular: '/fonts/Freeman-Regular.ttf'
    },
    'Frijole': {
        regular: '/fonts/Frijole-Regular.ttf'
    },
    'Fugaz One': {
        regular: '/fonts/FugazOne-Regular.ttf'
    },
    'Funnel Display': {
        bold: '/fonts/FunnelDisplay-Bold.ttf',
        regular: '/fonts/FunnelDisplay-Regular.ttf'
    },
    'Furgatorio Sans': {
        regular: '/fonts/Furgatorio-Sans.ttf'
    },
    'Garamond': {
        regular: '/fonts/Garamond.ttf',
        italic: '/fonts/Garamond-Italic.ttf'
    },
    'Georgia': {
        regular: '/fonts/Georgia.ttf',
        bold: '/fonts/GeorgiaBold.ttf',
        boldItalic: '/fonts/GeorgiaBoldItalic.ttf',
        italic: '/fonts/GeorgiaItalic.ttf'
    },
    'Gloock': {
        regular: '/fonts/Gloock-Regular.ttf'
    },
    'Gloria Hallelujah': {
        regular: '/fonts/GloriaHallelujah-Regular.ttf'
    },
    'Gluten': {
        regular: '/fonts/Gluten.ttf',
        bold: '/fonts/Gluten-Bold.ttf'
    },
    'Goblin One': {
        regular: '/fonts/GoblinOne-Regular.ttf'
    },
    'Gochi Hand': {
        regular: '/fonts/GochiHand-Regular.ttf'
    },
    'Goli': {
        bold: '/fonts/Goli-Bold.ttf',
        vf: '/fonts/GoliVF.ttf',
        regular: '/fonts/Goli-Regular.ttf'
    },
    'Gorditas': {
        bold: '/fonts/Gorditas-Bold.ttf',
        regular: '/fonts/Gorditas-Regular.ttf'
    },
    'Gothica': {
        bold: '/fonts/Gothica-Bold.ttf',
        book: '/fonts/Gothica-Book.ttf'
    },
    'Graduate': {
        regular: '/fonts/Graduate-Regular.ttf'
    },
    'Gravitas One': {
        regular: '/fonts/GravitasOne-Regular.ttf'
    },
    'Gully': {
        bold: '/fonts/Gully-Bold.ttf',
        vf: '/fonts/GullyVF.ttf'
    },
    'Gyrochrome VF': {
        regular: '/fonts/GyrochromeVF.ttf'
    },
    'Hammersmith One': {
        regular: '/fonts/HammersmithOne-Regular.ttf'
    },
    'Hanalei Fill': {
        regular: '/fonts/HanaleiFill-Regular.ttf'
    },
    'Happy Monkey': {
        regular: '/fonts/HappyMonkey-Regular.ttf'
    },
    'Heavy Equipment': {
        regular: '/fonts/HeavyEquipment.ttf'
    },
    'Henny Penny': {
        regular: '/fonts/HennyPenny-Regular.ttf'
    },
    'Hepta Slab': {
        hairline: '/fonts/HeptaSlabHairline-Regular.ttf',
        vf: '/fonts/HeptaSlab-VF.ttf'
    },
    'Holtwood One SC': {
        regular: '/fonts/HoltwoodOneSC-Regular.ttf'
    },
    'Homemade Apple': {
        regular: '/fonts/HomemadeApple-Regular.ttf'
    },
    'Hyrax': {
        regular: '/fonts/hyrax.ttf'
    },
    'IBM Plex Serif': {
        bold: '/fonts/IBMPlexSerif-Bold.ttf',
        boldItalic: '/fonts/IBMPlexSerif-BoldItalic.ttf',
        italic: '/fonts/IBMPlexSerif-Italic.ttf',
        regular: '/fonts/IBMPlexSerif-Regular.ttf'
    },
    'IM Fel Pica': {
        italic: '/fonts/IMFelPica-Italic.ttf',
        regular: '/fonts/IMFelPica-Regular.ttf'
    },
    'IM Fell DW Pica': {
        italic: '/fonts/IMFellDWPica-Italic.ttf',
        regular: '/fonts/IMFellDWPica-Regular.ttf'
    },
    'Impact': {
        regular: '/fonts/Impact.ttf'
    },
    'Imperial': {
        regular: '/fonts/Imperial-Web.ttf'
    },
    'Inconsolata': {
        bold: '/fonts/Inconsolata-Bold.ttf',
        regular: '/fonts/Inconsolata-Regular.ttf'
    },
    'Inder': {
        regular: '/fonts/Inder-Regular.ttf'
    },
    'Inspiration': {
        regular: '/fonts/Inspiration-Regular.ttf'
    },
    'Inter': {
        regular: '/fonts/Inter.ttf',
        ht: '/fonts/Interht.ttf',
        italic: '/fonts/Inter-Italic.ttf',
        italicht: '/fonts/Inter-Italicht.ttf'
    },
    'Irish Grover': {
        regular: '/fonts/IrishGrover-Regular.ttf'
    },
    'Ignotum': {
        bold: '/fonts/Ignotum-Bold.ttf',
        boldItalic: '/fonts/Ignotum-BoldItalic.ttf',
        italic: '/fonts/Ignotum-Italic.ttf',
        regular: '/fonts/Ignotum-Regular.ttf'
    },
    'Jolly Lodger': {
        regular: '/fonts/JollyLodger-Regular.ttf'
    },
    'Jonova': {
        bold: '/fonts/Jonova-Bold.ttf',
        boldItalic: '/fonts/Jonova-BoldItalic.ttf',
        italic: '/fonts/Jonova-Italic.ttf',
        regular: '/fonts/Jonova-Regular.ttf'
    },
    'Jua': {
        regular: '/fonts/Jua-Regular.ttf'
    },
    'Just Another Hand': {
        regular: '/fonts/JustAnotherHand-Regular.ttf'
    },
    'Kablammo': {
        regularMorF: '/fonts/Kablammo-Regular-MORF.ttf'
    },
    'Karantina': {
        bold: '/fonts/Karantina-Bold.ttf',
        regular: '/fonts/Karantina-Regular.ttf'
    },
    'Karla': {
        bold: '/fonts/Karla-Bold.ttf',
        boldItalic: '/fonts/Karla-BoldItalic.ttf',
        italic: '/fonts/Karla-Italic.ttf',
        regular: '/fonts/Karla-Regular.ttf'
    },
    'Kaushan Script': {
        regular: '/fonts/KaushanScript-Regular.ttf'
    },
    'Keyes': {
        regular: '/fonts/keyes.ttf'
    },
    'Kranky': {
        regular: '/fonts/Kranky-Regular.ttf'
    },
    'Kristi': {
        regular: '/fonts/Kristi-Regular.ttf'
    },
    'LT Crow': {
        bold: '/fonts/LTCrow-Bold.ttf',
        regular: '/fonts/LTCrow-Regular.ttf'
    },
    'LT Hoodlum': {
        regular: '/fonts/LTHoodlum-Regular.ttf'
    },
    'LT Hoop': {
        bold: '/fonts/LTHoop-Bold.ttf',
        regular: '/fonts/LTHoop-Regular.ttf'
    },
    'LT Humor': {
        bold: '/fonts/LTHumor-Bold.ttf',
        boldItalic: '/fonts/LTHumor-BoldItalic.ttf',
        italic: '/fonts/LTHumor-Italic.ttf',
        regular: '/fonts/LTHumor-Regular.ttf'
    },
    'LT Museum': {
        bold: '/fonts/LTMuseum-Bold.ttf',
        boldItalic: '/fonts/LTMuseum-BoldItalic.ttf'
    },
    'LT Overflux': {
        regular: '/fonts/LTOverflux-Regular.ttf'
    },
    'LT Turbo': {
        regular: '/fonts/LTTurbo-Regular.ttf'
    },
    'Lakki Reddy': {
        regular: '/fonts/LakkiReddy-Regular.ttf'
    },
    'Lato': {
        bold: '/fonts/Lato-Bold.ttf',
        boldItalic: '/fonts/Lato-BoldItalic.ttf',
        italic: '/fonts/Lato-Italic.ttf',
        regular: '/fonts/Lato-Regular.ttf'
    },
    'League Gothic': {
        condensedRegular: '/fonts/LeagueGothic_Condensed-Regular.ttf',
        regular: '/fonts/LeagueGothic-Regular.ttf'
    },
    'Lexend Giga': {
        regular: '/fonts/LexendGiga.ttf',
        bold: '/fonts/LexendGiga-Bold.ttf'
    },
    'Lexend Tera': {
        bold: '/fonts/LexendTera-Bold.ttf',
        regular: '/fonts/LexendTera-Regular.ttf'
    },
    'Libre Baskerville': {
        bold: '/fonts/LibreBaskerville-Bold.ttf',
        italic: '/fonts/LibreBaskerville-Italic.ttf',
        regular: '/fonts/LibreBaskerville-Regular.ttf'
    },
    'Literata': {
        regular: '/fonts/Literata.ttf',
        bold: '/fonts/Literata-Bold.ttf',
        boldItalic: '/fonts/Literata-BoldItalic.ttf',
        italic: '/fonts/Literata-Italic.ttf'
    },
    'Lobster': {
        regular: '/fonts/Lobster-Regular.ttf'
    },
    'Lobster Two': {
        bold: '/fonts/LobsterTwo-Bold.ttf',
        boldItalic: '/fonts/LobsterTwo-BoldItalic.ttf',
        italic: '/fonts/LobsterTwo-Italic.ttf',
        regular: '/fonts/LobsterTwo-Regular.ttf'
    },
    'Londrina Solid': {
        regular: '/fonts/LondrinaSolid-Regular.ttf'
    },
    'Lora': {
        regular: '/fonts/Lora.ttf',
        bold: '/fonts/Lora-Bold.ttf',
        boldItalic: '/fonts/Lora-BoldItalic.ttf',
        italic: '/fonts/Lora-Italic.ttf'
    },
    'Loved by the King': {
        regular: '/fonts/LovedbytheKing-Regular.ttf'
    },
    'Love Ya Like A Sister': {
        regular: '/fonts/LoveYaLikeASister-Regular.ttf'
    },
    'Loxley': {
        regular: '/fonts/loxley.TTF'
    },
    'Luckiest Guy': {
        regular: '/fonts/LuckiestGuy-Regular.ttf'
    },
    'Macondo': {
        regular: '/fonts/Macondo-Regular.ttf'
    },
    'Manufacturing Consent': {
        regular: '/fonts/ManufacturingConsent-Regular.ttf'
    },
    'Manuskript Gothisch': {
        regular: '/fonts/ManuskriptGothisch.ttf'
    },
    'Mara Pfont': {
        regular: '/fonts/MaraPfont.ttf'
    },
    'Marcellus SC': {
        regular: '/fonts/MarcellusSC-Regular.ttf'
    },
    'Margariney Words': {
        bold: '/fonts/MargarineyWordsBold.ttf',
        regular: '/fonts/MargarineyWords.ttf'
    },
    'Martius': {
        italic: '/fonts/Martius-Italic.ttf',
        regular: '/fonts/Martius-Regular.ttf'
    },
    'Matemasie': {
        regular: '/fonts/Matemasie-Regular.ttf'
    },
    'Medula One': {
        regular: '/fonts/MedulaOne-Regular.ttf'
    },
    'Merriweather': {
        wdth: '/fonts/Merriweatherwdth.ttf'
    },
    'Michroma': {
        regular: '/fonts/Michroma.ttf'
    },
    'Midnight Letters': {
        regular: '/fonts/MidnightLetters.ttf',
        italic: '/fonts/MidnightLettersItalic.ttf'
    },
    'Modak': {
        regular: '/fonts/Modak-Regular.ttf'
    },
    'Moloko Font': {
        regular: '/fonts/molokofont.ttf'
    },
    'Monoton': {
        regular: '/fonts/Monoton-Regular.ttf'
    },
    'Montez': {
        regular: '/fonts/Montez-Regular.ttf'
    },
    'Montserrat Alternates': {
        bold: '/fonts/MontserratAlternates-Bold.ttf',
        regular: '/fonts/MontserratAlternates-Regular.ttf'
    },
    'Moonlit Flow': {
        regular: '/fonts/MoonlitFlow.ttf',
        italic: '/fonts/MoonlitFlowItalic.ttf'
    },
    'Mouse Memoirs': {
        regular: '/fonts/MouseMemoirs-Regular.ttf'
    },
    'Mr De Haviland': {
        regular: '/fonts/MrDeHaviland-Regular.ttf'
    },
    'Mystery Quest': {
        regular: '/fonts/MysteryQuest-Regular.ttf'
    },
    'Nerko One': {
        regular: '/fonts/NerkoOne-Regular.ttf'
    },
    'Norican': {
        regular: '/fonts/Norican-Regular.ttf'
    },
    'Nova Round': {
        regular: '/fonts/NovaRound.ttf'
    },
    'Nunito Sans': {
        regular: '/fonts/NunitoSans.ttf',
        italic: '/fonts/NunitoSans-Italic.ttf'
    },
    'Ode Erik': {
        regular: '/fonts/Ode-Erik.ttf'
    },
    'Oi': {
        regular: '/fonts/Oi-Regular.ttf'
    },
    'Ole': {
        regular: '/fonts/Ole-Regular.ttf'
    },
    'Oleo Script': {
        bold: '/fonts/OleoScript-Bold.ttf',
        regular: '/fonts/OleoScript-Regular.ttf'
    },
    'Orbitron': {
        bold: '/fonts/Orbitron-Bold.ttf',
        regular: '/fonts/Orbitron-Regular.ttf'
    },
    'Oregano': {
        italic: '/fonts/Oregano-Italic.ttf',
        regular: '/fonts/Oregano-Regular.ttf'
    },
    'Original Surfer': {
        regular: '/fonts/OriginalSurfer-Regular.ttf'
    },
    'Oswald': {
        regular: '/fonts/Oswald-.ttf',
        bold: '/fonts/Oswald-Bold.ttf'
    },
    'Outfit': {
        regular: '/fonts/Outfit-.ttf',
        bold: '/fonts/Outfit-Bold.ttf'
    },
    'Outward Block': {
        regular: '/fonts/outward-block.ttf'
    },
    'Outward Borders': {
        regular: '/fonts/outward-borders.ttf'
    },
    'Outward Round': {
        regular: '/fonts/outward-round.ttf'
    },
    'Overhaul': {
        regular: '/fonts/Overhaul.ttf'
    },
    'Oxanium': {
        bold: '/fonts/Oxanium-Bold.ttf',
        regular: '/fonts/Oxanium-Regular.ttf'
    },
    'Pacifico': {
        regular: '/fonts/Pacifico-Regular.ttf'
    },
    'Passion One': {
        bold: '/fonts/PassionOne-Bold.ttf',
        regular: '/fonts/PassionOne-Regular.ttf'
    },
    'Pathway Gothic One': {
        regular: '/fonts/PathwayGothicOne-Regular.ttf'
    },
    'Pattaya': {
        regular: '/fonts/Pattaya-Regular.ttf'
    },
    'Patua One': {
        regular: '/fonts/PatuaOne-Regular.ttf'
    },
    'Paytone One': {
        regular: '/fonts/PaytoneOne.ttf'
    },
    'Peace Sans': {
        regular: '/fonts/Peace-Sans-Webfont.ttf'
    },
    'Peralta': {
        regular: '/fonts/Peralta-Regular.ttf'
    },
    'Permanent Marker': {
        regular: '/fonts/PermanentMarker-Regular.ttf'
    },
    'Piedra': {
        regular: '/fonts/Piedra-Regular.ttf'
    },
    'Playfair Display': {
        regular: '/fonts/PlayfairDisplay-.ttf',
        bold: '/fonts/PlayfairDisplay-Bold.ttf',
        boldItalic: '/fonts/PlayfairDisplay-BoldItalic.ttf',
        italic: '/fonts/PlayfairDisplay-Italic.ttf'
    },
    'Playwrite IT Moderna': {
        regular: '/fonts/PlaywriteITModerna-Regular.ttf'
    },
    'Plus Jakarta Sans': {
        bold: '/fonts/PlusJakartaSans-Bold.ttf',
        boldItalic: '/fonts/PlusJakartaSans-BoldItalic.ttf',
        italic: '/fonts/PlusJakartaSans-Italic.ttf',
        regular: '/fonts/PlusJakartaSans-Regular.ttf'
    },
    'Podkova': {
        bold: '/fonts/Podkova-Bold.ttf',
        regular: '/fonts/Podkova-Regular.ttf',
        vf: '/fonts/Podkova-VF.ttf',
        romanVf: '/fonts/Podkova-Roman-VF.ttf'
    },
    'Pompiere': {
        regular: '/fonts/Pompiere-Regular.ttf'
    },
    'Poppins': {
        regular: '/fonts/Poppins-Regular.ttf'
    },
    'Portmanteau': {
        regular: '/fonts/Portmanteau-Regular.ttf'
    },
    'Potta One': {
        regular: '/fonts/PottaOne-Regular.ttf'
    },
    'Power': {
        regular: '/fonts/Power.ttf'
    },
    'Pretzel': {
        regular: '/fonts/PretzelRegular.ttf'
    },
    'Princess Sofia': {
        regular: '/fonts/PrincessSofia-Regular.ttf'
    },
    'Prosto One': {
        regular: '/fonts/ProstoOne-Regular.ttf'
    },
    'Protest Riot': {
        regular: '/fonts/ProtestRiot-Regular.ttf'
    },
    'Purple Purse': {
        regular: '/fonts/PurplePurse-Regular.ttf'
    },
    'Quicksand': {
        bold: '/fonts/Quicksand-Bold.ttf',
        regular: '/fonts/Quicksand-Regular.ttf'
    },
    'Qwigley': {
        regular: '/fonts/Qwigley-Regular.ttf'
    },
    'Raleway': {
        regular: '/fonts/Raleway-.ttf',
        bold: '/fonts/Raleway-Bold.ttf',
        boldItalic: '/fonts/Raleway-BoldItalic.ttf',
        italic: '/fonts/Raleway-Italic.ttf'
    },
    'Rammento One': {
        regular: '/fonts/RammentoOne-Regular.ttf'
    },
    'Ranchers': {
        regular: '/fonts/Ranchers-Regular.ttf'
    },
    'Remarcle': {
        regular: '/fonts/Remarcle.ttf'
    },
    'Ribeye Marrow': {
        regular: '/fonts/RibeyeMarrow-Regular.ttf'
    },
    'Righteous': {
        regular: '/fonts/Righteous-Regular.ttf'
    },
    'Risque': {
        regular: '/fonts/Risque-Regular.ttf'
    },
    'Road Rage': {
        regular: '/fonts/RoadRage-Regular.ttf'
    },
    'Roboto': {
        boldItalic: '/fonts/Roboto-BoldItalic.ttf',
        italic: '/fonts/Roboto-Italic.ttf',
        regular: '/fonts/Roboto-Regular.ttf'
    },
    'Roboto Slab': {
        bold: '/fonts/RobotoSlab-Bold.ttf',
        regular: '/fonts/RobotoSlab-Regular.ttf'
    },
    'Rochester': {
        regular: '/fonts/Rochester-Regular.ttf'
    },
    'Rock Salt': {
        regular: '/fonts/RockSalt-Regular.ttf'
    },
    'Rokkitt': {
        regular: '/fonts/Rokkitt.ttf',
        bold: '/fonts/Rokkitt-Bold.ttf',
        boldItalic: '/fonts/Rokkitt-BoldItalic.ttf',
        italic: '/fonts/Rokkitt-Italic.ttf'
    },
    'Rotunda Pommerania': {
        regular: '/fonts/Rotunda_Pommerania.ttf'
    },
    'Rubik': {
        regular: '/fonts/Rubik-.ttf',
        bold: '/fonts/Rubik-Bold.ttf',
        boldItalic: '/fonts/Rubik-BoldItalic.ttf',
        italic: '/fonts/Rubik-Italic.ttf'
    },
    'Rubik Bubbles': {
        regular: '/fonts/RubikBubbles-Regular.ttf'
    },
    'Rubik Dirt': {
        regular: '/fonts/Rubik-Dirt-Regular.ttf'
    },
    'Rubik Glitch': {
        regular: '/fonts/RubikGlitch-Regular.ttf'
    },
    'Rubik Mono One': {
        regular: '/fonts/RubikMonoOne-Regular.ttf'
    },
    'Rubik One': {
        regular: '/fonts/RubikOne-Regular.ttf'
    },
    'Rum Raisin': {
        regular: '/fonts/RumRaisin-Regular.ttf'
    },
    'Russo One': {
        regular: '/fonts/RussoOne-Regular.ttf'
    },
    'Ruthless Sketch': {
        regular: '/fonts/RuthlessSketch.ttf',
        italic: '/fonts/RuthlessSketchItalic.ttf'
    },
    'Sacramento': {
        regular: '/fonts/Sacramento-Regular.ttf'
    },
    'Saira Condensed': {
        bold: '/fonts/SairaCondensed-Bold.ttf',
        regular: '/fonts/SairaCondensed-Regular.ttf'
    },
    'Salsa': {
        regular: '/fonts/Salsa-Regular.ttf'
    },
    'Sangyo': {
        italic: '/fonts/Sangyo-Italic.ttf',
        regular: '/fonts/Sangyo-Regular.ttf'
    },
    'Saniretro': {
        regular: '/fonts/Saniretro.ttf'
    },
    'Sansita One': {
        regular: '/fonts/SansitaOne.ttf'
    },
    'Sarina': {
        regular: '/fonts/Sarina-Regular.ttf'
    },
    'Satisfy': {
        regular: '/fonts/Satisfy-Regular.ttf'
    },
    'Scratched Letters': {
        regular: '/fonts/ScratchedLetters.ttf'
    },
    'Secular One': {
        regular: '/fonts/SecularOne-Regular.ttf'
    },
    'Sedgwick Ave Display': {
        regular: '/fonts/SedgwickAveDisplay-Regular.ttf'
    },
    'Seymaz GX': {
        regular: '/fonts/SeymazGX.ttf',
        italic: '/fonts/SeymazGXslanted.ttf'
    },
    'Shrikhand': {
        regular: '/fonts/Shrikhand-Regular.ttf'
    },
    'Signwood': {
        italic: '/fonts/Signwood-Italic.ttf',
        regular: '/fonts/Signwood-Regular.ttf'
    },
    'Sikat': {
        regular: '/fonts/SIKAT.ttf'
    },
    'Single Day': {
        regular: '/fonts/SingleDay-Regular.ttf'
    },
    'Six Caps': {
        regular: '/fonts/SixCaps.ttf'
    },
    'Slackey': {
        regular: '/fonts/Slackey-Regular.ttf'
    },
    'Slim Jim': {
        regular: '/fonts/SlimJim.ttf'
    },
    'Sofia': {
        regular: '/fonts/Sofia-Regular.ttf'
    },
    'Sohoma': {
        extraBold: '/fonts/sohoma_extrabold.ttf',
        light: '/fonts/sohoma_light.ttf'
    },
    'Solway': {
        bold: '/fonts/Solway-Bold.ttf',
        regular: '/fonts/Solway-Regular.ttf'
    },
    'Source Sans Pro': {
        bold: '/fonts/SourceSansPro-Bold.ttf',
        boldItalic: '/fonts/SourceSansPro-BoldItalic.ttf',
        italic: '/fonts/SourceSansPro-Italic.ttf',
        regular: '/fonts/SourceSansPro-Regular.ttf'
    },
    'Special Elite': {
        regular: '/fonts/SpecialElite-Regular.ttf'
    },
    'Spectral SC': {
        bold: '/fonts/SpectralSC-Bold.ttf',
        boldItalic: '/fonts/SpectralSC-BoldItalic.ttf',
        italic: '/fonts/SpectralSC-Italic.ttf',
        regular: '/fonts/SpectralSC-Regular.ttf'
    },
    'Spectra SC': {
        bold: '/fonts/SpectraSC-Bold.ttf',
        boldItalic: '/fonts/SpectraSC-BoldItalic.ttf',
        italic: '/fonts/SpectraSC-Italic.ttf',
        regular: '/fonts/SpectraSC-Regular.ttf'
    },
    'Spicy Rice': {
        regular: '/fonts/SpicyRice-Regular.ttf'
    },
    'Squada One': {
        regular: '/fonts/SquadaOne-Regular.ttf'
    },
    'Stalemate': {
        regular: '/fonts/Stalemate-Regular.ttf'
    },
    'Sue Ellen Francisco': {
        regular: '/fonts/SueEllenFrancisco-Regular.ttf'
    },
    'Syncopate': {
        bold: '/fonts/Syncopate-Bold.ttf',
        regular: '/fonts/Syncopate-Regular.ttf'
    },
    'Tagesschrift': {
        regular: '/fonts/Tagesschrift-Regular.ttf'
    },
    'Teko': {
        bold: '/fonts/Teko-Bold.ttf',
        regular: '/fonts/Teko-Regular.ttf'
    },
    'Thernaly': {
        regular: '/fonts/Thernaly.ttf'
    },
    'Times New Roman': {
        regular: '/fonts/TimesNewRoman.ttf',
        bold: '/fonts/TimesNewRomanBold.ttf',
        boldItalic: '/fonts/TimesNewRomanBoldItalic.ttf',
        italic: '/fonts/TimesNewRomanItalic.ttf'
    },
    'Tiny MCE': {
        regular: '/fonts/tinymce.ttf',
        small: '/fonts/tinymce-small.ttf'
    },
    'Titan One': {
        regular: '/fonts/TitanOne-Regular.ttf'
    },
    'TMT Limkin VF': {
        regular: '/fonts/TMT-LimkinVF.ttf'
    },
    'Trade Winds': {
        regular: '/fonts/TradeWinds-Regular.ttf'
    },
    'Transit CAT': {
        regular: '/fonts/Transit-CAT.ttf'
    },
    'Trochut': {
        bold: '/fonts/Trochut-Bold.ttf',
        italic: '/fonts/Trochut-Italic.ttf',
        regular: '/fonts/Trochut-Regular.ttf'
    },
    'Tschichold': {
        bold: '/fonts/Tschichold-Bold.ttf',
        regular: '/fonts/Tschichold.ttf'
    },
    'Tulpen One': {
        regular: '/fonts/TulpenOne-Regular.ttf'
    },
    'Ubuntu': {
        bold: '/fonts/Ubuntu-Bold.ttf',
        boldItalic: '/fonts/Ubuntu-BoldItalic.ttf',
        italic: '/fonts/Ubuntu-Italic.ttf',
        regular: '/fonts/Ubuntu-Regular.ttf'
    },
    'Ultra': {
        regular: '/fonts/Ultra-Regular.ttf'
    },
    'Unbounded': {
        regular: '/fonts/Unbounded-.ttf',
        bold: '/fonts/Unbounded-Bold.ttf'
    },
    'Unifraktur Cook': {
        bold: '/fonts/UnifrakturCook-Bold.ttf'
    },
    'Utusi Star': {
        regular: '/fonts/Utusi_Star_Normal.ttf'
    },
    'Verdana': {
        regular: '/fonts/Verdana.ttf',
        bold: '/fonts/VerdanaBold.ttf',
        boldItalic: '/fonts/VerdanaBoldItalic.ttf',
        italic: '/fonts/VerdanaItalic.ttf'
    },
    'Vervelle Script': {
        regular: '/fonts/VervelleScript.ttf'
    },
    'Viga': {
        regular: '/fonts/Viga-Regular.ttf'
    },
    'Vina Sans': {
        regular: '/fonts/VinaSans-Regular.ttf'
    },
    'Voces': {
        regular: '/fonts/Voces-Regular.ttf'
    },
    'Warenhause Standard': {
        regular: '/fonts/Warenhause-Standard.ttf'
    },
    'Water Brush': {
        regular: '/fonts/WaterBrush-Regular.ttf'
    },
    'Westhorn': {
        italic: '/fonts/Westhorn-Italic.ttf',
        regular: '/fonts/Westhorn-Regular.ttf'
    },
    'Willow': {
        regular: '/fonts/willow.ttf'
    },
    'Winky Sans': {
        regular: '/fonts/WinkySans-.ttf',
        bold: '/fonts/WinkySans-Bold.ttf',
        boldItalic: '/fonts/WinkySans-BoldItalic.ttf',
        italic: '/fonts/WinkySans-Italic.ttf'
    },
    'Work Sans': {
        regular: '/fonts/WorkSans-.ttf',
        blackItalic: '/fonts/WorkSans-BlackItalic.ttf',
        bold: '/fonts/WorkSans-Bold.ttf',
        boldItalic: '/fonts/WorkSans-BoldItalic.ttf'
    },
    'Xanmono': {
        regular: '/fonts/Xanmono.ttf',
        italic: '/fonts/Xanmonoltallic.ttf'
    },
    'Yellowtail': {
        regular: '/fonts/Yellowtail-Regular.ttf'
    },
    'Yesteryear': {
        regular: '/fonts/Yesteryear-Regular.ttf'
    },
    'Zen Dots': {
        regular: '/fonts/ZenDots-Regular.ttf'
    }
};
// Make fontMap accessible to window for use in HTML
window.fontMap = fontMap;
   // Function to populate font dropdown from fontMap
   function populateFontDropdown() {
       console.log('🔤 populateFontDropdown() called');

       const fontSelect = document.getElementById('iFontFamily');
       if (!fontSelect) {
           console.warn('❌ Font dropdown element not found');
           return;
       }

       console.log('✅ Font dropdown element found');
       console.log('🗂️ fontMap object:', typeof fontMap, Object.keys(fontMap).length, 'fonts');

       // Get sorted font names from fontMap
       const sortedFontNames = Object.keys(fontMap).sort();

       console.log('📋 Current dropdown options before clearing:', fontSelect.options.length);

       // Clear existing options
       fontSelect.innerHTML = '';

       // Add fonts from fontMap with font styling
       sortedFontNames.forEach(fontName => {
           const option = document.createElement('option');
           option.value = fontName;
           option.textContent = fontName;
           // Add CSS class for font styling
           option.className = `font-option-${fontName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`;
           fontSelect.appendChild(option);
       });

       // Generate and inject CSS for font preview styling
       generateFontPreviewCSS(sortedFontNames);

       console.log(`✅ Font dropdown populated with ${sortedFontNames.length} fonts from fontMap`);
       console.log('📋 Final dropdown options count:', fontSelect.options.length);
       console.log('📝 First 10 fonts:', sortedFontNames.slice(0, 10));
   }

   // Function to generate CSS for font preview in dropdown
   function generateFontPreviewCSS(fontNames) {
       console.log('🎨 Generating font preview CSS...');

       // Remove existing font preview styles if any
       const existingStyle = document.getElementById('font-preview-styles');
       if (existingStyle) {
           existingStyle.remove();
       }

       // Create CSS rules for each font (using regular variant only)
       let cssRules = '';
       fontNames.forEach(fontName => {
           const className = `font-option-${fontName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`;
           // Always use the regular font family name for dropdown preview
           // This ensures fonts display in normal style, not italic
           cssRules += `
               select#iFontFamily option.${className} {
                   font-family: "${fontName}", Arial, sans-serif !important;
                   font-style: normal !important;
                   font-weight: normal !important;
                   font-size: 16px !important;
                   padding: 4px 8px !important;
               }
           `;
       });

       // Add general styling for the dropdown
       cssRules += `
           select#iFontFamily {
               font-size: 14px;
           }
           select#iFontFamily option {
               padding: 6px 10px;
               font-size: 16px;
               font-style: normal !important;
               font-weight: normal !important;
           }
       `;

       // Create and inject the style element
       const styleElement = document.createElement('style');
       styleElement.id = 'font-preview-styles';
       styleElement.textContent = cssRules;
       document.head.appendChild(styleElement);

       console.log(`🎨 Generated CSS for ${fontNames.length} font previews`);
   }

   // Function to preload and register all fonts
   async function preloadFonts() {
       console.log('🔤 Starting font preloading...');
       const fontPromises = [];

       for (const [fontFamily, variants] of Object.entries(fontMap)) {
           for (const [variant, fontPath] of Object.entries(variants)) {
               if (fontPath) {
                   console.log(`🔄 Loading font: ${fontFamily} (${variant}) from ${fontPath}`);

                   // Use unique font family names for variants to prevent overwriting
                   const uniqueFontFamily = variant === 'regular' ? fontFamily : `${fontFamily}-${variant}`;
                   const fontFace = new FontFace(uniqueFontFamily, `url(${fontPath})`);
                   const promise = fontFace.load().then(() => {
                       document.fonts.add(fontFace);
                       console.log(`✅ Font loaded: ${uniqueFontFamily} (${variant})`);
                       return uniqueFontFamily;
                   }).catch(err => {
                       console.error(`❌ Failed to load font: ${fontFamily} (${variant}) from ${fontPath}:`, err);
                       return null;
                   });

                   fontPromises.push(promise);
               }
           }
       }

       const results = await Promise.allSettled(fontPromises);
       const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
       const totalCount = fontPromises.length;

       console.log(`🎉 Font preloading complete: ${successCount}/${totalCount} fonts loaded successfully`);

       // List all loaded fonts
       const loadedFonts = Array.from(document.fonts).map(f => f.family);
       console.log('📚 All loaded fonts:', [...new Set(loadedFonts)].sort());
   }

   // Call the function when the page loads
   document.addEventListener('DOMContentLoaded', () => {
       console.log('🚀 DOMContentLoaded event fired, scheduling font dropdown population and font preloading');
       // Small delay to ensure the DOM is fully ready
       setTimeout(async () => {
           console.log('⏰ Timeout fired, calling populateFontDropdown and preloadFonts');

           // First populate the dropdown (without styling)
           populateFontDropdown();

           // Then preload fonts
           await preloadFonts();

           // Finally, regenerate the dropdown with font styling now that fonts are loaded
           console.log('🎨 Regenerating dropdown with font styling...');
           populateFontDropdown();

           // Initialize font variant detector with the same fontMap
           if (window.fontVariantDetector) {
               console.log('🔤 Initializing font variant detector with fontMap...');
               window.fontVariantDetector.initialize(fontMap);
           }

       }, 100);
   });

   // Also try calling it when the window loads as a backup
   window.addEventListener('load', () => {
       console.log('🌐 Window load event fired, calling populateFontDropdown as backup');
       populateFontDropdown();
   });

   // Helper function to get font path for a font family
   function getFontPathForFamily(fontFamily, isBold = false, isItalic = false) {
       // Determine which variant to use
       let variant = 'regular';
       if (isBold && isItalic) {
           variant = 'boldItalic';
       } else if (isBold) {
           variant = 'bold';
       } else if (isItalic) {
           variant = 'italic';
       }

       // Get the font map for the requested family
       const familyMap = fontMap[fontFamily];

       // If we have a map for this family, return the appropriate variant
       if (familyMap) {
           // If the specific variant doesn't exist, fall back to regular
           return familyMap[variant] || familyMap['regular'];
       }

       // Use Poppins as a fallback since it's likely to exist
       return fontMap['Poppins']['regular'];
   }

   // Initialize grid control points for a text object
   function initializeGridPoints(textObj) {
       // Make sure gridDistort object exists
       if (!textObj.gridDistort) {
           console.log('Creating gridDistort object for text:', textObj.text);
           textObj.gridDistort = {
               gridCols: textObj.gridDistortCols || 2,
               gridRows: textObj.gridDistortRows || 1,
               gridPadding: textObj.gridDistortPadding || 120,
               intensity: (textObj.gridDistortIntensity || 100) / 100,
               controlPoints: [],
               showGrid: true,
               lastFontSize: textObj.fontSize,
               lastText: textObj.text,
               relativeControlPoints: [],
               verticalOnly: textObj.gridDistortVerticalOnly !== undefined ? textObj.gridDistortVerticalOnly : true
           };
       }

       // Get accurate text dimensions using a temporary canvas
       const tempCtx = document.createElement('canvas').getContext('2d');

       // Make sure to set the correct font style
       const fontStyle = `${textObj.italic ? 'italic ' : ''}${textObj.bold ? 'bold ' : ''}${textObj.fontSize}px "${textObj.fontFamily}"`;
       tempCtx.font = fontStyle;

       // Apply letter spacing if specified
       const letterSpacing = textObj.letterSpacing !== undefined ? textObj.letterSpacing : 0;

       console.log('Measuring text with font style:', fontStyle, 'letter spacing:', letterSpacing);

       // 📦 MULTI-LINE GRID: Check if text is wrapped (textBoxWidth > 0)
       const textBoxWidth = textObj.textBoxWidth || 0;
       let textWidth, textHeight;

       if (textBoxWidth > 0) {
           // 📦 WRAPPED TEXT: Calculate dimensions for multi-line text
           const lines = textObj.text.split('\n');
           console.log('📦 GRID: Calculating wrapped text dimensions for', lines.length, 'lines');

           // Find the widest line
           let maxLineWidth = 0;

           lines.forEach((line, index) => {
               let lineWidth;
               if (letterSpacing === 0) {
                   lineWidth = tempCtx.measureText(line).width;
               } else {
                   // Calculate width with letter spacing for this line
                   const letters = line.split('');
                   let totalWidth = 0;
                   letters.forEach(letter => {
                       totalWidth += tempCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }
                   lineWidth = totalWidth;
               }
               maxLineWidth = Math.max(maxLineWidth, lineWidth);
               console.log('📦 GRID: Line', index + 1, ':', line, 'width:', lineWidth);
           });

           textWidth = maxLineWidth;

           // Calculate height for multiple lines
           const fontSize = textObj.fontSize || 20;
           const lineHeight = fontSize * 1.2; // Standard line height
           textHeight = lines.length * lineHeight;

           console.log('📦 GRID: Wrapped text final dimensions - width:', textWidth, 'height:', textHeight, 'lines:', lines.length);
       } else {
           // 📦 SINGLE LINE: Use existing single-line calculation
           if (letterSpacing === 0) {
               // Standard text measurement
               textWidth = tempCtx.measureText(textObj.text).width;
           } else {
               // Calculate width with letter spacing
               const letters = textObj.text.split('');
               let totalWidth = 0;

               // Sum the width of each letter
               letters.forEach(letter => {
                   totalWidth += tempCtx.measureText(letter).width;
               });

               // Add letter spacing between characters
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               textWidth = totalWidth;
           }

           // Get metrics for height calculation
           const metrics = tempCtx.measureText('M'); // Use a representative character
           textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent || textObj.fontSize;

           console.log('📦 GRID: Single line text dimensions - width:', textWidth, 'height:', textHeight);
       }

       // Store the measured dimensions on the text object for reference
       textObj.measuredWidth = textWidth;
       textObj.measuredHeight = textHeight;

       // Log the text and its dimensions for debugging
       console.log('Initializing grid for text:', textObj.text, {
           width: textWidth,
           height: textHeight,
           fontSize: textObj.fontSize
       });

       // Calculate grid bounds with padding that scales with font size
       // Use a percentage of the font size for padding (e.g., 50% of font size)
       const paddingScale = 0.5; // 50% of font size
       const basePadding = textObj.gridDistort.gridPadding;
       const scaledPadding = Math.max(basePadding, textObj.fontSize * paddingScale);

       // Store the grid bounds for later use
       textObj.gridDistort.gridBounds = {
           width: textWidth,
           height: textHeight,
           padding: scaledPadding
       };

       // Calculate grid dimensions using the padding from gridBounds
       const padding = textObj.gridDistort.gridBounds.padding;
       const gridWidth = textWidth + padding * 2;
       const gridHeight = textHeight + padding * 2;
       const gridLeft = -textWidth/2 - padding;
       const gridTop = -textHeight/2 - padding;

       // Check if we need to preserve distortion from previous text
       const textChanged = textObj.gridDistort &&
                          textObj.gridDistort.lastText !== undefined &&
                          textObj.gridDistort.lastText !== textObj.text;

       // Always check for font size changes, not just significant ones
       const fontSizeChanged = textObj.gridDistort &&
                              textObj.gridDistort.lastFontSize &&
                              textObj.gridDistort.lastFontSize !== textObj.fontSize;

       console.log('Text/font change check:', {
           currentText: textObj.text,
           lastText: textObj.gridDistort ? textObj.gridDistort.lastText : 'undefined',
           textChanged: textChanged,
           fontSizeChanged: fontSizeChanged,
           oldFontSize: textObj.gridDistort ? textObj.gridDistort.lastFontSize : 'undefined',
           newFontSize: textObj.fontSize,
           hasRelativePoints: textObj.gridDistort &&
                             textObj.gridDistort.relativeControlPoints &&
                             textObj.gridDistort.relativeControlPoints.length > 0
       });

       // If text or font size changed and we have previous control points with relative positions, use them
       if ((textChanged || fontSizeChanged) &&
           textObj.gridDistort.relativeControlPoints &&
           textObj.gridDistort.relativeControlPoints.length > 0) {

           console.log('Text/font changed, preserving distortion pattern');

           // Initialize control points array
           textObj.gridDistort.controlPoints = [];

           // Get grid dimensions, ensuring at least 1 for rows and columns
           const gridRows = Math.max(1, textObj.gridDistort.gridRows);
           const gridCols = Math.max(1, textObj.gridDistort.gridCols);

           // Apply the relative control points to the new grid size
           for (let row = 0; row < textObj.gridDistort.relativeControlPoints.length; row++) {
               const rowPoints = [];
               for (let col = 0; col < textObj.gridDistort.relativeControlPoints[row].length; col++) {
                   const relPoint = textObj.gridDistort.relativeControlPoints[row][col];

                   // Convert relative position (0-1) back to absolute position
                   const x = gridLeft + relPoint.x * gridWidth;
                   const y = gridTop + relPoint.y * gridHeight;

                   rowPoints.push({ x, y });
               }
               textObj.gridDistort.controlPoints.push(rowPoints);
           }

           // Update the last text and font size AFTER we've used the old values for scaling
           textObj.gridDistort.lastText = textObj.text;
           textObj.gridDistort.lastFontSize = textObj.fontSize;

           return; // Skip the rest of the initialization since we've restored the points
       }

       // If we're here, we need to create new control points
       // Initialize control points array
       textObj.gridDistort.controlPoints = [];

       // Get grid dimensions, ensuring at least 1 for rows and columns
       const gridRows = Math.max(1, textObj.gridDistort.gridRows);
       const gridCols = Math.max(1, textObj.gridDistort.gridCols);

       // Special case for 1x1 grid (just 4 corner points)
       if (gridRows === 1 && gridCols === 1) {
           // Create a 2x2 grid (4 corner points) instead of a single point
           const topRow = [];
           const bottomRow = [];

           // Top-left
           topRow.push({ x: gridLeft, y: gridTop });
           // Top-right
           topRow.push({ x: gridLeft + gridWidth, y: gridTop });

           // Bottom-left
           bottomRow.push({ x: gridLeft, y: gridTop + gridHeight });
           // Bottom-right
           bottomRow.push({ x: gridLeft + gridWidth, y: gridTop + gridHeight });

           textObj.gridDistort.controlPoints.push(topRow);
           textObj.gridDistort.controlPoints.push(bottomRow);
       }
       // Special case for 1 row - create 2 rows with points at the edges
       else if (gridRows === 1) {
           const topRow = [];
           const bottomRow = [];

           // Create evenly spaced columns
           for (let col = 0; col <= gridCols; col++) {
               const xFactor = col / gridCols;
               const x = gridLeft + xFactor * gridWidth;

               // Add points at top and bottom edges
               topRow.push({ x, y: gridTop });
               bottomRow.push({ x, y: gridTop + gridHeight });
           }

           textObj.gridDistort.controlPoints.push(topRow);
           textObj.gridDistort.controlPoints.push(bottomRow);
       }
       // Special case for 1 column - create 2 columns with points at the edges
       else if (gridCols === 1) {
           // Create evenly spaced rows
           for (let row = 0; row <= gridRows; row++) {
               const rowPoints = [];
               const yFactor = row / gridRows;
               const y = gridTop + yFactor * gridHeight;

               // Add points at left and right edges
               rowPoints.push({ x: gridLeft, y });
               rowPoints.push({ x: gridLeft + gridWidth, y });

               textObj.gridDistort.controlPoints.push(rowPoints);
           }
       }
       // Normal case - create a grid with the specified number of rows and columns
       else {
           // Create grid points - these are in object space (relative to object center)
           for (let row = 0; row <= gridRows; row++) {
               const rowPoints = [];
               for (let col = 0; col <= gridCols; col++) {
                   // Calculate evenly spaced points
                   const xFactor = col / gridCols;
                   const yFactor = row / gridRows;

                   const x = gridLeft + xFactor * gridWidth;
                   const y = gridTop + yFactor * gridHeight;

                   rowPoints.push({ x, y });
               }
               textObj.gridDistort.controlPoints.push(rowPoints);
           }
       }

       console.log('Grid initialized with points:', textObj.gridDistort.controlPoints.length, 'rows');

       // Store the relative positions for future text changes
       storeRelativeControlPoints(textObj);

       // Update the last text and font size
       textObj.gridDistort.lastText = textObj.text;
       textObj.gridDistort.lastFontSize = textObj.fontSize;
   }

   // Draw grid for visualization
   function drawGrid(textObj, targetCtx) {
       if (!textObj.gridDistort || !textObj.gridDistort.controlPoints ||
           !textObj.gridDistort.controlPoints.length) {
           console.warn('No grid control points to draw');
           return;
       }

       const controlPoints = textObj.gridDistort.controlPoints;
       const gridRows = textObj.gridDistort.gridRows || 2;
       const gridCols = textObj.gridDistort.gridCols || 3;

       // Draw grid lines
       targetCtx.save();
       targetCtx.strokeStyle = '#3b82f6';
       targetCtx.lineWidth = 2 / scale; // Adjust line width based on zoom level

       console.log('Drawing grid with', controlPoints.length, 'rows and',
                  controlPoints[0] ? controlPoints[0].length : 0, 'columns');

       // Special case for 1x1 grid - draw a rectangle using the 4 corner points
       if (gridRows === 1 && gridCols === 1) {
           if (controlPoints.length >= 2 && controlPoints[0].length >= 2) {
               // Draw the rectangle outline
               targetCtx.beginPath();

               // Top edge
               targetCtx.moveTo(controlPoints[0][0].x, controlPoints[0][0].y);
               targetCtx.lineTo(controlPoints[0][1].x, controlPoints[0][1].y);

               // Right edge
               targetCtx.lineTo(controlPoints[1][1].x, controlPoints[1][1].y);

               // Bottom edge
               targetCtx.lineTo(controlPoints[1][0].x, controlPoints[1][0].y);

               // Left edge (back to start)
               targetCtx.lineTo(controlPoints[0][0].x, controlPoints[0][0].y);

               targetCtx.stroke();
           }
       }
       // Special case for 1 row - draw only the top and bottom edges
       else if (gridRows === 1) {
           if (controlPoints.length >= 2) {
               // Top edge
               targetCtx.beginPath();
               for (let col = 0; col < controlPoints[0].length; col++) {
                   const point = controlPoints[0][col];
                   if (col === 0) {
                       targetCtx.moveTo(point.x, point.y);
                   } else {
                       targetCtx.lineTo(point.x, point.y);
                   }
               }
               targetCtx.stroke();

               // Bottom edge
               targetCtx.beginPath();
               for (let col = 0; col < controlPoints[1].length; col++) {
                   const point = controlPoints[1][col];
                   if (col === 0) {
                       targetCtx.moveTo(point.x, point.y);
                   } else {
                       targetCtx.lineTo(point.x, point.y);
                   }
               }
               targetCtx.stroke();

               // Draw vertical lines connecting top and bottom
               if (gridCols > 0) {
                   for (let col = 0; col < controlPoints[0].length; col++) {
                       targetCtx.beginPath();
                       targetCtx.moveTo(controlPoints[0][col].x, controlPoints[0][col].y);
                       targetCtx.lineTo(controlPoints[1][col].x, controlPoints[1][col].y);
                       targetCtx.stroke();
                   }
               }
           }
       }
       // Special case for 1 column - draw only the left and right edges
       else if (gridCols === 1) {
           if (controlPoints[0] && controlPoints[0].length >= 2) {
               // Left edge
               targetCtx.beginPath();
               for (let row = 0; row < controlPoints.length; row++) {
                   const point = controlPoints[row][0];
                   if (row === 0) {
                       targetCtx.moveTo(point.x, point.y);
                   } else {
                       targetCtx.lineTo(point.x, point.y);
                   }
               }
               targetCtx.stroke();

               // Right edge
               targetCtx.beginPath();
               for (let row = 0; row < controlPoints.length; row++) {
                   const point = controlPoints[row][1];
                   if (row === 0) {
                       targetCtx.moveTo(point.x, point.y);
                   } else {
                       targetCtx.lineTo(point.x, point.y);
                   }
               }
               targetCtx.stroke();

               // Draw horizontal lines connecting left and right
               for (let row = 0; row < controlPoints.length; row++) {
                   targetCtx.beginPath();
                   targetCtx.moveTo(controlPoints[row][0].x, controlPoints[row][0].y);
                   targetCtx.lineTo(controlPoints[row][1].x, controlPoints[row][1].y);
                   targetCtx.stroke();
               }
           }
       }
       // Normal case - draw full grid
       else {
           // Draw horizontal grid lines
           for (let row = 0; row < controlPoints.length; row++) {
               targetCtx.beginPath();
               for (let col = 0; col < controlPoints[row].length; col++) {
                   const point = controlPoints[row][col];
                   if (col === 0) {
                       targetCtx.moveTo(point.x, point.y);
                   } else {
                       targetCtx.lineTo(point.x, point.y);
                   }
               }
               targetCtx.stroke();
           }

           // Draw vertical grid lines
           if (controlPoints[0]) {
               for (let col = 0; col < controlPoints[0].length; col++) {
                   targetCtx.beginPath();
                   for (let row = 0; row < controlPoints.length; row++) {
                       const point = controlPoints[row][col];
                       if (row === 0) {
                           targetCtx.moveTo(point.x, point.y);
                       } else {
                           targetCtx.lineTo(point.x, point.y);
                       }
                   }
                   targetCtx.stroke();
               }
           }
       }

       // Draw control points
       targetCtx.fillStyle = '#3b82f6';
       for (let row = 0; row < controlPoints.length; row++) {
           for (let col = 0; col < controlPoints[row].length; col++) {
               const point = controlPoints[row][col];
               targetCtx.beginPath();
               targetCtx.arc(point.x, point.y, 10 / scale, 0, Math.PI * 2); // Increased point size for better visibility
               targetCtx.fill();
           }
       }

       // Draw a border around the grid area
       if (textObj.gridDistort.gridBounds) {
           const bounds = textObj.gridDistort.gridBounds;
           const scaledPadding = bounds.padding; // This is already scaled with font size
           const width = bounds.width;
           const height = bounds.height;

           targetCtx.strokeStyle = '#ff6b6b'; // Different color for the border
           targetCtx.lineWidth = 1 / scale;
           targetCtx.setLineDash([5 / scale, 5 / scale]);

           // Draw rectangle around the text area (without padding)
           targetCtx.strokeRect(-width/2, -height/2, width, height);

           // Draw rectangle around the grid area (with padding)
           targetCtx.strokeStyle = '#3b82f6';
           targetCtx.strokeRect(-width/2 - scaledPadding, -height/2 - scaledPadding,
                               width + scaledPadding * 2, height + scaledPadding * 2);

           targetCtx.setLineDash([]); // Reset dash pattern
       }

       targetCtx.restore();
   }

   // Function to store relative positions of control points
   function storeRelativeControlPoints(textObj) {
       if (!textObj || !textObj.gridDistort || !textObj.gridDistort.controlPoints ||
           !textObj.gridDistort.gridBounds) {
           console.warn('Cannot store relative control points - missing required properties');
           return;
       }

       // Calculate grid dimensions
       const padding = textObj.gridDistort.gridBounds.padding;
       const textWidth = textObj.gridDistort.gridBounds.width;
       const textHeight = textObj.gridDistort.gridBounds.height;
       const gridWidth = textWidth + padding * 2;
       const gridHeight = textHeight + padding * 2;
       const gridLeft = -textWidth/2 - padding;
       const gridTop = -textHeight/2 - padding;

       // Initialize relative control points array
       textObj.gridDistort.relativeControlPoints = [];

       // Convert absolute positions to relative positions (0-1 range)
       for (let row = 0; row < textObj.gridDistort.controlPoints.length; row++) {
           const rowPoints = [];
           for (let col = 0; col < textObj.gridDistort.controlPoints[row].length; col++) {
               const point = textObj.gridDistort.controlPoints[row][col];

               // Convert to relative position (0-1 range)
               const relX = (point.x - gridLeft) / gridWidth;
               const relY = (point.y - gridTop) / gridHeight;

               rowPoints.push({ x: relX, y: relY });
           }
           textObj.gridDistort.relativeControlPoints.push(rowPoints);
       }

       console.log('Stored relative control points for preserving distortion', {
           gridDimensions: { width: gridWidth, height: gridHeight, left: gridLeft, top: gridTop },
           pointCount: textObj.gridDistort.controlPoints.length *
                      (textObj.gridDistort.controlPoints[0] ? textObj.gridDistort.controlPoints[0].length : 0),
           relativePointsCount: textObj.gridDistort.relativeControlPoints.length *
                               (textObj.gridDistort.relativeControlPoints[0] ?
                                textObj.gridDistort.relativeControlPoints[0].length : 0)
       });
   }

   // Variables to track grid point dragging
   let isDraggingGridPoint = false;
   let draggedPointRow = -1;
   let draggedPointCol = -1;
   let draggedObject = null;

   // Find if a point was clicked
   function findGridPointAt(obj, worldX, worldY) {
       if (!obj || !obj.gridDistort || !obj.gridDistort.controlPoints) {
           return { hit: false };
       }

       // Convert world coordinates to object-local coordinates
       const dx = worldX - obj.x;
       const dy = worldY - obj.y;
       const angleRad = -obj.rotation * Math.PI / 180;
       const cos = Math.cos(angleRad);
       const sin = Math.sin(angleRad);
       const localX = dx * cos - dy * sin;
       const localY = dx * sin + dy * cos;

       // Check each control point
       const controlPoints = obj.gridDistort.controlPoints;
       const hitRadius = 20 / scale; // Increased hit radius to make points easier to click

       for (let row = 0; row < controlPoints.length; row++) {
           for (let col = 0; col < controlPoints[row].length; col++) {
               const point = controlPoints[row][col];
               const dist = Math.sqrt(
                   Math.pow(point.x - localX, 2) +
                   Math.pow(point.y - localY, 2)
               );

               if (dist <= hitRadius) {
                   return {
                       hit: true,
                       row: row,
                       col: col
                   };
               }
           }
       }

       return { hit: false };
   }

   // Get warped position based on grid control points
   function getWarpedPosition(x, y, controlPoints, cols, rows, gridLeft, gridTop, gridWidth, gridHeight, intensity, verticalOnly = false) {
       try {
           // Handle special cases for 1 row or 1 column
           if (cols < 1 || rows < 1 || !controlPoints || !controlPoints.length) {
               return { x, y }; // Return original position for invalid grid
           }

           // Special case for 1x1 grid (just 4 corner points)
           if (cols === 1 && rows === 1) {
               // For a 1x1 grid, we just use the 4 corner points directly
               const p00 = controlPoints[0][0];
               const p10 = controlPoints[0][1];
               const p01 = controlPoints[1][0];
               const p11 = controlPoints[1][1];

               // Normalize coordinates to 0-1 range within the grid
               const u = Math.max(0, Math.min(1, (x - gridLeft) / gridWidth));
               const v = Math.max(0, Math.min(1, (y - gridTop) / gridHeight));

               // Smooth interpolation factors
               const fx2 = u * u * (3 - 2 * u);
               const fy2 = v * v * (3 - 2 * v);

               // Bilinear interpolation
               const topX = p00.x * (1 - fx2) + p10.x * fx2;
               const botX = p01.x * (1 - fx2) + p11.x * fx2;
               const topY = p00.y * (1 - fx2) + p10.y * fx2;
               const botY = p01.y * (1 - fx2) + p11.y * fx2;

               // Final interpolated position
               const warpedX = topX * (1 - fy2) + botX * fy2;
               const warpedY = topY * (1 - fy2) + botY * fy2;

               return {
                   // If verticalOnly is true, only apply the vertical distortion
                   x: verticalOnly ? x : x + (warpedX - x) * intensity,
                   y: y + (warpedY - y) * intensity
               };
           }

           // Special case for 1 row (which now has 2 rows of control points - top and bottom edges)
           if (rows === 1) {
               // For 1 row, we interpolate between top and bottom rows
               const u = Math.max(0, Math.min(1, (x - gridLeft) / gridWidth));
               const v = Math.max(0, Math.min(1, (y - gridTop) / gridHeight));

               // Get column index
               const cellX = Math.min(u * cols, cols - 0.001);
               const ix = Math.floor(cellX);
               const fx = cellX - ix;

               // Safety check
               if (ix < 0 || ix >= cols || !controlPoints[0] || !controlPoints[1] ||
                   !controlPoints[0][ix] || !controlPoints[0][ix+1] ||
                   !controlPoints[1][ix] || !controlPoints[1][ix+1]) {
                   return { x, y };
               }

               // Get the four control points (top and bottom row)
               const p00 = controlPoints[0][ix];     // top left
               const p10 = controlPoints[0][ix + 1]; // top right
               const p01 = controlPoints[1][ix];     // bottom left
               const p11 = controlPoints[1][ix + 1]; // bottom right

               // Smooth interpolation factors
               const fx2 = fx * fx * (3 - 2 * fx);
               const fy2 = v; // Linear interpolation for vertical (only 2 points)

               // Bilinear interpolation
               const topX = p00.x * (1 - fx2) + p10.x * fx2;
               const botX = p01.x * (1 - fx2) + p11.x * fx2;
               const topY = p00.y * (1 - fx2) + p10.y * fx2;
               const botY = p01.y * (1 - fx2) + p11.y * fx2;

               // Final interpolated position
               const warpedX = topX * (1 - fy2) + botX * fy2;
               const warpedY = topY * (1 - fy2) + botY * fy2;

               return {
                   // If verticalOnly is true, only apply the vertical distortion
                   x: verticalOnly ? x : x + (warpedX - x) * intensity,
                   y: y + (warpedY - y) * intensity
               };
           }

           // Special case for 1 column (which now has 2 columns of control points - left and right edges)
           if (cols === 1) {
               // For 1 column, we interpolate between left and right columns
               const u = Math.max(0, Math.min(1, (x - gridLeft) / gridWidth));
               const v = Math.max(0, Math.min(1, (y - gridTop) / gridHeight));

               // Get row index
               const cellY = Math.min(v * rows, rows - 0.001);
               const iy = Math.floor(cellY);
               const fy = cellY - iy;

               // Safety check
               if (iy < 0 || iy >= rows || !controlPoints[iy] || !controlPoints[iy+1] ||
                   !controlPoints[iy][0] || !controlPoints[iy][1] ||
                   !controlPoints[iy+1][0] || !controlPoints[iy+1][1]) {
                   return { x, y };
               }

               // Get the four control points (left and right columns)
               const p00 = controlPoints[iy][0];     // top left
               const p10 = controlPoints[iy][1];     // top right
               const p01 = controlPoints[iy+1][0];   // bottom left
               const p11 = controlPoints[iy+1][1];   // bottom right

               // Smooth interpolation factors
               const fx2 = u; // Linear interpolation for horizontal (only 2 points)
               const fy2 = fy * fy * (3 - 2 * fy);

               // Bilinear interpolation
               const topX = p00.x * (1 - fx2) + p10.x * fx2;
               const botX = p01.x * (1 - fx2) + p11.x * fx2;
               const topY = p00.y * (1 - fx2) + p10.y * fx2;
               const botY = p01.y * (1 - fx2) + p11.y * fx2;

               // Final interpolated position
               const warpedX = topX * (1 - fy2) + botX * fy2;
               const warpedY = topY * (1 - fy2) + botY * fy2;

               return {
                   x: x + (warpedX - x) * intensity,
                   y: y + (warpedY - y) * intensity
               };
           }

           // Normal case (multiple rows and columns)
           // Normalize coordinates to 0-1 range within the grid
           const nx = (x - gridLeft) / gridWidth;
           const ny = (y - gridTop) / gridHeight;

           // Clamp to valid range
           const u = Math.max(0, Math.min(1, nx));
           const v = Math.max(0, Math.min(1, ny));

           // Find grid cell
           const cellX = Math.min(u * cols, cols - 0.001);
           const cellY = Math.min(v * rows, rows - 0.001);

           // Get indices of the four corners
           const ix = Math.floor(cellX);
           const iy = Math.floor(cellY);

           // Safety check for valid indices
           if (ix < 0 || iy < 0 || ix >= cols || iy >= rows ||
               !controlPoints[iy] || !controlPoints[iy][ix] ||
               !controlPoints[iy][ix+1] || !controlPoints[iy+1] ||
               !controlPoints[iy+1][ix] || !controlPoints[iy+1][ix+1]) {
               return { x, y }; // Return original position if out of bounds
           }

           // Fractional position within the cell
           const fx = cellX - ix;
           const fy = cellY - iy;

           // Get the four control points around this position
           const p00 = controlPoints[iy][ix];
           const p10 = controlPoints[iy][ix + 1];
           const p01 = controlPoints[iy + 1][ix];
           const p11 = controlPoints[iy + 1][ix + 1];

           // Smooth interpolation factors (using cubic hermite)
           const fx2 = fx * fx * (3 - 2 * fx);
           const fy2 = fy * fy * (3 - 2 * fy);

           // Bilinear interpolation
           const topX = p00.x * (1 - fx2) + p10.x * fx2;
           const botX = p01.x * (1 - fx2) + p11.x * fx2;
           const topY = p00.y * (1 - fx2) + p10.y * fx2;
           const botY = p01.y * (1 - fx2) + p11.y * fx2;

           // Final interpolated position
           const warpedX = topX * (1 - fy2) + botX * fy2;
           const warpedY = topY * (1 - fy2) + botY * fy2;

           // Apply intensity factor
           const origX = x;
           const origY = y;

           return {
               // If verticalOnly is true, only apply the vertical distortion
               x: verticalOnly ? origX : origX + (warpedX - origX) * intensity,
               y: origY + (warpedY - origY) * intensity
           };
       } catch (e) {
           console.error('Error in getWarpedPosition:', e);
           return { x, y }; // Return original position on error
       }
   }

   // Draw grid distorted text using OpenType.js
   function drawGridDistortedText(textObj, targetCtx, font) {
       if (!font) {
           console.warn('Font not loaded for grid distort effect');
           return;
       }

       // Check if we have a valid text object
       if (!textObj || !textObj.text) {
           console.warn('Invalid text object for grid distort effect');
           return;
       }

       // Get text properties
       const text = textObj.text;
       const fontSize = textObj.fontSize || 100; // Default to 100 if not set

       // Note: Opacity is handled individually for text and stroke
       // Do not apply global opacity here as it would affect stroke independence

       // Log the text style for debugging
       console.log('Drawing grid distorted text with style:', {
           text: text,
           fontSize: fontSize,
           fontFamily: textObj.fontFamily,
           bold: textObj.bold,
           italic: textObj.italic,
           opacity: (textObj.opacity !== undefined) ? textObj.opacity / 100 : 1,
           letterSpacing: textObj._effectiveLetterSpacing,
           fontKey: `${textObj.fontFamily}_${textObj.bold ? 'bold' : 'regular'}_${textObj.italic ? 'italic' : 'normal'}`
       });

       // Create a path for the text with letter spacing
       let path;
       try {
           // Make sure the _effectiveLetterSpacing property is set
           if (textObj._effectiveLetterSpacing === undefined) {
               textObj._effectiveLetterSpacing = textObj.letterSpacing || 0;
           }

           // Get letter spacing value
           const letterSpacing = textObj._effectiveLetterSpacing;

           console.log('Creating text path with letter spacing:', letterSpacing);

           if (letterSpacing === 0) {
               // Standard text path creation
               path = font.getPath(text, 0, 0, fontSize);
           } else {
               // Create a composite path with letter spacing
               path = new opentype.Path();
               let currentX = 0;

               // Process each character with letter spacing
               for (let i = 0; i < text.length; i++) {
                   const char = text[i];
                   // Get path for this character
                   const charPath = font.getPath(char, currentX, 0, fontSize);

                   // Add this character's path commands to the composite path
                   if (charPath && charPath.commands) {
                       for (const cmd of charPath.commands) {
                           path.commands.push(Object.assign({}, cmd));
                       }
                   }

                   // Calculate character width for positioning the next character
                   const charWidth = font.getAdvanceWidth(char, fontSize);

                   // Move to the next character position with letter spacing
                   currentX += charWidth + letterSpacing;
               }
           }
       } catch (e) {
           console.error('Error creating text path:', e);
           return;
       }

       // Get path bounds
       let bounds;
       try {
           bounds = path.getBoundingBox();
       } catch (e) {
           console.error('Error getting path bounds:', e);
           return;
       }

       // Use the measured dimensions if available, otherwise use the path bounds
       const textWidth = textObj.measuredWidth || (bounds.x2 - bounds.x1);
       const textHeight = textObj.measuredHeight || (bounds.y2 - bounds.y1);

       // Log the dimensions for debugging
       console.log('Text dimensions:', {
           measuredWidth: textObj.measuredWidth,
           measuredHeight: textObj.measuredHeight,
           pathWidth: bounds.x2 - bounds.x1,
           pathHeight: bounds.y2 - bounds.y1,
           finalWidth: textWidth,
           finalHeight: textHeight
       });

       // Calculate grid bounds with padding that scales with font size and accounts for stroke
       const paddingScale = 0.5; // 50% of font size
       const basePadding = textObj.gridDistort.gridPadding;
       const scaledPadding = Math.max(basePadding, fontSize * paddingScale);

       // Add extra padding for stroke to prevent clipping
       const strokePadding = (textObj.strokeMode === "stroke" && textObj.strokeWidth) ?
           Math.max(textObj.strokeWidth * 30, 150) : 0; // 30x stroke width with 150px minimum

       // Add extra padding based on distortion intensity to account for extreme distortions
       // Use a more generous multiplier to ensure we capture all possible distortions
       const intensityPadding = (textObj.gridDistort.intensity / 100) * Math.max(textWidth, textHeight) * 0.5;

       const totalPadding = scaledPadding + strokePadding + intensityPadding;

       // Since we're already translated to textObj.x, textObj.y in drawTextObject,
       // we need to use 0,0 as the center point here, not textObj.x, textObj.y
       const gridLeft = -textWidth/2 - totalPadding;
       const gridTop = -textHeight/2 - totalPadding;
       const gridWidth = textWidth + totalPadding * 2;
       const gridHeight = textHeight + totalPadding * 2;

       console.log('Grid bounds calculation:', {
           gridLeft, gridTop, gridWidth, gridHeight, textWidth, textHeight,
           scaledPadding, strokePadding, intensityPadding, totalPadding,
           strokeMode: textObj.strokeMode, strokeWidth: textObj.strokeWidth,
           intensity: textObj.gridDistort.intensity,
           basePadding: textObj.gridDistort.gridPadding,
           fontSize: fontSize
       });

       // Set text properties - let normal gradient system handle gradients
       targetCtx.fillStyle = textObj.color;
       console.log('🎨 Grid Distort: Set fillStyle to solid color:', textObj.color);

       // Create a warped path based on the original path
       const warpedPath = new opentype.Path();

       // Center offset to position text at object center
       // This is the key difference from the previous implementation
       const centerX = -textWidth / 2 - bounds.x1;
       const centerY = -textHeight / 2 - bounds.y1;

       // Process each command in the original path
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];

           switch (cmd.type) {
               case 'M': // Move to
                   {
                       const x = cmd.x + centerX;
                       const y = cmd.y + centerY;
                       const warped = getWarpedPosition(
                           x, y,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );
                       warpedPath.moveTo(warped.x, warped.y);
                   }
                   break;
               case 'L': // Line to
                   {
                       const x = cmd.x + centerX;
                       const y = cmd.y + centerY;
                       const warped = getWarpedPosition(
                           x, y,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );
                       warpedPath.lineTo(warped.x, warped.y);
                   }
                   break;
               case 'C': // Cubic curve
                   {
                       const x1 = cmd.x1 + centerX;
                       const y1 = cmd.y1 + centerY;
                       const x2 = cmd.x2 + centerX;
                       const y2 = cmd.y2 + centerY;
                       const x = cmd.x + centerX;
                       const y = cmd.y + centerY;

                       const warped1 = getWarpedPosition(
                           x1, y1,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );

                       const warped2 = getWarpedPosition(
                           x2, y2,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );

                       const warped = getWarpedPosition(
                           x, y,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );

                       warpedPath.curveTo(warped1.x, warped1.y, warped2.x, warped2.y, warped.x, warped.y);
                   }
                   break;
               case 'Q': // Quadratic curve
                   {
                       const x1 = cmd.x1 + centerX;
                       const y1 = cmd.y1 + centerY;
                       const x = cmd.x + centerX;
                       const y = cmd.y + centerY;

                       const warped1 = getWarpedPosition(
                           x1, y1,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );

                       const warped = getWarpedPosition(
                           x, y,
                           textObj.gridDistort.controlPoints,
                           textObj.gridDistort.gridCols,
                           textObj.gridDistort.gridRows,
                           gridLeft, gridTop, gridWidth, gridHeight,
                           textObj.gridDistort.intensity,
                           textObj.gridDistortVerticalOnly
                       );

                       warpedPath.quadraticCurveTo(warped1.x, warped1.y, warped.x, warped.y);
                   }
                   break;
               case 'Z': // Close path
                   warpedPath.closePath();
                   break;
           }
       }

       // Apply shadow effects before drawing the path
       targetCtx.save();

       // Apply standard shadow if enabled
       if (textObj.shadowMode === "shadow") {
           targetCtx.shadowColor = textObj.shadowColor;
           targetCtx.shadowOffsetX = textObj.shadowOffsetX;
           targetCtx.shadowOffsetY = textObj.shadowOffsetY;
           targetCtx.shadowBlur = textObj.shadowBlur;
       }

       // Apply other shadow types if enabled
       if (textObj.shadowMode === "blockShadow") {
           applyBlockShadow(targetCtx, textObj, 0, 0, warpedPath);
       } else if (textObj.shadowMode === "perspectiveShadow") {
           applyPerspectiveShadow(targetCtx, textObj, 0, 0, warpedPath);
       } else if (textObj.shadowMode === "lineShadow") {
           applyLineShadow(targetCtx, textObj, 0, 0, warpedPath);
       } else if (textObj.shadowMode === "detailed3D") {
           applyDetailed3D_ExtrusionOnly(targetCtx, textObj, 0, 0, warpedPath);
       }

       // Apply stroke if enabled (before fill) - outward only
       if (textObj.strokeMode === "stroke") {
           // Apply stroke with independent opacity - outward only like shapes
           const strokeOpacity = (textObj.strokeOpacity !== undefined) ? textObj.strokeOpacity / 100 : 1;
           const strokeColor = hexToRgba(textObj.strokeColor, strokeOpacity);

           // Create a temporary canvas for outward-only stroke - make it much larger to accommodate stroke
           const strokeCanvas = document.createElement('canvas');
           // Use very generous extra space - account for distortion displacement + stroke width
           const baseExtraSpace = Math.max(textObj.strokeWidth * 60, 400);
           const distortionExtraSpace = (textObj.gridDistort.intensity / 100) * Math.max(textWidth, textHeight) * 1.5;
           const extraStrokeSpace = baseExtraSpace + distortionExtraSpace;

           strokeCanvas.width = targetCtx.canvas.width + extraStrokeSpace * 2;
           strokeCanvas.height = targetCtx.canvas.height + extraStrokeSpace * 2;
           const strokeCtx = strokeCanvas.getContext('2d');

           console.log('Stroke canvas setup:', {
               originalCanvasSize: { width: targetCtx.canvas.width, height: targetCtx.canvas.height },
               strokeCanvasSize: { width: strokeCanvas.width, height: strokeCanvas.height },
               baseExtraSpace: baseExtraSpace,
               distortionExtraSpace: distortionExtraSpace,
               totalExtraSpace: extraStrokeSpace,
               strokeWidth: textObj.strokeWidth,
               intensity: textObj.gridDistort.intensity
           });

           // Translate to account for the extra space
           strokeCtx.translate(extraStrokeSpace, extraStrokeSpace);

           // Disable image smoothing for sharp strokes
           strokeCtx.imageSmoothingEnabled = false;

           strokeCtx.save();
           // Reset globalAlpha to ensure stroke has independent opacity
           strokeCtx.globalAlpha = 1;
           // Use a moderately thicker stroke that will be partially cut out
           // Scale the multiplier based on stroke width to avoid overly thick strokes for small widths
           const strokeMultiplier = textObj.strokeWidth <= 1 ? 5 :
                                   textObj.strokeWidth <= 2 ? 4 :
                                   textObj.strokeWidth <= 5 ? 3 : 2;
           const effectiveStrokeWidth = Math.max(textObj.strokeWidth * strokeMultiplier, 8);

           console.log('Stroke width calculation:', {
               originalStrokeWidth: textObj.strokeWidth,
               strokeMultiplier: strokeMultiplier,
               effectiveStrokeWidth: effectiveStrokeWidth
           });

           strokeCtx.lineWidth = effectiveStrokeWidth;
           strokeCtx.strokeStyle = strokeColor;
           strokeCtx.lineJoin = 'round';
           strokeCtx.lineCap = 'round';

           // Create paths for stroking and filling
           const strokePath = new Path2D();
           const fillPath = new Path2D();

           // Convert OpenType.js path to Canvas Path2D
           for (let i = 0; i < warpedPath.commands.length; i++) {
               const cmd = warpedPath.commands[i];
               switch (cmd.type) {
                   case 'M':
                       strokePath.moveTo(cmd.x, cmd.y);
                       fillPath.moveTo(cmd.x, cmd.y);
                       break;
                   case 'L':
                       strokePath.lineTo(cmd.x, cmd.y);
                       fillPath.lineTo(cmd.x, cmd.y);
                       break;
                   case 'C':
                       strokePath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                       fillPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                       break;
                   case 'Q':
                       strokePath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                       fillPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                       break;
                   case 'Z':
                       strokePath.closePath();
                       fillPath.closePath();
                       break;
               }
           }

           // Draw the thick stroke
           strokeCtx.stroke(strokePath);

           // Use destination-out to cut out the interior (normal text area)
           strokeCtx.globalCompositeOperation = 'destination-out';
           strokeCtx.fillStyle = 'black'; // Color doesn't matter for destination-out
           strokeCtx.fill(fillPath);
           strokeCtx.restore();

           // Draw the outward-only stroke to the target canvas, accounting for the offset
           targetCtx.save();
           targetCtx.globalAlpha = 1; // Reset target context opacity for stroke
           targetCtx.drawImage(strokeCanvas, -extraStrokeSpace, -extraStrokeSpace);
           targetCtx.restore();
       }

       // Draw the warped path with fill color and opacity
       const textOpacity = (textObj.opacity !== undefined) ? textObj.opacity / 100 : 1;

       // Apply text opacity only to the fill (not stroke)
       targetCtx.save();
       targetCtx.globalAlpha = textOpacity;
       warpedPath.fill = textObj.color;
       warpedPath.draw(targetCtx);
       targetCtx.restore();

       // Apply decoration effects if enabled
       console.log(`🔍 GRID DISTORT SOLID: Checking decoration - mode: ${textObj.decorationMode}, enabled: ${textObj.decorationMode && textObj.decorationMode !== "noDecoration"}`);
       if (textObj.decorationMode && textObj.decorationMode !== "noDecoration") {
           console.log(`🔍 GRID DISTORT SOLID: ✅ APPLYING DECORATION via applyDecoration function`);
           console.log(`🔍 GRID DISTORT SOLID: Decoration type: ${textObj.decorationMode}`);
           console.log(`🔍 GRID DISTORT SOLID: WarpedPath provided:`, !!warpedPath);
           // Handle fill decoration (patterns, gradients, etc.)
           applyDecoration(targetCtx, textObj, warpedPath);
           console.log(`🔍 GRID DISTORT SOLID: ✅ DECORATION APPLIED via applyDecoration function`);
       } else {
           console.log(`🔍 GRID DISTORT SOLID: ❌ NO DECORATION - mode: ${textObj.decorationMode}`);
       }

       // Add front outlines for grid distorted text without gradients
       console.log('🔍 RENDER ORDER: Step 8 - Drawing front outlines on top for Grid Distort text (no gradient)');
       if (textObj.shadowMode === 'perspectiveShadow' && textObj.perspectiveShadowOutlineWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing perspective shadow front outline on top for Grid Distort text (no gradient)');
           const outlineColor = textObj.perspectiveShadowOutlineColor;
           const outlineOpacity = textObj.perspectiveShadowOutlineOpacity / 100;
           const outlineWidth = textObj.perspectiveShadowOutlineWidth;
           const outlineOffsetX = textObj.perspectiveShadowOutlineOffsetX || 0;
           const outlineOffsetY = textObj.perspectiveShadowOutlineOffsetY || 0;
           drawGridDistortFrontOutline(textObj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY, font);
       }
       if (textObj.shadowMode === 'detailed3D' && textObj.d3dSecondaryWidth > 0) {
           console.log('🔍 RENDER ORDER: Drawing detailed 3D front outline on top for Grid Distort text (no gradient)');
           const outlineColor = textObj.d3dSecondaryColor;
           const outlineOpacity = textObj.d3dSecondaryOpacity / 100;
           const outlineWidth = textObj.d3dSecondaryWidth;
           const outlineOffsetX = textObj.d3dSecondaryOffsetX || 0;
           const outlineOffsetY = textObj.d3dSecondaryOffsetY || 0;
           drawGridDistortFrontOutline(textObj, targetCtx, outlineColor, outlineOpacity, outlineWidth, outlineOffsetX, outlineOffsetY, font);
       }

       // Log the effective letter spacing for debugging
       console.log('Grid Distort text rendered with letter spacing:', textObj._effectiveLetterSpacing || textObj.letterSpacing || 0);

       targetCtx.restore();
   }

   // Apply block shadow to a path
   function applyBlockShadow(targetCtx, textObj, x, y, path) {
       // If no path is provided, use the standard text-based function
       if (!path) {
           console.log('🔍 BLOCK SHADOW OVERRIDE: Function called (no path)');
           // Use the original function for text objects WITH LETTER SPACING SUPPORT
           const color = textObj.blockShadowColor;
           const opacity = textObj.blockShadowOpacity / 100;
           const offset = textObj.blockShadowOffset;
           const angleDeg = textObj.blockShadowAngle;
           const blur = textObj.blockShadowBlur;
           const offsetCoords = calculateOffset(offset, angleDeg);

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);
           targetCtx.fillStyle = hexToRgba(color, opacity);

           if (blur > 0) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               targetCtx.shadowBlur = blur;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
           }

           // Handle letter spacing for block shadow
           const text = (textObj.text || '');
           const letterSpacing = textObj._effectiveLetterSpacing || 0;
           console.log('🔍 BLOCK SHADOW OVERRIDE DEBUG: text="' + text + '", letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + textObj._effectiveLetterSpacing);

           const steps = Math.max(10, Math.floor(offset / 1.5));
           for (let i = steps; i >= 1; i--) {
               const progress = i / steps;
               const currentX = x + offsetCoords.x * progress;
               const currentY = y + offsetCoords.y * progress;

               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = 'transparent';
               }

               // Handle letter spacing for block shadow
               if (letterSpacing !== 0) {
                   // Draw each character manually with letter spacing
                   const letters = text.split('');
                   let totalWidth = 0;

                   // Calculate total width with letter spacing
                   letters.forEach(letter => {
                       totalWidth += targetCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }

                   // Draw each letter with proper spacing
                   let letterX = currentX - totalWidth / 2;
                   for (let j = 0; j < letters.length; j++) {
                       const letter = letters[j];
                       const letterWidth = targetCtx.measureText(letter).width;
                       targetCtx.fillText(letter, letterX + letterWidth / 2, currentY);
                       letterX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
                   }
               } else {
                   // No letter spacing, use standard fillText
                   targetCtx.fillText(text, currentX, currentY);
               }

               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               }
           }

           targetCtx.restore();
           return;
       }

       // Path-based block shadow implementation
       const color = textObj.blockShadowColor;
       const opacity = textObj.blockShadowOpacity / 100;
       const offset = textObj.blockShadowOffset;
       const angleDeg = textObj.blockShadowAngle;
       const blur = textObj.blockShadowBlur;
       const offsetCoords = calculateOffset(offset, angleDeg);

       targetCtx.save();
       targetCtx.fillStyle = hexToRgba(color, opacity);

       if (blur > 0) {
           targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
           targetCtx.shadowBlur = blur;
           targetCtx.shadowOffsetX = 0;
           targetCtx.shadowOffsetY = 0;
       }

       // Create a Path2D object from the OpenType.js path
       const shadowPath = new Path2D();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
                   shadowPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   shadowPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   shadowPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   shadowPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   shadowPath.closePath();
                   break;
           }
       }

       // Draw the shadow in steps
       const steps = Math.max(10, Math.floor(offset / 1.5));
       for (let i = steps; i >= 1; i--) {
           const progress = i / steps;

           targetCtx.save();
           targetCtx.translate(offsetCoords.x * progress, offsetCoords.y * progress);

           if (blur > 5 && i < steps) {
               targetCtx.shadowColor = 'transparent';
           }

           targetCtx.fill(shadowPath);

           if (blur > 5 && i < steps) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
           }

           targetCtx.restore();
       }

       targetCtx.restore();
   }

   // Apply perspective shadow to a path
   function applyPerspectiveShadow(targetCtx, textObj, x, y, path) {
       // Generate a unique ID for this rendering pass to track in logs
       const renderPassId = Math.random().toString(36).substring(2, 8);

       console.log(`=== PERSPECTIVE SHADOW START (${renderPassId}) ===`);
       console.log(`[${renderPassId}] Text object:`, textObj.text);

       // If no path is provided, use the standard text-based function
       if (!path) {
           console.log('🔍 PERSPECTIVE SHADOW OVERRIDE: Function called (no path)');
           // Use the original function for text objects WITH LETTER SPACING SUPPORT
           const color = textObj.perspectiveShadowColor || '#000000';
           const opacity = (textObj.perspectiveShadowOpacity !== undefined) ? textObj.perspectiveShadowOpacity / 100 : 0.6;

           // Use more reasonable default values for offset and angle
           // Default offset should be much smaller (40px instead of 103px)
           const offset = (textObj.perspectiveShadowOffset !== undefined) ?
               Math.min(textObj.perspectiveShadowOffset, 100) : 40;

           // Default angle should be -45 degrees (down and to the right)
           const angleDeg = (textObj.perspectiveShadowAngle !== undefined) ?
               textObj.perspectiveShadowAngle : -45;

           const blur = (textObj.perspectiveShadowBlur !== undefined) ?
               textObj.perspectiveShadowBlur : 5;

           const perspectiveIntensity = (textObj.perspectiveShadowIntensity || 60) / 100;
           const offsetCoords = calculateOffset(offset, angleDeg);

           // Get outline properties
           const outlineColor = textObj.perspectiveShadowOutlineColor || '#00FF00';
           const outlineOpacity = (textObj.perspectiveShadowOutlineOpacity !== undefined) ?
               textObj.perspectiveShadowOutlineOpacity / 100 : 1.0;
           const outlineWidth = textObj.perspectiveShadowOutlineWidth || 4;
           const outlineOffsetX = textObj.perspectiveShadowOutlineOffsetX || -5;
           const outlineOffsetY = textObj.perspectiveShadowOutlineOffsetY || -5;

           console.log(`[${renderPassId}] Perspective Shadow properties:`, {
               color,
               opacity,
               offset,
               angleDeg,
               blur,
               perspectiveIntensity,
               shadowMode: textObj.shadowMode,
               offsetCoords,
               outlineColor,
               outlineOpacity,
               outlineWidth,
               outlineOffsetX,
               outlineOffsetY
           });

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);
           // Use a lower base opacity for smoother blending between shadow layers
           const baseOpacity = Math.min(0.8, opacity);
           targetCtx.fillStyle = hexToRgba(color, baseOpacity);

           if (blur > 0) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               targetCtx.shadowBlur = blur;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
           }

           // Calculate number of steps based on offset
           // Optimize for performance: reduce steps during movement, use fewer steps overall
           let baseSteps = PERFORMANCE_MODE && isDuringMovement ? 15 : 25; // Reduced from 50
           const steps = Math.max(baseSteps, Math.floor(offset * 1.5)); // Reduced multiplier
           performanceLog(`[${renderPassId}] Number of shadow steps:`, steps);

           // Draw shadows from back to front (farthest to closest)
           // This is the correct order for perspective shadows
           for (let i = 1; i <= steps; i++) {
               // Calculate progress from 0.0 (farthest from text) to 1.0 (closest to text)
               const progress = i / steps;

               // Calculate distance ratio - 0.0 is farthest from text, 1.0 is closest
               const distanceRatio = i / steps;

               // Apply scaling that makes distant shadows smaller
               // Higher intensity = more dramatic scaling at distance (smaller end point)
               // The intensity now controls how small the farthest shadow gets
               // With intensity=1%, the scale will be almost the same as the original text (0.95)
               // With intensity=100%, the scale will be very small at the farthest point (0.05)
               const minScale = 0.95 - (perspectiveIntensity * 0.9); // Minimum scale at farthest point (0.05 to 0.95)
               const scaleProgress = minScale + ((1 - minScale) * distanceRatio);

               if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                   debugLog(`[${renderPassId}] Shadow step ${i}/${steps}: distanceRatio=${distanceRatio.toFixed(2)}, scaleProgress=${scaleProgress.toFixed(3)}`);
               }

               // Calculate position for this shadow layer
               // Use the original position (x,y) as the center point
               // and apply the offset relative to that position
               // We're drawing from farthest to closest, so the farthest shadow (i=1)
               // should have the largest offset, and the closest shadow (i=steps) should have the smallest offset
               // Invert the progress to get the correct offset
               const offsetProgress = 1 - progress;
               const posX = x + (offsetCoords.x * offsetProgress * offset);
               const posY = y + (offsetCoords.y * offsetProgress * offset);

               if (DEBUG_MODE && (i % 10 === 0 || i === 1 || i === steps)) {
                   debugLog(`[${renderPassId}] Shadow position: (${posX.toFixed(1)}, ${posY.toFixed(1)}), scale: ${scaleProgress.toFixed(3)}`);
               }

               // Save state before transformations
               targetCtx.save();

               // Move to the position where we'll draw this shadow layer
               targetCtx.translate(posX, posY);

               // Apply scaling for perspective effect
               targetCtx.scale(scaleProgress, scaleProgress);

               // Handle shadow blur
               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = 'transparent';
               }

               // Draw the text at origin (0,0) since we've already translated
               // Handle letter spacing for perspective shadows
               const text = (textObj.text || '');
               const letterSpacing = textObj._effectiveLetterSpacing || 0;
               if (i === 1) { // Only log once per render pass
                   console.log('🔍 PERSPECTIVE SHADOW OVERRIDE DEBUG: text="' + text + '", letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + textObj._effectiveLetterSpacing);
               }
               if (letterSpacing !== 0) {
                   // Draw each character manually with letter spacing
                   const letters = text.split('');
                   let totalWidth = 0;

                   // Calculate total width with letter spacing
                   letters.forEach(letter => {
                       totalWidth += targetCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }

                   // Draw each letter with proper spacing
                   let currentX = -totalWidth / 2;
                   for (let j = 0; j < letters.length; j++) {
                       const letter = letters[j];
                       const letterWidth = targetCtx.measureText(letter).width;
                       targetCtx.fillText(letter, currentX + letterWidth / 2, 0);
                       currentX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
                   }
               } else {
                   // No letter spacing, use standard fillText
                   targetCtx.fillText(text, 0, 0);
               }

               // Restore shadow if needed
               if (blur > 5 && i < steps) {
                   targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
               }

               // Restore the context state
               targetCtx.restore();
           }

           // We no longer need to draw the main text or outline here
           // The main text is drawn in renderStyledObjectToOffscreen
           // The outline is drawn by applyPerspectiveShadow_FrontOutline

           console.log(`[${renderPassId}] === PERSPECTIVE SHADOW END ===`);
           targetCtx.restore();
           return;
       }

       // Path-based perspective shadow implementation
       const color = textObj.perspectiveShadowColor;
       const opacity = textObj.perspectiveShadowOpacity / 100;
       const offset = textObj.perspectiveShadowOffset;
       const angleDeg = textObj.perspectiveShadowAngle;
       const blur = textObj.perspectiveShadowBlur;
       const perspectiveIntensity = (textObj.perspectiveShadowIntensity || 60) / 100;
       const offsetCoords = calculateOffset(offset, angleDeg);

       // Get outline properties
       const outlineColor = textObj.perspectiveShadowOutlineColor || '#00FF00';
       const outlineOpacity = (textObj.perspectiveShadowOutlineOpacity !== undefined) ?
           textObj.perspectiveShadowOutlineOpacity / 100 : 1.0;
       const outlineWidth = textObj.perspectiveShadowOutlineWidth || 4;
       const outlineOffsetX = textObj.perspectiveShadowOutlineOffsetX || -5;
       const outlineOffsetY = textObj.perspectiveShadowOutlineOffsetY || -5;

       console.log(`[${renderPassId}] Path-based perspective shadow properties:`, {
           color,
           opacity,
           offset,
           angleDeg,
           blur,
           perspectiveIntensity,
           shadowMode: textObj.shadowMode,
           offsetCoords,
           outlineColor,
           outlineOpacity,
           outlineWidth,
           outlineOffsetX,
           outlineOffsetY
       });

       // Create a Path2D object from the OpenType.js path
       const shadowPath = new Path2D();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
                   shadowPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   shadowPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   shadowPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   shadowPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   shadowPath.closePath();
                   break;
           }
       }

       targetCtx.save();
       // Use a lower base opacity for smoother blending between shadow layers
       const baseOpacity = Math.min(0.8, opacity);
       targetCtx.fillStyle = hexToRgba(color, baseOpacity);

       if (blur > 0) {
           targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
           targetCtx.shadowBlur = blur;
           targetCtx.shadowOffsetX = 0;
           targetCtx.shadowOffsetY = 0;
       }

       // Draw the shadow in steps with perspective scaling
       // Optimize for performance: reduce steps during movement, use fewer steps overall
       let baseSteps = PERFORMANCE_MODE && isDuringMovement ? 15 : 25; // Reduced from 50
       const steps = Math.max(baseSteps, Math.floor(offset * 1.5)); // Reduced multiplier
       performanceLog(`[${renderPassId}] Number of path shadow steps:`, steps);

       // Draw shadows from back to front (farthest to closest)
       // This is the correct order for perspective shadows
       for (let i = 1; i <= steps; i++) {
           // Calculate progress from 0.0 (farthest from text) to 1.0 (closest to text)
           const progress = i / steps;
           // Calculate distance ratio - 0.0 is farthest from text, 1.0 is closest
           const distanceRatio = i / steps;
           // Apply scaling that makes distant shadows smaller
           // Higher intensity = more dramatic scaling at distance (smaller end point)
           // The intensity now controls how small the farthest shadow gets
           // With intensity=1%, the scale will be almost the same as the original text (0.95)
           // With intensity=100%, the scale will be very small at the farthest point (0.05)
           const minScale = 0.95 - (perspectiveIntensity * 0.9); // Minimum scale at farthest point (0.05 to 0.95)
           const scaleProgress = minScale + ((1 - minScale) * distanceRatio);

           if (i % 5 === 0 || i === 1 || i === steps) {
               console.log(`[${renderPassId}] Path shadow step ${i}/${steps}: scale=${scaleProgress.toFixed(3)}`);
           }

           targetCtx.save();

           // Invert the progress to get the correct offset (same as in the text-based version)
           // This ensures the shadow is drawn in the correct direction
           const offsetProgress = 1 - progress;

           // Apply both translation and scaling for perspective effect
           targetCtx.translate(offsetCoords.x * offsetProgress * offset, offsetCoords.y * offsetProgress * offset);
           targetCtx.scale(scaleProgress, scaleProgress);

           if (blur > 5 && i < steps) {
               targetCtx.shadowColor = 'transparent';
           }

           targetCtx.fill(shadowPath);

           if (blur > 5 && i < steps) {
               targetCtx.shadowColor = hexToRgba(color, opacity * 0.8);
           }

           targetCtx.restore();
       }

       // We no longer need to draw the main path or outline here
       // The main path is drawn in renderStyledObjectToOffscreen
       // The outline is drawn by applyPerspectiveShadow_FrontOutline

       console.log(`[${renderPassId}] === PERSPECTIVE SHADOW PATH END ===`);
       targetCtx.restore();
   }

   // Apply line shadow to a path
   function applyLineShadow(targetCtx, textObj, x, y, path) {
       // If no path is provided, use the standard text-based function
       if (!path) {
           console.log('🔍 LINE SHADOW OVERRIDE: Function called (no path)');
           // Use the original function for text objects WITH LETTER SPACING SUPPORT
           const color = textObj.lineShadowColor;
           const distance = textObj.lineShadowDist;
           const angleDeg = textObj.lineShadowAngle;
           const thickness = Math.max(1, textObj.lineShadowThickness);
           const fullOffset = calculateOffset(distance, angleDeg);
           const cutterDistance = Math.max(0, distance - thickness);
           const cutterOffset = calculateOffset(cutterDistance, angleDeg);

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);
           targetCtx.fillStyle = color;

           // Handle letter spacing for line shadow
           const text = (textObj.text || '');
           const letterSpacing = textObj._effectiveLetterSpacing || 0;
           console.log('🔍 LINE SHADOW OVERRIDE DEBUG: text="' + text + '", letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + textObj._effectiveLetterSpacing);

           // Draw the full shadow
           if (letterSpacing !== 0) {
               console.log('🔍 LINE SHADOW OVERRIDE: Using letter spacing mode');
               // Draw each character manually with letter spacing
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter with proper spacing for full shadow
               let currentX = x + fullOffset.x - totalWidth / 2;
               for (let i = 0; i < letters.length; i++) {
                   const letter = letters[i];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + fullOffset.y);
                   currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               console.log('🔍 LINE SHADOW OVERRIDE: Using standard mode (no letter spacing)');
               targetCtx.fillText(text, x + fullOffset.x, y + fullOffset.y);
           }

           // Cut out the inner part
           targetCtx.globalCompositeOperation = 'destination-out';
           targetCtx.fillStyle = 'black';

           if (letterSpacing !== 0) {
               // Draw each character manually with letter spacing for cutter
               const letters = text.split('');
               let totalWidth = 0;

               // Calculate total width with letter spacing
               letters.forEach(letter => {
                   totalWidth += targetCtx.measureText(letter).width;
               });
               if (letters.length > 1) {
                   totalWidth += letterSpacing * (letters.length - 1);
               }

               // Draw each letter with proper spacing for cutter
               let currentX = x + cutterOffset.x - totalWidth / 2;
               for (let i = 0; i < letters.length; i++) {
                   const letter = letters[i];
                   const letterWidth = targetCtx.measureText(letter).width;
                   targetCtx.fillText(letter, currentX + letterWidth / 2, y + cutterOffset.y);
                   currentX += letterWidth + (i < letters.length - 1 ? letterSpacing : 0);
               }
           } else {
               targetCtx.fillText(text, x + cutterOffset.x, y + cutterOffset.y);
           }

           console.log('🔍 LINE SHADOW OVERRIDE: Rendering complete');
           targetCtx.restore();
           return;
       }

       // Path-based line shadow implementation using temporary canvas for proper transparency
       const color = textObj.lineShadowColor;
       const distance = textObj.lineShadowDist;
       const angleDeg = textObj.lineShadowAngle;
       const thickness = Math.max(1, textObj.lineShadowThickness);
       const fullOffset = calculateOffset(distance, angleDeg);
       const cutterDistance = Math.max(0, distance - thickness);
       const cutterOffset = calculateOffset(cutterDistance, angleDeg);

       // Create a Path2D object from the OpenType.js path
       const shadowPath = new Path2D();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
                   shadowPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   shadowPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   shadowPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   shadowPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   shadowPath.closePath();
                   break;
           }
       }

       // Use a temporary canvas to ensure proper transparency handling
       // This prevents the white background issue with Grid Distort
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = targetCtx.canvas.width;
       tempCanvas.height = targetCtx.canvas.height;
       const tempCtx = tempCanvas.getContext('2d');

       // Ensure the temporary canvas has proper alpha channel with high-DPI preservation
       tempCtx.save();
       const tempTransform = tempCtx.getTransform();
       const tempScaleFactor = tempTransform.a;
       tempCtx.setTransform(tempScaleFactor, 0, 0, tempScaleFactor, 0, 0);
       tempCtx.clearRect(0, 0, tempCanvas.width / tempScaleFactor, tempCanvas.height / tempScaleFactor);
       tempCtx.restore();

       // Copy the current transformation matrix to the temp context
       const transform = targetCtx.getTransform();
       tempCtx.setTransform(transform);

       // Draw the shadow on the temporary canvas
       tempCtx.save();
       tempCtx.translate(fullOffset.x, fullOffset.y);
       tempCtx.fillStyle = color;
       tempCtx.fill(shadowPath);
       tempCtx.restore();

       // Cut out the inner part using destination-out on the temporary canvas
       tempCtx.save();
       tempCtx.translate(cutterOffset.x, cutterOffset.y);
       tempCtx.globalCompositeOperation = 'destination-out';
       tempCtx.fillStyle = 'black'; // Color doesn't matter for destination-out
       tempCtx.fill(shadowPath);
       tempCtx.restore();

       // Draw the temporary canvas result onto the target canvas
       // Reset transformation for the final draw to avoid double transformation
       targetCtx.save();
       targetCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset to identity matrix
       targetCtx.drawImage(tempCanvas, 0, 0);
       targetCtx.restore();
   }

   // Apply detailed 3D extrusion to a path
   function applyDetailed3D_ExtrusionOnly(targetCtx, textObj, x, y, path) {
       // If no path is provided, use the standard text-based function
       if (!path) {
           console.log('🔍 DETAILED 3D OVERRIDE: Function called (no path)');
           // Use the original function for text objects WITH LETTER SPACING SUPPORT
           const primaryColorRgba = hexToRgba(textObj.d3dPrimaryColor, textObj.d3dPrimaryOpacity / 100);
           const offset = textObj.d3dOffset;
           const angle = textObj.d3dAngle;
           const blur = textObj.d3dBlur;

           targetCtx.save();
           setTextContextOn(targetCtx, textObj);

           const totalOffset = calculateOffset(offset, angle);
           const steps = Math.max(30, Math.floor(offset));

           // Handle letter spacing for detailed 3D
           const text = (textObj.text || '').toUpperCase();
           const letterSpacing = textObj._effectiveLetterSpacing || 0;
           console.log('🔍 DETAILED 3D OVERRIDE DEBUG: text="' + text + '", letterSpacing=' + letterSpacing + ', _effectiveLetterSpacing=' + textObj._effectiveLetterSpacing);

           for (let i = steps; i >= 1; i--) {
               const progress = i / steps;
               const currentOffset = {
                   x: totalOffset.x * progress,
                   y: totalOffset.y * progress
               };

               targetCtx.fillStyle = primaryColorRgba;

               if (letterSpacing !== 0) {
                   // Draw each character manually with letter spacing
                   const letters = text.split('');
                   let totalWidth = 0;

                   // Calculate total width with letter spacing
                   letters.forEach(letter => {
                       totalWidth += targetCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }

                   // Draw each letter with proper spacing
                   let currentX = x + currentOffset.x - totalWidth / 2;
                   for (let j = 0; j < letters.length; j++) {
                       const letter = letters[j];
                       const letterWidth = targetCtx.measureText(letter).width;
                       targetCtx.fillText(letter, currentX + letterWidth / 2, y + currentOffset.y);
                       currentX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
                   }
               } else {
                   targetCtx.fillText(text, x + currentOffset.x, y + currentOffset.y);
               }
           }

           if (blur > 0) {
               targetCtx.save();
               targetCtx.shadowColor = primaryColorRgba;
               targetCtx.shadowBlur = blur;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
               targetCtx.fillStyle = primaryColorRgba;

               if (letterSpacing !== 0) {
                   // Draw each character manually with letter spacing for blur
                   const letters = text.split('');
                   let totalWidth = 0;

                   // Calculate total width with letter spacing
                   letters.forEach(letter => {
                       totalWidth += targetCtx.measureText(letter).width;
                   });
                   if (letters.length > 1) {
                       totalWidth += letterSpacing * (letters.length - 1);
                   }

                   // Draw each letter with proper spacing
                   let currentX = x + totalOffset.x - totalWidth / 2;
                   for (let j = 0; j < letters.length; j++) {
                       const letter = letters[j];
                       const letterWidth = targetCtx.measureText(letter).width;
                       targetCtx.fillText(letter, currentX + letterWidth / 2, y + totalOffset.y);
                       currentX += letterWidth + (j < letters.length - 1 ? letterSpacing : 0);
                   }
               } else {
                   targetCtx.fillText(text, x + totalOffset.x, y + totalOffset.y);
               }

               targetCtx.restore();
           }

           targetCtx.restore();
           return;
       }

       // Path-based detailed 3D implementation
       const primaryColorRgba = hexToRgba(textObj.d3dPrimaryColor, textObj.d3dPrimaryOpacity / 100);
       const offset = textObj.d3dOffset;
       const angle = textObj.d3dAngle;
       const blur = textObj.d3dBlur;

       // Create a Path2D object from the OpenType.js path
       const shadowPath = new Path2D();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
                   shadowPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   shadowPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   shadowPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   shadowPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   shadowPath.closePath();
                   break;
           }
       }

       targetCtx.save();

       const totalOffset = calculateOffset(offset, angle);
       const steps = Math.max(30, Math.floor(offset));

       for (let i = steps; i >= 1; i--) {
           const progress = i / steps;

           targetCtx.save();
           targetCtx.translate(totalOffset.x * progress, totalOffset.y * progress);
           targetCtx.fillStyle = primaryColorRgba;
           targetCtx.fill(shadowPath);
           targetCtx.restore();
       }

       if (blur > 0) {
           targetCtx.save();
           targetCtx.translate(totalOffset.x, totalOffset.y);
           targetCtx.shadowColor = primaryColorRgba;
           targetCtx.shadowBlur = blur;
           targetCtx.shadowOffsetX = 0;
           targetCtx.shadowOffsetY = 0;
           targetCtx.fillStyle = primaryColorRgba;
           targetCtx.fill(shadowPath);
           targetCtx.restore();
       }

       targetCtx.restore();
   }

   // Apply decoration to a path
   function applyDecoration(ctx, textObj, path) {
       const applyDecorationCallId = Math.random().toString(36).substring(2, 8);
       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: === STARTING applyDecoration FUNCTION ===`);
       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Decoration mode: ${textObj.decorationMode}`);
       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Path provided:`, !!path);
       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Path commands count:`, path ? path.commands.length : 'N/A');

       // Skip if no decoration mode is set
       if (!textObj.decorationMode || textObj.decorationMode === "noDecoration") {
           console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: ❌ NO DECORATION MODE OR noDecoration`);
           return;
       }

       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Creating Path2D from OpenType.js path`);

       // Create a Path2D object from the OpenType.js path
       const decorPath = new Path2D();
       for (let i = 0; i < path.commands.length; i++) {
           const cmd = path.commands[i];
           switch (cmd.type) {
               case 'M':
                   decorPath.moveTo(cmd.x, cmd.y);
                   break;
               case 'L':
                   decorPath.lineTo(cmd.x, cmd.y);
                   break;
               case 'C':
                   decorPath.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                   break;
               case 'Q':
                   decorPath.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                   break;
               case 'Z':
                   decorPath.closePath();
                   break;
           }
       }

       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Path2D created, applying decoration type: ${textObj.decorationMode}`);

       // Apply different decoration types
       switch (textObj.decorationMode) {
           case 'horizontalLines':
               // Create a pattern of horizontal lines
               const hLineCanvas = document.createElement('canvas');
               const hLineSize = Math.max(10, textObj.hLineDist || 10);
               hLineCanvas.width = hLineSize;
               hLineCanvas.height = hLineSize;
               const hLineCtx = hLineCanvas.getContext('2d');

               hLineCtx.strokeStyle = textObj.hLineColor || '#000000';
               hLineCtx.lineWidth = Math.max(1, textObj.hLineWeight || 2);
               hLineCtx.beginPath();
               hLineCtx.moveTo(0, hLineSize / 2);
               hLineCtx.lineTo(hLineSize, hLineSize / 2);
               hLineCtx.stroke();

               const hLinePattern = ctx.createPattern(hLineCanvas, 'repeat');
               ctx.fillStyle = hLinePattern;
               ctx.fill(decorPath);
               break;

           case 'colorCut':
               // Apply color cut decoration with a simpler approach
               const cutDistance = textObj.ccDist || 50; // Default to 50% if not set
               const cutColor = textObj.ccColor || '#00FF00'; // Default to green if not set
               const fillDirection = textObj.ccFillDir || 'top'; // Default to top if not set

               // First fill the entire path with the text color
               ctx.fill(decorPath);

               // Create a clipping path
               ctx.save();
               ctx.beginPath();
               ctx.clip(decorPath);

               // For grid distorted text, we need a different approach
               // Since we're already translated to the object's position, we can use 0,0 as the center

               // Estimate the text height based on the font size
               // For grid distorted text, we need to use a larger multiplier
               // to ensure the effect covers the entire distorted text
               const heightMultiplier = textObj.effectMode === 'grid-distort' ? 3.0 : 1.5;
               const estimatedHeight = textObj.fontSize * heightMultiplier;

               // Calculate the cut position based on the estimated height
               const cutPercent = cutDistance / 100;
               const cutY = fillDirection === 'top'
                   ? -estimatedHeight/2 + (estimatedHeight * cutPercent)
                   : estimatedHeight/2 - (estimatedHeight * cutPercent);

               // Apply the color cut
               ctx.fillStyle = cutColor;

               if (fillDirection === 'top') {
                   // Fill from top to cut line
                   ctx.fillRect(-10000, -10000, 20000, cutY + 10000);
               } else {
                   // Fill from cut line to bottom
                   ctx.fillRect(-10000, cutY, 20000, 20000);
               }

               ctx.restore();
               break;

           case 'obliqueLines':
               // Special handling for grid distorted text
               if (textObj.effectMode === 'grid-distort') {
                   // For grid distorted text, we'll use a direct drawing approach instead of a pattern
                   // First fill with the text color
                   ctx.fill(decorPath);

                   // Create a clipping path to constrain the lines to the text shape
                   ctx.save();
                   ctx.beginPath();
                   ctx.clip(decorPath);

                   // Get the color for the lines
                   const lineColor = textObj.oLineColor || '#000000';
                   ctx.strokeStyle = lineColor;

                   // Get the line weight
                   const lineWeight = Math.max(1, textObj.oLineWeight || 2);
                   ctx.lineWidth = lineWeight;

                   // Get the line spacing
                   const lineSpacing = Math.max(10, textObj.oLineDist || 10);

                   // Calculate the bounds of the text to draw lines across
                   // We'll use a large area to ensure we cover the entire text
                   const bounds = {
                       left: -1000,
                       top: -1000,
                       right: 1000,
                       bottom: 1000,
                       width: 2000,
                       height: 2000
                   };

                   // Draw diagonal lines across the entire text area
                   ctx.beginPath();

                   // Draw lines from top-left to bottom-right
                   for (let x = bounds.left; x < bounds.right; x += lineSpacing) {
                       ctx.moveTo(x, bounds.top);
                       ctx.lineTo(x + bounds.width, bounds.top + bounds.height);
                   }

                   // Draw additional lines to ensure coverage
                   for (let y = bounds.top; y < bounds.bottom; y += lineSpacing) {
                       ctx.moveTo(bounds.left, y);
                       ctx.lineTo(bounds.left + bounds.width, y + bounds.height);
                   }

                   ctx.stroke();
                   ctx.restore();
               } else {
                   // Standard pattern-based approach for non-distorted text
                   const oLineCanvas = document.createElement('canvas');
                   const oLineSize = Math.max(10, textObj.oLineDist || 10);
                   oLineCanvas.width = oLineSize;
                   oLineCanvas.height = oLineSize;
                   const oLineCtx = oLineCanvas.getContext('2d');

                   oLineCtx.strokeStyle = textObj.oLineColor || '#000000';
                   oLineCtx.lineWidth = Math.max(1, textObj.oLineWeight || 2);
                   oLineCtx.beginPath();
                   oLineCtx.moveTo(0, oLineSize);
                   oLineCtx.lineTo(oLineSize, 0);
                   oLineCtx.stroke();

                   const oLinePattern = ctx.createPattern(oLineCanvas, 'repeat');
                   ctx.fillStyle = oLinePattern;
                   ctx.fill(decorPath);
               }
               break;

           case 'concentricCircles':
               // Create a pattern of concentric circles
               const ccCanvas = document.createElement('canvas');
               const ccSize = Math.max(20, textObj.ccDist || 20);
               ccCanvas.width = ccSize;
               ccCanvas.height = ccSize;
               const ccCtx = ccCanvas.getContext('2d');

               ccCtx.strokeStyle = textObj.ccColor || '#000000';
               ccCtx.lineWidth = 1;
               ccCtx.beginPath();
               ccCtx.arc(ccSize / 2, ccSize / 2, ccSize / 4, 0, Math.PI * 2);
               ccCtx.stroke();

               const ccPattern = ctx.createPattern(ccCanvas, 'repeat');
               ctx.fillStyle = ccPattern;
               ctx.fill(decorPath);
               break;

           case 'fishingLines':
               // Create a pattern of fishing lines
               const flCanvas = document.createElement('canvas');
               const flSize = Math.max(20, textObj.flcDist || 20);
               flCanvas.width = flSize;
               flCanvas.height = flSize;
               const flCtx = flCanvas.getContext('2d');

               flCtx.strokeStyle = textObj.flcColor || '#000000';
               flCtx.lineWidth = Math.max(1, textObj.flcWeight || 2);

               // Draw vertical lines with varying thickness
               const spacing = Math.max(4, textObj.flcSpacing || 5);
               for (let x = 0; x < flSize; x += spacing) {
                   flCtx.beginPath();
                   flCtx.moveTo(x, 0);
                   flCtx.lineTo(x, flSize);
                   flCtx.stroke();
               }

               const flPattern = ctx.createPattern(flCanvas, 'repeat');
               ctx.fillStyle = flPattern;
               ctx.fill(decorPath);
               break;

           case 'fadingLinesCut':
               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: ✅ FOUND fadingLinesCut CASE!`);
               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Fading Lines properties:`, {
                   flcDist: textObj.flcDist,
                   flcColor: textObj.flcColor,
                   flcWeight: textObj.flcWeight,
                   flcSpacing: textObj.flcSpacing,
                   flcDir: textObj.flcDir
               });

               // For Grid Distort, we need to use a direct drawing approach instead of patterns
               // because patterns don't account for the expanded bounds
               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Using direct drawing approach for Grid Distort`);

               const baseFadingColor = textObj.flcColor || '#0000FF';
               const fadingOpacity = (textObj.flcOpacity || 100) / 100; // Convert percentage to decimal
               const fadingDistance = (textObj.flcDist || 45) / 100;
               const fadingWeight = textObj.flcWeight || 3;
               const fadingSpacing = textObj.flcSpacing || 10;
               const fadingDirection = textObj.flcDir || 'top';

               // Convert hex color to rgba with opacity
               let fadingColor;
               if (baseFadingColor.startsWith('#')) {
                   const hex = baseFadingColor.slice(1);
                   const r = parseInt(hex.slice(0, 2), 16);
                   const g = parseInt(hex.slice(2, 4), 16);
                   const b = parseInt(hex.slice(4, 6), 16);
                   fadingColor = `rgba(${r}, ${g}, ${b}, ${fadingOpacity})`;
               } else {
                   fadingColor = baseFadingColor; // Use as is if not hex
               }

               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Drawing fading lines with:`, {
                   baseColor: baseFadingColor, opacity: fadingOpacity, finalColor: fadingColor,
                   distance: fadingDistance, weight: fadingWeight, spacing: fadingSpacing, direction: fadingDirection
               });

               // First fill the entire path with the text color to create the base
               ctx.fill(decorPath);

               // Create a clipping path to constrain the fading lines to the text shape
               ctx.save();
               ctx.beginPath();
               ctx.clip(decorPath);

               // Set the fading lines color
               ctx.fillStyle = fadingColor;

               // Calculate expanded bounds for Grid Distort
               // Grid Distort typically expands the text by 2-3x in all directions
               const gridPadding = textObj.gridDistortPadding || 120;
               const intensity = (textObj.gridDistortIntensity || 100) / 100;
               const expansionFactor = Math.max(2.5, 1 + (gridPadding / 100) + intensity);

               const expandedHeight = (textObj.fontSize || 100) * expansionFactor;
               const expandedWidth = expandedHeight * 2; // Wide enough to cover distorted text

               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Grid Distort expansion:`, {
                   gridPadding, intensity, expansionFactor, expandedHeight, expandedWidth
               });

               // Calculate the area to fill with fading lines
               const fillHeight = expandedHeight * fadingDistance;
               const totalArea = expandedHeight;

               // Calculate line parameters
               const totalLines = Math.floor(fillHeight / (fadingWeight + fadingSpacing));
               const solidBlockHeight = fillHeight * 0.3; // 30% solid block
               const fadingAreaHeight = fillHeight - solidBlockHeight;

               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Fading area calculation:`, {
                   fillHeight, totalLines, solidBlockHeight, fadingAreaHeight
               });

               if (fadingDirection === 'top') {
                   // Draw from top of expanded bounds
                   const startY = -totalArea / 2;

                   // Draw solid block at the top
                   if (solidBlockHeight > 0) {
                       ctx.fillRect(-expandedWidth / 2, startY, expandedWidth, solidBlockHeight);
                       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Drew solid block at top`);
                   }

                   // Draw fading lines below the solid block
                   let currentY = startY + solidBlockHeight;
                   for (let i = 0; i < totalLines; i++) {
                       const progress = i / totalLines;
                       const lineHeight = Math.max(1, fadingWeight * (1 - progress));

                       if (currentY + lineHeight > startY + fillHeight) break;

                       ctx.fillRect(-expandedWidth / 2, currentY, expandedWidth, lineHeight);
                       currentY += lineHeight + fadingSpacing * (1 - progress * 0.5); // Reduce spacing as lines get smaller
                   }
                   console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Drew ${totalLines} fading lines from top`);
               } else {
                   // Draw from bottom of expanded bounds
                   const endY = totalArea / 2;
                   const startY = endY - fillHeight;

                   // Draw fading lines at the top of the area
                   let currentY = startY;
                   for (let i = 0; i < totalLines; i++) {
                       const progress = i / totalLines;
                       const lineHeight = Math.max(1, fadingWeight * (1 - progress));

                       if (currentY + lineHeight > startY + fadingAreaHeight) break;

                       ctx.fillRect(-expandedWidth / 2, currentY, expandedWidth, lineHeight);
                       currentY += lineHeight + fadingSpacing * (1 - progress * 0.5);
                   }

                   // Draw solid block at the bottom
                   if (solidBlockHeight > 0) {
                       ctx.fillRect(-expandedWidth / 2, endY - solidBlockHeight, expandedWidth, solidBlockHeight);
                       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Drew solid block at bottom`);
                   }
                   console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: Drew ${totalLines} fading lines from bottom`);
               }

               ctx.restore();
               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: ✅ FADING LINES APPLIED WITH GRID DISTORT EXPANSION!`);
               break;

           default:
               console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: ❌ UNKNOWN DECORATION TYPE: ${textObj.decorationMode}`);
               break;
       }
       console.log(`🔍 APPLY DECORATION [${applyDecorationCallId}]: === applyDecoration FUNCTION COMPLETE ===`);
   }

   // --- Rectangle Drawing Function ---
   function drawRectangleObject(obj, targetCtx) {
       if (!obj || obj.type !== 'rectangle') return;

       console.log('📐 RECTANGLE: Drawing rectangle object:', obj.id);

       targetCtx.save();

       // Set up rectangle properties
       const x = obj.x - (obj.width / 2);
       const y = obj.y - (obj.height / 2);
       const width = obj.width;
       const height = obj.height;

       console.log('📐 RECTANGLE: Drawing at:', { x, y, width, height });

       // Draw filled rectangle if fillOpacity > 0
       if (obj.fillOpacity && obj.fillOpacity > 0 && obj.color) {
           targetCtx.globalAlpha = obj.fillOpacity;
           targetCtx.fillStyle = obj.color;
           targetCtx.fillRect(x, y, width, height);
           console.log('📐 RECTANGLE: Filled with color:', obj.color, 'opacity:', obj.fillOpacity);
       }

       // Draw stroke if strokeOpacity > 0 and strokeWidth > 0
       if (obj.strokeOpacity && obj.strokeOpacity > 0 && obj.strokeColor && obj.strokeWidth && obj.strokeWidth > 0) {
           targetCtx.globalAlpha = obj.strokeOpacity;
           targetCtx.strokeStyle = obj.strokeColor;
           targetCtx.lineWidth = obj.strokeWidth;
           targetCtx.strokeRect(x, y, width, height);
           console.log('📐 RECTANGLE: Stroked with color:', obj.strokeColor, 'width:', obj.strokeWidth, 'opacity:', obj.strokeOpacity);
       }

       // 🔗 RESIZE HANDLES: Draw resize handles if this rectangle is selected and is a text controller
       if (obj.isSelected && obj.isTextController && targetCtx === canvas.getContext('2d')) {
           const handleSize = 8 / scale;
           const half = handleSize / 2;

           // Calculate handle positions
           const handles = [
               { id: 'nw', x: x, y: y },                           // Top-left
               { id: 'ne', x: x + width, y: y },                  // Top-right
               { id: 'sw', x: x, y: y + height },                 // Bottom-left
               { id: 'se', x: x + width, y: y + height },         // Bottom-right
               { id: 'n', x: x + width/2, y: y },                 // Top-center
               { id: 's', x: x + width/2, y: y + height },        // Bottom-center
               { id: 'w', x: x, y: y + height/2 },                // Left-center
               { id: 'e', x: x + width, y: y + height/2 }         // Right-center
           ];

           // Draw handles
           targetCtx.fillStyle = '#ffffff';
           targetCtx.strokeStyle = '#0066cc';
           targetCtx.lineWidth = 1 / scale;

           handles.forEach(handle => {
               targetCtx.fillRect(handle.x - half, handle.y - half, handleSize, handleSize);
               targetCtx.strokeRect(handle.x - half, handle.y - half, handleSize, handleSize);
           });

           console.log('📐 RECTANGLE: Drew resize handles for text controller rectangle');
       }

       targetCtx.restore();
       console.log('📐 RECTANGLE: Drawing complete');
   }

   // --- Main Drawing Logic Per Object ---
   function drawTextObject(obj, targetCtx) { // Added targetCtx
       if (!obj || obj.type !== 'text' || !obj.text) return;

       // DETAILED PNG EXPORT LOGGING
       console.log(`[PNG Export] drawTextObject ENTRY - Input object:`, {
           x: obj.x, y: obj.y, text: obj.text, fontSize: obj.fontSize,
           fontFamily: obj.fontFamily, color: obj.color, rotation: obj.rotation
       });
       console.log(`[PNG Export] drawTextObject - Canvas context info:`, {
           canvasWidth: targetCtx.canvas.width,
           canvasHeight: targetCtx.canvas.height,
           currentTransform: targetCtx.getTransform()
       });

       targetCtx.save(); // Use targetCtx
       console.log(`[PNG Export] drawTextObject - BEFORE translate: transform =`, targetCtx.getTransform());
       targetCtx.translate(obj.x, obj.y); // Use targetCtx
       console.log(`[PNG Export] drawTextObject - AFTER translate(${obj.x}, ${obj.y}): transform =`, targetCtx.getTransform());
       targetCtx.rotate(obj.rotation * Math.PI / 180); // Use targetCtx

       // Apply scaling if present (like image objects do)
       if (obj.scale && obj.scale !== 1) {
           targetCtx.scale(obj.scale, obj.scale);
           console.log('🎨 [DrawText] Applied scale:', obj.scale);
       }

       if (obj.effectMode === 'skew') {
           const skewXRad = obj.skewX / 100;
           const skewYRad = obj.skewY / 100;
           targetCtx.transform(1, skewYRad, skewXRad, 1, 0, 0); // Use targetCtx
       }
       targetCtx.textBaseline = "middle"; // Use targetCtx
       console.log(`[PNG Export] drawTextObject - Set textBaseline = "middle"`);
       console.log(`[PNG Export] drawTextObject - Current transform before drawing:`, targetCtx.getTransform());
       console.log('🎯 EFFECT MODE: About to render with effectMode:', obj.effectMode, 'for text:', obj.text);
       switch (obj.effectMode) {
           case 'normal': case 'skew':
               drawNormalOrSkewObject(obj, targetCtx);
               console.log('🎯 EFFECT MODE: Completed normal/skew rendering for:', obj.text);
               break; // Pass targetCtx
           case 'warp':
               drawWarpedObject(obj, targetCtx);
               console.log('🎯 EFFECT MODE: Completed warp rendering for:', obj.text);
               break; // Pass targetCtx
           case 'circle':
               // Render circular text directly to target canvas (no offscreen)
               console.log('🎯 EFFECT MODE: Starting direct circular rendering for:', obj.text);
               drawCircularObject(obj, targetCtx); // Render directly to target canvas
               console.log('🎯 EFFECT MODE: Completed direct circular rendering for:', obj.text);
               break;
           case 'curve':
               drawCurvedObject(obj, targetCtx);
               console.log('🎯 EFFECT MODE: Completed curve rendering for:', obj.text);
               break; // Pass targetCtx
           case 'grid-distort':
               // Initialize grid if needed
               if (!obj.gridDistort) {
                   obj.gridDistort = {
                       gridCols: obj.gridDistortCols || 3,
                       gridRows: obj.gridDistortRows || 2,
                       gridPadding: obj.gridDistortPadding || 120,
                       intensity: (obj.gridDistortIntensity || 100) / 100,
                       controlPoints: [],
                       showGrid: true,
                       lastFontSize: obj.fontSize, // Store the current font size
                       lastText: obj.text // Store the current text content
                   };
                   // Set vertical-only mode based on radio button
                   obj.gridDistortVerticalOnly = obj.gridDistortVerticalOnly || false;
                   initializeGridPoints(obj);
               }
               drawGridDistortObject(obj, targetCtx);
               break; // Pass targetCtx
           case 'mesh':
               // Try to use the object's own mesh handler first, then fall back to active handler
               if (obj._meshWarpHandler) {
                   console.log('[MeshRender] Using object\'s own mesh handler for:', obj.text || obj.id);
                   obj._meshWarpHandler.drawWarpedText(targetCtx);
               } else if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler && activeMeshWarpHandler.selectedTextObject === obj) {
                   console.log('[MeshRender] Using active mesh handler for:', obj.text || obj.id);
                   activeMeshWarpHandler.drawWarpedText(targetCtx);
               } else {
                   // Fallback if no handler is available for this object
                   console.warn("Mesh effect selected, but no handler found for object:", obj.id);
                   drawNormalOrSkewObject(obj, targetCtx);
               }
               break;
           default:
               setTextContextOn(targetCtx, obj); // Use targetCtx
               targetCtx.fillStyle = obj.color; // Use targetCtx
               targetCtx.fillText(obj.text + ' (Unknown Effect)', 0, 0); // Use targetCtx
       }

       console.log('🎯 EFFECT MODE: About to restore context for:', obj.effectMode, 'text:', obj.text);
       // Final canvas check before restore
       if (obj.effectMode === 'circle') {
           // Check the center area where circular text is likely positioned
           const centerX = targetCtx.canvas.width / 2;
           const centerY = targetCtx.canvas.height / 2;
           const checkSize = 200; // Check a larger area around center
           const checkX = Math.max(0, centerX - checkSize / 2);
           const checkY = Math.max(0, centerY - checkSize / 2);
           const checkW = Math.min(checkSize, targetCtx.canvas.width - checkX);
           const checkH = Math.min(checkSize, targetCtx.canvas.height - checkY);

           const finalImageData = targetCtx.getImageData(checkX, checkY, checkW, checkH);
           const finalHasPixels = Array.from(finalImageData.data).some((value, index) => index % 4 === 3 && value > 0);
           console.log('🎯 EFFECT MODE: Final canvas state before restore', {
               hasVisiblePixels: finalHasPixels,
               effectMode: obj.effectMode,
               checkArea: { x: checkX, y: checkY, w: checkW, h: checkH }
           });
       }

       targetCtx.restore(); // Use targetCtx
       console.log('🎯 EFFECT MODE: Context restored for:', obj.effectMode, 'text:', obj.text);
   }

   // Function to create filtered image using offscreen canvas and HTML element
   function createFilteredImageSync(originalImage, filterString) {
       try {
           console.log('🎨 [Canvas] Creating filtered image with filter:', filterString);

           // Create an offscreen canvas
           const offscreenCanvas = document.createElement('canvas');
           const offscreenCtx = offscreenCanvas.getContext('2d');

           // Set canvas size to match original image
           const width = originalImage.naturalWidth || originalImage.width || 100;
           const height = originalImage.naturalHeight || originalImage.height || 100;
           offscreenCanvas.width = width;
           offscreenCanvas.height = height;

           console.log('🎨 [Canvas] Canvas size:', width, 'x', height);

           // Try to use CSS filters first (modern browsers)
           if (offscreenCtx.filter !== undefined) {
               console.log('🎨 [Canvas] Using CSS filter support:', filterString);
               offscreenCtx.filter = filterString;
               offscreenCtx.drawImage(originalImage, 0, 0, width, height);
           } else {
               // Fallback to manual pixel manipulation for older browsers
               console.log('🎨 [Canvas] Using manual filter processing:', filterString);

               // Draw the original image to the offscreen canvas first
               offscreenCtx.drawImage(originalImage, 0, 0, width, height);

               // Get the image data
               const imageData = offscreenCtx.getImageData(0, 0, width, height);

               // Apply basic filters manually (simplified version)
               if (filterString.includes('grayscale')) {
                   applyGrayscaleFilter(imageData);
               }
               if (filterString.includes('sepia')) {
                   applySepiaFilter(imageData);
               }
               if (filterString.includes('invert')) {
                   applyInvertFilter(imageData);
               }
               if (filterString.includes('brightness')) {
                   const match = filterString.match(/brightness\(([^)]+)\)/);
                   if (match) {
                       const value = parseFloat(match[1]);
                       applyBrightnessFilter(imageData, value);
                   }
               }
               if (filterString.includes('contrast')) {
                   const match = filterString.match(/contrast\(([^)]+)\)/);
                   if (match) {
                       const value = parseFloat(match[1]);
                       applyContrastFilter(imageData, value);
                   }
               }
               if (filterString.includes('saturate')) {
                   const match = filterString.match(/saturate\(([^)]+)\)/);
                   if (match) {
                       const value = parseFloat(match[1]);
                       applySaturateFilter(imageData, value);
                   }
               }

               // Put the modified image data back
               offscreenCtx.putImageData(imageData, 0, 0);
           }

           // Create new image from the filtered canvas
           const filteredImg = new Image();
           filteredImg.src = offscreenCanvas.toDataURL();

           console.log('🎨 [Canvas] Filtered image created successfully');
           return filteredImg;

       } catch (error) {
           console.error('🎨 [Canvas] Error creating filtered image:', error);
           return originalImage; // Return original on error
       }
   }

   // Helper functions for manual filter application
   function applyGrayscaleFilter(imageData) {
       const data = imageData.data;
       for (let i = 0; i < data.length; i += 4) {
           const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
           data[i] = gray;     // Red
           data[i + 1] = gray; // Green
           data[i + 2] = gray; // Blue
       }
   }

   function applySepiaFilter(imageData) {
       const data = imageData.data;
       for (let i = 0; i < data.length; i += 4) {
           const r = data[i];
           const g = data[i + 1];
           const b = data[i + 2];

           data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));     // Red
           data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168)); // Green
           data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131)); // Blue
       }
   }

   function applyInvertFilter(imageData) {
       const data = imageData.data;
       for (let i = 0; i < data.length; i += 4) {
           data[i] = 255 - data[i];         // Red
           data[i + 1] = 255 - data[i + 1]; // Green
           data[i + 2] = 255 - data[i + 2]; // Blue
       }
   }

   function applyBrightnessFilter(imageData, brightness) {
       const data = imageData.data;
       const factor = brightness; // brightness is already a multiplier (1.0 = normal)
       for (let i = 0; i < data.length; i += 4) {
           data[i] = Math.min(255, Math.max(0, data[i] * factor));         // Red
           data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor)); // Green
           data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor)); // Blue
       }
   }

   function applyContrastFilter(imageData, contrast) {
       const data = imageData.data;
       const factor = contrast; // contrast is already a multiplier (1.0 = normal)
       const intercept = 128 * (1 - factor);
       for (let i = 0; i < data.length; i += 4) {
           data[i] = Math.min(255, Math.max(0, data[i] * factor + intercept));         // Red
           data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor + intercept)); // Green
           data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor + intercept)); // Blue
       }
   }

   function applySaturateFilter(imageData, saturation) {
       const data = imageData.data;
       for (let i = 0; i < data.length; i += 4) {
           const r = data[i];
           const g = data[i + 1];
           const b = data[i + 2];

           // Convert to grayscale
           const gray = r * 0.299 + g * 0.587 + b * 0.114;

           // Apply saturation
           data[i] = Math.min(255, Math.max(0, gray + (r - gray) * saturation));         // Red
           data[i + 1] = Math.min(255, Math.max(0, gray + (g - gray) * saturation));     // Green
           data[i + 2] = Math.min(255, Math.max(0, gray + (b - gray) * saturation));     // Blue
       }
   }

   // Function to create duotone image using matrix transformation
   function createDuotoneImageSync(originalImage, matrixValues) {
       try {
           console.log('🎨 [Canvas] Creating duotone image with matrix:', matrixValues);

           // Create an offscreen canvas
           const offscreenCanvas = document.createElement('canvas');
           const offscreenCtx = offscreenCanvas.getContext('2d');

           // Set canvas size to match original image
           const width = originalImage.naturalWidth || originalImage.width || 100;
           const height = originalImage.naturalHeight || originalImage.height || 100;
           offscreenCanvas.width = width;
           offscreenCanvas.height = height;

           console.log('🎨 [Canvas] Duotone canvas size:', width, 'x', height);

           // Draw the original image
           offscreenCtx.drawImage(originalImage, 0, 0, width, height);

           // Get the image data for pixel manipulation
           const imageData = offscreenCtx.getImageData(0, 0, width, height);
           const data = imageData.data;

           // Parse matrix values
           const matrix = matrixValues.split(' ').map(parseFloat);
           if (matrix.length !== 20) {
               console.error('🎨 [Canvas] Invalid matrix length:', matrix.length);
               return originalImage;
           }

           // Apply duotone matrix transformation
           for (let i = 0; i < data.length; i += 4) {
               const r = data[i];
               const g = data[i + 1];
               const b = data[i + 2];
               const a = data[i + 3];

               // Apply matrix transformation
               // Matrix format: [r1, g1, b1, a1, offset1, r2, g2, b2, a2, offset2, r3, g3, b3, a3, offset3, r4, g4, b4, a4, offset4]
               const newR = Math.min(255, Math.max(0,
                   r * matrix[0] + g * matrix[1] + b * matrix[2] + a * matrix[3] + matrix[4] * 255));
               const newG = Math.min(255, Math.max(0,
                   r * matrix[5] + g * matrix[6] + b * matrix[7] + a * matrix[8] + matrix[9] * 255));
               const newB = Math.min(255, Math.max(0,
                   r * matrix[10] + g * matrix[11] + b * matrix[12] + a * matrix[13] + matrix[14] * 255));
               const newA = Math.min(255, Math.max(0,
                   r * matrix[15] + g * matrix[16] + b * matrix[17] + a * matrix[18] + matrix[19] * 255));

               data[i] = newR;
               data[i + 1] = newG;
               data[i + 2] = newB;
               data[i + 3] = newA;
           }

           // Put the modified image data back
           offscreenCtx.putImageData(imageData, 0, 0);

           // Return the canvas directly instead of creating a new Image object
           // This avoids async loading issues
           console.log('🎨 [Canvas] Duotone image created successfully');
           return offscreenCanvas;

       } catch (error) {
           console.error('🎨 [Canvas] Error creating duotone image:', error);
           return originalImage; // Return original on error
       }
   }

   // Function to create glitch image using multiple effects
   function createGlinchImageSync(originalImage, effects) {
       try {
           console.log('🎨 [Canvas] Creating glitch image with effects:', effects);

           // Create an offscreen canvas
           const offscreenCanvas = document.createElement('canvas');
           const offscreenCtx = offscreenCanvas.getContext('2d');

           // Set canvas size to match original image
           const width = originalImage.naturalWidth || originalImage.width || 100;
           const height = originalImage.naturalHeight || originalImage.height || 100;
           offscreenCanvas.width = width;
           offscreenCanvas.height = height;

           console.log('🎨 [Canvas] Glitch canvas size:', width, 'x', height);

           // Draw the original image
           offscreenCtx.drawImage(originalImage, 0, 0, width, height);

           // Get the image data for pixel manipulation
           let imageData = offscreenCtx.getImageData(0, 0, width, height);
           let outputData = new ImageData(width, height);

           // Apply effects in sequence
           if (effects.paletteReduction && effects.paletteReduction.enabled) {
               outputData = new ImageData(width, height);
               applyPaletteReductionEffect(imageData, outputData, effects.paletteReduction);
               imageData = outputData;
           }

           if (effects.colorShift && effects.colorShift.enabled) {
               outputData = new ImageData(width, height);
               applyColorShiftEffect(imageData, outputData, effects.colorShift);
               imageData = outputData;
           }

           if (effects.waveDeform && effects.waveDeform.enabled) {
               outputData = new ImageData(width, height);
               applyWaveDeformEffect(imageData, outputData, effects.waveDeform);
               imageData = outputData;
           }

           if (effects.displacement && effects.displacement.enabled) {
               outputData = new ImageData(width, height);
               applyDisplacementEffect(imageData, outputData, effects.displacement);
               imageData = outputData;
           }

           if (effects.pixelSort && effects.pixelSort.enabled) {
               outputData = new ImageData(width, height);
               applyPixelSortEffect(imageData, outputData, effects.pixelSort);
               imageData = outputData;
           }

           // Put the modified image data back
           offscreenCtx.putImageData(imageData, 0, 0);

           // Create new image from the glitch canvas
           // Return the canvas directly instead of creating a new Image object
           // This avoids async loading issues
           console.log('🎨 [Canvas] Glitch image created successfully');
           return offscreenCanvas;

       } catch (error) {
           console.error('🎨 [Canvas] Error creating glitch image:', error);
           return originalImage; // Return original on error
       }
   }

   // Function to create halftone image effect
   function createHalftoneImageSync(originalImage, settings) {
       try {
           console.log('🎨 [Canvas] Creating halftone image with settings:', settings);

           // Create an offscreen canvas for the halftone effect
           const canvas = document.createElement('canvas');
           const ctx = canvas.getContext('2d');

           // Set canvas size to match original image
           const width = originalImage.naturalWidth || originalImage.width || 100;
           const height = originalImage.naturalHeight || originalImage.height || 100;
           canvas.width = width;
           canvas.height = height;

           console.log('🎨 [Canvas] Halftone canvas size:', width, 'x', height);

           // Create the halftone pattern canvas
           const patternCanvas = document.createElement('canvas');
           const patternCtx = patternCanvas.getContext('2d');
           patternCanvas.width = width;
           patternCanvas.height = height;

           // Convert dot size from em to pixels (assuming 16px base font size)
           const dotSizeInPixels = Math.max(1, settings.dotSize * 16);

           // Create the dot pattern with rotation
           patternCtx.save();
           patternCtx.fillStyle = settings.dotColor;

           // Apply rotation to the entire pattern
           const centerX = width / 2;
           const centerY = height / 2;
           patternCtx.translate(centerX, centerY);
           patternCtx.rotate(20 * Math.PI / 180); // 20 degree rotation like original halftone
           patternCtx.translate(-centerX, -centerY);

           // Create dot pattern across the canvas
           const spacing = dotSizeInPixels * 1.5; // Space between dots
           for (let x = -spacing; x < width + spacing; x += spacing) {
               for (let y = -spacing; y < height + spacing; y += spacing) {
                   patternCtx.beginPath();
                   patternCtx.arc(x, y, dotSizeInPixels / 2, 0, 2 * Math.PI);
                   patternCtx.fill();
               }
           }
           patternCtx.restore();

           // Draw the original image with grayscale filter
           ctx.filter = 'grayscale(1)';
           ctx.drawImage(originalImage, 0, 0, width, height);

           // Apply the halftone pattern using blend mode
           ctx.globalCompositeOperation = settings.blendMode;
           ctx.drawImage(patternCanvas, 0, 0);

           // Return the canvas directly instead of creating a new Image object
           // This avoids async loading issues and matches the glitch implementation
           console.log('🎨 [Canvas] Halftone image created successfully');
           return canvas;

       } catch (error) {
           console.error('🎨 [Canvas] Error creating halftone image:', error);
           return originalImage; // Return original on error
       }
   }

   // Helper functions for glitch effects
   function applyColorShiftEffect(inputImageData, outputImageData, params) {
       const { width, height, data: src } = inputImageData;
       const dst = outputImageData.data;

       const shiftX = Math.round(params.shiftAmount);
       const intensity = params.intensity;

       // Clear output
       dst.fill(0);

       for (let y = 0; y < height; y++) {
           for (let x = 0; x < width; x++) {
               const srcIdx = (y * width + x) * 4;

               // Red channel with positive shift
               const redX = x + shiftX;
               if (redX >= 0 && redX < width) {
                   const redIdx = (y * width + redX) * 4;
                   dst[redIdx] = Math.min(255, dst[redIdx] + src[srcIdx] * intensity);
               }

               // Green channel (no shift)
               dst[srcIdx + 1] = Math.min(255, dst[srcIdx + 1] + src[srcIdx + 1] * intensity);

               // Blue channel with negative shift
               const blueX = x - shiftX;
               if (blueX >= 0 && blueX < width) {
                   const blueIdx = (y * width + blueX) * 4;
                   dst[blueIdx + 2] = Math.min(255, dst[blueIdx + 2] + src[srcIdx + 2] * intensity);
               }

               // Alpha channel
               dst[srcIdx + 3] = src[srcIdx + 3];
           }
       }

       return outputImageData;
   }

   function applyWaveDeformEffect(inputImageData, outputImageData, params) {
       const { width, height, data: src } = inputImageData;
       const dst = outputImageData.data;

       const { direction, amplitude, frequency } = params;
       const isHorizontal = direction === "horizontal";

       // Clear output
       dst.fill(0);

       for (let y = 0; y < height; y++) {
           for (let x = 0; x < width; x++) {
               const srcIdx = (y * width + x) * 4;

               let newX = x;
               let newY = y;

               if (isHorizontal) {
                   newX = x + Math.sin(y * frequency) * amplitude;
               } else {
                   newY = y + Math.sin(x * frequency) * amplitude;
               }

               newX = Math.round(newX);
               newY = Math.round(newY);

               if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                   const newIdx = (newY * width + newX) * 4;
                   dst[newIdx] = src[srcIdx];
                   dst[newIdx + 1] = src[srcIdx + 1];
                   dst[newIdx + 2] = src[srcIdx + 2];
                   dst[newIdx + 3] = src[srcIdx + 3];
               }
           }
       }

       return outputImageData;
   }

   function applyDisplacementEffect(inputImageData, outputImageData, params) {
       const { width, height, data: src } = inputImageData;
       const dst = outputImageData.data;

       const { mode, displacementIntensity, displacementSize, displacementFrequency } = params;
       const isHorizontal = mode === 'horizontal';

       // Simple random function with fixed seed for consistency
       let seed = 12345;
       const random = () => {
           seed = (seed * 9301 + 49297) % 233280;
           return seed / 233280;
       };

       // Copy original data first
       for (let i = 0; i < src.length; i++) {
           dst[i] = src[i];
       }

       // Apply displacement in blocks
       const blockCount = Math.floor((isHorizontal ? height : width) / displacementSize);

       for (let block = 0; block < blockCount; block++) {
           if (random() > displacementFrequency) continue;

           const displacement = Math.round((random() - 0.5) * 2 * displacementIntensity);
           const blockStart = block * displacementSize;
           const blockEnd = Math.min(blockStart + displacementSize, isHorizontal ? height : width);

           for (let i = blockStart; i < blockEnd; i++) {
               if (isHorizontal) {
                   // Horizontal displacement
                   for (let x = 0; x < width; x++) {
                       const srcX = x + displacement;
                       if (srcX >= 0 && srcX < width) {
                           const srcIdx = (i * width + srcX) * 4;
                           const dstIdx = (i * width + x) * 4;
                           dst[dstIdx] = src[srcIdx];
                           dst[dstIdx + 1] = src[srcIdx + 1];
                           dst[dstIdx + 2] = src[srcIdx + 2];
                           dst[dstIdx + 3] = src[srcIdx + 3];
                       }
                   }
               } else {
                   // Vertical displacement
                   for (let y = 0; y < height; y++) {
                       const srcY = y + displacement;
                       if (srcY >= 0 && srcY < height) {
                           const srcIdx = (srcY * width + i) * 4;
                           const dstIdx = (y * width + i) * 4;
                           dst[dstIdx] = src[srcIdx];
                           dst[dstIdx + 1] = src[srcIdx + 1];
                           dst[dstIdx + 2] = src[srcIdx + 2];
                           dst[dstIdx + 3] = src[srcIdx + 3];
                       }
                   }
               }
           }
       }

       return outputImageData;
   }

   function applyPixelSortEffect(inputImageData, outputImageData, params) {
       const { width, height, data: src } = inputImageData;
       const dst = outputImageData.data;

       const { direction, blockSize, frequency } = params;
       const isHorizontal = direction === 'horizontal';

       // Simple random function with fixed seed for consistency
       let seed = 54321;
       const random = () => {
           seed = (seed * 9301 + 49297) % 233280;
           return seed / 233280;
       };

       // Copy original data first
       for (let i = 0; i < src.length; i++) {
           dst[i] = src[i];
       }

       if (isHorizontal) {
           // Process horizontal blocks
           for (let y = 0; y < height; y += blockSize) {
               for (let x = 0; x < width; x += blockSize) {
                   if (random() > frequency) continue;

                   const blockWidth = Math.min(blockSize, width - x);
                   const blockHeight = Math.min(blockSize, height - y);

                   // Extract pixels from block
                   const pixels = [];
                   for (let by = 0; by < blockHeight; by++) {
                       for (let bx = 0; bx < blockWidth; bx++) {
                           const idx = ((y + by) * width + (x + bx)) * 4;
                           pixels.push([dst[idx], dst[idx + 1], dst[idx + 2], dst[idx + 3]]);
                       }
                   }

                   // Shuffle pixels
                   for (let i = pixels.length - 1; i > 0; i--) {
                       const j = Math.floor(random() * (i + 1));
                       [pixels[i], pixels[j]] = [pixels[j], pixels[i]];
                   }

                   // Put pixels back
                   let pixelIndex = 0;
                   for (let by = 0; by < blockHeight; by++) {
                       for (let bx = 0; bx < blockWidth; bx++) {
                           const idx = ((y + by) * width + (x + bx)) * 4;
                           const pixel = pixels[pixelIndex++];
                           dst[idx] = pixel[0];
                           dst[idx + 1] = pixel[1];
                           dst[idx + 2] = pixel[2];
                           dst[idx + 3] = pixel[3];
                       }
                   }
               }
           }
       }

       return outputImageData;
   }

   // Predefined color palettes for palette reduction
   const predefinedPalettes = {
       gameboy: [[15, 56, 15], [48, 98, 48], [139, 172, 15], [155, 188, 15]],
       firewatch: [[255, 94, 77], [255, 160, 0], [72, 52, 212], [29, 29, 29]],
       desert: [[239, 214, 167], [201, 133, 61], [129, 80, 47], [60, 42, 33]],
       lavender: [[32, 32, 64], [96, 64, 128], [160, 128, 192], [240, 240, 255]],
       strangerThings: [[12, 12, 20], [220, 30, 30], [240, 240, 240], [30, 30, 60]],
       dawnbringer: [[20, 12, 28], [68, 36, 52], [48, 52, 109], [208, 70, 72], [210, 125, 44], [109, 194, 202], [218, 212, 94], [222, 238, 214]],
       blackwhite: [[0, 0, 0], [255, 255, 255]],
       grayscale4: [[0, 0, 0], [85, 85, 85], [170, 170, 170], [255, 255, 255]],
       bladeRunner: [[10, 10, 30], [200, 30, 60], [30, 150, 200], [250, 180, 80]],
       madMax: [[255, 213, 79], [244, 67, 54], [33, 33, 33], [158, 158, 158]],
       matrix: [[0, 0, 0], [0, 255, 70], [20, 20, 20], [100, 255, 180]],
       tronLegacy: [[0, 0, 0], [0, 240, 255], [255, 255, 255], [0, 60, 160]],
       drive: [[255, 0, 128], [255, 255, 255], [10, 10, 10], [80, 0, 120]],
       akira: [[255, 0, 0], [30, 30, 30], [255, 230, 200], [80, 80, 80]],
       vaporwave: [[255, 105, 180], [0, 255, 255], [255, 255, 255], [20, 20, 20]],
       miamiVice: [[255, 85, 170], [0, 204, 204], [255, 255, 255], [0, 0, 0]],
       lofi: [[144, 129, 112], [192, 159, 142], [236, 208, 185], [78, 61, 53]],
       nes: [[124, 124, 124], [0, 0, 252], [252, 0, 0], [0, 0, 0]],
       glitchCore: [[0, 255, 255], [255, 0, 255], [255, 255, 0], [0, 0, 0]],
       acid: [[255, 0, 255], [0, 255, 0], [0, 0, 255], [255, 255, 0]]
   };

   function getDistanceFunctionForPalette(mode) {
       switch (mode) {
           case "fast":
               return function(r, g, b, pr, pg, pb) {
                   return Math.abs(r - pr) + Math.abs(g - pg) + Math.abs(b - pb);
               };
           case "perceptual":
               return function(r, g, b, pr, pg, pb) {
                   let dr = r - pr;
                   let dg = g - pg;
                   let db = b - pb;
                   return 0.3 * dr * dr + 0.59 * dg * dg + 0.11 * db * db;
               };
           case "accurate":
           default:
               return function(r, g, b, pr, pg, pb) {
                   let dr = r - pr;
                   let dg = g - pg;
                   let db = b - pb;
                   return dr * dr + dg * dg + db * db;
               };
       }
   }

   function distributeErrorForDithering(data, width, height, x, y, errR, errG, errB) {
       const diffusion = [
           [1, 0, 7 / 16],
           [-1, 1, 3 / 16],
           [0, 1, 5 / 16],
           [1, 1, 1 / 16]
       ];

       for (const [dx, dy, factor] of diffusion) {
           const nx = x + dx;
           const ny = y + dy;

           if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
               const ni = (ny * width + nx) * 4;
               data[ni] = Math.max(0, Math.min(255, data[ni] + errR * factor));
               data[ni + 1] = Math.max(0, Math.min(255, data[ni + 1] + errG * factor));
               data[ni + 2] = Math.max(0, Math.min(255, data[ni + 2] + errB * factor));
           }
       }
   }

   function applyPaletteReductionEffect(inputImageData, outputImageData, params) {
       const paletteName = params.paletteName || "desert";
       const distanceMode = params.distanceMode || "accurate";
       const useDithering = params.useDithering;

       const palette = predefinedPalettes[paletteName] || predefinedPalettes.desert;
       const src = inputImageData.data;
       const dst = outputImageData.data;
       const width = inputImageData.width;
       const height = inputImageData.height;
       const len = src.length;
       const palLen = palette.length;

       const getDist = getDistanceFunctionForPalette(distanceMode);
       const cache = new Map();

       const palette32 = new Uint32Array(palLen);
       for (let j = 0; j < palLen; j++) {
           const [pr, pg, pb] = palette[j];
           palette32[j] = (pr << 24) | (pg << 16) | (pb << 8);
       }

       const temp = useDithering ? new Uint8ClampedArray(src) : src;

       for (let i = 0; i < len; i += 4) {
           const r = temp[i];
           const g = temp[i + 1];
           const b = temp[i + 2];
           const a = temp[i + 3];

           const key = (r << 16) | (g << 8) | b;

           let match = cache.get(key);
           if (match === undefined) {
               let minDist = Infinity;
               let nearest = 0;

               for (let j = 0; j < palLen; j++) {
                   const p = palette32[j];
                   const pr = (p >> 24) & 0xFF;
                   const pg = (p >> 16) & 0xFF;
                   const pb = (p >> 8) & 0xFF;

                   const dist = getDist(r, g, b, pr, pg, pb);
                   if (dist < minDist) {
                       minDist = dist;
                       nearest = p;
                       if (dist === 0) break;
                   }
               }

               match = nearest;
               cache.set(key, match);
           }

           const nr = (match >> 24) & 0xFF;
           const ng = (match >> 16) & 0xFF;
           const nb = (match >> 8) & 0xFF;

           dst[i] = nr;
           dst[i + 1] = ng;
           dst[i + 2] = nb;
           dst[i + 3] = a;

           if (useDithering) {
               const errR = r - nr;
               const errG = g - ng;
               const errB = b - nb;

               const x = (i >> 2) % width;
               const y = (i >> 2) / width | 0;

               distributeErrorForDithering(temp, width, height, x, y, errR, errG, errB);

               temp[i] = nr;
               temp[i + 1] = ng;
               temp[i + 2] = nb;
           }
       }
       return outputImageData;
   }



   function drawImageObject(obj, targetCtx) { // Added targetCtx
       if (!obj || obj.type !== 'image' || !obj.image) return;
       targetCtx.save(); // Use targetCtx
       targetCtx.translate(obj.x, obj.y); // Use targetCtx
       targetCtx.rotate(obj.rotation * Math.PI / 180); // Use targetCtx
       const scaledWidth = obj.originalWidth * obj.scale;
       const scaledHeight = obj.originalHeight * obj.scale;

       // Apply stroke/border if enabled (BEFORE drawing the main image)
       if (obj.strokeMode === 'standard') {
           const strokeWidth = obj.strokeWidth || 3;
           const strokeColor = obj.strokeColor || '#000000';

           // Apply independent stroke opacity (default 100% if not specified)
           const strokeOpacity = (obj.strokeOpacity !== undefined) ? obj.strokeOpacity / 100 : 1;
           targetCtx.save();
           targetCtx.globalAlpha = strokeOpacity;

           if (obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg')) {
               // Check if we need to regenerate the stroke cache
               const strokeCacheKey = `${obj.imageUrl}_${strokeWidth}_${strokeColor}_${scaledWidth}_${scaledHeight}`;

               if (!obj.strokeCache || obj.strokeCacheKey !== strokeCacheKey) {
                   // Use high-resolution rendering for ultra-sharp strokes
                   const hiResScale = 2; // 2x resolution for crisp rendering (more stable than 3x)
                   const padding = Math.max(strokeWidth * 8, 60); // 8x multiplier, 60px minimum

                   // Create high-resolution stroke canvas
                   const strokeCanvas = document.createElement('canvas');
                   strokeCanvas.width = (scaledWidth + padding * 2) * hiResScale;
                   strokeCanvas.height = (scaledHeight + padding * 2) * hiResScale;
                   const strokeCtx = strokeCanvas.getContext('2d');

                   // Clear the canvas to ensure no artifacts with high-DPI preservation
                   strokeCtx.save();
                   const strokeTransform = strokeCtx.getTransform();
                   const strokeScaleFactor = strokeTransform.a;
                   strokeCtx.setTransform(strokeScaleFactor, 0, 0, strokeScaleFactor, 0, 0);
                   strokeCtx.clearRect(0, 0, strokeCanvas.width / strokeScaleFactor, strokeCanvas.height / strokeScaleFactor);
                   strokeCtx.restore();

                   // Scale up the context for high-resolution rendering
                   strokeCtx.scale(hiResScale, hiResScale);

                   // Improve stroke sharpness with pixel-perfect rendering
                   strokeCtx.imageSmoothingEnabled = false;
                   strokeCtx.webkitImageSmoothingEnabled = false;
                   strokeCtx.mozImageSmoothingEnabled = false;
                   strokeCtx.msImageSmoothingEnabled = false;

                   // Center everything in the padded canvas (use original coordinates since context is scaled)
                   const centerX = Math.floor((scaledWidth + padding * 2) / 2);
                   const centerY = Math.floor((scaledHeight + padding * 2) / 2);

                   // KNOCKOUT STROKE RENDERING: Create true outline effect
                   // This creates a clean outline by cutting out the interior of the stroke

                   // Step 1: Create the stroke outline by drawing the shape multiple times in stroke color
                   const directions = [];
                   const steps = Math.max(8, Math.ceil(strokeWidth / 2));
                   for (let i = 0; i < steps; i++) {
                       const angle = (i / steps) * Math.PI * 2;
                       const dx = Math.cos(angle) * strokeWidth;
                       const dy = Math.sin(angle) * strokeWidth;
                       directions.push([dx, dy]);
                   }

                   // Create high-resolution colored version of the image for stroke
                   const colorPadding = Math.max(strokeWidth * 8, 80);
                   const colorCanvas = document.createElement('canvas');
                   colorCanvas.width = (scaledWidth + colorPadding) * hiResScale;
                   colorCanvas.height = (scaledHeight + colorPadding) * hiResScale;
                   const colorCtx = colorCanvas.getContext('2d');

                   // Clear with high-DPI preservation
                   colorCtx.save();
                   const colorTransform = colorCtx.getTransform();
                   const colorScaleFactor = colorTransform.a;
                   colorCtx.setTransform(colorScaleFactor, 0, 0, colorScaleFactor, 0, 0);
                   colorCtx.clearRect(0, 0, colorCanvas.width / colorScaleFactor, colorCanvas.height / colorScaleFactor);
                   colorCtx.restore();

                   // Scale up the color context
                   colorCtx.scale(hiResScale, hiResScale);
                   colorCtx.imageSmoothingEnabled = false;
                   colorCtx.webkitImageSmoothingEnabled = false;
                   colorCtx.mozImageSmoothingEnabled = false;
                   colorCtx.msImageSmoothingEnabled = false;

                   const colorImagePadding = Math.max(strokeWidth * 4, 40);
                   colorCtx.drawImage(obj.image, Math.floor(colorImagePadding), Math.floor(colorImagePadding), scaledWidth, scaledHeight);
                   colorCtx.globalCompositeOperation = 'source-in';
                   colorCtx.fillStyle = strokeColor;
                   colorCtx.fillRect(0, 0, colorCanvas.width, colorCanvas.height);

                   // Step 2: Draw stroke outline in all directions
                   for (const [dx, dy] of directions) {
                       strokeCtx.drawImage(colorCanvas,
                           Math.floor(centerX - (scaledWidth + colorPadding) / 2 + dx),
                           Math.floor(centerY - (scaledHeight + colorPadding) / 2 + dy),
                           scaledWidth + colorPadding,
                           scaledHeight + colorPadding);
                   }

                   // Step 3: KNOCKOUT - Cut out the interior using destination-out compositing
                   strokeCtx.globalCompositeOperation = 'destination-out';
                   strokeCtx.drawImage(obj.image,
                       Math.floor(centerX - scaledWidth / 2),
                       Math.floor(centerY - scaledHeight / 2),
                       scaledWidth, scaledHeight);

                   // Reset compositing operation
                   strokeCtx.globalCompositeOperation = 'source-over';

                   // Cache the result
                   obj.strokeCache = strokeCanvas;
                   obj.strokeCacheKey = strokeCacheKey;
               }

               // Draw the cached stroke (knockout outline) with high-resolution scaling
               targetCtx.save();
               targetCtx.shadowColor = 'transparent';
               targetCtx.shadowBlur = 0;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;

               // Enable high-quality scaling for the final render
               targetCtx.imageSmoothingEnabled = true;
               targetCtx.imageSmoothingQuality = 'high';

               // Calculate padding for final drawing (same as cache generation)
               const finalPadding = Math.max(strokeWidth * 8, 60);
               const finalWidth = (scaledWidth + finalPadding * 2);
               const finalHeight = (scaledHeight + finalPadding * 2);

               // Draw the knockout stroke outline
               targetCtx.drawImage(obj.strokeCache,
                   -finalWidth / 2,
                   -finalHeight / 2,
                   finalWidth,
                   finalHeight);
               targetCtx.restore();
           } else {
               // For regular images (JPG, PNG), use simple rectangle stroke
               targetCtx.strokeStyle = strokeColor;
               targetCtx.lineWidth = strokeWidth;
               targetCtx.shadowColor = 'transparent';
               targetCtx.shadowBlur = 0;
               targetCtx.shadowOffsetX = 0;
               targetCtx.shadowOffsetY = 0;
               targetCtx.strokeRect(-scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
           }

           // Restore stroke opacity context
           targetCtx.restore();
       }

       // Apply image opacity (separate from stroke opacity)
       const imageOpacity = (obj.opacity !== undefined) ? obj.opacity / 100 : 1;
       targetCtx.globalAlpha = imageOpacity;

       // Store original image if not already stored
       if (!obj.originalImage && obj.image) {
           obj.originalImage = obj.image;
           console.log('🎨 [Canvas] Stored original image for future filter operations');
       }

       // Apply CSS filters if they exist
       if (obj.cssFilterString && obj.cssFilterString !== 'none') {
           console.log('🎨 [Canvas] Applying CSS filter to image:', obj.cssFilterString);

           // Check if we have a cached filtered image
           const cacheKey = `${obj.id}_${obj.cssFilterString}`;
           if (obj.filteredImageCache && obj.filteredImageCache[cacheKey]) {
               console.log('🎨 [Canvas] Using cached filtered image');
               obj.image = obj.filteredImageCache[cacheKey];
           } else {
               // Create filtered image using ORIGINAL image (not current filtered version)
               console.log('🎨 [Canvas] Creating filtered image from original');
               const sourceImage = obj.originalImage || obj.image;
               const filteredImage = createFilteredImageSync(sourceImage, obj.cssFilterString);
               if (filteredImage) {
                   // Cache the filtered image
                   if (!obj.filteredImageCache) obj.filteredImageCache = {};
                   obj.filteredImageCache[cacheKey] = filteredImage;
                   obj.image = filteredImage;
                   console.log('🎨 [Canvas] Filtered image created and cached from original');
               }
           }
       } else {
           // No filters applied, use original image
           if (obj.originalImage) {
               obj.image = obj.originalImage;
               console.log('🎨 [Canvas] Using original image (no filters)');
           }
       }

       // Apply duotone effect if enabled
       if (obj.duotoneEnabled && obj.duotoneMatrix) {
           console.log('🎨 [Canvas] Applying duotone effect to image');

           // Check if we have a cached duotone image
           const duotoneCacheKey = `${obj.id}_duotone_${obj.duotoneMatrix}`;
           if (obj.duotoneImageCache && obj.duotoneImageCache[duotoneCacheKey]) {
               console.log('🎨 [Canvas] Using cached duotone image');
               obj.image = obj.duotoneImageCache[duotoneCacheKey];
           } else {
               // Create duotone image using the current image (after CSS filters if applied)
               console.log('🎨 [Canvas] Creating duotone image');
               const sourceImage = obj.image;
               const duotoneImage = createDuotoneImageSync(sourceImage, obj.duotoneMatrix);
               if (duotoneImage) {
                   // Cache the duotone image
                   if (!obj.duotoneImageCache) obj.duotoneImageCache = {};
                   obj.duotoneImageCache[duotoneCacheKey] = duotoneImage;
                   obj.image = duotoneImage;
                   console.log('🎨 [Canvas] Duotone image created and cached');
               }
           }
       }

       // Apply glitch effects if enabled
       if (obj.glinchEnabled && obj.glinchEffects) {
           console.log('🎨 [Canvas] Applying glitch effects to image');

           // Create a cache key based on all glitch effects
           const glinchCacheKey = `${obj.id}_glinch_${JSON.stringify(obj.glinchEffects)}`;
           if (obj.glinchImageCache && obj.glinchImageCache[glinchCacheKey]) {
               console.log('🎨 [Canvas] Using cached glitch image');
               obj.image = obj.glinchImageCache[glinchCacheKey];
           } else {
               // Create glitch image using the current image (after CSS filters and duotone if applied)
               console.log('🎨 [Canvas] Creating glitch image');
               const sourceImage = obj.image;
               const glinchImage = createGlinchImageSync(sourceImage, obj.glinchEffects);
               if (glinchImage) {
                   // Cache the glitch image
                   if (!obj.glinchImageCache) obj.glinchImageCache = {};
                   obj.glinchImageCache[glinchCacheKey] = glinchImage;
                   obj.image = glinchImage;
                   console.log('🎨 [Canvas] Glitch image created and cached');
               }
           }
       }

       // Apply halftone effect if enabled
       if (obj.halftoneEnabled && obj.halftoneSettings) {
           console.log('🎨 [Canvas] Applying halftone effect to image');

           // Create a cache key based on all halftone settings
           const halftoneCacheKey = `${obj.id}_halftone_${JSON.stringify(obj.halftoneSettings)}`;
           if (obj.halftoneImageCache && obj.halftoneImageCache[halftoneCacheKey]) {
               console.log('🎨 [Canvas] Using cached halftone image');
               obj.image = obj.halftoneImageCache[halftoneCacheKey];
           } else {
               // Create halftone image using the current image (after CSS filters, duotone, and glitch if applied)
               console.log('🎨 [Canvas] Creating halftone image');
               const sourceImage = obj.image;
               const halftoneImage = createHalftoneImageSync(sourceImage, obj.halftoneSettings);
               if (halftoneImage) {
                   // Cache the halftone image
                   if (!obj.halftoneImageCache) obj.halftoneImageCache = {};
                   obj.halftoneImageCache[halftoneCacheKey] = halftoneImage;
                   obj.image = halftoneImage;
                   console.log('🎨 [Canvas] Halftone image created and cached');
               }
           }
       }

       // Apply shadow if enabled
       if (obj.shadowMode === 'standard') {
           const shadowOpacity = (obj.shadowOpacity !== undefined) ? obj.shadowOpacity / 100 : 1;
           // Convert hex color to rgba with opacity
           const shadowColor = hexToRgba(obj.shadowColor || '#000000', shadowOpacity);
           targetCtx.shadowColor = shadowColor;
           targetCtx.shadowOffsetX = obj.shadowOffsetX || 5;
           targetCtx.shadowOffsetY = obj.shadowOffsetY || 5;
           targetCtx.shadowBlur = obj.shadowBlur || 10;
       }

       // Check if this is an SVG with gradient
       if (obj.fillType === 'gradient' && obj.gradient && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg')) {
           console.log('🎨 Drawing SVG with gradient:', obj.gradient);

           // Create bounds for gradient
           const bounds = {
               x: -scaledWidth / 2,
               y: -scaledHeight / 2,
               width: scaledWidth,
               height: scaledHeight
           };

           // Create an offscreen canvas for the gradient effect
           const offscreenCanvas = document.createElement('canvas');
           offscreenCanvas.width = scaledWidth;
           offscreenCanvas.height = scaledHeight;
           const offscreenCtx = offscreenCanvas.getContext('2d');

           // Draw the gradient on the offscreen canvas
           const gradientBounds = {
               x: 0,
               y: 0,
               width: scaledWidth,
               height: scaledHeight
           };
           applySVGGradientFill(offscreenCtx, obj, gradientBounds);
           offscreenCtx.fillRect(0, 0, scaledWidth, scaledHeight);

           // Draw the original SVG as a mask
           offscreenCtx.globalCompositeOperation = 'destination-in';
           try {
               offscreenCtx.drawImage(obj.image, 0, 0, scaledWidth, scaledHeight);
           } catch (e) {
               console.error("Error drawing SVG mask:", e);
           }

           // Draw the final result to the main canvas
           try {
               targetCtx.drawImage(offscreenCanvas, bounds.x, bounds.y);
           } catch (e) {
               console.error("Error drawing gradient SVG:", e);
               // Fallback to normal image
               targetCtx.drawImage(obj.image, bounds.x, bounds.y, scaledWidth, scaledHeight);
           }
       } else {
           // Check if image is masked
           if (obj.isMasked && obj.maskShape && obj.maskShape.image) {
               console.log('[Masking] 🎭 Drawing masked image:', {
                   imageId: obj.id,
                   maskId: obj.maskShape.id,
                   imagePos: { x: obj.x, y: obj.y },
                   maskPos: { x: obj.maskShape.x, y: obj.maskShape.y }
               });

               try {
                   // Create an offscreen canvas for the masking effect
                   const maskCanvas = document.createElement('canvas');
                   const maskScaledWidth = obj.maskShape.originalWidth * obj.maskShape.scale;
                   const maskScaledHeight = obj.maskShape.originalHeight * obj.maskShape.scale;

                   // Make the mask canvas large enough to contain both image and mask
                   const canvasWidth = Math.max(scaledWidth, maskScaledWidth) + 100;
                   const canvasHeight = Math.max(scaledHeight, maskScaledHeight) + 100;
                   maskCanvas.width = canvasWidth;
                   maskCanvas.height = canvasHeight;
                   const maskCtx = maskCanvas.getContext('2d');

                   // Calculate positions relative to mask canvas center
                   const centerX = canvasWidth / 2;
                   const centerY = canvasHeight / 2;

                   // Calculate relative positions
                   const maskRelativeX = obj.maskShape.x - obj.x;
                   const maskRelativeY = obj.maskShape.y - obj.y;

                   console.log('[Masking] 🎭 Mask canvas setup:', {
                       canvasSize: { width: canvasWidth, height: canvasHeight },
                       centerPos: { x: centerX, y: centerY },
                       maskRelative: { x: maskRelativeX, y: maskRelativeY }
                   });

                   // Step 1: Draw the mask shape as a clipping mask
                   maskCtx.save();
                   maskCtx.translate(centerX + maskRelativeX, centerY + maskRelativeY);
                   maskCtx.rotate(obj.maskShape.rotation * Math.PI / 180);
                   maskCtx.drawImage(obj.maskShape.image, -maskScaledWidth / 2, -maskScaledHeight / 2, maskScaledWidth, maskScaledHeight);
                   maskCtx.restore();

                   // Step 2: Use the mask as a clipping path for the image
                   maskCtx.globalCompositeOperation = 'source-in';
                   maskCtx.save();
                   maskCtx.translate(centerX, centerY);
                   maskCtx.rotate(obj.rotation * Math.PI / 180);
                   maskCtx.drawImage(obj.image, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
                   maskCtx.restore();

                   // Step 3: Draw the final masked result to the main canvas
                   targetCtx.save();
                   targetCtx.translate(-maskRelativeX, -maskRelativeY);
                   targetCtx.drawImage(maskCanvas, -canvasWidth / 2, -canvasHeight / 2);
                   targetCtx.restore();

                   console.log('[Masking] 🎭 Masked image drawn successfully');

               } catch (e) {
                   console.error("[Masking] 🎭 Error drawing masked image:", e, obj);
                   // Fallback to normal drawing
                   targetCtx.drawImage(obj.image, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
               }
           } else {
               // Normal image drawing
               try {
                   targetCtx.drawImage( obj.image, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight ); // Use targetCtx
               } catch (e) {
                   console.error("Error drawing image:", e, obj);
                   targetCtx.fillStyle = 'red'; // Use targetCtx
                   targetCtx.fillRect(-scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight); // Use targetCtx
                   targetCtx.fillStyle = 'white'; // Use targetCtx
                   targetCtx.fillText('ERR', 0, 0); // Use targetCtx
               }
           }
       }



       targetCtx.restore(); // Use targetCtx
   }
   function drawSelectionBox(obj, isMultiSelect = false) {
       if (!obj || !obj.isSelected) return;
       const bounds = calculateObjectBounds(obj);

       // 📦 SELECTION BOX DEBUG: Log bounds for text objects
       if (obj.type === 'text') {
           console.log('📦 SELECTION BOX: Drawing selection for text object:', {
               text: obj.text.substring(0, 50) + '...',
               textBoxWidth: obj.textBoxWidth,
               bounds: bounds,
               isWrapped: (obj.textBoxWidth || 0) > 0
           });
       }

       if (bounds.width === 0 || bounds.height === 0) return;
       const rotatedBounds = getRotatedBoundingBox(bounds, obj.rotation);
       const effectivePadding = selectionBoxPadding / scale;
       const effectiveLineWidth = 1 / scale;
       const paddedX = rotatedBounds.x - effectivePadding;
       const paddedY = rotatedBounds.y - effectivePadding;
       const paddedWidth = rotatedBounds.width + effectivePadding * 2;
       const paddedHeight = rotatedBounds.height + effectivePadding * 2;
       ctx.save();

       if (isMultiSelect) {
           // Multi-select styling: brighter blue with thicker line
           ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
           ctx.lineWidth = effectiveLineWidth * 2;
           ctx.setLineDash([8 / scale, 4 / scale]);
       } else {
           // Single select styling: standard blue dashed line
           ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
           ctx.lineWidth = effectiveLineWidth;
           ctx.setLineDash([4 / scale, 4 / scale]);
       }

       ctx.strokeRect(paddedX, paddedY, paddedWidth, paddedHeight);
       ctx.restore();
   }

   // Function to draw object state indicators (lock/hide icons)
   function drawObjectStateIndicators() {
       // Create a fixed panel on the top-left corner of the canvas for state indicators
       const panelX = 10 / scale;
       const panelY = 10 / scale;
       const indicatorSize = 24 / scale;
       const spacing = 30 / scale;

       let currentY = panelY;
       let indicatorCount = 0;

       // Draw indicators for canvas objects (locked or hidden)
       canvasObjects.forEach((obj, index) => {
           // Only show indicators for locked or hidden objects
           if (!obj.isLocked && !obj.isHidden) return;

           const indicatorX = panelX;
           const indicatorY = currentY;

           ctx.save();

           // Draw indicator background with better visibility
           ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
           ctx.strokeStyle = obj.isLocked ? '#f59e0b' : '#ef4444';
           ctx.lineWidth = 3 / scale;
           ctx.beginPath();
           ctx.arc(indicatorX, indicatorY, indicatorSize / 2, 0, Math.PI * 2);
           ctx.fill();
           ctx.stroke();

           // Add a subtle shadow for better visibility
           ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
           ctx.shadowBlur = 4 / scale;
           ctx.shadowOffsetX = 2 / scale;
           ctx.shadowOffsetY = 2 / scale;

           // Draw icon with better contrast
           ctx.fillStyle = obj.isLocked ? '#92400e' : '#dc2626';
           ctx.font = `bold ${12 / scale}px Arial`;
           ctx.textAlign = 'center';
           ctx.textBaseline = 'middle';

           if (obj.isLocked) {
               ctx.fillText('🔒', indicatorX, indicatorY);
           } else if (obj.isHidden) {
               ctx.fillText('👁️', indicatorX, indicatorY);
           }

           // Add object type/name label next to the icon
           ctx.shadowColor = 'transparent'; // Remove shadow for text
           ctx.fillStyle = '#374151';
           ctx.font = `${10 / scale}px Arial`;
           ctx.textAlign = 'left';

           // Use custom name if available, otherwise use default naming
           let labelText;
           if (obj.customName) {
               labelText = obj.customName.length > 12 ? obj.customName.substring(0, 12) + '...' : obj.customName;
           } else if (obj.type === 'text') {
               labelText = obj.text?.substring(0, 10) + '...';
           } else {
               labelText = obj.type;
           }

           ctx.fillText(labelText, indicatorX + indicatorSize, indicatorY);

           ctx.restore();

           // Store indicator position for click detection
           obj._stateIndicator = {
               x: indicatorX,
               y: indicatorY,
               size: indicatorSize,
               index: index,
               labelX: indicatorX + indicatorSize,
               labelY: indicatorY,
               labelWidth: 80 / scale,
               labelHeight: indicatorSize
           };

           currentY += spacing;
           indicatorCount++;
       });

       // Draw indicators for hidden layout rectangles
       if (layoutRectangles && Array.isArray(layoutRectangles)) {
           layoutRectangles.forEach((layout, index) => {
               // Only show indicators for hidden layouts
               if (!layout.isHidden) return;

               const indicatorX = panelX;
               const indicatorY = currentY;

               ctx.save();

               // Draw indicator background with layout-specific styling
               ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
               ctx.strokeStyle = '#8b5cf6'; // Purple for layouts
               ctx.lineWidth = 3 / scale;
               ctx.beginPath();
               ctx.arc(indicatorX, indicatorY, indicatorSize / 2, 0, Math.PI * 2);
               ctx.fill();
               ctx.stroke();

               // Add a subtle shadow for better visibility
               ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
               ctx.shadowBlur = 4 / scale;
               ctx.shadowOffsetX = 2 / scale;
               ctx.shadowOffsetY = 2 / scale;

               // Draw layout icon
               ctx.fillStyle = '#7c3aed';
               ctx.font = `bold ${12 / scale}px Arial`;
               ctx.textAlign = 'center';
               ctx.textBaseline = 'middle';
               ctx.fillText('📐', indicatorX, indicatorY);

               // Add layout name label next to the icon
               ctx.shadowColor = 'transparent'; // Remove shadow for text
               ctx.fillStyle = '#374151';
               ctx.font = `${10 / scale}px Arial`;
               ctx.textAlign = 'left';

               // Use custom name if available, otherwise use default naming
               let labelText = layout.customName || `Layout ${index + 1}`;
               if (labelText.length > 12) {
                   labelText = labelText.substring(0, 12) + '...';
               }

               ctx.fillText(labelText, indicatorX + indicatorSize, indicatorY);

               ctx.restore();

               // Store indicator position for click detection
               layout._stateIndicator = {
                   x: indicatorX,
                   y: indicatorY,
                   size: indicatorSize,
                   index: index,
                   labelX: indicatorX + indicatorSize,
                   labelY: indicatorY,
                   labelWidth: 80 / scale,
                   labelHeight: indicatorSize,
                   isLayout: true // Flag to identify layout indicators
               };

               currentY += spacing;
               indicatorCount++;
           });
       }

       // Draw panel background if there are indicators
       if (indicatorCount > 0) {
           ctx.save();
           ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
           ctx.fillRect(
               panelX - 5 / scale,
               panelY - indicatorSize / 2 - 5 / scale,
               120 / scale,
               indicatorCount * spacing + 10 / scale
           );
           ctx.restore();
       }
   }

   // Function to draw template ID badges
   function drawTemplateIdBadges() {
       canvasObjects.forEach(obj => {
           if (obj.templateId) {
               const bounds = calculateObjectBounds(obj);
               if (bounds.width === 0 || bounds.height === 0) return;

               const badgeSize = 20 / scale;
               const badgeX = bounds.x + bounds.width - badgeSize / 2;
               const badgeY = bounds.y - badgeSize / 2;

               ctx.save();

               // Draw badge background
               ctx.fillStyle = '#e74c3c';
               ctx.strokeStyle = '#ffffff';
               ctx.lineWidth = 2 / scale;
               ctx.beginPath();
               ctx.arc(badgeX, badgeY, badgeSize / 2, 0, Math.PI * 2);
               ctx.fill();
               ctx.stroke();

               // Draw ID text
               ctx.fillStyle = '#ffffff';
               ctx.font = `bold ${8 / scale}px Arial`;
               ctx.textAlign = 'center';
               ctx.textBaseline = 'middle';
               ctx.fillText(obj.templateId, badgeX, badgeY);

               ctx.restore();
           }
       });
   }

   // --- Main Update/Render Function ---
   async function update() {
       console.log('🎨 ===== UPDATE FUNCTION CALLED =====');
       // 🔄 SYNC: Sync local variables from global references (in case external code modified them)
       syncFromGlobalReferences();

       const renderStartTime = performance.now();

       // CRITICAL FIX: Create decoration state management to prevent multiple decorations
       const currentFrameId = Math.random().toString(36).substring(2, 8);
       // Removed frame start logging for performance - was logging on every frame

       // Initialize global decoration state tracker
       window._decorationState = window._decorationState || {
           currentDecorations: new Map(), // objectId -> decorationHash
           lastRenderTime: 0
       };

       // Track current render time
       window._decorationState.lastRenderTime = Date.now();

       canvasObjects.forEach(obj => {
           if (obj.type === 'text') {
               // Removed text frame logging for performance - was logging on every frame
           }
       });

       // Performance optimization: throttle rendering during movement
       if (PERFORMANCE_MODE && isDuringMovement) {
           const currentTime = performance.now();
           if (currentTime - lastRenderTime < 16) { // Limit to ~60fps during movement
               return;
           }
           lastRenderTime = currentTime;
       }

       renderCount++;
       if (DEBUG_MODE && renderCount % 100 === 0) {
           debugLog(`Render count: ${renderCount}`);
       }

       // Log canvas state at start of update (only every 60 frames to avoid spam)
       if (renderCount % 60 === 0) {
           console.log(`🎨 [UPDATE] Frame ${renderCount} - Canvas: ${canvas.width}x${canvas.height}, Style: ${canvas.style.width}x${canvas.style.height}`);
           console.log(`🎨 [UPDATE] Canvas scaleFactor: ${canvas.scaleFactor}`);
           console.log(`🎨 [UPDATE] Current transform before save:`, ctx.getTransform());
       }

       ctx.save();
       // Preserve high-DPI scaling when clearing canvas
       const canvasScaleFactor = canvas.scaleFactor || 1;
       ctx.setTransform(canvasScaleFactor, 0, 0, canvasScaleFactor, 0, 0);
       // Clear with background color first
       ctx.fillStyle = canvasBackgroundColor;
       ctx.fillRect(0, 0, canvas.width / canvasScaleFactor, canvas.height / canvasScaleFactor);
       // ctx.clearRect(0, 0, canvas.width / canvasScaleFactor, canvas.height / canvasScaleFactor); // Original clear removed
       ctx.restore();

       if (renderCount % 60 === 0) {
           console.log(`🎨 [UPDATE] Restored transform after clearing:`, ctx.getTransform());
       }

       ctx.save();
       ctx.translate(offsetX, offsetY);
       ctx.scale(scale, scale);

       // Draw Artboard if exists (on main canvas only)
       if (artboard && !artboard.isSelected && ctx === canvas.getContext('2d')) { // Check if drawing on main canvas
           ctx.save();
           ctx.strokeStyle = '#bdbdbd';
           ctx.lineWidth = 2 / scale;
           ctx.setLineDash([6 / scale, 4 / scale]);
           ctx.strokeRect(artboard.x, artboard.y, artboard.width, artboard.height);

           ctx.setLineDash([]);
           ctx.font = `${16 / scale}px sans-serif`;
           ctx.fillStyle = '#bdbdbd';
           ctx.fillText('Artboard', artboard.x + 5 / scale, artboard.y + 20 / scale);
           ctx.restore();
       }

       // Draw all objects - Pass the main context 'ctx' (with async support for unified pipeline)
       for (const obj of canvasObjects) {
           // Skip hidden objects
           if (obj.isHidden) {
               continue;
           }

           // Skip drawing mask shapes that are being used as masks (they should be invisible)
           if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
               console.log('[Masking] 🎭 Skipping drawing of mask shape:', obj.id);
               continue; // Skip this object
           }

           if (obj.type === 'text') {
               drawTextObject(obj, ctx); // Pass ctx (synchronous)
           } else if (obj.type === 'image') {
               await drawImageObject(obj, ctx); // Pass ctx (async for unified pipeline)
           } else if (obj.type === 'rectangle') {
               drawRectangleObject(obj, ctx); // Draw rectangle objects
           }
       }

       // Draw guidelines (on main canvas only) - they use the same transform as canvas objects
       if (ctx === canvas.getContext('2d') && areGuidelinesVisible) { // Check if drawing on main canvas and guidelines are visible
           drawGuidelines(ctx);
       }

       // Draw SVG component bounds (on main canvas only)
       if (ctx === canvas.getContext('2d') && svgComponentsVisible && svgComponents.length > 0) {
           drawSVGComponentBounds(ctx);
       }

       // Draw selection boxes (on main canvas only)
       if (ctx === canvas.getContext('2d')) { // Check if drawing on main canvas
           if (isMultiSelectMode) {
               // Draw selection boxes for all selected objects
               selectedObjectIndices.forEach(index => {
                   if (canvasObjects[index]) {
                       drawSelectionBox(canvasObjects[index], true); // true for multi-select style
                   }
               });
           } else if (selectedObjectIndex !== -1) {
               // Draw single selection box
               drawSelectionBox(canvasObjects[selectedObjectIndex], false);
           }

           // Draw object state indicators (lock/hide icons)
           drawObjectStateIndicators();
       }

       // Draw template ID badges (on main canvas only)
       if (ctx === canvas.getContext('2d')) { // Check if drawing on main canvas
           drawTemplateIdBadges();
       }

       // Draw Artboard on top if selected (on main canvas only)
       if (artboard && artboard.isSelected && ctx === canvas.getContext('2d')) { // Check if drawing on main canvas
           ctx.save();

           // Use different styling based on edit mode
           if (isArtboardEditMode) {
               // More prominent styling in edit mode
               ctx.strokeStyle = '#4ade80'; // Green color to match confirm button
               ctx.lineWidth = 3 / scale;
               ctx.setLineDash([8 / scale, 4 / scale]);
           } else {
               // Normal styling when not in edit mode
               ctx.strokeStyle = '#bdbdbd';
               ctx.lineWidth = 2 / scale;
               ctx.setLineDash([6 / scale, 4 / scale]);
           }

           ctx.strokeRect(artboard.x, artboard.y, artboard.width, artboard.height);

           ctx.setLineDash([]);
           ctx.font = `${16 / scale}px sans-serif`;
           ctx.fillStyle = isArtboardEditMode ? '#4ade80' : '#bdbdbd';
           ctx.fillText('Artboard', artboard.x + 5 / scale, artboard.y + 20 / scale);

           // Only draw resize handles when in artboard edit mode
           if (isArtboardEditMode) {
               // Draw resize handles
               const size = 8 / scale;
               const half = size / 2;
               const corners = [
                   [artboard.x, artboard.y],
                   [artboard.x + artboard.width, artboard.y],
                   [artboard.x, artboard.y + artboard.height],
                   [artboard.x + artboard.width, artboard.y + artboard.height]
               ];
               ctx.fillStyle = '#4ade80'; // Green color for handles
               for (const [x, y] of corners) {
                   ctx.fillRect(x - half, y - half, size, size);
               }
           }
           ctx.restore();
       }

       // Draw Layout Rectangles (on main canvas only) - Always visible if they exist and not hidden
       if (ctx === canvas.getContext('2d') && layoutRectangles.length > 0) {
           // Draw existing layout rectangles (skip hidden ones)
           layoutRectangles.forEach((rect, index) => {
               // Skip hidden layout rectangles
               if (rect.isHidden) {
                   return;
               }

               ctx.save();

               // Use green for unselected rectangles, grey for selected
               if (index === selectedLayoutRectIndex) {
                   ctx.strokeStyle = '#6b7280'; // Grey for selected
                   ctx.fillStyle = 'rgba(107, 114, 128, 0.2)'; // Light grey fill (more visible)
               } else {
                   ctx.strokeStyle = '#22c55e'; // Green for unselected
                   ctx.fillStyle = 'rgba(34, 197, 94, 0.1)'; // Light green fill
               }

               ctx.lineWidth = 2 / scale;
               ctx.setLineDash([8 / scale, 4 / scale]);

               // Draw rectangle with fill and stroke
               ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
               ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

               // Draw label
               ctx.setLineDash([]);
               ctx.font = `${14 / scale}px sans-serif`;
               ctx.fillStyle = index === selectedLayoutRectIndex ? '#6b7280' : '#22c55e';
               const label = index === selectedLayoutRectIndex ? 'Layout (Selected)' : 'Layout';
               ctx.fillText(label, rect.x + 5 / scale, rect.y + 18 / scale);

               // Draw resize control points for selected rectangle
               if (index === selectedLayoutRectIndex) {
                   const handleSize = 8 / scale;
                   const handleColor = '#6b7280';

                   ctx.fillStyle = handleColor;
                   ctx.strokeStyle = 'white';
                   ctx.lineWidth = 1 / scale;
                   ctx.setLineDash([]);

                   // Corner handles
                   const handles = [
                       { x: rect.x, y: rect.y, cursor: 'nw-resize', id: 'tl' }, // Top-left
                       { x: rect.x + rect.width, y: rect.y, cursor: 'ne-resize', id: 'tr' }, // Top-right
                       { x: rect.x, y: rect.y + rect.height, cursor: 'sw-resize', id: 'bl' }, // Bottom-left
                       { x: rect.x + rect.width, y: rect.y + rect.height, cursor: 'se-resize', id: 'br' } // Bottom-right
                   ];

                   handles.forEach(handle => {
                       ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                       ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                   });
               }

               ctx.restore();
           });

           // Draw currently drawing rectangle (only when Layout Tool is active)
           if (isLayoutToolActive && isDrawingLayoutRect && window.currentDrawingLayoutRect) {
               const rect = window.currentDrawingLayoutRect;
               ctx.save();
               ctx.strokeStyle = '#22c55e'; // Green
               ctx.fillStyle = 'rgba(34, 197, 94, 0.1)'; // Light green fill
               ctx.lineWidth = 2 / scale;
               ctx.setLineDash([8 / scale, 4 / scale]);

               ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
               ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

               ctx.restore();
           }
       }

       // No need to redraw objects here again

       // Draw selection boxes again if needed (on main canvas only)
       if (ctx === canvas.getContext('2d')) { // Check if drawing on main canvas
           if (isMultiSelectMode) {
               // Draw selection boxes for all selected objects
               selectedObjectIndices.forEach(index => {
                   if (canvasObjects[index]) {
                       drawSelectionBox(canvasObjects[index], true); // true for multi-select style
                   }
               });
           } else if (selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length && canvasObjects[selectedObjectIndex]) {
               // Draw single selection box
               drawSelectionBox(canvasObjects[selectedObjectIndex], false);

               // Draw mesh grid if needed and if the function exists
               if (canvasObjects[selectedObjectIndex].type === 'text' &&
                   canvasObjects[selectedObjectIndex].effectMode === 'mesh') {

                   const selectedObj = canvasObjects[selectedObjectIndex];

                   // Check for object's own mesh handler first, then active handler
                   if (selectedObj._meshWarpHandler) {
                       // Use the object's own mesh handler
                       selectedObj._meshWarpHandler.drawMeshGrid(ctx);
                   } else if (typeof activeMeshWarpHandler !== 'undefined' &&
                       activeMeshWarpHandler &&
                       activeMeshWarpHandler.selectedTextObject === selectedObj) {
                       // Use the active handler as fallback
                       activeMeshWarpHandler.drawMeshGrid(ctx);
                   } else {
                       console.warn("Mesh effect selected, but no handler found for object:", selectedObj.id);
                   }
               }
           }
       }

       ctx.restore();
       updateZoomDisplay();

       // Performance monitoring
       const renderEndTime = performance.now();
       const renderTime = renderEndTime - renderStartTime;
       updatePerformanceStats(renderTime);

       if (PERFORMANCE_MODE && isDuringMovement) {
           const currentTime = performance.now();
           if (currentTime - movementStartTime > 1000) { // Log if movement takes more than 1 second
               debugLog(`Long movement detected: ${(currentTime - movementStartTime).toFixed(2)}ms`);
           }
       }

       // Log slow renders
       if (DEBUG_MODE && renderTime > 50) { // Log renders taking more than 50ms
           debugLog(`Slow render detected: ${renderTime.toFixed(2)}ms`);
       }
   }
   function updateZoomDisplay() { zoomLevelSpan.textContent = `${Math.round(scale * 100)}%`; }

   // --- Event Handlers & Listeners ---
   function handleAddTextObject() {
    console.log('🆕 HANDLE ADD TEXT OBJECT: Called');
    const text = iText.value.trim();
    console.log('🆕 HANDLE ADD TEXT OBJECT: text =', text);

    if (!text) {
        alert("Please enter text before adding.");
        return;
    }

    const viewCenterX = canvas.clientWidth / 2;
    const viewCenterY = canvas.clientHeight / 2;
    const worldCenter = canvasToWorld(viewCenterX, viewCenterY);

    // Create new text object with default settings
    const newObjOptions = {
        text: text,
        x: worldCenter.x + (Math.random() * 40 - 20) / scale,
        y: worldCenter.y + (Math.random() * 40 - 20) / scale,
        color: iTextColor.value,
        fontFamily: iFontFamily.value,
        fontSize: parseInt(iFontSize.value, 10),
        bold: iBold.checked,
        italic: iItalic.checked,
        rotation: parseInt(iTextRotation.value, 10),
        // Always set effectMode to 'normal' for new text objects
        effectMode: 'normal',
        // Keep other properties from UI for convenience
        skewX: parseInt(skewSlider.value, 10),
        skewY: parseInt(skewYSlider.value, 10),
        warpCurve: parseInt(iCurve.value, 10),
        warpOffset: parseInt(iOffset.value, 10),
        warpHeight: parseInt(iHeight.value, 10),
        warpBottom: parseInt(iBottom.value, 10),
        warpTriangle: iTriangle.checked,
        warpShiftCenter: parseInt(iShiftCenter.value, 10),
        circleDiameter: parseInt(iDiameter.value, 10),
        circleKerning: parseInt(iKerning.value, 10),
        circleFlip: iFlip.checked,
        curveAmount: parseInt(iCurveAmount.value, 10),
        curveKerning: parseInt(iCurveKerning.value, 10),
        curveFlip: iCurveFlip.checked,
        // Grid Distort parameters (will be used only when user explicitly selects grid-distort)
        gridDistortCols: iGridDistortCols ? parseInt(iGridDistortCols.value, 10) : 2,
        gridDistortRows: iGridDistortRows ? parseInt(iGridDistortRows.value, 10) : 1,
        gridDistortPadding: iGridDistortPadding ? parseInt(iGridDistortPadding.value, 10) : 120,
        gridDistortIntensity: iGridDistortIntensity ? parseInt(iGridDistortIntensity.value, 10) : 100,
        gridDistortVerticalOnly: true, // Set vertical only as default
        // Reset shadow and decoration modes to default for new text
        shadowMode: 'noShadow',
        shadowColor: shadowColorPicker.value,
        shadowOffsetX: parseInt(shadowOffsetXSlider.value, 10),
        shadowOffsetY: parseInt(shadowOffsetYSlider.value, 10),
        shadowBlur: parseInt(shadowBlurSlider.value, 10),
        blockShadowColor: blockShadowColorPicker.value,
        blockShadowOpacity: parseInt(blockShadowOpacitySlider.value, 10),
        blockShadowOffset: parseInt(blockShadowOffsetSlider.value, 10),
        blockShadowAngle: parseInt(blockShadowAngleSlider.value, 10),
        blockShadowBlur: parseInt(blockShadowBlurSlider.value, 10),
        blockShadowPerspective: false,
        blockShadowPerspectiveIntensity: 50,
        lineShadowColor: lineShadowColorPicker.value,
        lineShadowDist: parseInt(lineShadowDistanceSlider.value, 10),
        lineShadowAngle: parseInt(lineShadowAngleSlider.value, 10),
        lineShadowThickness: parseInt(lineShadowThicknessSlider.value, 10),
        d3dPrimaryColor: detailed3DPrimaryColorPicker.value,
        d3dPrimaryOpacity: parseInt(detailed3DPrimaryOpacitySlider.value, 10),
        d3dOffset: parseInt(detailed3DOffsetSlider.value, 10),
        d3dAngle: parseInt(detailed3DAngleSlider.value, 10),
        d3dBlur: parseInt(detailed3DBlurSlider.value, 10),
        d3dSecondaryColor: detailed3DSecondaryColorPicker.value,
        d3dSecondaryOpacity: parseInt(detailed3DSecondaryOpacitySlider.value, 10),
        d3dSecondaryWidth: parseInt(detailed3DSecondaryWidthSlider.value, 10),
        d3dSecondaryOffsetX: parseInt(detailed3DSecondaryOffsetXSlider.value, 10),
        d3dSecondaryOffsetY: parseInt(detailed3DSecondaryOffsetYSlider.value, 10),
        strokeMode: 'noStroke',
        strokeWidth: parseInt(strokeWidthSlider.value, 10),
        strokeColor: strokeColorPicker.value,
        decorationMode: 'noDecoration',
        hLineWeight: parseInt(hWeight.value, 10),
        hLineDist: parseInt(hDistance.value, 10),
        hLineColor: hColor.value,
        hLineOpacity: parseInt(hOpacity.value, 10),
        ccDist: parseInt(ccDistance.value, 10),
        ccColor: ccColor.value,
        ccOpacity: parseInt(ccOpacity.value, 10),
        ccFillDir: ccFillTop.checked ? 'top' : 'bottom',
        oLineWeight: parseInt(oWeight.value, 10),
        oLineDist: parseInt(oDistance.value, 10),
        oLineColor: oColor.value,
        oOpacity: parseInt(oOpacity.value, 10),
        flcDist: parseInt(flcDistance.value, 10),
        flcColor: flcColor.value,
        flcOpacity: parseInt(flcOpacity.value, 10),
        flcWeight: parseInt(flcMaxWeight.value, 10),
        flcSpacing: parseInt(flcSpacing.value, 10),
        flcDir: flcFillTop.checked ? 'top' : 'bottom',
        // Color intensity for smart palette colors
        colorIntensity: 'no-change', // Default to no change for new text objects
        // Text box width for text wrapping (0 = unlimited)
        textBoxWidth: 0,
        // Persistent parameter system - initialize with N/A for new objects
        newColorIntensity: 'N/A',
        newTemplateId: 'N/A'
    };

    const newObj = createTextObject(newObjOptions);
    console.log('🆕 HANDLE ADD TEXT OBJECT: Created new text object:', {
        id: newObj.id,
        text: newObj.text,
        type: newObj.type
    });

    // Ensure gridDistort is initialized with showGrid set to false
    if (newObj.gridDistort) {
        newObj.gridDistort.showGrid = false;
    }

    if (selectedObjectIndex !== -1) {
        console.log('🆕 HANDLE ADD TEXT OBJECT: Deselecting previous object at index:', selectedObjectIndex);
        canvasObjects[selectedObjectIndex].isSelected = false;
    }

    canvasObjects.push(newObj);
    selectedObjectIndex = canvasObjects.length - 1;
    newObj.isSelected = true;

    console.log('🆕 HANDLE ADD TEXT OBJECT: Added to canvas, new selectedObjectIndex =', selectedObjectIndex);
    console.log('🆕 HANDLE ADD TEXT OBJECT: Total canvas objects =', canvasObjects.length);

    // Check for ID collisions after adding new object
    checkForIdCollisions();

    // Update UI to reflect the new object's properties
    updateUIFromSelectedObject();

    // Make sure the effect mode dropdown is set to 'normal'
    if (effectModeSelect) {
        effectModeSelect.value = 'normal';
    }

    update();

    // Save state for undo/redo
    saveState('Add Text');
}
   // **** ADDED SEMICOLON ****
   function handleAddImage(file) { if (!file || !file.type.startsWith('image/')) { alert('Please select a valid image file.'); return; } const reader = new FileReader(); reader.onload = function(event) { const img = new Image(); img.onload = function() { const viewCenterX = canvas.clientWidth / 2; const viewCenterY = canvas.clientHeight / 2; const worldCenter = canvasToWorld(viewCenterX, viewCenterY); const newObj = createImageObject(img, { x: worldCenter.x + (Math.random() * 40 - 20) / scale, y: worldCenter.y + (Math.random() * 40 - 20) / scale, imageUrl: event.target.result /* Store data URL initially? Or null? Let's use data URL */ }); if (selectedObjectIndex !== -1) { canvasObjects[selectedObjectIndex].isSelected = false; } canvasObjects.push(newObj); selectedObjectIndex = canvasObjects.length - 1; newObj.isSelected = true; updateUIFromSelectedObject(); update(); saveState('Add Image'); }; img.onerror = function() { alert('Error loading image.'); }; img.src = event.target.result; }; reader.readAsDataURL(file); }
   function handleDeleteObject() {
       if (selectedObjectIndex !== -1) {
           const deletedObject = canvasObjects[selectedObjectIndex];

           // Handle multi-select deletion
           if (isMultiSelectMode && selectedObjectIndices.length > 1) {
               // Delete all selected objects (sort indices in descending order to avoid index shifting)
               const sortedIndices = [...selectedObjectIndices].sort((a, b) => b - a);
               sortedIndices.forEach(index => {
                   canvasObjects.splice(index, 1);
               });
               clearMultiSelection();
               selectedObjectIndex = -1;
               isMultiSelectMode = false;
               updateAlignmentUI();
               saveState(`Delete ${sortedIndices.length} Objects`);
           } else {
               // Single object deletion
               canvasObjects.splice(selectedObjectIndex, 1);
               selectedObjectIndex = -1;
               selectedObjectIndices = [];
               isMultiSelectMode = false;
               updateAlignmentUI();
               saveState(`Delete ${deletedObject.type === 'text' ? 'Text' : 'Image'}`);
           }

           updateUIFromSelectedObject();
           update();
       }
   }
   function handleMouseDown(e) {
       const coords = getCanvasCoordinates(e);

       // 🔒 UI INTERACTION LOCK: Prevent object selection during UI interactions
       if (isUIInteractionActive) {
           console.log('🔒 UI LOCK: Blocking canvas interaction - UI controls are active');
           return;
       }

       // Middle mouse button for panning
       if (e.button === 1) {
           isPanning = true;
           isDraggingObject = false;
           isDraggingGridPoint = false;
           panStartX = coords.x;
           panStartY = coords.y;
           canvasArea.classList.add('panning');
           e.preventDefault();
           return;
       }

       // If in artboard edit mode, prevent object selection
       if (isArtboardEditMode && artboard && artboard.isSelected) {
           // Only allow artboard corner interactions which are handled separately
           return;
       }

       // Layout Tool Mode - Handle layout rectangle drawing and selection
       if (isLayoutToolActive && e.button === 0) {
           const worldCoords = canvasToWorld(coords.x, coords.y);

           // Check if clicking on an existing layout rectangle
           let hitLayoutRectIndex = -1;
           for (let i = layoutRectangles.length - 1; i >= 0; i--) {
               const rect = layoutRectangles[i];
               if (worldCoords.x >= rect.x && worldCoords.x <= rect.x + rect.width &&
                   worldCoords.y >= rect.y && worldCoords.y <= rect.y + rect.height) {
                   hitLayoutRectIndex = i;
                   break;
               }
           }

           if (hitLayoutRectIndex !== -1) {
               // Select the layout rectangle (change color to grey)
               selectedLayoutRectIndex = hitLayoutRectIndex;
               window.selectedLayoutRectIndex = hitLayoutRectIndex;
               console.log('[LayoutTool] Selected layout rectangle:', hitLayoutRectIndex);

               // Update UI to reflect layout selection
               updateLayoutSelectionUI();
           } else {
               // Start drawing a new layout rectangle with snap-to-guidelines
               selectedLayoutRectIndex = -1;
               window.selectedLayoutRectIndex = -1;
               isDrawingLayoutRect = true;

               // Apply snap-to-guidelines for start position
               console.log('🧲 [Snap] === CALLING snapToGuidelines for START POSITION ===');
               const snappedStart = snapToGuidelines(worldCoords.x, worldCoords.y);
               layoutRectStartX = snappedStart.x;
               layoutRectStartY = snappedStart.y;
               console.log('[LayoutTool] Started drawing new layout rectangle at:', snappedStart.x, snappedStart.y);
               if (snappedStart.x !== worldCoords.x || snappedStart.y !== worldCoords.y) {
                   console.log('🧲 [Snap] ✅ Start position snapped from:', worldCoords.x, worldCoords.y, 'to:', snappedStart.x, snappedStart.y);
               } else {
                   console.log('🧲 [Snap] ❌ No snap occurred for start position');
               }
           }

           update();
           return;
       }

       // Left mouse button
       if (e.button === 0) {
           const worldCoords = canvasToWorld(coords.x, coords.y);

           // --- Check for State Indicator Click FIRST ---
           console.log('[StateIndicator] Checking for state indicator clicks at world coords:', worldCoords);

           // Check canvas object indicators
           for (let i = 0; i < canvasObjects.length; i++) {
               const obj = canvasObjects[i];
               if (obj._stateIndicator && (obj.isLocked || obj.isHidden)) {
                   const indicator = obj._stateIndicator;
                   const distance = Math.sqrt(
                       Math.pow(worldCoords.x - indicator.x, 2) +
                       Math.pow(worldCoords.y - indicator.y, 2)
                   );

                   console.log(`[StateIndicator] Object ${i} (${obj.id}) - indicator at (${indicator.x}, ${indicator.y}), distance: ${distance}, size: ${indicator.size}, isLocked: ${obj.isLocked}, isHidden: ${obj.isHidden}`);

                   if (distance <= indicator.size / 2) {
                       console.log('[StateIndicator] ✅ Clicked on state indicator for object:', obj.id, 'type:', obj.type);

                       if (obj.isLocked) {
                           console.log('[StateIndicator] Unlocking object:', obj.id);
                           unlockObject(i);
                       } else if (obj.isHidden) {
                           console.log('[StateIndicator] Showing object:', obj.id);
                           showObject(i);
                       }

                       return; // Stop further processing
                   }
               }
           }

           // Check layout indicator clicks
           if (layoutRectangles && Array.isArray(layoutRectangles)) {
               for (let i = 0; i < layoutRectangles.length; i++) {
                   const layout = layoutRectangles[i];
                   if (layout._stateIndicator && layout.isHidden) {
                       const indicator = layout._stateIndicator;
                       const distance = Math.sqrt(
                           Math.pow(worldCoords.x - indicator.x, 2) +
                           Math.pow(worldCoords.y - indicator.y, 2)
                       );

                       console.log(`[LayoutIndicator] Layout ${i} - indicator at (${indicator.x}, ${indicator.y}), distance: ${distance}, size: ${indicator.size}, isHidden: ${layout.isHidden}`);

                       if (distance <= indicator.size / 2) {
                           console.log('[LayoutIndicator] ✅ Clicked on state indicator for layout:', i, layout.customName || `Layout ${i + 1}`);

                           // Show the hidden layout
                           layout.isHidden = false;
                           console.log('[LayoutIndicator] Showing layout:', i);
                           update();
                           return; // Stop further processing
                       }
                   }
               }
           }

           // --- Check for Grid Point Hit FIRST ---
           if (selectedObjectIndex !== -1 &&
               selectedObjectIndex < canvasObjects.length &&
               canvasObjects[selectedObjectIndex] &&
               canvasObjects[selectedObjectIndex].type === 'text' &&
               canvasObjects[selectedObjectIndex].effectMode === 'grid-distort' &&
               canvasObjects[selectedObjectIndex].gridDistort &&
               canvasObjects[selectedObjectIndex].gridDistort.showGrid) {

               // Log for debugging
               console.log('Checking for grid point hit');

               const result = findGridPointAt(
                   canvasObjects[selectedObjectIndex],
                   worldCoords.x,
                   worldCoords.y
               );

               if (result.hit) {
                   console.log('Grid point hit:', result.row, result.col);
                   isDraggingGridPoint = true;
                   isDraggingObject = false;
                   draggedPointRow = result.row;
                   draggedPointCol = result.col;
                   draggedObject = canvasObjects[selectedObjectIndex];
                   canvas.classList.add('dragging-grid-point');
                   return; // Stop further processing
               }
           }

           // --- PRIORITY: Check for Layout Rectangle Resize Handle FIRST ---
           // This must come before guideline hit detection to prevent guidelines from blocking resize handles
           if (selectedLayoutRectIndex !== -1 && layoutRectangles[selectedLayoutRectIndex]) {
               const rect = layoutRectangles[selectedLayoutRectIndex];
               const handleSize = 8 / scale;

               const handles = [
                   { x: rect.x, y: rect.y, id: 'tl' }, // Top-left
                   { x: rect.x + rect.width, y: rect.y, id: 'tr' }, // Top-right
                   { x: rect.x, y: rect.y + rect.height, id: 'bl' }, // Bottom-left
                   { x: rect.x + rect.width, y: rect.y + rect.height, id: 'br' } // Bottom-right
               ];

               for (const handle of handles) {
                   if (worldCoords.x >= handle.x - handleSize/2 && worldCoords.x <= handle.x + handleSize/2 &&
                       worldCoords.y >= handle.y - handleSize/2 && worldCoords.y <= handle.y + handleSize/2) {
                       // Start resizing - this takes priority over guideline interaction
                       isResizingLayoutRect = true;
                       layoutResizeCorner = handle.id;
                       console.log('[LayoutTool] 🎯 PRIORITY: Started resizing layout rectangle:', handle.id, '(overriding any guideline hit)');
                       update();
                       return;
                   }
               }
           }

           // --- Check for Guideline Hit (only if no layout resize handle was hit and guidelines are visible) ---
           if (areGuidelinesVisible) {
               const hitGuideline = getGuidelineAtPoint(worldCoords.x, worldCoords.y);
               if (hitGuideline) {
                   // Check if guidelines are locked
                   if (areGuidelinesLocked) {
                       console.log('🔒 Canvas guideline hit but guidelines are locked, ignoring drag attempt');
                       return;
                   }

                   console.log('🔧 Guideline hit, starting drag:', hitGuideline);
                   isDraggingGuideline = true;
                   isDraggingObject = false;
                   isDraggingGridPoint = false;
                   draggedGuideline = hitGuideline;
                   canvas.style.cursor = hitGuideline.type === 'horizontal' ? 'ns-resize' : 'ew-resize';
                   return; // Stop further processing
               }
           }

           // --- Check for Mesh Point Hit NEXT ---
           // Check if mesh mode is active and if the click hit a control point
           if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler &&
               selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex] === activeMeshWarpHandler.selectedTextObject) {
               // activeMeshWarpHandler.handleMouseDown(e) will set its internal isDragging state
               // We don't need to call it directly here if it's already attached to the canvas mousedown
               // Instead, we check if the handler *is currently* dragging after its own listener ran.
               // Note: This relies on the mesh handler's listener running *before* this one.
               // If event listener order is not guaranteed, call the handler's check method directly:
               const hitPointIndex = activeMeshWarpHandler.findPointAt(worldCoords.x, worldCoords.y);
               if (hitPointIndex !== -1) {
                    // If a mesh point was hit, let the mesh handler manage the drag.
                    // We might need to explicitly call its mousedown logic if stopPropagation isn't enough
                    // activeMeshWarpHandler.handleMouseDown(e); // Call if needed
                    console.log("Main mouse down: Mesh point hit, preventing object drag.");
                    isDraggingObject = false; // Ensure object dragging is off
                    return; // Stop further processing in this handler
               }
           }
           // --- End Mesh Point Check ---

           // --- Layout Tool Mode - Prevent Object Selection ---
           if (isLayoutToolActive) {
               // Layout tool is active, prevent object selection and movement
               return;
           }

           // --- Object Hit Testing (if no mesh point was hit) ---
           let hitIndex = -1;
           for (let i = canvasObjects.length - 1; i >= 0; i--) {
               const obj = canvasObjects[i];

               // Skip locked and hidden objects
               if (obj.isLocked || obj.isHidden) {
                   continue;
               }

               const bounds = calculateObjectBounds(obj);
               console.log('🎯 HIT TEST: Object', i, 'type:', obj.type, 'bounds:', bounds);

               const dx = worldCoords.x - obj.x;
               const dy = worldCoords.y - obj.y;
               const rotation = obj.rotation || 0; // Default to 0 if rotation is undefined
               const angleRad = -rotation * Math.PI / 180;
               const cos = Math.cos(angleRad);
               const sin = Math.sin(angleRad);
               const localClickX = dx * cos - dy * sin;
               const localClickY = dx * sin + dy * cos;
               const hit = localClickX >= -bounds.width / 2 && localClickX <= bounds.width / 2 &&
                           localClickY >= -bounds.height / 2 && localClickY <= bounds.height / 2;

               console.log('🎯 HIT TEST: Click at world coords:', worldCoords, 'local:', {localClickX, localClickY}, 'hit:', hit);

               if (hit) {
                   console.log('🎯 HIT TEST: ✅ Object', i, 'type:', obj.type, 'was hit!');
                   hitIndex = i;
                   break;
               }
           }

           if (hitIndex !== -1) {
               // Check if we're in mask selection mode
               if (isMaskSelectionMode && pendingMaskImage) {
                   const clickedObject = canvasObjects[hitIndex];

                   console.log('[Masking] 🎭 Object clicked during mask selection:', {
                       id: clickedObject.id,
                       type: clickedObject.type,
                       imageUrl: clickedObject.imageUrl,
                       x: clickedObject.x,
                       y: clickedObject.y,
                       pendingMaskImageId: pendingMaskImage.id
                   });

                   // Check if clicked object is a valid shape for masking
                   if (clickedObject.type === 'image' &&
                       clickedObject.id !== pendingMaskImage.id &&
                       clickedObject.imageUrl &&
                       (clickedObject.imageUrl.includes('.svg') || clickedObject.imageUrl.includes('/shapes/'))) {

                       console.log('[Masking] 🎭 Valid shape selected for masking');

                       // Apply mask
                       applyMaskToImage(pendingMaskImage, clickedObject);
                       exitMaskSelectionMode();
                       return; // Exit early, don't proceed with normal selection
                   } else {
                       console.log('[Masking] 🎭 Invalid shape clicked:', {
                           isImage: clickedObject.type === 'image',
                           isDifferentFromPending: clickedObject.id !== pendingMaskImage.id,
                           hasImageUrl: !!clickedObject.imageUrl,
                           isSvg: clickedObject.imageUrl && clickedObject.imageUrl.includes('.svg'),
                           isShape: clickedObject.imageUrl && clickedObject.imageUrl.includes('/shapes/')
                       });

                       // Invalid shape clicked
                       if (window.showToast) {
                           window.showToast('Please select a vector shape to use as mask', 'warning');
                       }
                       return; // Exit early, don't proceed with normal selection
                   }
               }

               // 🔗 RESIZE DETECTION: Check if clicked on resize handle of selected rectangle
               if (selectedObjectIndex !== -1) {
                   const selectedObject = canvasObjects[selectedObjectIndex];
                   if (selectedObject.type === 'rectangle' && selectedObject.isTextController) {
                       const handleSize = 8 / scale;
                       const half = handleSize / 2;
                       const x = selectedObject.x - (selectedObject.width / 2);
                       const y = selectedObject.y - (selectedObject.height / 2);
                       const width = selectedObject.width;
                       const height = selectedObject.height;

                       const handles = [
                           { id: 'nw', x: x, y: y },
                           { id: 'ne', x: x + width, y: y },
                           { id: 'sw', x: x, y: y + height },
                           { id: 'se', x: x + width, y: y + height },
                           { id: 'n', x: x + width/2, y: y },
                           { id: 's', x: x + width/2, y: y + height },
                           { id: 'w', x: x, y: y + height/2 },
                           { id: 'e', x: x + width, y: y + height/2 }
                       ];

                       for (const handle of handles) {
                           if (worldCoords.x >= handle.x - half && worldCoords.x <= handle.x + half &&
                               worldCoords.y >= handle.y - half && worldCoords.y <= handle.y + half) {
                               // Start resizing
                               isResizingRectangle = true;
                               resizeHandle = handle.id;
                               resizeInitialWidth = selectedObject.width;
                               resizeInitialHeight = selectedObject.height;
                               resizeInitialX = selectedObject.x;
                               resizeInitialY = selectedObject.y;
                               dragStartX = coords.x;
                               dragStartY = coords.y;
                               console.log('🔗 RESIZE: Started resizing rectangle handle:', handle.id);
                               return; // Don't proceed with normal object selection
                           }
                       }
                   }
               }

               // Clicked on an object (selection logic with multi-select support)
               isDraggingObject = true;
               isPanning = false;

               // Check if Shift is held for multi-select
               if (e.shiftKey) {
                   // Multi-select mode
                   if (selectedObjectIndices.includes(hitIndex)) {
                       // Deselect if already selected
                       selectedObjectIndices = selectedObjectIndices.filter(i => i !== hitIndex);
                       canvasObjects[hitIndex].isSelected = false;
                       if (selectedObjectIndex === hitIndex) {
                           selectedObjectIndex = selectedObjectIndices.length > 0 ? selectedObjectIndices[0] : -1;
                       }
                   } else {
                       // Add to selection
                       selectedObjectIndices.push(hitIndex);
                       canvasObjects[hitIndex].isSelected = true;
                       selectedObjectIndex = hitIndex; // Make this the primary selection
                   }
                   isMultiSelectMode = selectedObjectIndices.length > 1;
                   updateAlignmentUI();
               } else {
                   // Single select mode (clear multi-selection)
                   clearMultiSelection();
                   if (selectedObjectIndex !== hitIndex) {
                       if (selectedObjectIndex !== -1) {
                           canvasObjects[selectedObjectIndex].isSelected = false;
                       }
                       selectedObjectIndex = hitIndex;
                       canvasObjects[selectedObjectIndex].isSelected = true;
                       selectedObjectIndices = [hitIndex];
                   } else {
                       // 🔧 FIX: Clicking on already selected object - ensure it stays selected
                       // clearMultiSelection() above may have cleared isSelected, so restore it
                       canvasObjects[selectedObjectIndex].isSelected = true;
                       selectedObjectIndices = [hitIndex];
                   }
                   isMultiSelectMode = false;
                   updateAlignmentUI();
               }

               // Deselect any selected layout rectangle when selecting a canvas object
               if (selectedLayoutRectIndex !== -1) {
                   selectedLayoutRectIndex = -1;
                   window.selectedLayoutRectIndex = -1;
                   console.log('[LayoutTool] Deselected layout rectangle due to canvas object selection');

                   // Update UI to reflect layout deselection
                   updateLayoutSelectionUI();
               }

                   // Activate mesh warp handler if the selected object has mesh effect
                   const selectedObject = canvasObjects[selectedObjectIndex];
                   console.log('[Selection] Selected object:', selectedObject.text || selectedObject.type, 'effectMode:', selectedObject.effectMode, 'hasMeshHandler:', !!selectedObject._meshWarpHandler);
                   if (selectedObject.type === 'text' && selectedObject.effectMode === 'mesh') {
                       // If the object has its own mesh handler, use it
                       if (selectedObject._meshWarpHandler) {
                           console.log('[Selection] Activating existing mesh warp handler for text object:', selectedObject.text);
                           console.log('[Selection] Handler control points:', selectedObject._meshWarpHandler.controlPoints.length);
                           activeMeshWarpHandler = selectedObject._meshWarpHandler;
                           activeMeshWarpHandler.selectedTextObject = selectedObject;
                           console.log('[Selection] Active mesh warp handler set:', !!activeMeshWarpHandler);
                       } else {
                           // Create a new mesh handler if one doesn't exist
                           console.log('[Selection] Creating new mesh warp handler for text object:', selectedObject.text);
                           try {
                               activeMeshWarpHandler = new MeshWarpHandler(
                                   document.getElementById('demo'),
                                   selectedObject
                               );
                               // Store the handler on the object for future use
                               selectedObject._meshWarpHandler = activeMeshWarpHandler;
                               console.log('[Selection] New mesh warp handler created and stored on object');
                           } catch (error) {
                               console.error('Error creating mesh warp handler:', error);
                               activeMeshWarpHandler = null;
                           }
                       }
                   } else if (selectedObject.type !== 'text') {
                       // When selecting non-text objects (shapes/images), clear active handler for interaction
                       // but preserve individual object handlers
                       console.log('[Selection] Selected non-text object, clearing active handler but preserving object handlers');
                       activeMeshWarpHandler = null; // Clear active handler for interaction only
                   } else if (selectedObject.type === 'text' && selectedObject.effectMode !== 'mesh') {
                       // Only deactivate if switching to a text object without mesh effect
                       console.log('[Selection] Switching to non-mesh text object, clearing active mesh handler');
                       activeMeshWarpHandler = null;
                   }

               dragStartX = coords.x;
               dragStartY = coords.y;
               dragInitialObjectX = canvasObjects[selectedObjectIndex].x;
               dragInitialObjectY = canvasObjects[selectedObjectIndex].y;

               // Track movement start for performance optimization
               isDuringMovement = true;
               movementStartTime = performance.now();
               lastMovementTime = movementStartTime;

               // --- BEGIN FIX V2: Store initial mesh points on drag start ---
               if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler &&
                   activeMeshWarpHandler.selectedTextObject === canvasObjects[selectedObjectIndex] &&
                   activeMeshWarpHandler.controlPoints) {
                   // Store a deep copy of the control points at the start of the drag
                   dragInitialControlPoints = activeMeshWarpHandler.controlPoints.map(p => ({ ...p }));
                   console.log("Stored initial mesh points for drag");
               } else {
                   dragInitialControlPoints = null; // Ensure it's null if not dragging a mesh object
               }
               // --- END FIX V2 ---

               canvas.classList.add('dragging');
               updateUIFromSelectedObject();
               update();
           } else {
               // Clicked on empty space - check for layout rectangle selection

               // Layout Rectangle Resize Handle check has been moved to priority position earlier in the code
               // to prevent guidelines from blocking resize handle interaction

               // Check for Layout Rectangle Selection (only when no object is hit)
               let hitLayoutRectIndex = -1;
               for (let i = layoutRectangles.length - 1; i >= 0; i--) {
                   const rect = layoutRectangles[i];
                   if (worldCoords.x >= rect.x && worldCoords.x <= rect.x + rect.width &&
                       worldCoords.y >= rect.y && worldCoords.y <= rect.y + rect.height) {
                       hitLayoutRectIndex = i;
                       break;
                   }
               }

               if (hitLayoutRectIndex !== -1) {
                   // Select the layout rectangle (change color to grey)
                   selectedLayoutRectIndex = hitLayoutRectIndex;
                   window.selectedLayoutRectIndex = hitLayoutRectIndex;
                   console.log('[LayoutTool] Selected layout rectangle in normal mode:', hitLayoutRectIndex);
               console.log('[LayoutTool] Layout rectangle details:', layoutRectangles[hitLayoutRectIndex]);
               console.log('[LayoutTool] Global selectedLayoutRectIndex updated to:', window.selectedLayoutRectIndex);

                   // Update UI to reflect layout selection
                   updateLayoutSelectionUI();

                   // Deselect any selected canvas objects
                   clearMultiSelection();
                   if (selectedObjectIndex !== -1) {
                       canvasObjects[selectedObjectIndex].isSelected = false;
                       selectedObjectIndex = -1;
                       updateUIFromSelectedObject();
                   }
                   isMultiSelectMode = false;
                   updateAlignmentUI();

                   // 🎯 LAYOUT SELECTION: Show fit green rectangle button when layout is selected
                   updateLayoutSelectionUI();

                   update();
               } else {
                   // Truly clicked on empty space
                   clearMultiSelection();
                   if (selectedObjectIndex !== -1) {
                       canvasObjects[selectedObjectIndex].isSelected = false;
                       selectedObjectIndex = -1;
                       updateUIFromSelectedObject();
                   }

                   // Also deselect any selected layout rectangle
                   if (selectedLayoutRectIndex !== -1) {
                       selectedLayoutRectIndex = -1;
                       window.selectedLayoutRectIndex = -1;
                       console.log('[LayoutTool] Deselected layout rectangle due to empty space click');

                       // 🎯 LAYOUT DESELECTION: Hide fit green rectangle button when layout is deselected
                       updateLayoutSelectionUI();
                   }

                   isMultiSelectMode = false;
                   updateAlignmentUI();
                   dragInitialControlPoints = null; // Clear stored points if clicking empty space
                   update();
               }
           }
       }
   }
   function handleMouseMove(e) {
        // --- Layout Tool Drawing FIRST ---
        if (isLayoutToolActive && isDrawingLayoutRect) {
            const coords = getCanvasCoordinates(e);
            const worldCoords = canvasToWorld(coords.x, coords.y);

            // Apply snap-to-guidelines for current position
            console.log('🧲 [Snap] === CALLING snapToGuidelines for MOUSE MOVE ===');
            const snappedCoords = snapToGuidelines(worldCoords.x, worldCoords.y);

            // Update the current drawing rectangle (will be drawn in the update function)
            const currentRect = {
                x: Math.min(layoutRectStartX, snappedCoords.x),
                y: Math.min(layoutRectStartY, snappedCoords.y),
                width: Math.abs(snappedCoords.x - layoutRectStartX),
                height: Math.abs(snappedCoords.y - layoutRectStartY)
            };

            // Store as temporary rectangle for drawing
            window.currentDrawingLayoutRect = currentRect;
            update();
            return;
        }

        // 🔗 RECTANGLE RESIZING: Handle rectangle resize with linked text scaling
        if (isResizingRectangle && selectedObjectIndex !== -1 && resizeHandle) {
            const coords = getCanvasCoordinates(e);
            const dragDeltaX = coords.x - dragStartX;
            const dragDeltaY = coords.y - dragStartY;
            const worldDeltaX = dragDeltaX / scale;
            const worldDeltaY = dragDeltaY / scale;

            const selectedObject = canvasObjects[selectedObjectIndex];
            let newWidth = resizeInitialWidth;
            let newHeight = resizeInitialHeight;
            let newX = resizeInitialX;
            let newY = resizeInitialY;

            // Calculate new dimensions based on handle
            switch (resizeHandle) {
                case 'se': // Bottom-right
                    newWidth = resizeInitialWidth + worldDeltaX;
                    newHeight = resizeInitialHeight + worldDeltaY;
                    break;
                case 'nw': // Top-left
                    newWidth = resizeInitialWidth - worldDeltaX;
                    newHeight = resizeInitialHeight - worldDeltaY;
                    newX = resizeInitialX + worldDeltaX / 2;
                    newY = resizeInitialY + worldDeltaY / 2;
                    break;
                case 'ne': // Top-right
                    newWidth = resizeInitialWidth + worldDeltaX;
                    newHeight = resizeInitialHeight - worldDeltaY;
                    newY = resizeInitialY + worldDeltaY / 2;
                    break;
                case 'sw': // Bottom-left
                    newWidth = resizeInitialWidth - worldDeltaX;
                    newHeight = resizeInitialHeight + worldDeltaY;
                    newX = resizeInitialX + worldDeltaX / 2;
                    break;
            }

            // Minimum size constraints
            if (newWidth > 20 && newHeight > 20) {
                selectedObject.width = newWidth;
                selectedObject.height = newHeight;
                selectedObject.x = newX;
                selectedObject.y = newY;

                // 🔗 LINKED SCALING: Scale the linked text proportionally
                if (selectedObject.linkedTextId) {
                    console.log('🔗 LINKED SCALING: Looking for linked text with ID:', selectedObject.linkedTextId);
                    const linkedText = canvasObjects.find(obj => obj.id === selectedObject.linkedTextId);
                    console.log('🔗 LINKED SCALING: Found linked text:', linkedText ? 'YES' : 'NO');
                    if (linkedText) {
                        console.log('🔗 LINKED SCALING: Text originalFontSize:', linkedText.originalFontSize, 'current fontSize:', linkedText.fontSize);
                        if (linkedText.originalFontSize) {
                            const scaleFactorX = newWidth / resizeInitialWidth;
                            const scaleFactorY = newHeight / resizeInitialHeight;
                            const scaleFactor = Math.min(scaleFactorX, scaleFactorY); // Use smaller scale to fit

                            linkedText.fontSize = linkedText.originalFontSize * scaleFactor;
                            linkedText.x = newX;
                            linkedText.y = newY;

                            console.log('🔗 LINKED SCALING: Scaled text font size:', linkedText.fontSize, 'scale factor:', scaleFactor);
                        } else {
                            console.log('🔗 LINKED SCALING: ❌ No originalFontSize found, setting it now');
                            linkedText.originalFontSize = linkedText.fontSize;
                            const scaleFactorX = newWidth / resizeInitialWidth;
                            const scaleFactorY = newHeight / resizeInitialHeight;
                            const scaleFactor = Math.min(scaleFactorX, scaleFactorY);
                            linkedText.fontSize = linkedText.originalFontSize * scaleFactor;
                            linkedText.x = newX;
                            linkedText.y = newY;
                            console.log('🔗 LINKED SCALING: Set originalFontSize and scaled text:', linkedText.fontSize);
                        }
                    }
                }
            }

            update();
            return;
        }

        // --- Layout Rectangle Resizing ---
        if (isResizingLayoutRect && selectedLayoutRectIndex !== -1 && layoutResizeCorner) {
            const coords = getCanvasCoordinates(e);
            const worldCoords = canvasToWorld(coords.x, coords.y);
            const rect = layoutRectangles[selectedLayoutRectIndex];

            // Resize based on corner
            switch (layoutResizeCorner) {
                case 'tl': // Top-left
                    const newWidth = rect.x + rect.width - worldCoords.x;
                    const newHeight = rect.y + rect.height - worldCoords.y;
                    if (newWidth > 5 && newHeight > 5) {
                        rect.width = newWidth;
                        rect.height = newHeight;
                        rect.x = worldCoords.x;
                        rect.y = worldCoords.y;
                    }
                    break;
                case 'tr': // Top-right
                    const newWidthTR = worldCoords.x - rect.x;
                    const newHeightTR = rect.y + rect.height - worldCoords.y;
                    if (newWidthTR > 5 && newHeightTR > 5) {
                        rect.width = newWidthTR;
                        rect.height = newHeightTR;
                        rect.y = worldCoords.y;
                    }
                    break;
                case 'bl': // Bottom-left
                    const newWidthBL = rect.x + rect.width - worldCoords.x;
                    const newHeightBL = worldCoords.y - rect.y;
                    if (newWidthBL > 5 && newHeightBL > 5) {
                        rect.width = newWidthBL;
                        rect.height = newHeightBL;
                        rect.x = worldCoords.x;
                    }
                    break;
                case 'br': // Bottom-right
                    const newWidthBR = worldCoords.x - rect.x;
                    const newHeightBR = worldCoords.y - rect.y;
                    if (newWidthBR > 5 && newHeightBR > 5) {
                        rect.width = newWidthBR;
                        rect.height = newHeightBR;
                    }
                    break;
            }

            update();
            return;
        }

        // --- Check Grid Point Drag FIRST ---
        if (isDraggingGridPoint && draggedObject && draggedPointRow !== -1 && draggedPointCol !== -1) {
            console.log('Dragging grid point:', draggedPointRow, draggedPointCol);

            const coords = getCanvasCoordinates(e);
            const worldCoords = canvasToWorld(coords.x, coords.y);

            // Convert world coordinates to object-local coordinates
            const dx = worldCoords.x - draggedObject.x;
            const dy = worldCoords.y - draggedObject.y;
            const angleRad = -draggedObject.rotation * Math.PI / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;

            console.log('Moving point to local coordinates:', localX, localY);

            // Update the control point position
            if (draggedObject.gridDistort &&
                draggedObject.gridDistort.controlPoints &&
                draggedObject.gridDistort.controlPoints[draggedPointRow] &&
                draggedObject.gridDistort.controlPoints[draggedPointRow][draggedPointCol]) {

                // Store the previous position for logging
                const prevX = draggedObject.gridDistort.controlPoints[draggedPointRow][draggedPointCol].x;
                const prevY = draggedObject.gridDistort.controlPoints[draggedPointRow][draggedPointCol].y;

                // Update the position
                draggedObject.gridDistort.controlPoints[draggedPointRow][draggedPointCol].x = localX;
                draggedObject.gridDistort.controlPoints[draggedPointRow][draggedPointCol].y = localY;

                console.log('Updated point position:',
                    `(${prevX.toFixed(2)}, ${prevY.toFixed(2)}) -> (${localX.toFixed(2)}, ${localY.toFixed(2)})`);

                // Store relative positions for preserving distortion when text changes
                storeRelativeControlPoints(draggedObject);

                update();
            } else {
                console.warn('Could not update control point - invalid grid structure');
            }

            return;
        }

        // --- Check Guideline Drag ---
        if (isDraggingGuideline && draggedGuideline) {
            const coords = getCanvasCoordinates(e);
            const worldCoords = canvasToWorld(coords.x, coords.y);

            // Update guideline position
            if (draggedGuideline.type === 'horizontal') {
                draggedGuideline.worldPosition = worldCoords.y;
                console.log(`🔧 Dragging horizontal guideline to Y: ${worldCoords.y}`);
            } else if (draggedGuideline.type === 'vertical') {
                draggedGuideline.worldPosition = worldCoords.x;
                console.log(`🔧 Dragging vertical guideline to X: ${worldCoords.x}`);
            }

            update();
            return;
        }

        // --- Check Mesh Drag NEXT ---
        if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler && activeMeshWarpHandler.isDragging) {
            // If the mesh handler is dragging, let it handle the move and prevent object drag
            // activeMeshWarpHandler.handleMouseMove(e); // Already handled by its own listener
            isDraggingObject = false; // Ensure object drag state is off
            return;
        }
        // --- End Mesh Drag Check ---

        // --- Layout Rectangle Cursor Updates ---
        if (!isLayoutToolActive && !isResizingLayoutRect && !isPanning && !isDraggingObject) {
            // Check if hovering over resize handles
            if (selectedLayoutRectIndex !== -1 && layoutRectangles[selectedLayoutRectIndex]) {
                const coords = getCanvasCoordinates(e);
                const worldCoords = canvasToWorld(coords.x, coords.y);
                const rect = layoutRectangles[selectedLayoutRectIndex];
                const handleSize = 8 / scale;

                const handles = [
                    { x: rect.x, y: rect.y, cursor: 'nw-resize' }, // Top-left
                    { x: rect.x + rect.width, y: rect.y, cursor: 'ne-resize' }, // Top-right
                    { x: rect.x, y: rect.y + rect.height, cursor: 'sw-resize' }, // Bottom-left
                    { x: rect.x + rect.width, y: rect.y + rect.height, cursor: 'se-resize' } // Bottom-right
                ];

                let overHandle = false;
                for (const handle of handles) {
                    if (worldCoords.x >= handle.x - handleSize/2 && worldCoords.x <= handle.x + handleSize/2 &&
                        worldCoords.y >= handle.y - handleSize/2 && worldCoords.y <= handle.y + handleSize/2) {
                        canvas.style.cursor = handle.cursor;
                        overHandle = true;
                        break;
                    }
                }

                if (!overHandle) {
                    canvas.style.cursor = '';
                }
            } else {
                canvas.style.cursor = '';
            }
        }

        // Original Mouse Move Logic (Panning or Object Drag)
        if (!isPanning && !isDraggingObject) return;
        const coords = getCanvasCoordinates(e);
        if (isPanning) {
            const dx = coords.x - panStartX;
            const dy = coords.y - panStartY;
            offsetX += dx;
            offsetY += dy;
            panStartX = coords.x;
            panStartY = coords.y;
            update();

            // Update rulers during panning for smooth visual feedback
            if (typeof updateRulers === 'function') {
                updateRulers();
            }

            // Canvas-based guidelines update automatically with canvas redraw
        } else if (isDraggingObject && selectedObjectIndex !== -1) {
            const dragDeltaX = coords.x - dragStartX;
            const dragDeltaY = coords.y - dragStartY;
            // Calculate TOTAL displacement from the start of the drag
            const totalWorldDeltaX = (coords.x - dragStartX) / scale;
            const totalWorldDeltaY = (coords.y - dragStartY) / scale;

            const draggedObject = canvasObjects[selectedObjectIndex];

            // Only log occasionally during movement to avoid performance issues
            const currentTime = performance.now();
            if (DEBUG_MODE && (currentTime - lastMovementTime > 100)) { // Log every 100ms max
                debugLog('[Masking] 🎭 Mouse move - dragging object:', {
                    id: draggedObject.id,
                    type: draggedObject.type,
                    isMasked: draggedObject.isMasked,
                    totalDeltaX: totalWorldDeltaX,
                    totalDeltaY: totalWorldDeltaY,
                    newX: dragInitialObjectX + totalWorldDeltaX,
                    newY: dragInitialObjectY + totalWorldDeltaY
                });
                lastMovementTime = currentTime;
            }

            // Update object's position based on total delta
            draggedObject.x = dragInitialObjectX + totalWorldDeltaX;
            draggedObject.y = dragInitialObjectY + totalWorldDeltaY;

            // 🔗 LINKED MOVEMENT: Handle linked text-rectangle relationships
            if (draggedObject.isTextController && draggedObject.linkedTextId) {
                // Rectangle is being moved - move the linked text
                const linkedText = canvasObjects.find(obj => obj.id === draggedObject.linkedTextId);
                if (linkedText && linkedText.isControlledByRectangle) {
                    if (!linkedText._dragInitialX) {
                        linkedText._dragInitialX = linkedText.x;
                        linkedText._dragInitialY = linkedText.y;
                    }
                    linkedText.x = linkedText._dragInitialX + totalWorldDeltaX;
                    linkedText.y = linkedText._dragInitialY + totalWorldDeltaY;
                    console.log('🔗 LINKED MOVEMENT: Moved linked text with rectangle');
                }
            } else if (draggedObject.isControlledByRectangle && draggedObject.linkedRectangleId) {
                // Text is being moved - move the linked rectangle
                const linkedRect = canvasObjects.find(obj => obj.id === draggedObject.linkedRectangleId);
                if (linkedRect && linkedRect.isTextController) {
                    if (!linkedRect._dragInitialX) {
                        linkedRect._dragInitialX = linkedRect.x;
                        linkedRect._dragInitialY = linkedRect.y;
                    }
                    linkedRect.x = linkedRect._dragInitialX + totalWorldDeltaX;
                    linkedRect.y = linkedRect._dragInitialY + totalWorldDeltaY;
                    console.log('🔗 LINKED MOVEMENT: Moved linked rectangle with text');
                }
            }

            // 🟢🔴 RECTANGLE GROUP MOVEMENT: Handle grouped rectangle movement
            if (draggedObject.groupId && draggedObject.isMasterRectangle) {
                // Green rectangle is being moved - move the red rectangle with it
                const followerRect = canvasObjects.find(obj =>
                    obj.groupId === draggedObject.groupId &&
                    !obj.isMasterRectangle &&
                    obj.masterRectangleId === draggedObject.id
                );
                if (followerRect) {
                    if (!followerRect._dragInitialX) {
                        followerRect._dragInitialX = followerRect.x;
                        followerRect._dragInitialY = followerRect.y;
                    }
                    // Move follower maintaining its relative offset
                    followerRect.x = followerRect._dragInitialX + totalWorldDeltaX;
                    followerRect.y = followerRect._dragInitialY + totalWorldDeltaY;
                    console.log('🟢🔴 RECTANGLE GROUP: Moved red rectangle with green rectangle');
                }
            }

            // --- Handle mask relationships when objects are moved ---
            // For masked images, we need to move the mask shape to maintain the same relative position
            if (draggedObject.type === 'image' && draggedObject.isMasked && draggedObject.maskShape) {
                // Store initial mask position if not already stored
                if (!draggedObject.maskShape._dragInitialX) {
                    draggedObject.maskShape._dragInitialX = draggedObject.maskShape.x;
                    draggedObject.maskShape._dragInitialY = draggedObject.maskShape.y;
                    debugLog('[Masking] 🎭 Stored initial mask position:', {
                        maskId: draggedObject.maskShape.id,
                        initialX: draggedObject.maskShape._dragInitialX,
                        initialY: draggedObject.maskShape._dragInitialY
                    });
                }

                // Move mask shape by the same total delta
                draggedObject.maskShape.x = draggedObject.maskShape._dragInitialX + totalWorldDeltaX;
                draggedObject.maskShape.y = draggedObject.maskShape._dragInitialY + totalWorldDeltaY;

                performanceLog('[Masking] 🎭 Synchronized mask movement:', {
                    maskId: draggedObject.maskShape.id,
                    newMaskX: draggedObject.maskShape.x,
                    newMaskY: draggedObject.maskShape.y,
                    imageX: draggedObject.x,
                    imageY: draggedObject.y
                });
            }

            // For mask shapes being dragged, move all images that use this mask
            if (draggedObject.type === 'image' && draggedObject.isMaskShape) {
                performanceLog('[Masking] 🎭 Dragging mask shape, finding associated images');
                canvasObjects.forEach(obj => {
                    if (obj.type === 'image' && obj.isMasked && obj.maskShapeId === draggedObject.id) {
                        // Store initial image position if not already stored
                        if (!obj._dragInitialX) {
                            obj._dragInitialX = obj.x;
                            obj._dragInitialY = obj.y;
                            debugLog('[Masking] 🎭 Stored initial image position for mask movement:', {
                                imageId: obj.id,
                                initialX: obj._dragInitialX,
                                initialY: obj._dragInitialY
                            });
                        }

                        // Move image by the same total delta
                        obj.x = obj._dragInitialX + totalWorldDeltaX;
                        obj.y = obj._dragInitialY + totalWorldDeltaY;

                        performanceLog('[Masking] 🎭 Synchronized image movement with mask:', {
                            imageId: obj.id,
                            newImageX: obj.x,
                            newImageY: obj.y,
                            maskX: draggedObject.x,
                            maskY: draggedObject.y
                        });
                    }
                });
            }

            // --- BEGIN FIX V2: Update mesh control points based on total delta ---
            if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler &&
                activeMeshWarpHandler.selectedTextObject === draggedObject &&
                dragInitialControlPoints && // Check if we stored initial points
                activeMeshWarpHandler.controlPoints &&
                dragInitialControlPoints.length === activeMeshWarpHandler.controlPoints.length) {

                // Set current points based on their initial drag position + total delta
                for (let i = 0; i < activeMeshWarpHandler.controlPoints.length; i++) {
                    if (dragInitialControlPoints[i]) { // Check if specific initial point exists
                       activeMeshWarpHandler.controlPoints[i].x = dragInitialControlPoints[i].x + totalWorldDeltaX;
                       activeMeshWarpHandler.controlPoints[i].y = dragInitialControlPoints[i].y + totalWorldDeltaY;
                    }
                }
                // console.log("Updated mesh points based on total drag delta"); // Optional log
            }
            // --- END FIX V2 ---

            update();
        }

        // --- Cursor Feedback for Guidelines (when not dragging anything and guidelines are visible) ---
        if (!isDraggingObject && !isDraggingGuideline && !isDraggingGridPoint && !isPanning && areGuidelinesVisible) {
            const coords = getCanvasCoordinates(e);
            const worldCoords = canvasToWorld(coords.x, coords.y);
            const hitGuideline = getGuidelineAtPoint(worldCoords.x, worldCoords.y);

            if (hitGuideline) {
                canvas.style.cursor = hitGuideline.type === 'horizontal' ? 'ns-resize' : 'ew-resize';
            } else {
                canvas.style.cursor = 'default';
            }
        }
    }
   function handleMouseUp(e) {
       // --- Layout Tool Drawing FIRST ---
       if (isLayoutToolActive && isDrawingLayoutRect) {
           const coords = getCanvasCoordinates(e);
           const worldCoords = canvasToWorld(coords.x, coords.y);

           // Apply snap-to-guidelines for final position
           console.log('🧲 [Snap] === CALLING snapToGuidelines for MOUSE UP ===');
           const snappedCoords = snapToGuidelines(worldCoords.x, worldCoords.y);

           // Create the final layout rectangle
           const newRect = {
               x: Math.min(layoutRectStartX, snappedCoords.x),
               y: Math.min(layoutRectStartY, snappedCoords.y),
               width: Math.abs(snappedCoords.x - layoutRectStartX),
               height: Math.abs(snappedCoords.y - layoutRectStartY),
               id: Date.now() // Unique ID for each rectangle
           };

           if (snappedCoords.x !== worldCoords.x || snappedCoords.y !== worldCoords.y) {
               console.log('🧲 [Snap] Final position snapped from:', worldCoords.x, worldCoords.y, 'to:', snappedCoords.x, snappedCoords.y);
           }

           // Only add if rectangle has meaningful size
           if (newRect.width > 10 && newRect.height > 10) {
               layoutRectangles.push(newRect);
               window.layoutRectangles = layoutRectangles; // Update global reference
               console.log('[LayoutTool] Created new layout rectangle:', newRect);
           }

           // Reset drawing state
           isDrawingLayoutRect = false;
           window.currentDrawingLayoutRect = null;
           update();
           return;
       }

       // --- Check Grid Point Drag FIRST ---
       if (isDraggingGridPoint) {
           isDraggingGridPoint = false;
           draggedPointRow = -1;
           draggedPointCol = -1;
           draggedObject = null;
           canvas.classList.remove('dragging-grid-point');
           update();
           return;
       }

       // --- Check Guideline Drag ---
       if (isDraggingGuideline) {
           isDraggingGuideline = false;
           draggedGuideline = null;
           canvas.style.cursor = 'default';
           console.log('🔧 Stopped dragging guideline');
           update();
           return;
       }

       // 🔗 RECTANGLE RESIZE CLEANUP: Stop resizing rectangle
       if (isResizingRectangle) {
           isResizingRectangle = false;
           resizeHandle = null;
           resizeInitialWidth = 0;
           resizeInitialHeight = 0;
           resizeInitialX = 0;
           resizeInitialY = 0;
           console.log('🔗 RESIZE: Stopped resizing rectangle');
           update();
           return;
       }

       // --- Layout Rectangle Resizing ---
       if (isResizingLayoutRect) {
           isResizingLayoutRect = false;
           layoutResizeCorner = null;
           console.log('[LayoutTool] Stopped resizing layout rectangle');
           return;
       }

       // --- Check Mesh Drag NEXT ---
       if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler && activeMeshWarpHandler.isDragging) {
           // Let the mesh handler finish its drag
           // activeMeshWarpHandler.handleMouseUp(e); // Already handled by its own listener
           // No need to return early, just ensure object drag state is correct below
       }
       // --- End Mesh Drag Check ---

       if (isPanning) {
           isPanning = false;
           canvasArea.classList.remove('panning');

           // Update rulers after panning
           if (typeof updateRulers === 'function') {
               updateRulers();
           }

           // Canvas-based guidelines update automatically with canvas redraw
       }
       if (isDraggingObject) {
           isDraggingObject = false;
           canvas.classList.remove('dragging');

           // End movement tracking for performance optimization
           isDuringMovement = false;
           const movementDuration = performance.now() - movementStartTime;
           if (DEBUG_MODE) {
               debugLog(`Movement completed in ${movementDuration.toFixed(2)}ms`);
           }

           // Clean up mask drag state
           if (selectedObjectIndex !== -1) {
               const selectedObject = canvasObjects[selectedObjectIndex];

               // Clean up for masked images
               if (selectedObject.type === 'image' && selectedObject.isMasked && selectedObject.maskShape) {
                   // Clean up temporary drag position storage for mask shape
                   delete selectedObject.maskShape._dragInitialX;
                   delete selectedObject.maskShape._dragInitialY;
                   console.log('[Masking] 🎭 Cleaned up mask drag state for masked image:', selectedObject.id);
               }

               // Clean up for mask shapes
               if (selectedObject.type === 'image' && selectedObject.isMaskShape) {
                   // Clean up temporary drag position storage for all associated images
                   canvasObjects.forEach(obj => {
                       if (obj.type === 'image' && obj.isMasked && obj.maskShapeId === selectedObject.id) {
                           delete obj._dragInitialX;
                           delete obj._dragInitialY;
                           console.log('[Masking] 🎭 Cleaned up image drag state for mask shape movement:', obj.id);
                       }
                   });
               }

               // 🔗 LINKED CLEANUP: Clean up linked text-rectangle drag state
               if (selectedObject.isTextController && selectedObject.linkedTextId) {
                   // Rectangle was moved - clean up linked text drag state
                   const linkedText = canvasObjects.find(obj => obj.id === selectedObject.linkedTextId);
                   if (linkedText) {
                       delete linkedText._dragInitialX;
                       delete linkedText._dragInitialY;
                       console.log('🔗 LINKED CLEANUP: Cleaned up linked text drag state');
                   }
               } else if (selectedObject.isControlledByRectangle && selectedObject.linkedRectangleId) {
                   // Text was moved - clean up linked rectangle drag state
                   const linkedRect = canvasObjects.find(obj => obj.id === selectedObject.linkedRectangleId);
                   if (linkedRect) {
                       delete linkedRect._dragInitialX;
                       delete linkedRect._dragInitialY;
                       console.log('🔗 LINKED CLEANUP: Cleaned up linked rectangle drag state');
                   }
               }

               // Save state for undo/redo when object movement ends
               saveState(`Move ${selectedObject.type === 'text' ? 'Text' : 'Image'}`);
           }
       }
       // Ensure mesh dragging state is also reset if mouseup happens here
       if (typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler) {
             activeMeshWarpHandler.isDragging = false;
             activeMeshWarpHandler.draggingPointIndex = -1;
        }
        // --- BEGIN FIX V2: Clear stored initial points on mouse up ---
        dragInitialControlPoints = null;
        // --- END FIX V2 ---
    }
   function handleMouseLeave(e) {
        // Call mouse up to stop any dragging if mouse leaves canvas
        handleMouseUp(e);
   }
   function handleWheel(e) {
       e.preventDefault();
       const coords = getCanvasCoordinates(e);
       const worldPosBeforeZoom = canvasToWorld(coords.x, coords.y);
       const delta = -e.deltaY * ZOOM_SENSITIVITY;
       const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * Math.exp(delta)));
       offsetX = coords.x - worldPosBeforeZoom.x * newScale;
       offsetY = coords.y - worldPosBeforeZoom.y * newScale;
       scale = newScale;
       window.scale = scale;
       window.offsetX = offsetX;
       window.offsetY = offsetY;
       update();

       // Update rulers after wheel zoom
       if (typeof updateRulers === 'function') {
           updateRulers();
       }

       // Canvas-based guidelines update automatically with canvas redraw
   }
   // --- MULTI-SELECT FUNCTIONS ---
   function clearMultiSelection() {
       selectedObjectIndices.forEach(index => {
           if (canvasObjects[index]) {
               canvasObjects[index].isSelected = false;
           }
       });
       selectedObjectIndices = [];
   }

   function updateAlignmentUI() {
       const alignmentControls = document.getElementById('alignment-controls');
       const alignmentSeparator = document.getElementById('alignment-separator');
       const selectedCount = document.getElementById('selected-count');

       if (isMultiSelectMode && selectedObjectIndices.length > 1) {
           alignmentControls.style.display = 'inline-flex';
           alignmentSeparator.style.display = 'block';
           selectedCount.textContent = `${selectedObjectIndices.length} objects selected`;
           showMultiSelectHint();
       } else {
           alignmentControls.style.display = 'none';
           alignmentSeparator.style.display = 'none';
       }
   }

   function showMultiSelectHint() {
       // Remove existing hint if any
       const existingHint = document.querySelector('.multi-select-hint');
       if (existingHint) {
           existingHint.remove();
       }

       // Create and show hint
       const hint = document.createElement('div');
       hint.className = 'multi-select-hint';
       hint.textContent = 'Hold Shift + Click to select multiple objects';
       document.body.appendChild(hint);

       // Auto-remove after 3 seconds
       setTimeout(() => {
           if (hint.parentNode) {
               hint.remove();
           }
       }, 3000);
   }

   // --- ALIGNMENT FUNCTIONS ---
   function alignLeft() {
       if (!isMultiSelectMode || selectedObjectIndices.length < 2) return;

       // Find the leftmost position
       let leftmostX = Infinity;
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           const bounds = calculateObjectBounds(obj);
           leftmostX = Math.min(leftmostX, bounds.x);
       });

       // Align all objects to the leftmost position
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           const bounds = calculateObjectBounds(obj);
           const deltaX = leftmostX - bounds.x;
           obj.x += deltaX;
       });

       update();
       saveState('Align Left');
   }

   function alignCenter() {
       if (!isMultiSelectMode || selectedObjectIndices.length < 2) return;

       // Calculate the center of all selected objects
       let totalCenterX = 0;
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           totalCenterX += obj.x;
       });
       const averageCenterX = totalCenterX / selectedObjectIndices.length;

       // Align all objects to the average center
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           obj.x = averageCenterX;
       });

       update();
       saveState('Align Center');
   }

   function alignRight() {
       if (!isMultiSelectMode || selectedObjectIndices.length < 2) return;

       // Find the rightmost position
       let rightmostX = -Infinity;
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           const bounds = calculateObjectBounds(obj);
           rightmostX = Math.max(rightmostX, bounds.x + bounds.width);
       });

       // Align all objects to the rightmost position
       selectedObjectIndices.forEach(index => {
           const obj = canvasObjects[index];
           const bounds = calculateObjectBounds(obj);
           const deltaX = rightmostX - (bounds.x + bounds.width);
           obj.x += deltaX;
       });

       update();
       saveState('Align Right');
   }

   function zoom(factor, centerOnCanvas = true) {
       let centerX, centerY;
       if(centerOnCanvas){
           centerX = canvas.clientWidth / 2;
           centerY = canvas.clientHeight / 2;
       } else {
           centerX = panStartX ?? canvas.clientWidth / 2;
           centerY = panStartY ?? canvas.clientHeight / 2;
       }
       const worldPosBeforeZoom = canvasToWorld(centerX, centerY);
       const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor));
       offsetX = centerX - worldPosBeforeZoom.x * newScale;
       offsetY = centerY - worldPosBeforeZoom.y * newScale;
       scale = newScale;
       window.scale = scale;
       window.offsetX = offsetX;
       window.offsetY = offsetY;
       update();

       // Update rulers after zoom
       if (typeof updateRulers === 'function') {
           updateRulers();
       }

       // Canvas-based guidelines update automatically with canvas redraw
   }

   // Attach Input Listeners
   iText.oninput = () => {
       console.log('🔤 ===== TEXT INPUT FLOW START =====');
       console.log('🔤 TEXT INPUT CHANGED: value =', iText.value);
       console.log('🔤 TEXT INPUT CHANGED: selectedObjectIndex =', selectedObjectIndex);
       console.log('🔤 TEXT INPUT CHANGED: canvasObjects.length =', canvasObjects.length);

       // Only update if we have a selected text object
       if (selectedObjectIndex !== -1 &&
           selectedObjectIndex < canvasObjects.length &&
           canvasObjects[selectedObjectIndex] &&
           canvasObjects[selectedObjectIndex].type === 'text') {

           const selectedText = canvasObjects[selectedObjectIndex];
           console.log('🔤 TEXT INPUT CHANGED: Updating selected text object:', selectedText.id, 'old text:', selectedText.text, 'new text:', iText.value);
           console.log('🔤 TEXT INPUT CHANGED: Current textBoxWidth:', selectedText.textBoxWidth);
           console.log('🔤 TEXT INPUT CHANGED: Current textAlign:', selectedText.textAlign);
           updateSelectedObjectFromUI('text', iText.value);
           console.log('🔤 ===== TEXT INPUT FLOW END =====');
       } else {
           console.log('🔤 TEXT INPUT CHANGED: No valid text object selected, ignoring input change');
       }
   }; addEditTextBtn.onclick = () => {
       console.log('🔘 ADD/EDIT BUTTON CLICKED');
       console.log('🔘 selectedObjectIndex =', selectedObjectIndex);
       console.log('🔘 canvasObjects.length =', canvasObjects.length);

       if (selectedObjectIndex !== -1 &&
           selectedObjectIndex < canvasObjects.length &&
           canvasObjects[selectedObjectIndex] &&
           canvasObjects[selectedObjectIndex].type === 'text') {

           console.log('🔘 EDIT MODE: Focusing text input for selected text object:', canvasObjects[selectedObjectIndex].id);
           iText.focus();
       } else {
           console.log('🔘 ADD MODE: Creating new text object');
           handleAddTextObject();
       }
   }; deleteTextBtn.onclick = handleDeleteObject; iTextColor.oninput = (e) => updateSelectedObjectFromUI('color', e.target.value);

   // Text Box Width control
   if (iTextBoxWidth && textBoxWidthValue) {
       console.log('📦 Setting up iTextBoxWidth event handler');

       // Update display value when slider changes
       iTextBoxWidth.oninput = (e) => {
           const value = parseInt(e.target.value, 10);
           textBoxWidthValue.textContent = value === 0 ? '0 (unlimited)' : `${value} characters`;
           console.log('📦 Text box width changed to:', value);
           updateSelectedObjectFromUI('textBoxWidth', value);
       };
   } else {
       console.log('📦 iTextBoxWidth or textBoxWidthValue element not found!');
   }

   // Text Alignment controls
   const alignmentButtons = document.querySelectorAll('.alignment-btn');
   if (alignmentButtons.length > 0) {
       console.log('📝 Setting up text alignment buttons');

       alignmentButtons.forEach(button => {
           button.addEventListener('click', (e) => {
               const alignment = e.currentTarget.getAttribute('data-align');
               console.log('📝 ===== ALIGNMENT BUTTON FLOW START =====');
               console.log('📝 Text alignment button clicked:', alignment);
               console.log('📝 selectedObjectIndex:', selectedObjectIndex);

               if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex]) {
                   const selectedObj = canvasObjects[selectedObjectIndex];
                   console.log('📝 Selected object before alignment change:', {
                       id: selectedObj.id,
                       text: selectedObj.text,
                       textAlign: selectedObj.textAlign,
                       textBoxWidth: selectedObj.textBoxWidth,
                       x: selectedObj.x,
                       y: selectedObj.y
                   });
               }

               // Update button states
               alignmentButtons.forEach(btn => btn.classList.remove('active'));
               e.currentTarget.classList.add('active');

               // Update selected object
               updateSelectedObjectFromUI('textAlign', alignment);
               console.log('📝 ===== ALIGNMENT BUTTON FLOW END =====');
           });
       });
   } else {
       console.log('📝 Text alignment buttons not found!');
   }

   // Line Height control
   if (iLineHeight && lineHeightValue) {
       console.log('📏 Setting up line height control');

       // Update display value when slider changes
       iLineHeight.oninput = (e) => {
           const value = parseFloat(e.target.value);
           lineHeightValue.textContent = `${value}x`;
           console.log('📏 Line height changed to:', value);
           updateSelectedObjectFromUI('lineHeight', value);
       };
   } else {
       console.log('📏 Line height control elements not found!');
   }

   // Color Intensity control for text
   if (iTextColorIntensity) {
       console.log('🔧 Setting up iTextColorIntensity event handler');
       iTextColorIntensity.onchange = (e) => {
           console.log('🔧 iTextColorIntensity changed to:', e.target.value);
           console.log('🔧 selectedObjectIndex:', selectedObjectIndex);
           console.log('🔧 canvasObjects length:', canvasObjects.length);

           updateSelectedObjectFromUI('colorIntensity', e.target.value);
           // Update persistent value and save to database if changed from N/A
           if (selectedObjectIndex !== -1) {
               const selectedObject = canvasObjects[selectedObjectIndex];
               console.log('🔧 Selected object:', selectedObject);
               console.log('🔧 Selected object ID:', selectedObject.id);
               console.log('🔧 Selected object type:', selectedObject.type);

               const oldValue = selectedObject.newColorIntensity;
               selectedObject.newColorIntensity = e.target.value;

               // Update debug display
               const debugNewColorIntensity = document.getElementById('debugNewColorIntensity');
               if (debugNewColorIntensity) {
                   debugNewColorIntensity.textContent = e.target.value;
               }

               // Save to database if value changed from N/A to something else
               console.log('💾 Color Intensity change - oldValue:', oldValue, 'newValue:', e.target.value);
               console.log('💾 Selected object:', selectedObject);
               console.log('💾 Conditions check:', {
                   'oldValue === N/A': oldValue === 'N/A',
                   'newValue !== N/A': e.target.value !== 'N/A',
                   'oldValue !== N/A': oldValue !== 'N/A',
                   'newValue !== oldValue': e.target.value !== oldValue
               });

               if ((oldValue === 'N/A' && e.target.value !== 'N/A') ||
                   (oldValue !== 'N/A' && e.target.value !== oldValue)) {
                   console.log('💾 Saving color intensity:', e.target.value);
                   savePersistentParameter(selectedObject.id, 'newColorIntensity', e.target.value);
               } else {
                   console.log('💾 Not saving - conditions not met');
               }
           } else {
               console.log('🔧 No object selected, not saving');
           }
       };
   } else {
       console.log('🔧 iTextColorIntensity element not found!');
   } iFontFamily.onchange = (e) => {
       updateSelectedObjectFromUI('fontFamily', e.target.value);

       // FONT VARIANT SYSTEM: Update Bold/Italic controls when font family changes
       if (window.fontVariantDetector && window.fontVariantDetector.initialized) {
           window.fontVariantDetector.updateVariantControls(e.target.value);
       }
   }; iBold.onchange = (e) => updateSelectedObjectFromUI('bold', e.target.checked); iItalic.onchange = (e) => updateSelectedObjectFromUI('italic', e.target.checked); iFontSize.oninput = (e) => updateSelectedObjectFromUI('fontSize', parseInt(e.target.value, 10));

   // Letter spacing and opacity controls
   const iLetterSpacing = document.getElementById('iLetterSpacing');
   const iOpacity = document.getElementById('iOpacity');

   if (iLetterSpacing) {
       iLetterSpacing.oninput = (e) => updateSelectedObjectFromUI('letterSpacing', parseInt(e.target.value, 10));
   }

   // Shrink text box button
   const btnShrinkTextBox = document.getElementById('btnShrinkTextBox');
   if (btnShrinkTextBox) {
       btnShrinkTextBox.onclick = () => shrinkTextBoxToFitText();
   }

   // Draw fitting rectangle button
   const btnDrawFittingRectangle = document.getElementById('btnDrawFittingRectangle');
   if (btnDrawFittingRectangle) {
       btnDrawFittingRectangle.onclick = () => drawFittingRectangleAroundText();
   }

   // Draw fitting rectangle button for shapes/images
   const btnDrawFittingRectangleShape = document.getElementById('btnDrawFittingRectangleShape');
   if (btnDrawFittingRectangleShape) {
       btnDrawFittingRectangleShape.onclick = () => drawFittingRectangleAroundShape();
   }

   // Clean all rectangles button
   const btnCleanRectangles = document.getElementById('btnCleanRectangles');
   if (btnCleanRectangles) {
       btnCleanRectangles.onclick = () => cleanAllRectangles();
   }

   // Rectangle scale slider
   const rectangleScale = document.getElementById('rectangleScale');
   const rectangleScaleValue = document.getElementById('rectangleScaleValue');
   if (rectangleScale && rectangleScaleValue) {
       rectangleScale.oninput = (e) => {
           const scale = parseFloat(e.target.value);
           rectangleScaleValue.textContent = scale.toFixed(1) + 'x';
           scaleRectangleGroup(scale);
       };
   }

   // Fit green rectangle inside layout button
   const btnFitGreenRectangle = document.getElementById('btnFitGreenRectangle');
   if (btnFitGreenRectangle) {
       btnFitGreenRectangle.onclick = () => fitGreenRectangleInLayout();
   }

   if (iOpacity) {
       iOpacity.oninput = (e) => updateSelectedObjectFromUI('opacity', parseInt(e.target.value, 10));
   }

   // Main rotation slider
   iTextRotation.oninput = (e) => {
       const rotationValue = parseInt(e.target.value, 10);
       updateSelectedObjectFromUI('rotation', rotationValue);
       // Sync with circular rotation slider if it exists
       if (document.getElementById('iCircleRotation')) {
           document.getElementById('iCircleRotation').value = rotationValue;
           document.getElementById('vCircleRotation').textContent = rotationValue + '°';
       }
   };

   effectModeSelect.onchange = (e) => updateSelectedObjectFromUI('effectMode', e.target.value); skewSlider.oninput = (e) => updateSelectedObjectFromUI('skewX', parseInt(e.target.value, 10)); skewYSlider.oninput = (e) => updateSelectedObjectFromUI('skewY', parseInt(e.target.value, 10)); iCurve.oninput = (e) => updateSelectedObjectFromUI('warpCurve', parseInt(e.target.value, 10)); iOffset.oninput = (e) => updateSelectedObjectFromUI('warpOffset', parseInt(e.target.value, 10)); iHeight.oninput = (e) => updateSelectedObjectFromUI('warpHeight', parseInt(e.target.value, 10)); iBottom.oninput = (e) => updateSelectedObjectFromUI('warpBottom', parseInt(e.target.value, 10)); iTriangle.onchange = (e) => updateSelectedObjectFromUI('warpTriangle', e.target.checked); iShiftCenter.oninput = (e) => updateSelectedObjectFromUI('warpShiftCenter', parseInt(e.target.value, 10)); iDiameter.oninput = (e) => updateSelectedObjectFromUI('circleDiameter', parseInt(e.target.value, 10)); iKerning.oninput = (e) => updateSelectedObjectFromUI('circleKerning', parseInt(e.target.value, 10));

   // Circular rotation slider
   const iCircleRotation = document.getElementById('iCircleRotation');
   if (iCircleRotation) {
       iCircleRotation.oninput = (e) => {
           const rotationValue = parseInt(e.target.value, 10);
           updateSelectedObjectFromUI('rotation', rotationValue);
           // Sync with main rotation slider
           iTextRotation.value = rotationValue;
           vTextRotation.textContent = rotationValue + '°';
           document.getElementById('vCircleRotation').textContent = rotationValue + '°';
       };
   }

   iFlip.onchange = (e) => updateSelectedObjectFromUI('circleFlip', e.target.checked); iCurveAmount.oninput = (e) => updateSelectedObjectFromUI('curveAmount', parseInt(e.target.value, 10)); iCurveKerning.oninput = (e) => updateSelectedObjectFromUI('curveKerning', parseInt(e.target.value, 10)); iCurveFlip.onchange = (e) => updateSelectedObjectFromUI('curveFlip', e.target.checked);

   // Perspective Shadow Outline controls
   const perspectiveShadowOutlineColorPicker = document.getElementById('perspectiveShadowOutlineColor');
   const perspectiveShadowOutlineOpacitySlider = document.getElementById('perspectiveShadowOutlineOpacity');
   const perspectiveShadowOutlineWidthSlider = document.getElementById('perspectiveShadowOutlineWidth');
   const perspectiveShadowOutlineOffsetXSlider = document.getElementById('perspectiveShadowOutlineOffsetX');
   const perspectiveShadowOutlineOffsetYSlider = document.getElementById('perspectiveShadowOutlineOffsetY');

   if (perspectiveShadowOutlineColorPicker) perspectiveShadowOutlineColorPicker.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOutlineColor', e.target.value);
   if (perspectiveShadowOutlineOpacitySlider) perspectiveShadowOutlineOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOutlineOpacity', parseInt(e.target.value, 10));
   if (perspectiveShadowOutlineWidthSlider) perspectiveShadowOutlineWidthSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOutlineWidth', parseInt(e.target.value, 10));
   if (perspectiveShadowOutlineOffsetXSlider) perspectiveShadowOutlineOffsetXSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOutlineOffsetX', parseInt(e.target.value, 10));
   if (perspectiveShadowOutlineOffsetYSlider) perspectiveShadowOutlineOffsetYSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOutlineOffsetY', parseInt(e.target.value, 10));

   // Grid Distort controls
   const iGridDistortCols = document.getElementById('iGridDistortCols');
   const iGridDistortRows = document.getElementById('iGridDistortRows');
   const iGridDistortPadding = document.getElementById('iGridDistortPadding');
   const iGridDistortIntensity = document.getElementById('iGridDistortIntensity');
   const gridDistortDirectionBoth = document.getElementById('gridDistortDirectionBoth');
   const gridDistortDirectionVertical = document.getElementById('gridDistortDirectionVertical');
   const resetGridDistortBtn = document.getElementById('resetGridDistortBtn');
   const toggleGridDistortBtn = document.getElementById('toggleGridDistortBtn');

   if (iGridDistortCols) iGridDistortCols.oninput = (e) => updateSelectedObjectFromUI('gridDistortCols', parseInt(e.target.value, 10));
   if (iGridDistortRows) iGridDistortRows.oninput = (e) => updateSelectedObjectFromUI('gridDistortRows', parseInt(e.target.value, 10));
   if (iGridDistortPadding) iGridDistortPadding.oninput = (e) => updateSelectedObjectFromUI('gridDistortPadding', parseInt(e.target.value, 10));
   if (iGridDistortIntensity) iGridDistortIntensity.oninput = (e) => updateSelectedObjectFromUI('gridDistortIntensity', parseInt(e.target.value, 10));
   if (gridDistortDirectionBoth) gridDistortDirectionBoth.onchange = (e) => {
       if (e.target.checked) {
           updateSelectedObjectFromUI('gridDistortVerticalOnly', false);
       }
   };
   if (gridDistortDirectionVertical) gridDistortDirectionVertical.onchange = (e) => {
       if (e.target.checked) {
           updateSelectedObjectFromUI('gridDistortVerticalOnly', true);
       }
   };

   if (resetGridDistortBtn) {
       resetGridDistortBtn.onclick = () => {
           if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex].type === 'text') {
               const selectedObject = canvasObjects[selectedObjectIndex];
               if (selectedObject.gridDistort) {
                   // Reset grid points to their initial positions
                   initializeGridPoints(selectedObject);
                   update();
               }
           }
       };
   }

   if (toggleGridDistortBtn) {
       toggleGridDistortBtn.onclick = () => {
           if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex].type === 'text') {
               const selectedObject = canvasObjects[selectedObjectIndex];

               // Initialize gridDistort if it doesn't exist
               if (!selectedObject.gridDistort) {
                   console.log('Creating gridDistort object for text:', selectedObject.text);
                   selectedObject.gridDistort = {
                       gridCols: selectedObject.gridDistortCols || 3,
                       gridRows: selectedObject.gridDistortRows || 2,
                       gridPadding: selectedObject.gridDistortPadding || 120,
                       intensity: (selectedObject.gridDistortIntensity || 100) / 100,
                       controlPoints: [],
                       showGrid: true,
                       lastFontSize: selectedObject.fontSize,
                       lastText: selectedObject.text,
                       relativeControlPoints: []
                   };

                   // Initialize grid points
                   initializeGridPoints(selectedObject);
               }

               // Toggle grid visibility
               selectedObject.gridDistort.showGrid = !selectedObject.gridDistort.showGrid;
               console.log('Grid visibility toggled:', selectedObject.gridDistort.showGrid);

               // Update button text to reflect current state
               toggleGridDistortBtn.textContent = selectedObject.gridDistort.showGrid ? 'Hide Grid' : 'Show Grid';

               // Show a tooltip to inform the user that the grid is only visible when the text is selected
               if (selectedObject.gridDistort.showGrid) {
                   console.log('Grid will only be visible when this text object is selected');
                   // If there's a toast function available, use it
                   if (typeof window.showToast === 'function') {
                       window.showToast('Grid will only be visible when this text is selected', 'info');
                   }
               }

               // Force effect mode to grid-distort if it's not already
               if (selectedObject.effectMode !== 'grid-distort') {
                   selectedObject.effectMode = 'grid-distort';
                   if (effectModeSelect) {
                       effectModeSelect.value = 'grid-distort';
                   }
                   updateBodyClass(selectedObject);
               }

               // Make sure grid points are initialized if they don't exist
               if (!selectedObject.gridDistort.controlPoints ||
                   selectedObject.gridDistort.controlPoints.length === 0) {
                   initializeGridPoints(selectedObject);
               }

               update();
           }
       };

       // Initialize button text based on current state
       if (selectedObjectIndex !== -1 &&
           canvasObjects[selectedObjectIndex].type === 'text') {

           // Make sure gridDistort exists
           if (!canvasObjects[selectedObjectIndex].gridDistort) {
               canvasObjects[selectedObjectIndex].gridDistort = {
                   gridCols: canvasObjects[selectedObjectIndex].gridDistortCols || 3,
                   gridRows: canvasObjects[selectedObjectIndex].gridDistortRows || 2,
                   gridPadding: canvasObjects[selectedObjectIndex].gridDistortPadding || 120,
                   intensity: (canvasObjects[selectedObjectIndex].gridDistortIntensity || 100) / 100,
                   controlPoints: [],
                   showGrid: true,
                   lastFontSize: canvasObjects[selectedObjectIndex].fontSize,
                   lastText: canvasObjects[selectedObjectIndex].text,
                   relativeControlPoints: []
               };
           }

           // Set button text based on grid visibility
           toggleGridDistortBtn.textContent = canvasObjects[selectedObjectIndex].gridDistort.showGrid ?
               'Hide Grid' : 'Show Grid';
       } else {
           // Default text when no text object is selected
           toggleGridDistortBtn.textContent = 'Show Grid';
       }
   }

   // Effect mode control
   effectModeSelect.onchange = (e) => {
       const newMode = e.target.value;
       updateSelectedObjectFromUI('effectMode', newMode);

       // If switching to grid-distort, make sure grid is initialized
       if (newMode === 'grid-distort' && selectedObjectIndex !== -1) {
           const selectedObject = canvasObjects[selectedObjectIndex];
           if (selectedObject && selectedObject.type === 'text') {
               console.log('Switching to grid-distort mode, initializing grid');

               // Set default values for Grid Distort
               selectedObject.gridDistortCols = 2;
               selectedObject.gridDistortRows = 1;
               selectedObject.gridDistortPadding = 120;
               selectedObject.gridDistortIntensity = 100;
               selectedObject.gridDistortVerticalOnly = true;

               // Update UI to reflect these values
               if (iGridDistortCols) {
                   iGridDistortCols.value = 2;
                   document.getElementById('vGridDistortCols').textContent = '2';
               }
               if (iGridDistortRows) {
                   iGridDistortRows.value = 1;
                   document.getElementById('vGridDistortRows').textContent = '1';
               }
               if (iGridDistortPadding) {
                   iGridDistortPadding.value = 120;
                   document.getElementById('vGridDistortPadding').textContent = '120px';
               }
               if (iGridDistortIntensity) {
                   iGridDistortIntensity.value = 100;
                   document.getElementById('vGridDistortIntensity').textContent = '100%';
               }
               if (gridDistortDirectionVertical && gridDistortDirectionBoth) {
                   gridDistortDirectionVertical.checked = true;
                   gridDistortDirectionBoth.checked = false;
               }

               // Initialize grid if not already initialized
               if (!selectedObject.gridDistort ||
                   !selectedObject.gridDistort.controlPoints ||
                   selectedObject.gridDistort.controlPoints.length === 0) {

                   initializeGridPoints(selectedObject);
                   console.log('Grid initialized for text:', selectedObject.text);
               }

               // Make sure the grid is visible by default
               if (selectedObject.gridDistort) {
                   selectedObject.gridDistort.showGrid = true;

                   // Update the toggle button text
                   if (toggleGridDistortBtn) {
                       toggleGridDistortBtn.textContent = 'Hide Grid';
                   }
               }
           }
       }

       // If switching to mesh warp, make sure the mesh handler is initialized
       // This is handled by the event listener in mesh-warp-implementation.js,
       // but we need to force an update to make sure the grid appears immediately
       if (newMode === 'mesh') {
           // Force a redraw to ensure the mesh grid appears
           update();
       }
   };

   // Shadow controls
   shadowSelect.onchange = (e) => {
       console.log('=== SHADOW MODE CHANGE DEBUG ===');
       const shadowMode = e.target.value;
       console.log('Shadow mode changed to:', shadowMode);

       // Check if we have a selected object
       if (selectedObjectIndex === -1) {
           console.error('No object selected when changing shadow mode!');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       console.log('Selected object before update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       updateSelectedObjectFromUI('shadowMode', shadowMode);

       console.log('Selected object after update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       // Enable/disable the perspective toggle based on shadow mode
       if (blockShadowPerspective) {
           blockShadowPerspective.disabled = (shadowMode !== 'blockShadow');
           console.log('Perspective toggle disabled:', blockShadowPerspective.disabled);

           // If switching to block shadow and perspective was previously enabled, make sure it's still checked
           if (shadowMode === 'blockShadow' && selectedObject.blockShadowPerspective) {
               console.log('Ensuring perspective checkbox is checked');
               blockShadowPerspective.checked = true;

               // Show the perspective control
               const perspectiveControl = document.querySelector('.perspective-control');
               if (perspectiveControl) {
                   perspectiveControl.style.display = 'block';
                   console.log('Perspective control display set to: block');
               }
           }
       } else {
           console.error('Could not find blockShadowPerspective checkbox!');
       }

       // Show/hide shadow controls based on shadow mode
       // Only hide shadow-related parameter controls, not all parameter controls
       document.querySelectorAll('.shadow-param, .block-shadow-param, .perspective-shadow-param, .line-shadow-param, .detailed-3d-param').forEach(el => {
           el.style.display = 'none';
       });

       if (shadowMode === 'shadow') {
           const control = document.querySelector('.shadow-param');
           if (control) {
               control.style.display = 'block';
               console.log('Showing shadow-param controls');
           } else {
               console.error('Could not find shadow-param element!');
           }
       } else if (shadowMode === 'blockShadow') {
           const control = document.querySelector('.block-shadow-param');
           if (control) {
               control.style.display = 'block';
               console.log('Showing block-shadow-param controls');
           } else {
               console.error('Could not find block-shadow-param element!');
           }
       } else if (shadowMode === 'perspectiveShadow') {
           const control = document.querySelector('.perspective-shadow-param');
           if (control) {
               control.style.display = 'block';
               console.log('Showing perspective-shadow-param controls');
           } else {
               console.error('Could not find perspective-shadow-param element!');
           }
       } else if (shadowMode === 'lineShadow') {
           const control = document.querySelector('.line-shadow-param');
           if (control) {
               control.style.display = 'block';
               console.log('Showing line-shadow-param controls');
           } else {
               console.error('Could not find line-shadow-param element!');
           }
       } else if (shadowMode === 'detailed3D') {
           const control = document.querySelector('.detailed-3d-param');
           if (control) {
               control.style.display = 'block';
               console.log('Showing detailed-3d-param controls');
           } else {
               console.error('Could not find detailed-3d-param element!');
           }
       }

       // Force a redraw to ensure the effect is applied
       console.log('Forcing redraw...');
       update();
       console.log('=== END SHADOW MODE CHANGE DEBUG ===');
   };
   shadowColorPicker.oninput = (e) => updateSelectedObjectFromUI('shadowColor', e.target.value);
   shadowOffsetXSlider.oninput = (e) => updateSelectedObjectFromUI('shadowOffsetX', parseInt(e.target.value, 10));
   shadowOffsetYSlider.oninput = (e) => updateSelectedObjectFromUI('shadowOffsetY', parseInt(e.target.value, 10));
   shadowBlurSlider.oninput = (e) => updateSelectedObjectFromUI('shadowBlur', parseInt(e.target.value, 10));
   blockShadowColorPicker.oninput = (e) => updateSelectedObjectFromUI('blockShadowColor', e.target.value);
   blockShadowOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('blockShadowOpacity', parseInt(e.target.value, 10));
   blockShadowOffsetSlider.oninput = (e) => updateSelectedObjectFromUI('blockShadowOffset', parseInt(e.target.value, 10));
   blockShadowAngleSlider.oninput = (e) => updateSelectedObjectFromUI('blockShadowAngle', parseInt(e.target.value, 10));
   blockShadowBlurSlider.oninput = (e) => updateSelectedObjectFromUI('blockShadowBlur', parseInt(e.target.value, 10));
   blockShadowPerspective.onchange = (e) => {
       console.log('=== PERSPECTIVE TOGGLE DEBUG ===');
       console.log('Perspective toggle changed to:', e.target.checked);

       // Check if we have a selected object
       if (selectedObjectIndex === -1) {
           console.error('No object selected when toggling perspective!');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       console.log('Selected object before update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       // Verify shadow mode is correct
       if (selectedObject.shadowMode !== 'blockShadow') {
           console.warn('Shadow mode is not blockShadow! Current mode:', selectedObject.shadowMode);
           console.log('Forcing shadow mode to blockShadow');
           selectedObject.shadowMode = 'blockShadow';
           if (shadowSelect) {
               shadowSelect.value = 'blockShadow';
           }
       }

       updateSelectedObjectFromUI('blockShadowPerspective', e.target.checked);

       // Show/hide and enable/disable the perspective intensity slider based on the toggle
       const perspectiveControl = document.querySelector('.perspective-control');
       if (perspectiveControl) {
           perspectiveControl.style.display = e.target.checked ? 'block' : 'none';
           console.log('Perspective control display set to:', perspectiveControl.style.display);
       } else {
           console.error('Could not find perspective-control element!');
       }

       if (blockShadowPerspectiveIntensity) {
           blockShadowPerspectiveIntensity.disabled = !e.target.checked;
           console.log('Perspective intensity slider disabled:', blockShadowPerspectiveIntensity.disabled);
       } else {
           console.error('Could not find blockShadowPerspectiveIntensity element!');
       }

       // Verify the object was updated correctly
       console.log('Selected object after update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       // Force a redraw to ensure the effect is applied or removed
       console.log('Forcing redraw...');
       update();
       console.log('=== END PERSPECTIVE TOGGLE DEBUG ===');
   };
   blockShadowPerspectiveIntensity.oninput = (e) => {
       console.log('=== PERSPECTIVE INTENSITY DEBUG ===');
       const value = parseInt(e.target.value, 10);
       console.log('Perspective intensity changed to:', value);

       // Check if we have a selected object
       if (selectedObjectIndex === -1) {
           console.error('No object selected when changing perspective intensity!');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       if (selectedObject.type !== 'text') {
           console.error('Selected object is not a text object!');
           return;
       }

       console.log('Selected object before update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       // Verify shadow mode is correct
       if (selectedObject.shadowMode !== 'blockShadow') {
           console.warn('Shadow mode is not blockShadow! Current mode:', selectedObject.shadowMode);
           console.log('Forcing shadow mode to blockShadow');
           selectedObject.shadowMode = 'blockShadow';
           if (shadowSelect) {
               shadowSelect.value = 'blockShadow';
           }
       }

       // Ensure perspective is enabled
       if (!selectedObject.blockShadowPerspective) {
           console.log('Forcing perspective mode to be enabled');
           selectedObject.blockShadowPerspective = true;

           if (blockShadowPerspective) {
               blockShadowPerspective.checked = true;
               console.log('Updated checkbox state to checked');
           } else {
               console.error('Could not find blockShadowPerspective checkbox!');
           }

           // Show the perspective control
           const perspectiveControl = document.querySelector('.perspective-control');
           if (perspectiveControl) {
               perspectiveControl.style.display = 'block';
               console.log('Perspective control display set to: block');
           } else {
               console.error('Could not find perspective-control element!');
           }
       }

       console.log('Updating blockShadowPerspectiveIntensity to:', value);
       updateSelectedObjectFromUI('blockShadowPerspectiveIntensity', value);

       // Verify the object was updated correctly
       console.log('Selected object after update:', {
           id: selectedObject.id,
           text: selectedObject.text,
           shadowMode: selectedObject.shadowMode,
           blockShadowPerspective: selectedObject.blockShadowPerspective,
           blockShadowPerspectiveIntensity: selectedObject.blockShadowPerspectiveIntensity
       });

       // Force a redraw to ensure the effect is applied
       console.log('Forcing redraw...');
       update();
       console.log('=== END PERSPECTIVE INTENSITY DEBUG ===');
   };

   // Perspective Shadow controls
   const perspectiveShadowColorPicker = document.getElementById('perspectiveShadowColor');
   const perspectiveShadowOpacitySlider = document.getElementById('perspectiveShadowOpacity');
   const perspectiveShadowOffsetSlider = document.getElementById('perspectiveShadowOffset');
   const perspectiveShadowAngleSlider = document.getElementById('perspectiveShadowAngle');
   const perspectiveShadowBlurSlider = document.getElementById('perspectiveShadowBlur');
   const perspectiveShadowIntensitySlider = document.getElementById('perspectiveShadowIntensity');

   if (perspectiveShadowColorPicker) perspectiveShadowColorPicker.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowColor', e.target.value);
   if (perspectiveShadowOpacitySlider) perspectiveShadowOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOpacity', parseInt(e.target.value, 10));
   if (perspectiveShadowOffsetSlider) perspectiveShadowOffsetSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowOffset', parseInt(e.target.value, 10));
   if (perspectiveShadowAngleSlider) perspectiveShadowAngleSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowAngle', parseInt(e.target.value, 10));
   if (perspectiveShadowBlurSlider) perspectiveShadowBlurSlider.oninput = (e) => updateSelectedObjectFromUI('perspectiveShadowBlur', parseInt(e.target.value, 10));

   if (perspectiveShadowIntensitySlider) {
       perspectiveShadowIntensitySlider.oninput = (e) => {
           console.log('=== PERSPECTIVE SHADOW INTENSITY DEBUG ===');
           const value = parseInt(e.target.value, 10);
           console.log('Perspective shadow intensity changed to:', value);

           // Check if we have a selected object
           if (selectedObjectIndex === -1) {
               console.error('No object selected when changing perspective shadow intensity!');
               return;
           }

           const selectedObject = canvasObjects[selectedObjectIndex];
           if (selectedObject.type !== 'text') {
               console.error('Selected object is not a text object!');
               return;
           }

           console.log('Selected object before update:', {
               id: selectedObject.id,
               text: selectedObject.text,
               shadowMode: selectedObject.shadowMode,
               perspectiveShadowIntensity: selectedObject.perspectiveShadowIntensity
           });

           // Verify shadow mode is correct
           if (selectedObject.shadowMode !== 'perspectiveShadow') {
               console.warn('Shadow mode is not perspectiveShadow! Current mode:', selectedObject.shadowMode);
               console.log('Forcing shadow mode to perspectiveShadow');
               selectedObject.shadowMode = 'perspectiveShadow';
               if (shadowSelect) {
                   shadowSelect.value = 'perspectiveShadow';
               }
           }

           console.log('Updating perspectiveShadowIntensity to:', value);
           updateSelectedObjectFromUI('perspectiveShadowIntensity', value);

           // Verify the object was updated correctly
           console.log('Selected object after update:', {
               id: selectedObject.id,
               text: selectedObject.text,
               shadowMode: selectedObject.shadowMode,
               perspectiveShadowIntensity: selectedObject.perspectiveShadowIntensity
           });

           // Force a redraw to ensure the effect is applied
           console.log('Forcing redraw...');
           update();
           console.log('=== END PERSPECTIVE SHADOW INTENSITY DEBUG ===');
       };
   }

   lineShadowColorPicker.oninput = (e) => updateSelectedObjectFromUI('lineShadowColor', e.target.value);
   lineShadowDistanceSlider.oninput = (e) => updateSelectedObjectFromUI('lineShadowDist', parseInt(e.target.value, 10));
   lineShadowAngleSlider.oninput = (e) => updateSelectedObjectFromUI('lineShadowAngle', parseInt(e.target.value, 10));
   lineShadowThicknessSlider.oninput = (e) => updateSelectedObjectFromUI('lineShadowThickness', parseInt(e.target.value, 10));
   detailed3DPrimaryColorPicker.oninput = (e) => updateSelectedObjectFromUI('d3dPrimaryColor', e.target.value);
   detailed3DPrimaryOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('d3dPrimaryOpacity', parseInt(e.target.value, 10));
   detailed3DOffsetSlider.oninput = (e) => updateSelectedObjectFromUI('d3dOffset', parseInt(e.target.value, 10));
   detailed3DAngleSlider.oninput = (e) => updateSelectedObjectFromUI('d3dAngle', parseInt(e.target.value, 10));
   detailed3DBlurSlider.oninput = (e) => updateSelectedObjectFromUI('d3dBlur', parseInt(e.target.value, 10));
   detailed3DSecondaryColorPicker.oninput = (e) => updateSelectedObjectFromUI('d3dSecondaryColor', e.target.value);
   detailed3DSecondaryOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('d3dSecondaryOpacity', parseInt(e.target.value, 10));
   detailed3DSecondaryWidthSlider.oninput = (e) => updateSelectedObjectFromUI('d3dSecondaryWidth', parseInt(e.target.value, 10));
   detailed3DSecondaryOffsetXSlider.oninput = (e) => updateSelectedObjectFromUI('d3dSecondaryOffsetX', parseInt(e.target.value, 10));
   detailed3DSecondaryOffsetYSlider.oninput = (e) => updateSelectedObjectFromUI('d3dSecondaryOffsetY', parseInt(e.target.value, 10));

   // Stroke and decoration controls
   strokeToggle.onchange = (e) => updateSelectedObjectFromUI('strokeMode', e.target.value);
   strokeWidthSlider.oninput = (e) => updateSelectedObjectFromUI('strokeWidth', parseInt(e.target.value, 10));
   strokeColorPicker.oninput = (e) => updateSelectedObjectFromUI('strokeColor', e.target.value);
   strokeOpacitySlider.oninput = (e) => updateSelectedObjectFromUI('strokeOpacity', parseInt(e.target.value, 10));
   linesDecorationSelect.onchange = (e) => updateSelectedObjectFromUI('decorationMode', e.target.value);
   hWeight.oninput = (e) => {
       updateSelectedObjectFromUI('hLineWeight', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   hDistance.oninput = (e) => {
       updateSelectedObjectFromUI('hLineDist', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   hColor.oninput = (e) => {
       updateSelectedObjectFromUI('hLineColor', e.target.value);
       update(); // Force canvas redraw for decoration changes
   };
   hOpacity.oninput = (e) => {
       updateSelectedObjectFromUI('hLineOpacity', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   ccDistance.oninput = (e) => {
       updateSelectedObjectFromUI('ccDist', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   ccColor.oninput = (e) => {
       updateSelectedObjectFromUI('ccColor', e.target.value);
       update(); // Force canvas redraw for decoration changes
   };
   ccOpacity.oninput = (e) => {
       updateSelectedObjectFromUI('ccOpacity', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   ccFillTop.onchange = () => {
       updateSelectedObjectFromUI('ccFillDir', 'top');
       update(); // Force canvas redraw for decoration changes
   };
   ccFillBottom.onchange = () => {
       updateSelectedObjectFromUI('ccFillDir', 'bottom');
       update(); // Force canvas redraw for decoration changes
   };
   oWeight.oninput = (e) => {
       updateSelectedObjectFromUI('oLineWeight', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   oDistance.oninput = (e) => {
       updateSelectedObjectFromUI('oLineDist', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   oColor.oninput = (e) => {
       updateSelectedObjectFromUI('oLineColor', e.target.value);
       update(); // Force canvas redraw for decoration changes
   };
   oOpacity.oninput = (e) => {
       updateSelectedObjectFromUI('oOpacity', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   flcDistance.oninput = (e) => {
       updateSelectedObjectFromUI('flcDist', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   flcColor.oninput = (e) => {
       updateSelectedObjectFromUI('flcColor', e.target.value);
       update(); // Force canvas redraw for decoration changes
   };
   flcOpacity.oninput = (e) => {
       updateSelectedObjectFromUI('flcOpacity', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   flcMaxWeight.oninput = (e) => {
       updateSelectedObjectFromUI('flcWeight', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   flcSpacing.oninput = (e) => {
       updateSelectedObjectFromUI('flcSpacing', parseInt(e.target.value, 10));
       update(); // Force canvas redraw for decoration changes
   };
   flcFillTop.onchange = () => {
       updateSelectedObjectFromUI('flcDir', 'top');
       update(); // Force canvas redraw for decoration changes
   };
   flcFillBottom.onchange = () => {
       updateSelectedObjectFromUI('flcDir', 'bottom');
       update(); // Force canvas redraw for decoration changes
   };
   addImageBtn.onclick = () => imageFileInput.click(); imageFileInput.onchange = (e) => { if (e.target.files && e.target.files[0]) { handleAddImage(e.target.files[0]); } e.target.value = null; }; deleteImageBtn.onclick = handleDeleteObject; iImageSize.oninput = (e) => updateSelectedObjectFromUI('scale', e.target.value); iImageRotation.oninput = (e) => updateSelectedObjectFromUI('rotation', e.target.value);
   document.getElementById('removeBgBtn').addEventListener('click', handleBgRemoveClick); // Add listener for new button
   document.getElementById('regenerateBtn').addEventListener('click', handleRegenerateClick); // Add listener for regenerate button

   // Add event listener for restyle button with error handling
   const restyleBtn = document.getElementById('restyleBtn');
   if (restyleBtn) {
       console.log('🎨 Adding event listener to Restyle button');
       restyleBtn.addEventListener('click', handleRestyleClick);
       console.log('🎨 Restyle button event listener added successfully');
   } else {
       console.error('🎨 Restyle button not found when trying to add event listener');
   }

   // Add event listener for replace button with error handling
   const replaceBtn = document.getElementById('replaceBtn');
   if (replaceBtn) {
       console.log('🔄 Adding event listener to Replace button');
       replaceBtn.addEventListener('click', handleReplaceClick);
       console.log('🔄 Replace button event listener added successfully');
   } else {
       console.error('🔄 Replace button not found when trying to add event listener');
   }

   // Image masking event listeners
   if (maskImageBtn) {
       maskImageBtn.addEventListener('click', handleMaskImageClick);
   }
   if (unmaskImageBtn) {
       unmaskImageBtn.addEventListener('click', handleUnmaskImageClick);
   }

   // Add event listener for SVG color picker
   const iImageColor = document.getElementById('iImageColor');
   if (iImageColor) {
       console.log('✅ iImageColor element found, attaching event handler');
       iImageColor.oninput = (e) => {
           console.log('🎨 ===== COLOR PICKER DEBUG =====');
           console.log('🎨 Image/Shape color picker changed:', e.target.value);
           console.log('🎨 Current selectedObjectIndex:', selectedObjectIndex);
           if (selectedObjectIndex >= 0) {
               const selectedObj = canvasObjects[selectedObjectIndex];
               console.log('🎨 Selected object:', selectedObj);
               console.log('🎨 Object imageUrl:', selectedObj.imageUrl);
               console.log('🎨 Is SVG?', selectedObj.imageUrl?.toLowerCase().endsWith('.svg'));
               console.log('🎨 Current svgColor:', selectedObj.svgColor);
               console.log('🎨 New color being applied:', e.target.value);
               console.log('🎨 Color change:', selectedObj.svgColor, '->', e.target.value);
           }
           updateSelectedObjectFromUI('svgColor', e.target.value);
           console.log('🎨 ===== COLOR PICKER DEBUG END =====');
       };
   } else {
       console.error('❌ iImageColor element not found!');
   }

   // Add event listener for image color intensity
   if (iImageColorIntensity) {
       iImageColorIntensity.addEventListener('change', async (e) => {
           console.log('🎨 Image color intensity changed to:', e.target.value);
           updateSelectedObjectFromUI('colorIntensity', e.target.value);

           // Update persistent value and save to database if changed from N/A
           if (selectedObjectIndex !== -1) {
               const selectedObject = canvasObjects[selectedObjectIndex];
               const oldValue = selectedObject.newColorIntensity;
               selectedObject.newColorIntensity = e.target.value;

               // Update debug display
               const debugImageNewColorIntensity = document.getElementById('debugImageNewColorIntensity');
               if (debugImageNewColorIntensity) {
                   debugImageNewColorIntensity.textContent = e.target.value;
               }

               // Save to database if value changed from N/A to something else
               if (oldValue === 'N/A' && e.target.value !== 'N/A') {
                   savePersistentParameter(selectedObject.id, 'newColorIntensity', e.target.value);
               } else if (oldValue !== 'N/A' && e.target.value !== oldValue) {
                   // Also save if value changed from one non-N/A value to another
                   savePersistentParameter(selectedObject.id, 'newColorIntensity', e.target.value);
               }
           }

           // SIMPLIFIED APPROACH: Don't apply colors immediately when assigning Color Intensity
           // Colors will only be applied when user explicitly uses "Include Texts and Shapes" feature
           // This prevents conflicts and gives users full control

           console.log('🎨 Color Intensity assigned to shape - colors will be applied during generation if "Include Texts and Shapes" is checked');
       });
   }

   // Image shadow controls event handlers
   if (iImageShadow) {
       console.log('✅ iImageShadow element found, attaching event handler');
       iImageShadow.onchange = (e) => {
           console.log('🌫️ Image shadow dropdown changed:', e.target.value);
           console.log('🌫️ Current selectedObjectIndex:', selectedObjectIndex);
           if (selectedObjectIndex >= 0) {
               console.log('🌫️ Selected object:', canvasObjects[selectedObjectIndex]);
           }
           updateSelectedObjectFromUI('shadowMode', e.target.value);
           // Show/hide shadow parameter controls
           const imageShadowParam = document.querySelector('.image-shadow-param');
           if (imageShadowParam) {
               imageShadowParam.style.display = e.target.value === 'standard' ? 'block' : 'none';
           }
       };
   } else {
       console.error('❌ iImageShadow element not found!');
   }
   if (iImageShadowColor) {
       iImageShadowColor.oninput = (e) => updateSelectedObjectFromUI('shadowColor', e.target.value);
   }
   if (iImageShadowOffsetX) {
       iImageShadowOffsetX.oninput = (e) => updateSelectedObjectFromUI('shadowOffsetX', e.target.value);
   }
   if (iImageShadowOffsetY) {
       iImageShadowOffsetY.oninput = (e) => updateSelectedObjectFromUI('shadowOffsetY', e.target.value);
   }
   if (iImageShadowBlur) {
       iImageShadowBlur.oninput = (e) => updateSelectedObjectFromUI('shadowBlur', e.target.value);
   }
   if (iImageShadowOpacity) {
       iImageShadowOpacity.oninput = (e) => updateSelectedObjectFromUI('shadowOpacity', e.target.value);
   }
   if (iImageOpacity) {
       console.log('✅ iImageOpacity element found, attaching event handler');
       iImageOpacity.oninput = (e) => {
           console.log('🎛️ Image opacity slider changed:', e.target.value);
           console.log('🎛️ Current selectedObjectIndex:', selectedObjectIndex);
           if (selectedObjectIndex >= 0) {
               console.log('🎛️ Selected object:', canvasObjects[selectedObjectIndex]);
           }
           updateSelectedObjectFromUI('opacity', e.target.value);
       };
   } else {
       console.error('❌ iImageOpacity element not found!');
   }

   // Template ID controls
   const textTemplateId = document.getElementById('textTemplateId');
   const imageTemplateId = document.getElementById('imageTemplateId');

   if (textTemplateId) {
       console.log('🔧 Setting up textTemplateId event handler');
       textTemplateId.onchange = (e) => {
           console.log('🔧 textTemplateId changed to:', e.target.value);
           console.log('🔧 selectedObjectIndex:', selectedObjectIndex);
           console.log('🔧 canvasObjects length:', canvasObjects.length);

           if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex].type === 'text') {
               updateSelectedObjectFromUI('templateId', e.target.value || null);

               // Update persistent value and save to database if changed from N/A
               const selectedObject = canvasObjects[selectedObjectIndex];
               console.log('🔧 Selected object:', selectedObject);
               console.log('🔧 Selected object ID:', selectedObject.id);
               console.log('🔧 Selected object type:', selectedObject.type);

               const oldValue = selectedObject.newTemplateId;
               const newValue = e.target.value ? e.target.value : 'Not Replaceable';
               selectedObject.newTemplateId = newValue;

               // Update debug display
               const debugNewTemplateId = document.getElementById('debugNewTemplateId');
               if (debugNewTemplateId) {
                   debugNewTemplateId.textContent = newValue;
               }

               // Save to database if value changed from N/A to something else
               console.log('💾 Template ID change - oldValue:', oldValue, 'newValue:', newValue);
               console.log('💾 Selected object:', selectedObject);
               console.log('💾 Conditions check:', {
                   'oldValue === N/A': oldValue === 'N/A',
                   'newValue !== N/A': newValue !== 'N/A',
                   'oldValue !== N/A': oldValue !== 'N/A',
                   'newValue !== oldValue': newValue !== oldValue
               });

               if ((oldValue === 'N/A' && newValue !== 'N/A') ||
                   (oldValue !== 'N/A' && newValue !== oldValue)) {
                   console.log('💾 Saving template ID:', newValue);
                   savePersistentParameter(selectedObject.id, 'newTemplateId', newValue);
               } else {
                   console.log('💾 Not saving - conditions not met');
               }
           } else {
               console.log('🔧 No text object selected, not saving');
           }
       };
   } else {
       console.log('🔧 textTemplateId element not found!');
   }

   if (imageTemplateId) {
       imageTemplateId.onchange = (e) => {
           if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex].type === 'image') {
               updateSelectedObjectFromUI('templateId', e.target.value || null);

               // Update persistent value and save to database if changed from N/A
               const selectedObject = canvasObjects[selectedObjectIndex];
               const oldValue = selectedObject.newTemplateId;
               const newValue = e.target.value ? e.target.value : 'Not Replaceable';
               selectedObject.newTemplateId = newValue;

               // Update debug display
               const debugImageNewTemplateId = document.getElementById('debugImageNewTemplateId');
               if (debugImageNewTemplateId) {
                   debugImageNewTemplateId.textContent = newValue;
               }

               // Save to database if value changed from N/A to something else
               if (oldValue === 'N/A' && newValue !== 'N/A') {
                   savePersistentParameter(selectedObject.id, 'newTemplateId', newValue);
               } else if (oldValue !== 'N/A' && newValue !== oldValue) {
                   // Also save if value changed from one non-N/A value to another
                   savePersistentParameter(selectedObject.id, 'newTemplateId', newValue);
               }
           }
       };
   }

   // Image stroke controls event handlers
   if (iImageStroke) {
       iImageStroke.onchange = (e) => {
           updateSelectedObjectFromUI('strokeMode', e.target.value);
           // Show/hide stroke parameter controls
           const imageStrokeParam = document.querySelector('.image-stroke-param');
           if (imageStrokeParam) {
               imageStrokeParam.style.display = e.target.value === 'standard' ? 'block' : 'none';
           }
       };
   }
   if (iImageStrokeWidth) {
       iImageStrokeWidth.oninput = (e) => updateSelectedObjectFromUI('strokeWidth', e.target.value);
   }
   if (iImageStrokeColor) {
       iImageStrokeColor.oninput = (e) => updateSelectedObjectFromUI('strokeColor', e.target.value);
   }

   // Add stroke opacity control
   if (iImageStrokeOpacity) {
       iImageStrokeOpacity.oninput = (e) => updateSelectedObjectFromUI('strokeOpacity', e.target.value);
   }

   // Initialize gradient color pickers
   initializeGradientColorPickers();

   // --- Rulers and Guidelines System (Canvas-based) ---
   const horizontalRuler = document.getElementById('horizontal-ruler');
   const verticalRuler = document.getElementById('vertical-ruler');

   // Guidelines are now canvas objects that get drawn with the same transform as everything else
   let guidelines = [];
   let isDraggingGuideline = false;
   let draggedGuideline = null;
   let guidelineIdCounter = 0;

   // Get the guidelines container for DOM-based guidelines
   const guidelinesContainer = document.getElementById('guidelines-container');

   // Initialize rulers
   function initializeRulers() {
       console.log('🔧 Initializing rulers...');

       if (!horizontalRuler || !verticalRuler) {
           console.error('❌ Ruler elements not found in DOM');
           return;
       }

       const canvasArea = document.getElementById('canvas-area');
       if (!canvasArea) {
           console.error('❌ Canvas area not found');
           return;
       }

       const canvasAreaRect = canvasArea.getBoundingClientRect();

       // Set ruler dimensions
       horizontalRuler.width = canvasAreaRect.width - 20;
       horizontalRuler.height = 20;
       verticalRuler.width = 20;
       verticalRuler.height = canvasAreaRect.height - 20;

       console.log('✅ Rulers initialized successfully');
       drawRulers();
   }

   function drawRulers() {
       // Removed ruler drawing logs for performance
       drawHorizontalRuler();
       drawVerticalRuler();
   }

   function drawHorizontalRuler() {
       // Removed ruler drawing logs for performance

       const ctx = horizontalRuler.getContext('2d');
       const width = horizontalRuler.width;
       const height = horizontalRuler.height;

       console.log(`🔧 RULER DRAW: Horizontal ruler dimensions - width: ${width}, height: ${height}`);

       ctx.clearRect(0, 0, width, height);
       ctx.fillStyle = '#f5f5f5';
       ctx.fillRect(0, 0, width, height);

       ctx.strokeStyle = '#999';
       ctx.lineWidth = 1;

       // Simplified ruler: uniform tick marks every 10 pixels
       const tickSpacing = 10;

       for (let screenX = 0; screenX <= width; screenX += tickSpacing) {
           ctx.beginPath();
           ctx.moveTo(screenX, height - 3);
           ctx.lineTo(screenX, height);
           ctx.stroke();
       }

       console.log(`🔧 RULER DRAW: === HORIZONTAL RULER COMPLETE ===`);
   }

   function drawVerticalRuler() {
       // Removed ruler drawing logs for performance

       const ctx = verticalRuler.getContext('2d');
       const width = verticalRuler.width;
       const height = verticalRuler.height;

       console.log(`🔧 RULER DRAW: Vertical ruler dimensions - width: ${width}, height: ${height}`);

       ctx.clearRect(0, 0, width, height);
       ctx.fillStyle = '#f5f5f5';
       ctx.fillRect(0, 0, width, height);

       ctx.strokeStyle = '#999';
       ctx.lineWidth = 1;

       // Simplified ruler: uniform tick marks every 10 pixels
       const tickSpacing = 10;

       for (let screenY = 0; screenY <= height; screenY += tickSpacing) {
           ctx.beginPath();
           ctx.moveTo(width - 3, screenY);
           ctx.lineTo(width, screenY);
           ctx.stroke();
       }

       console.log(`🔧 RULER DRAW: === VERTICAL RULER COMPLETE ===`);
   }

   // Canvas-based Guideline functions
   function createCanvasGuideline(type, worldPosition) {
       console.log(`🔧 GUIDELINE CREATE: Creating canvas-based ${type} guideline at world position: ${worldPosition}`);

       const guideline = {
           id: `guideline_${++guidelineIdCounter}`,
           type: type, // 'horizontal' or 'vertical'
           worldPosition: worldPosition, // World coordinate (same as canvas objects)
           color: '#ff0000',
           lineWidth: 1,
           isDragging: false
       };

       guidelines.push(guideline);
       console.log(`🔧 GUIDELINE CREATE: Created ${type} guideline at world position: ${worldPosition}. Total guidelines: ${guidelines.length}`);

       return guideline;
   }

   function drawGuidelines(ctx) {
       // Guidelines are drawn with the same transform as canvas objects
       // Use the exact same coordinate system as rectangles for perfect alignment
       guidelines.forEach(guideline => {
           ctx.save();

           // Set guideline style
           ctx.strokeStyle = guideline.color;
           ctx.lineWidth = guideline.lineWidth / scale; // Adjust line width for zoom
           ctx.setLineDash([5 / scale, 5 / scale]); // Dashed line that scales with zoom

           ctx.beginPath();
           if (guideline.type === 'horizontal') {
               // Draw horizontal line across a very wide area to ensure visibility
               // Use the same coordinate system as rectangles
               ctx.moveTo(-10000, guideline.worldPosition);
               ctx.lineTo(10000, guideline.worldPosition);
               // Removed guideline drawing log for performance
           } else {
               // Draw vertical line across a very wide area to ensure visibility
               // Use the same coordinate system as rectangles
               ctx.moveTo(guideline.worldPosition, -10000);
               ctx.lineTo(guideline.worldPosition, 10000);
               // Removed guideline drawing log for performance
           }
           ctx.stroke();

           ctx.restore();
       });
   }

   function removeGuideline(guideline) {
       const index = guidelines.indexOf(guideline);
       if (index > -1) {
           guidelines.splice(index, 1);
           console.log(`🔧 GUIDELINE REMOVE: Removed guideline. Total guidelines: ${guidelines.length}`);
       }
   }

   // Canvas-based guidelines don't need HTML positioning functions

   // Ruler event listeners for creating guidelines
   if (horizontalRuler) {
       horizontalRuler.addEventListener('mousedown', (e) => {
           console.log('🔧 GUIDELINE CREATE: Horizontal ruler clicked!', e);
           const rulerRect = horizontalRuler.getBoundingClientRect();

           // Get X position relative to the ruler itself
           const rulerX = e.clientX - rulerRect.left;

           // Convert ruler click to world coordinates
           // Ruler is positioned at left: 20px, so we need to account for this offset
           // Canvas uses: screenX = worldX * scale + offsetX
           // So: worldX = (screenX - offsetX) / scale
           const screenX = rulerX + 20; // Add 20px offset for ruler position
           const worldX = (screenX - offsetX) / scale;

           console.log('🔧 GUIDELINE CREATE: Ruler click - clientX:', e.clientX);
           console.log('🔧 GUIDELINE CREATE: Ruler left:', rulerRect.left);
           console.log('🔧 GUIDELINE CREATE: Ruler relative X:', rulerX);
           console.log('🔧 GUIDELINE CREATE: World X:', worldX);
           console.log('🔧 GUIDELINE CREATE: Current guidelines count before:', guidelines.length);

           // Create canvas-based guideline
           createCanvasGuideline('vertical', worldX);

           // Trigger canvas redraw to show the new guideline
           update();
       });
   }

   if (verticalRuler) {
       verticalRuler.addEventListener('mousedown', (e) => {
           console.log('🔧 GUIDELINE CREATE: Vertical ruler clicked!', e);
           const rulerRect = verticalRuler.getBoundingClientRect();

           // Get Y position relative to the ruler itself
           const rulerY = e.clientY - rulerRect.top;

           // Convert ruler click to world coordinates
           // Ruler is positioned at top: 20px, so we need to account for this offset
           // Canvas uses: screenY = worldY * scale + offsetY
           // So: worldY = (screenY - offsetY) / scale
           const screenY = rulerY + 20; // Add 20px offset for ruler position
           const worldY = (screenY - offsetY) / scale;

           console.log('🔧 GUIDELINE CREATE: Ruler click - clientY:', e.clientY);
           console.log('🔧 GUIDELINE CREATE: Ruler top:', rulerRect.top);
           console.log('🔧 GUIDELINE CREATE: Ruler relative Y:', rulerY);
           console.log('🔧 GUIDELINE CREATE: World Y:', worldY);
           console.log('🔧 GUIDELINE CREATE: Current guidelines count before:', guidelines.length);

           // Create canvas-based guideline
           createCanvasGuideline('horizontal', worldY);

           // Trigger canvas redraw to show the new guideline
           update();
       });
   }

   // Global mouse events for guideline dragging
   window.addEventListener('mousemove', (e) => {
       if (isDraggingGuideline && draggedGuideline && draggedGuideline.dataset) {
           const canvasAreaRect = document.getElementById('canvas-area').getBoundingClientRect();
           const type = draggedGuideline.dataset.type;

           if (type === 'horizontal') {
               // Get Y position relative to guidelines container (which is offset by 20px from canvas-area)
               const containerY = e.clientY - canvasAreaRect.top - 20; // Subtract ruler height
               // Convert to world coordinates using same transformation as canvas
               const worldY = (containerY - offsetY) / scale;
               console.log(`🔧 GUIDELINE DRAG: Horizontal - containerY: ${containerY}, worldY: ${worldY}`);
               draggedGuideline.dataset.worldPosition = worldY;
               updateGuidelinePosition(draggedGuideline);
           } else {
               // Get X position relative to guidelines container (which is offset by 20px from canvas-area)
               const containerX = e.clientX - canvasAreaRect.left - 20; // Subtract ruler width
               // Convert to world coordinates using same transformation as canvas
               const worldX = (containerX - offsetX) / scale;
               console.log(`🔧 GUIDELINE DRAG: Vertical - containerX: ${containerX}, worldX: ${worldX}`);
               draggedGuideline.dataset.worldPosition = worldX;
               updateGuidelinePosition(draggedGuideline);
           }
       }
   });

   window.addEventListener('mouseup', () => {
       if (isDraggingGuideline && draggedGuideline && draggedGuideline.classList) {
           draggedGuideline.classList.remove('dragging');

           // Check if guideline was dragged back to ruler (remove it)
           const type = draggedGuideline.dataset.type;
           const worldPosition = parseFloat(draggedGuideline.dataset.worldPosition);

           // Convert world position back to container coordinates to check if it's in ruler area
           let containerPosition;
           if (type === 'horizontal') {
               containerPosition = worldPosition * scale + offsetY;
           } else {
               containerPosition = worldPosition * scale + offsetX;
           }

           // If dragged to negative position (into ruler area), remove the guideline
           if (containerPosition < 0) {
               console.log(`🔧 GUIDELINE REMOVE: ${type} guideline dragged to ruler area, removing`);
               removeGuideline(draggedGuideline);
           }

           isDraggingGuideline = false;
           draggedGuideline = null;
       }
   });

   // Update rulers when canvas transforms change
   function updateRulers() {
       console.log(`🔧 RULER UPDATE: === UPDATING RULERS ===`);
       console.log(`🔧 RULER UPDATE: Current transform state - offsetX: ${offsetX}, offsetY: ${offsetY}, scale: ${scale}`);

       if (horizontalRuler && verticalRuler) {
           drawRulers();
           console.log(`🔧 RULER UPDATE: Rulers redrawn successfully`);
       } else {
           console.log(`🔧 RULER UPDATE: ❌ Ruler elements not found`);
       }

       console.log(`🔧 RULER UPDATE: === RULERS UPDATE COMPLETE ===`);
   }

   // Create guideline from ruler drag
   function createGuideline(type, position) {
       console.log(`🔧 GUIDELINE CREATE: Starting creation of ${type} guideline at canvas position ${position}`);
       console.log(`🔧 GUIDELINE CREATE: Current transform - offsetX: ${offsetX}, offsetY: ${offsetY}, scale: ${scale}`);

       const guideline = document.createElement('div');
       guideline.className = `guideline ${type}`;
       guideline.dataset.type = type;

       // Convert canvas screen position to world position
       let worldPosition;
       if (type === 'horizontal') {
           // Convert canvas screen Y to world Y
           worldPosition = (position - offsetY) / scale;
           console.log(`🔧 GUIDELINE CREATE: Horizontal guideline - canvas screen Y: ${position} → world Y: ${worldPosition}`);
           console.log(`🔧 GUIDELINE CREATE: Calculation: (${position} - ${offsetY}) / ${scale} = ${worldPosition}`);
       } else {
           // Convert canvas screen X to world X
           worldPosition = (position - offsetX) / scale;
           console.log(`🔧 GUIDELINE CREATE: Vertical guideline - canvas screen X: ${position} → world X: ${worldPosition}`);
           console.log(`🔧 GUIDELINE CREATE: Calculation: (${position} - ${offsetX}) / ${scale} = ${worldPosition}`);
       }

       guideline.dataset.worldPosition = worldPosition;
       console.log(`🔧 GUIDELINE CREATE: Created ${type} guideline at world position: ${worldPosition}`);

       guidelinesContainer.appendChild(guideline);
       guidelines.push(guideline);
       console.log(`🔧 GUIDELINE CREATE: Added guideline to container and array. Total guidelines: ${guidelines.length}`);

       // Add guideline event listeners
       guideline.addEventListener('mousedown', (e) => {
           console.log('🔧 GUIDELINE MOUSEDOWN: Checking lock state and layout resize handle priority');

           // Check if guidelines are locked
           if (areGuidelinesLocked) {
               console.log('🔒 GUIDELINE MOUSEDOWN: Guidelines are locked, ignoring drag attempt');
               return;
           }

           // Check if this click should be handled by layout resize handles instead
           const coords = getCanvasCoordinates(e);
           const worldCoords = canvasToWorld(coords.x, coords.y);

           // Check for Layout Rectangle Resize Handle (only for selected rectangle)
           if (selectedLayoutRectIndex !== -1 && layoutRectangles[selectedLayoutRectIndex]) {
               const rect = layoutRectangles[selectedLayoutRectIndex];
               const handleSize = 8 / scale;

               const handles = [
                   { x: rect.x, y: rect.y, id: 'tl' }, // Top-left
                   { x: rect.x + rect.width, y: rect.y, id: 'tr' }, // Top-right
                   { x: rect.x, y: rect.y + rect.height, id: 'bl' }, // Bottom-left
                   { x: rect.x + rect.width, y: rect.y + rect.height, id: 'br' } // Bottom-right
               ];

               for (const handle of handles) {
                   if (worldCoords.x >= handle.x - handleSize/2 && worldCoords.x <= handle.x + handleSize/2 &&
                       worldCoords.y >= handle.y - handleSize/2 && worldCoords.y <= handle.y + handleSize/2) {
                       console.log('🔧 GUIDELINE MOUSEDOWN: Layout resize handle detected, giving priority to layout');
                       // Don't prevent default, let the canvas handle this
                       return;
                   }
               }
           }

           console.log('🔧 GUIDELINE MOUSEDOWN: No layout handle conflict, proceeding with guideline drag');
           e.preventDefault();
           isDraggingGuideline = true;
           draggedGuideline = guideline;
           guideline.classList.add('dragging');
       });

       // Double-click to remove guideline
       guideline.addEventListener('dblclick', () => {
           guidelinesContainer.removeChild(guideline);
           guidelines = guidelines.filter(g => g !== guideline);
       });

       // Update guideline position based on current zoom/pan
       updateGuidelinePosition(guideline);

       return guideline;
   }

   // Canvas-based guidelines don't need HTML positioning - they're drawn directly on canvas

   // Function to check if a point is near a guideline (for selection/dragging)
   function getGuidelineAtPoint(worldX, worldY, tolerance = 5) {
       const toleranceInWorld = tolerance / scale; // Convert screen tolerance to world coordinates

       for (let guideline of guidelines) {
           if (guideline.type === 'horizontal') {
               if (Math.abs(worldY - guideline.worldPosition) <= toleranceInWorld) {
                   return guideline;
               }
           } else if (guideline.type === 'vertical') {
               if (Math.abs(worldX - guideline.worldPosition) <= toleranceInWorld) {
                   return guideline;
               }
           }
       }
       return null;
   }

   // Right-click context menu for guidelines
   let contextMenu = null;
   let contextMenuX = 0;
   let contextMenuY = 0;

   function createContextMenu() {
       if (contextMenu) {
           document.body.removeChild(contextMenu);
       }

       contextMenu = document.createElement('div');
       contextMenu.style.cssText = `
           position: fixed;
           background: white;
           border: 1px solid #ccc;
           border-radius: 4px;
           box-shadow: 0 2px 10px rgba(0,0,0,0.1);
           z-index: 10000;
           padding: 4px 0;
           font-family: Arial, sans-serif;
           font-size: 12px;
           min-width: 180px;
       `;

       // Copy option (only show if an object is selected)
       if (selectedObjectIndex !== -1) {
           const copyOption = document.createElement('div');
           copyOption.textContent = '📋 Copy';
           copyOption.style.cssText = `
               padding: 6px 12px;
               cursor: pointer;
               border-bottom: 1px solid #eee;
           `;
           copyOption.addEventListener('mouseenter', () => copyOption.style.background = '#f0f0f0');
           copyOption.addEventListener('mouseleave', () => copyOption.style.background = 'white');
           copyOption.addEventListener('click', () => {
               copySelectedElement();
               hideContextMenu();
           });
           contextMenu.appendChild(copyOption);
       }

       // Paste option (only show if something is copied)
       if (copiedElement) {
           const pasteOption = document.createElement('div');
           pasteOption.textContent = '📄 Paste';
           pasteOption.style.cssText = `
               padding: 6px 12px;
               cursor: pointer;
               border-bottom: 1px solid #eee;
           `;
           pasteOption.addEventListener('mouseenter', () => pasteOption.style.background = '#f0f0f0');
           pasteOption.addEventListener('mouseleave', () => pasteOption.style.background = 'white');
           pasteOption.addEventListener('click', () => {
               pasteElement();
               hideContextMenu();
           });
           contextMenu.appendChild(pasteOption);
       }

       // 🎯 REVOLUTIONARY: Add "Add Guidelines Around" option for selected text, shape, and image objects
       if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex] &&
           (canvasObjects[selectedObjectIndex].type === 'text' || canvasObjects[selectedObjectIndex].type === 'shape' || canvasObjects[selectedObjectIndex].type === 'image')) {
           const addGuidelinesAround = document.createElement('div');
           addGuidelinesAround.textContent = '🎯 Add Guidelines Around';
           addGuidelinesAround.style.cssText = `
               padding: 6px 12px;
               cursor: pointer;
               border-bottom: 1px solid #eee;
               background: #e8f5e8;
               font-weight: bold;
           `;
           addGuidelinesAround.addEventListener('mouseenter', () => addGuidelinesAround.style.background = '#d4f0d4');
           addGuidelinesAround.addEventListener('mouseleave', () => addGuidelinesAround.style.background = '#e8f5e8');
           addGuidelinesAround.addEventListener('click', () => {
               addGuidelinesAroundSelectedText();
               hideContextMenu();
           });
           contextMenu.appendChild(addGuidelinesAround);
       }

       // 🔍 SVG Component Detection options for SVG images
       if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex] &&
           canvasObjects[selectedObjectIndex].type === 'image' &&
           canvasObjects[selectedObjectIndex].imageUrl &&
           canvasObjects[selectedObjectIndex].imageUrl.toLowerCase().endsWith('.svg')) {

           // Add separator
           const svgSeparator = document.createElement('div');
           svgSeparator.style.cssText = `
               height: 1px;
               background: #eee;
               margin: 4px 0;
           `;
           contextMenu.appendChild(svgSeparator);

           // Detect Components option
           const detectComponents = document.createElement('div');
           detectComponents.textContent = '🔍 Detect Components';
           detectComponents.style.cssText = `
               padding: 6px 12px;
               cursor: pointer;
               border-bottom: 1px solid #eee;
               background: #e8f0ff;
               color: #1e3a8a;
               font-weight: bold;
           `;
           detectComponents.addEventListener('mouseenter', () => detectComponents.style.background = '#dbeafe');
           detectComponents.addEventListener('mouseleave', () => detectComponents.style.background = '#e8f0ff');
           detectComponents.addEventListener('click', () => {
               detectSVGComponents();
               hideContextMenu();
           });
           contextMenu.appendChild(detectComponents);

           // Show/Hide Component Bounds option (only if components are detected)
           if (svgComponents.length > 0) {
               const toggleBounds = document.createElement('div');
               toggleBounds.textContent = svgComponentsVisible ? '👁️ Hide Component Bounds' : '👁️ Show Component Bounds';
               toggleBounds.style.cssText = `
                   padding: 6px 12px;
                   cursor: pointer;
                   border-bottom: 1px solid #eee;
                   background: #fff7ed;
                   color: #9a3412;
               `;
               toggleBounds.addEventListener('mouseenter', () => toggleBounds.style.background = '#fed7aa');
               toggleBounds.addEventListener('mouseleave', () => toggleBounds.style.background = '#fff7ed');
               toggleBounds.addEventListener('click', () => {
                   if (svgComponentsVisible) {
                       hideSVGComponentBounds();
                   } else {
                       showSVGComponentBounds();
                   }
                   hideContextMenu();
               });
               contextMenu.appendChild(toggleBounds);

               // Create Component Guidelines option
               const createGuidelines = document.createElement('div');
               createGuidelines.textContent = '📐 Component Guidelines';
               createGuidelines.style.cssText = `
                   padding: 6px 12px;
                   cursor: pointer;
                   border-bottom: 1px solid #eee;
                   background: #f0fdf4;
                   color: #166534;
                   font-weight: bold;
               `;
               createGuidelines.addEventListener('mouseenter', () => createGuidelines.style.background = '#dcfce7');
               createGuidelines.addEventListener('mouseleave', () => createGuidelines.style.background = '#f0fdf4');
               createGuidelines.addEventListener('click', () => {
                   createSVGComponentGuidelines();
                   hideContextMenu();
               });
               contextMenu.appendChild(createGuidelines);

               // Create Layout Rectangles option
               const createLayoutRects = document.createElement('div');
               createLayoutRects.textContent = '🔲 Create Layout Rectangles';
               createLayoutRects.style.cssText = `
                   padding: 6px 12px;
                   cursor: pointer;
                   border-bottom: 1px solid #eee;
                   background: #fef3c7;
                   color: #92400e;
                   font-weight: bold;
               `;
               createLayoutRects.addEventListener('mouseenter', () => createLayoutRects.style.background = '#fde68a');
               createLayoutRects.addEventListener('mouseleave', () => createLayoutRects.style.background = '#fef3c7');
               createLayoutRects.addEventListener('click', () => {
                   createSVGComponentLayoutRectangles();
                   hideContextMenu();
               });
               contextMenu.appendChild(createLayoutRects);
           }
       }

       // Add separator if copy/paste options were added
       if ((selectedObjectIndex !== -1 || copiedElement) && contextMenu.children.length > 0) {
           const separator = document.createElement('div');
           separator.style.cssText = `
               height: 1px;
               background: #eee;
               margin: 4px 0;
           `;
           contextMenu.appendChild(separator);
       }

       const addHorizontal = document.createElement('div');
       addHorizontal.textContent = 'Add Horizontal Guideline';
       addHorizontal.style.cssText = `
           padding: 6px 12px;
           cursor: pointer;
           border-bottom: 1px solid #eee;
       `;
       addHorizontal.addEventListener('mouseenter', () => addHorizontal.style.background = '#f0f0f0');
       addHorizontal.addEventListener('mouseleave', () => addHorizontal.style.background = 'white');
       addHorizontal.addEventListener('click', () => {
           // Convert click position to world coordinates
           const worldY = (contextMenuY - offsetY) / scale;
           createCanvasGuideline('horizontal', worldY);
           update();
           hideContextMenu();
           console.log(`🔧 Created horizontal guideline at world Y: ${worldY}`);
       });

       const addVertical = document.createElement('div');
       addVertical.textContent = 'Add Vertical Guideline';
       addVertical.style.cssText = `
           padding: 6px 12px;
           cursor: pointer;
       `;
       addVertical.addEventListener('mouseenter', () => addVertical.style.background = '#f0f0f0');
       addVertical.addEventListener('mouseleave', () => addVertical.style.background = 'white');
       addVertical.addEventListener('click', () => {
           // Convert click position to world coordinates
           const worldX = (contextMenuX - offsetX) / scale;
           createCanvasGuideline('vertical', worldX);
           update();
           hideContextMenu();
           console.log(`🔧 Created vertical guideline at world X: ${worldX}`);
       });

       contextMenu.appendChild(addHorizontal);
       contextMenu.appendChild(addVertical);
       document.body.appendChild(contextMenu);
   }

   function showContextMenu(x, y, canvasX, canvasY) {
       createContextMenu();
       contextMenu.style.left = x + 'px';
       contextMenu.style.top = y + 'px';
       contextMenuX = canvasX;
       contextMenuY = canvasY;
   }

   function hideContextMenu() {
       if (contextMenu) {
           document.body.removeChild(contextMenu);
           contextMenu = null;
       }
   }

   // Add right-click event listener to canvas
   canvas.addEventListener('contextmenu', (e) => {
       e.preventDefault();

       // Get canvas coordinates
       const rect = canvas.getBoundingClientRect();
       const canvasX = e.clientX - rect.left;
       const canvasY = e.clientY - rect.top;

       // Convert to world coordinates
       const worldCoords = canvasToWorld(canvasX, canvasY);

       // Check if right-clicking on a state indicator label
       for (let i = 0; i < canvasObjects.length; i++) {
           const obj = canvasObjects[i];
           if (obj._stateIndicator && (obj.isLocked || obj.isHidden)) {
               const indicator = obj._stateIndicator;

               // Check if clicking on the label area
               if (worldCoords.x >= indicator.labelX &&
                   worldCoords.x <= indicator.labelX + indicator.labelWidth &&
                   worldCoords.y >= indicator.labelY - indicator.labelHeight / 2 &&
                   worldCoords.y <= indicator.labelY + indicator.labelHeight / 2) {

                   // Edit the object name
                   const currentName = obj.customName || (obj.type === 'text' ? obj.text?.substring(0, 15) : obj.type);
                   const newName = prompt(`Edit name for this ${obj.type}:`, currentName);
                   if (newName && newName.trim()) {
                       obj.customName = newName.trim();
                       update(); // Redraw to show new name
                   }
                   return; // Don't show context menu
               }
           }
       }

       // Show context menu at mouse position
       showContextMenu(e.clientX, e.clientY, canvasX, canvasY);
   });

   // Hide context menu when clicking elsewhere
   document.addEventListener('click', (e) => {
       if (contextMenu && !contextMenu.contains(e.target)) {
           hideContextMenu();
       }
   });

   // SVG Component Detection functionality
   let svgComponents = [];
   let svgComponentsVisible = false;

   function detectSVGComponentsByColor(canvas, offsetX, offsetY, scale, svgObj) {
       const ctx = canvas.getContext('2d');
       const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
       const data = imageData.data;
       const width = canvas.width;
       const height = canvas.height;

       // Find all unique colors (excluding white/transparent background)
       const colorMap = new Map();

       for (let y = 0; y < height; y++) {
           for (let x = 0; x < width; x++) {
               const index = (y * width + x) * 4;
               const r = data[index];
               const g = data[index + 1];
               const b = data[index + 2];
               const a = data[index + 3];

               // Skip transparent or near-white pixels
               if (a < 128 || (r > 240 && g > 240 && b > 240)) continue;

               const colorKey = `${r},${g},${b}`;
               if (!colorMap.has(colorKey)) {
                   colorMap.set(colorKey, []);
               }
               colorMap.get(colorKey).push({x, y});
           }
       }

       // Group pixels by color and find bounding boxes
       const components = [];
       colorMap.forEach((pixels, colorKey) => {
           if (pixels.length < 50) return; // Skip very small components

           let minX = width, maxX = 0, minY = height, maxY = 0;
           pixels.forEach(pixel => {
               minX = Math.min(minX, pixel.x);
               maxX = Math.max(maxX, pixel.x);
               minY = Math.min(minY, pixel.y);
               maxY = Math.max(maxY, pixel.y);
           });

           // Only include components that are within the SVG area
           const svgAreaLeft = offsetX;
           const svgAreaRight = offsetX + svgObj.originalWidth * svgObj.scale;
           const svgAreaTop = offsetY;
           const svgAreaBottom = offsetY + svgObj.originalHeight * svgObj.scale;

           console.log(`🔍 Color Component Check:`, {
               component: { minX, maxX, minY, maxY, pixelCount: pixels.length },
               svgArea: { left: svgAreaLeft, right: svgAreaRight, top: svgAreaTop, bottom: svgAreaBottom },
               withinArea: minX >= svgAreaLeft && maxX <= svgAreaRight && minY >= svgAreaTop && maxY <= svgAreaBottom
           });

           if (minX >= svgAreaLeft && maxX <= svgAreaRight && minY >= svgAreaTop && maxY <= svgAreaBottom) {

               components.push({
                   method: 'C',
                   color: colorKey,
                   pixelCount: pixels.length,
                   bounds: {
                       x: minX,
                       y: minY,
                       width: maxX - minX + 1,
                       height: maxY - minY + 1
                   }
               });
           }
       });

       // Sort by size (largest first)
       components.sort((a, b) => b.pixelCount - a.pixelCount);

       return components;
   }

   function detectSVGComponentsByRegion(canvas, offsetX, offsetY, scale, svgObj) {
       const ctx = canvas.getContext('2d');
       const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
       const data = imageData.data;
       const width = canvas.width;
       const height = canvas.height;

       // Create a grid-based approach to find connected regions
       const visited = new Array(width * height).fill(false);
       const components = [];

       function floodFill(startX, startY) {
           const stack = [{x: startX, y: startY}];
           const pixels = [];
           let minX = width, maxX = 0, minY = height, maxY = 0;

           while (stack.length > 0) {
               const {x, y} = stack.pop();
               const index = y * width + x;

               if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) continue;

               const pixelIndex = index * 4;
               const r = data[pixelIndex];
               const g = data[pixelIndex + 1];
               const b = data[pixelIndex + 2];
               const a = data[pixelIndex + 3];

               // Skip transparent or near-white pixels
               if (a < 128 || (r > 240 && g > 240 && b > 240)) continue;

               visited[index] = true;
               pixels.push({x, y});

               minX = Math.min(minX, x);
               maxX = Math.max(maxX, x);
               minY = Math.min(minY, y);
               maxY = Math.max(maxY, y);

               // Add neighboring pixels
               stack.push({x: x + 1, y}, {x: x - 1, y}, {x, y: y + 1}, {x, y: y - 1});
           }

           return pixels.length > 0 ? {pixels, minX, maxX, minY, maxY} : null;
       }

       // Scan for connected regions
       for (let y = Math.floor(offsetY); y < offsetY + svgObj.originalHeight * svgObj.scale; y += 5) {
           for (let x = Math.floor(offsetX); x < offsetX + svgObj.originalWidth * svgObj.scale; x += 5) {
               const index = y * width + x;
               if (!visited[index]) {
                   const region = floodFill(x, y);
                   if (region && region.pixels.length > 100) { // Minimum size for regions
                       components.push({
                           method: 'R',
                           pixelCount: region.pixels.length,
                           bounds: {
                               x: region.minX,
                               y: region.minY,
                               width: region.maxX - region.minX + 1,
                               height: region.maxY - region.minY + 1
                           }
                       });
                   }
               }
           }
       }

       return components;
   }

   function mergeComponentDetections(colorComponents, regionComponents) {
       const allComponents = [...colorComponents, ...regionComponents];
       const merged = [];

       // Simple deduplication based on overlap
       allComponents.forEach(comp => {
           const overlaps = merged.some(existing => {
               const overlapX = Math.max(0, Math.min(comp.bounds.x + comp.bounds.width, existing.bounds.x + existing.bounds.width) - Math.max(comp.bounds.x, existing.bounds.x));
               const overlapY = Math.max(0, Math.min(comp.bounds.y + comp.bounds.height, existing.bounds.y + existing.bounds.height) - Math.max(comp.bounds.y, existing.bounds.y));
               const overlapArea = overlapX * overlapY;
               const compArea = comp.bounds.width * comp.bounds.height;
               const existingArea = existing.bounds.width * existing.bounds.height;

               // If overlap is more than 70% of either component, consider them the same
               return (overlapArea / compArea > 0.7) || (overlapArea / existingArea > 0.7);
           });

           if (!overlaps) {
               merged.push(comp);
           }
       });

       // Sort by size
       merged.sort((a, b) => b.pixelCount - a.pixelCount);

       return merged;
   }

   function detectSVGComponents() {
       if (selectedObjectIndex === -1 || !canvasObjects[selectedObjectIndex] ||
           canvasObjects[selectedObjectIndex].type !== 'image' ||
           !canvasObjects[selectedObjectIndex].imageUrl ||
           !canvasObjects[selectedObjectIndex].imageUrl.toLowerCase().endsWith('.svg')) {
           console.log('🔍 SVG Component Detection: No SVG selected');
           return;
       }

       const svgObj = canvasObjects[selectedObjectIndex];
       console.log('🔍 SVG Component Detection: Analyzing SVG object', svgObj);

       // Create a temporary canvas to render the SVG for analysis
       const tempCanvas = document.createElement('canvas');
       tempCanvas.width = canvas.width;
       tempCanvas.height = canvas.height;
       const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

       // Apply the same transformations as the main canvas
       tempCtx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

       // Draw the SVG on the temporary canvas
       if (svgObj.image && svgObj.image.complete) {
           const drawX = svgObj.x - (svgObj.originalWidth * svgObj.scale) / 2;
           const drawY = svgObj.y - (svgObj.originalHeight * svgObj.scale) / 2;
           const drawWidth = svgObj.originalWidth * svgObj.scale;
           const drawHeight = svgObj.originalHeight * svgObj.scale;

           tempCtx.drawImage(svgObj.image, drawX, drawY, drawWidth, drawHeight);

           // Calculate screen coordinates for the SVG
           const screenX = svgObj.x * scale + offsetX - (drawWidth * scale) / 2;
           const screenY = svgObj.y * scale + offsetY - (drawHeight * scale) / 2;

           console.log('🔍 SVG Detection Coordinates:', {
               svgObj: { x: svgObj.x, y: svgObj.y, scale: svgObj.scale },
               drawDimensions: { drawWidth, drawHeight },
               screenCoords: { screenX, screenY },
               canvasTransform: { scale, offsetX, offsetY }
           });

           // Detect components using both methods
           const colorComponents = detectSVGComponentsByColor(tempCanvas, screenX, screenY, scale, svgObj);
           const regionComponents = detectSVGComponentsByRegion(tempCanvas, screenX, screenY, scale, svgObj);

           // Combine and store results
           svgComponents = mergeComponentDetections(colorComponents, regionComponents);

           console.log(`🔍 SVG Component Detection: Found ${svgComponents.length} components`, svgComponents);

           // Automatically show component bounds after detection
           if (svgComponents.length > 0) {
               showSVGComponentBounds();
               console.log('🔍 SVG Component Detection: Automatically showing component bounds');
           } else {
               console.log('🔍 SVG Component Detection: No components found to display');
           }
       } else {
           console.log('🔍 SVG Component Detection: SVG image not loaded');
       }
   }

   function showSVGComponentBounds() {
       svgComponentsVisible = true;
       update(); // Redraw canvas to show component bounds
       console.log('🔍 SVG Component Detection: Showing component bounds');
   }

   function hideSVGComponentBounds() {
       svgComponentsVisible = false;
       update(); // Redraw canvas to hide component bounds
       console.log('🔍 SVG Component Detection: Hiding component bounds');
   }

   function createSVGComponentGuidelines() {
       if (svgComponents.length === 0) {
           console.log('🔍 SVG Component Detection: No components detected');
           return;
       }

       let guidelinesCreated = 0;

       svgComponents.forEach((component, index) => {
           const bounds = component.bounds;

           // Convert screen coordinates back to world coordinates
           const worldLeft = (bounds.x - offsetX) / scale;
           const worldRight = (bounds.x + bounds.width - offsetX) / scale;
           const worldTop = (bounds.y - offsetY) / scale;
           const worldBottom = (bounds.y + bounds.height - offsetY) / scale;

           // Create guidelines for each component
           createCanvasGuideline('vertical', worldLeft);
           createCanvasGuideline('vertical', worldRight);
           createCanvasGuideline('horizontal', worldTop);
           createCanvasGuideline('horizontal', worldBottom);

           guidelinesCreated += 4;
       });

       update();
       console.log(`🔍 SVG Component Detection: Created ${guidelinesCreated} guidelines for ${svgComponents.length} components`);
   }

   // Function to create layout rectangles from detected SVG components
   function createSVGComponentLayoutRectangles() {
       if (!svgComponents || svgComponents.length === 0) {
           console.log('🔍 SVG Component Layout Rectangles: No components detected');
           if (window.showToast) {
               window.showToast('No SVG components detected. Please detect components first.', 'error');
           }
           return;
       }

       let rectanglesCreated = 0;

       svgComponents.forEach((component, index) => {
           const bounds = component.bounds;

           // Convert screen coordinates back to world coordinates for layout rectangles
           const worldLeft = (bounds.x - offsetX) / scale;
           const worldTop = (bounds.y - offsetY) / scale;
           const worldWidth = bounds.width / scale;
           const worldHeight = bounds.height / scale;

           // Create layout rectangle for each component
           const newRect = {
               id: Date.now() + rectanglesCreated,
               x: worldLeft,
               y: worldTop,
               width: worldWidth,
               height: worldHeight,
               // Use component detection method for color coding
               borderColor: component.method === 'C' ? '#ff6b6b' : component.method === 'R' ? '#4ecdc4' : '#45b7d1',
               borderWidth: 2
           };

           layoutRectangles.push(newRect);
           rectanglesCreated++;

           console.log(`🔍 SVG Component Layout Rectangle ${index + 1}:`, {
               component: component,
               screenBounds: bounds,
               worldBounds: { x: worldLeft, y: worldTop, width: worldWidth, height: worldHeight },
               rectangle: newRect
           });
       });

       // Update global reference
       window.layoutRectangles = layoutRectangles;

       console.log(`🔍 SVG Component Layout Rectangles: Created ${rectanglesCreated} layout rectangles for ${svgComponents.length} components`);

       if (window.showToast) {
           window.showToast(`Created ${rectanglesCreated} layout rectangles for ${svgComponents.length} SVG components`, 'success');
       }

       // Update the canvas
       update();
   }

   function drawSVGComponentBounds(ctx) {
       if (!svgComponents || svgComponents.length === 0) return;

       ctx.save();

       // Keep the current world coordinate transform (don't reset to screen coordinates)
       // The bounds are already in screen coordinates, so we need to convert them to world coordinates

       svgComponents.forEach((component, index) => {
           const bounds = component.bounds;

           // Convert screen coordinates back to world coordinates for drawing
           const worldLeft = (bounds.x - offsetX) / scale;
           const worldTop = (bounds.y - offsetY) / scale;
           const worldWidth = bounds.width / scale;
           const worldHeight = bounds.height / scale;

           // Removed console.log for performance - was logging on every frame

           // Choose color based on detection method
           let color;
           if (component.method === 'C') {
               color = '#ff6b6b'; // Red for color-based detection
           } else if (component.method === 'R') {
               color = '#4ecdc4'; // Teal for region-based detection
           } else {
               color = '#45b7d1'; // Blue for merged/other
           }

           // Draw bounding box in world coordinates
           ctx.strokeStyle = color;
           ctx.lineWidth = 2 / scale; // Scale line width
           ctx.setLineDash([5 / scale, 3 / scale]); // Scale dash pattern
           ctx.strokeRect(worldLeft, worldTop, worldWidth, worldHeight);

           // Draw component label
           ctx.fillStyle = color;
           ctx.font = `${12 / scale}px Arial`; // Scale font size
           ctx.fillText(`C${index + 1}`, worldLeft + 2 / scale, worldTop - 5 / scale);

           // Draw method indicator
           ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
           ctx.fillRect(worldLeft + worldWidth - 20 / scale, worldTop, 18 / scale, 16 / scale);
           ctx.fillStyle = 'white';
           ctx.font = `${10 / scale}px Arial`; // Scale font size
           ctx.fillText(component.method, worldLeft + worldWidth - 17 / scale, worldTop + 11 / scale);
       });

       ctx.setLineDash([]);
       ctx.restore();
   }

   // Ruler toggle functionality
   let rulersVisible = false;
   const toggleRulersBtn = document.getElementById('toggleRulersBtn');
   const rulerCorner = document.getElementById('ruler-corner');

   function toggleRulers() {
       rulersVisible = !rulersVisible;

       if (rulersVisible) {
           horizontalRuler.style.display = 'block';
           verticalRuler.style.display = 'block';
           rulerCorner.style.display = 'block';
           toggleRulersBtn.style.background = '#e3f2fd';
           drawRulers(); // Redraw rulers when shown
       } else {
           horizontalRuler.style.display = 'none';
           verticalRuler.style.display = 'none';
           rulerCorner.style.display = 'none';
           toggleRulersBtn.style.background = '';
       }
   }

   if (toggleRulersBtn) {
       toggleRulersBtn.addEventListener('click', toggleRulers);
   }

   // Clear guidelines functionality
   const clearGuidelinesBtn = document.getElementById('clearGuidelinesBtn');

   function clearAllGuidelines() {
       // Clear DOM-based guidelines
       if (guidelinesContainer) {
           while (guidelinesContainer.firstChild) {
               guidelinesContainer.removeChild(guidelinesContainer.firstChild);
           }
       }

       // Clear canvas-based guidelines array
       guidelines.length = 0;

       update(); // Redraw canvas
       console.log('🔧 All guidelines cleared (both DOM and canvas-based)');
   }

   if (clearGuidelinesBtn) {
       clearGuidelinesBtn.addEventListener('click', clearAllGuidelines);
   }

   // Canvas-based guidelines update automatically with canvas redraw

   // Test function to create guidelines and test zoom synchronization
   window.testGuidelineZoomSync = function() {
       console.log(`🧪 GUIDELINE TEST: Starting guideline zoom synchronization test`);
       console.log(`🧪 GUIDELINE TEST: Current guidelines count: ${guidelines.length}`);
       console.log(`🧪 GUIDELINE TEST: Current transform - offsetX: ${offsetX}, offsetY: ${offsetY}, scale: ${scale}`);

       // Clear existing guidelines for clean test
       guidelines.forEach(guideline => guideline.remove());
       guidelines.length = 0;
       console.log(`🧪 GUIDELINE TEST: Cleared existing guidelines`);

       // Create test guidelines using canvas coordinates
       console.log(`🧪 GUIDELINE TEST: Creating test guidelines...`);
       createGuideline('vertical', 300);   // Vertical guideline at canvas X position 300
       createGuideline('horizontal', 200); // Horizontal guideline at canvas Y position 200

       console.log(`🧪 GUIDELINE TEST: Created guidelines. New count: ${guidelines.length}`);

       // Test zoom operations
       setTimeout(() => {
           console.log(`🧪 GUIDELINE TEST: Testing zoom in...`);
           const initialScale = scale;
           zoom(1.5);
           console.log(`🧪 GUIDELINE TEST: Scale changed from ${initialScale} to ${scale}`);

           setTimeout(() => {
               console.log(`🧪 GUIDELINE TEST: Testing zoom out...`);
               const beforeScale = scale;
               zoom(0.8);
               console.log(`🧪 GUIDELINE TEST: Scale changed from ${beforeScale} to ${scale}`);

               setTimeout(() => {
                   console.log(`🧪 GUIDELINE TEST: Test completed. Check if guidelines moved correctly with zoom.`);
                   console.log(`🧪 GUIDELINE TEST: Final transform - offsetX: ${offsetX}, offsetY: ${offsetY}, scale: ${scale}`);
               }, 1000);
           }, 1000);
       }, 1000);
   };

   // Comprehensive verification function
   window.verifyGuidelineSync = function() {
       console.log('🔍 VERIFICATION: Starting guideline synchronization verification...');

       // Check if required elements exist
       const canvasArea = document.getElementById('canvas-area');
       const horizontalRuler = document.getElementById('horizontal-ruler');
       const verticalRuler = document.getElementById('vertical-ruler');

       if (!canvasArea || !horizontalRuler || !verticalRuler) {
           console.error('❌ VERIFICATION: Required elements not found');
           return false;
       }

       console.log('✅ VERIFICATION: Required elements found');
       console.log(`📊 VERIFICATION: Current guidelines count: ${guidelines.length}`);
       console.log(`📊 VERIFICATION: Current transform - offsetX: ${offsetX}, offsetY: ${offsetY}, scale: ${scale}`);

       // Clear existing guidelines
       guidelines.forEach(guideline => guideline.remove());
       guidelines.length = 0;
       console.log('🧹 VERIFICATION: Cleared existing guidelines');

       // Create test guidelines at known positions
       const testVerticalX = 300;
       const testHorizontalY = 200;

       console.log(`🎯 VERIFICATION: Creating test vertical guideline at canvas X: ${testVerticalX}`);
       createGuideline('vertical', testVerticalX);

       console.log(`🎯 VERIFICATION: Creating test horizontal guideline at canvas Y: ${testHorizontalY}`);
       createGuideline('horizontal', testHorizontalY);

       if (guidelines.length !== 2) {
           console.error('❌ VERIFICATION: Failed to create test guidelines');
           return false;
       }

       console.log('✅ VERIFICATION: Test guidelines created successfully');

       // Record initial positions
       const verticalGuideline = guidelines.find(g => g.dataset.type === 'vertical');
       const horizontalGuideline = guidelines.find(g => g.dataset.type === 'horizontal');

       const initialVerticalWorld = parseFloat(verticalGuideline.dataset.worldPosition);
       const initialHorizontalWorld = parseFloat(horizontalGuideline.dataset.worldPosition);

       console.log(`📍 VERIFICATION: Initial vertical world position: ${initialVerticalWorld}`);
       console.log(`📍 VERIFICATION: Initial horizontal world position: ${initialHorizontalWorld}`);

       // Test zoom operations
       console.log('🔍 VERIFICATION: Testing zoom operations...');

       const initialScale = scale;
       const initialOffsetX = offsetX;
       const initialOffsetY = offsetY;

       // Zoom in
       zoom(1.5);

       setTimeout(() => {
           console.log(`📊 VERIFICATION: After zoom in - scale: ${initialScale} → ${scale}`);

           // Check if world positions remained the same
           const newVerticalWorld = parseFloat(verticalGuideline.dataset.worldPosition);
           const newHorizontalWorld = parseFloat(horizontalGuideline.dataset.worldPosition);

           if (Math.abs(newVerticalWorld - initialVerticalWorld) < 0.001 &&
               Math.abs(newHorizontalWorld - initialHorizontalWorld) < 0.001) {
               console.log('✅ VERIFICATION: World positions preserved during zoom');
           } else {
               console.error('❌ VERIFICATION: World positions changed during zoom');
               console.error(`   Vertical: ${initialVerticalWorld} → ${newVerticalWorld}`);
               console.error(`   Horizontal: ${initialHorizontalWorld} → ${newHorizontalWorld}`);
           }

           // Check screen position calculation (same formula as ruler drawing)
           const expectedVerticalScreen = initialVerticalWorld * scale + offsetX;
           const expectedHorizontalScreen = initialHorizontalWorld * scale + offsetY;

           const actualVerticalScreen = parseFloat(verticalGuideline.style.left);
           const actualHorizontalScreen = parseFloat(horizontalGuideline.style.top);

           console.log(`🧮 VERIFICATION: Expected vertical screen: ${expectedVerticalScreen}, actual: ${actualVerticalScreen}`);
           console.log(`🧮 VERIFICATION: Expected horizontal screen: ${expectedHorizontalScreen}, actual: ${actualHorizontalScreen}`);

           if (Math.abs(actualVerticalScreen - expectedVerticalScreen) < 1 &&
               Math.abs(actualHorizontalScreen - expectedHorizontalScreen) < 1) {
               console.log('✅ VERIFICATION: Screen position calculations correct');
           } else {
               console.error('❌ VERIFICATION: Screen position calculations incorrect');
           }

           // Zoom back out
           zoom(0.8);

           setTimeout(() => {
               console.log('🎉 VERIFICATION: Test completed');
               console.log('📋 VERIFICATION: Manual test instructions:');
               console.log('   1. Look at the guidelines on screen');
               console.log('   2. Use mouse wheel to zoom in/out');
               console.log('   3. Guidelines should move with canvas objects');
               console.log('   4. If they stay aligned, the fix is working!');
           }, 500);

       }, 500);

       return true;
   };







   // Initialize rulers on load and resize
   window.addEventListener('load', () => {
       initializeRulers();
   });
   window.addEventListener('resize', () => {
       initializeRulers();
       // Canvas-based guidelines update automatically with canvas redraw
   });

   canvas.addEventListener('mousedown', handleMouseDown); canvas.addEventListener('wheel', handleWheel, { passive: false }); window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleMouseUp); canvas.addEventListener('mouseleave', handleMouseLeave);
   zoomInBtn.addEventListener('click', () => zoom(1.2)); zoomOutBtn.addEventListener('click', () => zoom(1 / 1.2));
   // Ensure listeners are added only once, check if they exist before adding if necessary
   if (moveForwardBtn && !moveForwardBtn.onclick) { // Basic check
       moveForwardBtn.addEventListener('click', moveObjectForward);
   }
   if (moveBackwardBtn && !moveBackwardBtn.onclick) { // Basic check
       moveBackwardBtn.addEventListener('click', moveObjectBackward);
   }

   // Background Color Picker Listeners (Now using Pickr)
   // Pickr initialization moved to DOMContentLoaded listener below

   const sidebarTabs = document.querySelectorAll('.sidebar-tab'); const sidebarContents = document.querySelectorAll('.sidebar-content'); const propertyTabs = document.querySelectorAll('.property-tab'); const propertyPanels = document.querySelectorAll('.property-panel'); sidebarTabs.forEach(tab => { tab.addEventListener('click', () => { const targetContentId = tab.getAttribute('data-tab'); sidebarTabs.forEach(t => t.classList.remove('active')); sidebarContents.forEach(c => c.classList.remove('active')); tab.classList.add('active'); document.getElementById(targetContentId)?.classList.add('active'); }); }); propertyTabs.forEach(tab => { tab.addEventListener('click', () => { const targetPanelClass = tab.getAttribute('data-panel'); propertyTabs.forEach(t => t.classList.remove('active')); propertyPanels.forEach(p => p.classList.remove('active')); tab.classList.add('active'); document.querySelector(`#text-controls .${targetPanelClass}`)?.classList.add('active'); }); });

   // --- Persistent Parameter System ---
   async function savePersistentParameter(objectId, parameterName, value) {
       try {
           const templateId = getCurrentTemplateId();
           const requestData = {
               objectId: objectId,
               parameterName: parameterName,
               value: value,
               templateId: templateId
           };

           console.log(`💾 Saving persistent parameter: ${parameterName} = ${value} for object ${objectId}`);
           console.log('💾 Request data:', requestData);

           const response = await fetch('/api/persistent-parameters', {
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json'
               },
               body: JSON.stringify(requestData)
           });

           if (!response.ok) {
               throw new Error(`Failed to save persistent parameter: ${response.statusText}`);
           }

           const result = await response.json();
           console.log(`💾 Successfully saved persistent parameter:`, result);

           // Show success toast if available
           if (window.showToast) {
               window.showToast(`Saved ${parameterName}: ${value}`, 'success');
           }

       } catch (error) {
           console.error(`💾 Error saving persistent parameter:`, error);

           // Show error toast if available
           if (window.showToast) {
               window.showToast(`Failed to save ${parameterName}`, 'error');
           }
       }
   }

   // Helper function to get current template ID if available
   function getCurrentTemplateId() {
       // Try to get template ID from URL parameters or other context
       const urlParams = new URLSearchParams(window.location.search);
       return urlParams.get('templateId') || null;
   }

   // Load persistent parameters for all objects
   async function loadPersistentParametersForAllObjects() {
       console.log('💾 Loading persistent parameters for all objects...');

       for (const obj of canvasObjects) {
           try {
               await loadPersistentParametersForObject(obj);
           } catch (error) {
               console.error(`💾 Error loading persistent parameters for object ${obj.id}:`, error);
           }
       }

       console.log('💾 Finished loading persistent parameters for all objects');
   }

   // Load persistent parameters for a single object
   async function loadPersistentParametersForObject(obj) {
       try {
           console.log(`💾 Loading persistent parameters for object ${obj.id}`);

           const response = await fetch(`/api/persistent-parameters/${obj.id}`, {
               method: 'GET',
               headers: {
                   'Content-Type': 'application/json'
               }
           });

           if (!response.ok) {
               if (response.status === 404) {
                   console.log(`💾 No persistent parameters found for object ${obj.id}`);
                   return;
               }
               throw new Error(`Failed to load persistent parameters: ${response.statusText}`);
           }

           const result = await response.json();
           console.log(`💾 Loaded persistent parameters for object ${obj.id}:`, result.data);

           // Apply the persistent parameters to the object
           if (result.data.newColorIntensity) {
               obj.newColorIntensity = result.data.newColorIntensity.value;
               console.log(`💾 Applied newColorIntensity: ${obj.newColorIntensity} to object ${obj.id}`);
           }

           if (result.data.newTemplateId) {
               obj.newTemplateId = result.data.newTemplateId.value;
               console.log(`💾 Applied newTemplateId: ${obj.newTemplateId} to object ${obj.id}`);
           }

       } catch (error) {
           console.error(`💾 Error loading persistent parameters for object ${obj.id}:`, error);
           // Don't throw - just log the error and continue
       }
   }

   // --- Background Removal Handler ---
   async function handleBgRemoveClick() {
       console.log('🎯 [BG REMOVE DEBUG] ===== BACKGROUND REMOVAL STARTED =====');
       console.log('🎯 [BG REMOVE DEBUG] selectedObjectIndex:', selectedObjectIndex);
       console.log('🎯 [BG REMOVE DEBUG] canvasObjects.length:', canvasObjects.length);

       if (selectedObjectIndex === -1 || canvasObjects[selectedObjectIndex].type !== 'image') {
           console.log('🎯 [BG REMOVE DEBUG] ❌ No image selected or wrong object type');
           return;
       }

       const imageObj = canvasObjects[selectedObjectIndex];
       console.log('🎯 [BG REMOVE DEBUG] Selected image object:', {
           type: imageObj.type,
           imageUrl: imageObj.imageUrl,
           generationId: imageObj.generationId,
           backgroundRemoved: imageObj.backgroundRemoved
       });

       // Check if background already removed
       if (imageObj.backgroundRemoved) {
           if (window.showToast) window.showToast('Background already removed from this image', 'warning');
           return;
       }

       const removeBgBtn = document.getElementById('removeBgBtn');
       removeBgBtn.disabled = true;
       removeBgBtn.textContent = 'Removing...';
       if (window.showToast) window.showToast('Removing background...', 'info');

       try {
           // First, check if user is authenticated by testing a simple API call
           console.log('Checking authentication...');
           const authTestResponse = await fetch('/api/auth/check', {
               credentials: 'include'
           });

           if (!authTestResponse.ok) {
               throw new Error('User not authenticated. Please log in and try again.');
           }

           const userProfile = await authTestResponse.json();
           console.log('User authenticated:', userProfile.user.email || userProfile.user.name || 'Unknown user');
           // Get the current image URL and handle different URL types
           let currentUrl = imageObj.imageUrl;

           console.log('🎯 [BG REMOVE DEBUG] Starting URL processing...');
           console.log('🎯 [BG REMOVE DEBUG] Initial currentUrl:', currentUrl);
           console.log('🎯 [BG REMOVE DEBUG] typeof currentUrl:', typeof currentUrl);
           console.log('🎯 [BG REMOVE DEBUG] currentUrl.includes("/api/assets/by-id/"):', currentUrl.includes('/api/assets/by-id/'));

           // Check if it's an asset URL - if so, get the B2 URL that Replicate can access
           if (currentUrl.includes('/api/assets/by-id/')) {
               console.log('🎯 [BG REMOVE DEBUG] Asset URL detected, getting B2 URL for Replicate access...');
               console.log('🎯 [BG REMOVE DEBUG] Original asset URL:', currentUrl);

               // Extract asset ID from URL like /api/assets/by-id/images-image-xyz
               const assetIdMatch = currentUrl.match(/\/api\/assets\/by-id\/(.+)$/);
               if (assetIdMatch) {
                   const assetId = assetIdMatch[1];
                   console.log('🎯 [BG REMOVE DEBUG] Extracted asset ID:', assetId);

                   try {
                       console.log('🎯 [BG REMOVE DEBUG] Fetching bucket URL from:', `/api/assets/bucket-url/${assetId}`);
                       const bucketUrlResponse = await fetch(`/api/assets/bucket-url/${assetId}`, {
                           credentials: 'include'
                       });

                       console.log('🎯 [BG REMOVE DEBUG] Bucket URL response status:', bucketUrlResponse.status);

                       if (bucketUrlResponse.ok) {
                           const bucketData = await bucketUrlResponse.json();
                           console.log('🎯 [BG REMOVE DEBUG] Bucket URL response data:', bucketData);

                           if (bucketData.success && bucketData.bucketUrl) {
                               currentUrl = bucketData.bucketUrl;
                               console.log('🎯 [BG REMOVE DEBUG] ✅ Successfully got B2 URL for Replicate:', currentUrl);
                           } else {
                               console.error('🎯 [BG REMOVE DEBUG] ❌ Asset has no B2 URL available:', bucketData);
                               throw new Error('Asset does not have a B2 URL available for background removal');
                           }
                       } else {
                           const errorText = await bucketUrlResponse.text();
                           console.error('🎯 [BG REMOVE DEBUG] ❌ Failed to get bucket URL, status:', bucketUrlResponse.status, 'error:', errorText);
                           throw new Error('Failed to get asset B2 URL for background removal');
                       }
                   } catch (error) {
                       console.error('🎯 [BG REMOVE DEBUG] ❌ Error getting bucket URL:', error);
                       throw new Error(`Cannot access asset for background removal: ${error.message}`);
                   }
               } else {
                   console.error('🎯 [BG REMOVE DEBUG] ❌ Invalid asset URL format:', currentUrl);
                   throw new Error('Invalid asset URL format');
               }
           }

           // Check if it's a base64 data URL - if so, we need to upload it first
           if (currentUrl.startsWith('data:')) {
               console.log('Base64 image detected, uploading to storage first...');

               // Convert base64 to blob
               const response = await fetch(currentUrl);
               const blob = await response.blob();

               // Create FormData for upload
               const formData = new FormData();
               formData.append('image', blob, 'image.png');

               // Upload to B2 storage
               const uploadResponse = await fetch('/api/images/upload', {
                   method: 'POST',
                   body: formData,
                   credentials: 'include'
               });

               if (!uploadResponse.ok) {
                   const errorData = await uploadResponse.json();
                   throw new Error(`Failed to upload image: ${errorData.error || 'Unknown error'}`);
               }

               const uploadData = await uploadResponse.json();
               currentUrl = uploadData.imageUrl || uploadData.url;

               // Update the image object with the new URL
               imageObj.imageUrl = currentUrl;

               console.log('Image uploaded successfully, new URL:', currentUrl);
           }

           console.log('🎯 [BG REMOVE DEBUG] Checking URL type for:', currentUrl);
           console.log('🎯 [BG REMOVE DEBUG] currentUrl.startsWith("http"):', currentUrl.startsWith('http'));
           console.log('🎯 [BG REMOVE DEBUG] currentUrl.startsWith("data:"):', currentUrl.startsWith('data:'));
           console.log('🎯 [BG REMOVE DEBUG] currentUrl.includes("/api/assets/by-id/"):', currentUrl.includes('/api/assets/by-id/'));

           if (!currentUrl.startsWith('http')) {
               console.log('🎯 [BG REMOVE DEBUG] Converting relative URL to absolute...');
               console.log('🎯 [BG REMOVE DEBUG] Original URL:', currentUrl);
               console.log('🎯 [BG REMOVE DEBUG] window.location.origin:', window.location.origin);

               // Convert relative URL to absolute using current origin
               if (currentUrl.startsWith('/')) {
                   currentUrl = window.location.origin + currentUrl;
               } else {
                   // For relative paths without leading slash
                   currentUrl = window.location.origin + '/' + currentUrl;
               }
               console.log('🎯 [BG REMOVE DEBUG] ✅ Converted relative URL to absolute:', currentUrl);
           }

           // Ensure URL is properly encoded
           console.log('🎯 [BG REMOVE DEBUG] Validating URL with new URL():', currentUrl);
           try {
               currentUrl = new URL(currentUrl).toString();
               console.log('🎯 [BG REMOVE DEBUG] ✅ URL validation successful:', currentUrl);
           } catch (e) {
               console.error('🎯 [BG REMOVE DEBUG] ❌ Invalid URL:', currentUrl);
               console.error('🎯 [BG REMOVE DEBUG] ❌ URL validation error:', e);
               throw new Error('Invalid image URL');
           }

           console.log('Sending image URL for background removal:', currentUrl);

           let generationId = imageObj.generationId;

           // If no generationId exists, create a temporary Generation record using collections endpoint
           if (!generationId) {
               console.log('No generationId found, creating temporary Generation record...');

               // First, create a temporary collection to hold our generation
               const createCollectionResponse = await fetch('/api/collections', {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({
                       title: 'Temp Collection for BG Removal',
                       description: 'Temporary collection for background removal'
                   }),
                   credentials: 'include'
               });

               if (!createCollectionResponse.ok) {
                   const errorData = await createCollectionResponse.json();
                   throw new Error(`Failed to create temporary collection: ${errorData.error || 'Unknown error'}`);
               }

               const collectionData = await createCollectionResponse.json();
               const tempCollectionId = collectionData._id;

               // Now add the image to the collection, which creates a Generation record
               const addImageResponse = await fetch(`/api/collections/${tempCollectionId}/images`, {
                   method: 'POST',
                   headers: { 'Content-Type': 'application/json' },
                   body: JSON.stringify({
                       imageUrl: currentUrl,
                       prompt: 'Uploaded Image for Background Removal'
                   }),
                   credentials: 'include'
               });

               if (!addImageResponse.ok) {
                   const errorData = await addImageResponse.json();
                   throw new Error(`Failed to create generation record: ${errorData.error || 'Unknown error'}`);
               }

               const addImageData = await addImageResponse.json();
               console.log('Add image response data:', addImageData);

               // The response should be the Generation object with _id field
               generationId = addImageData._id || addImageData.generationId;

               if (!generationId) {
                   console.error('No generationId found in response:', addImageData);
                   throw new Error('Failed to get generation ID from response');
               }

               // Update the image object with the new generationId
               imageObj.generationId = generationId;
               imageObj.isFromGeneration = true;

               console.log('Created temporary Generation record with ID:', generationId);

               // Note: Temporary collection is left in place as DELETE endpoint doesn't exist
               // This is acceptable as it will contain the background-removed image
           }

           console.log('🎯 [BG REMOVE DEBUG] Calling background removal API with:', {
               imageUrl: currentUrl,
               generationId: generationId
           });

           const response = await fetch('/api/images/bgremove', {
               method: 'POST',
               headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify({
                   imageUrl: currentUrl,
                   generationId: generationId
               }),
               credentials: 'include'
           });

           console.log('🎯 [BG REMOVE DEBUG] API response status:', response.status);
           console.log('🎯 [BG REMOVE DEBUG] API response headers:', Object.fromEntries(response.headers.entries()));

           if (!response.ok) {
               const errorText = await response.text();
               console.error('🎯 [BG REMOVE DEBUG] ❌ API error response:', errorText);
               let data;
               try {
                   data = JSON.parse(errorText);
               } catch (e) {
                   data = { error: errorText };
               }
               throw new Error(data.error || data.details || 'Failed to remove background');
           }

           const data = await response.json();
           console.log('🎯 [BG REMOVE DEBUG] ✅ API success response:', data);
           console.log('Background removal response:', data);

           // Check if we got the expected response format
           if (!data.imageUrl && !data.url) {
               console.error('Invalid background removal response format:', data);
               throw new Error('Invalid response format from background removal API');
           }

           // Use imageUrl or url from response
           const transparentUrl = data.imageUrl || data.url;
           console.log('Using transparent URL:', transparentUrl);

           // Load the new image
           const newImg = new Image();
           newImg.crossOrigin = 'anonymous';
           newImg.onload = () => {
               imageObj.image = newImg; // Replace the image element in the object
               // 🎯 FIX: Store proxied URL instead of direct B2 URL to avoid CORS issues when saving/loading projects
               imageObj.imageUrl = getProxiedImageUrlIfNeeded(transparentUrl); // Update the stored URL
               imageObj.backgroundRemoved = true; // Mark as removed
               imageObj.originalWidth = newImg.naturalWidth; // Update dimensions if needed
               imageObj.originalHeight = newImg.naturalHeight;
               removeBgBtn.textContent = 'Background Removed'; // Keep disabled
               removeBgBtn.disabled = true; // Disable but keep visible
               update(); // Redraw canvas
               console.log('🎯 Stored proxied URL for project saving:', imageObj.imageUrl);
               if (window.showToast) window.showToast('Background removed successfully!', 'success');
           };
           newImg.onerror = () => {
               console.error('Failed to load the background-removed image:', transparentUrl);
               throw new Error('Failed to load updated image');
           };
           newImg.src = getProxiedImageUrlIfNeeded(transparentUrl); // Use proxy helper

       } catch (error) {
           console.error('🎯 [BG REMOVE DEBUG] ❌ ===== BACKGROUND REMOVAL FAILED =====');
           console.error('🎯 [BG REMOVE DEBUG] Error details:', error);
           console.error('🎯 [BG REMOVE DEBUG] Error message:', error.message);
           console.error('🎯 [BG REMOVE DEBUG] Error stack:', error.stack);

           if (window.showToast) window.showToast(`Failed to remove background: ${error.message}`, 'error');
           else alert(`Error removing background: ${error.message}`);
           removeBgBtn.disabled = false; // Re-enable on error
           removeBgBtn.textContent = 'Remove Background';
       }
   }

   // --- Check if Admin Data is Available ---
   function checkIfHasAdminData() {
       const adminPrompt = document.getElementById('adminPrompt');
       const adminModel = document.getElementById('adminModel');
       const adminOriginalObject = document.getElementById('adminOriginalObject');
       const adminOriginalPalette = document.getElementById('adminOriginalPalette');

       return adminPrompt && adminPrompt.value.trim() !== '' &&
              adminModel && adminModel.value.trim() !== '' &&
              adminOriginalObject && adminOriginalObject.value.trim() !== '' &&
              adminOriginalPalette && adminOriginalPalette.value.trim() !== '';
   }

   // --- Check if Restyle is Available (only needs Original Object) ---
   function checkIfRestyleAvailable() {
       const adminOriginalObject = document.getElementById('adminOriginalObject');
       return adminOriginalObject && adminOriginalObject.value.trim() !== '';
   }

   // --- Regenerate Image Function ---
   async function handleRegenerateClick() {
       console.log('Regenerate button clicked');

       if (selectedObjectIndex === -1) {
           if (window.showToast) window.showToast('No image selected', 'error');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       if (selectedObject.type !== 'image') {
           if (window.showToast) window.showToast('Selected object is not an image', 'error');
           return;
       }

       // Save target image reference for replacement
       window.targetImageIndexForReplacement = selectedObjectIndex;
       console.log('🎯 Saved target image index for regeneration:', selectedObjectIndex);

       // Get admin data
       const adminPrompt = document.getElementById('adminPrompt');
       const adminModel = document.getElementById('adminModel');
       const adminOriginalObject = document.getElementById('adminOriginalObject');
       const adminOriginalPalette = document.getElementById('adminOriginalPalette');

       if (!adminPrompt || !adminModel || !adminOriginalObject || !adminOriginalPalette) {
           if (window.showToast) window.showToast('Admin data fields not found', 'error');
           return;
       }

       const prompt = adminPrompt.value.trim();
       const model = adminModel.value.trim();
       const originalObject = adminOriginalObject.value.trim();
       const originalPalette = adminOriginalPalette.value.trim();

       if (!prompt || !model || !originalObject || !originalPalette) {
           if (window.showToast) window.showToast('Missing required admin data for regeneration', 'error');
           return;
       }

       const regenerateBtn = document.getElementById('regenerateBtn');
       regenerateBtn.disabled = true;
       regenerateBtn.textContent = 'Regenerating...';
       if (window.showToast) window.showToast('Regenerating image...', 'info');

       try {
           // Replace [object] and [image-palette] in the prompt (correct variable names)
           let processedPrompt = prompt.replace(/\[object\]/gi, originalObject);
           processedPrompt = processedPrompt.replace(/\[image-palette\]/gi, originalPalette);

           // Also handle legacy variable names for backward compatibility
           processedPrompt = processedPrompt.replace(/\[input-object\]/gi, originalObject);
           processedPrompt = processedPrompt.replace(/\[palette\]/gi, originalPalette);

           console.log('Regenerating with:', {
               originalPrompt: prompt,
               processedPrompt: processedPrompt,
               model: model,
               originalObject: originalObject,
               originalPalette: originalPalette
           });

           // Prepare request data similar to full-generator.html
           const requestData = {
               prompt: processedPrompt,
               model: model,
               noText: true // Don't include text in the generation
           };

           console.log('Sending regeneration request:', requestData);

           const response = await fetch('/api/generate', {
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json'
               },
               credentials: 'include',
               body: JSON.stringify(requestData)
           });

           if (!response.ok) {
               const errorData = await response.json();
               throw new Error(errorData.error || 'Failed to regenerate image');
           }

           const data = await response.json();
           console.log('Regeneration response:', data);

           // Update button text to show background removal is starting
           regenerateBtn.textContent = 'Removing background...';
           if (window.showToast) window.showToast('Image generated! Removing background...', 'success');

           // Automatically trigger background removal after generation
           console.log('Automatically triggering background removal for regenerated image...');
           await performAutomaticBackgroundRemoval(data.imageUrl, data.generationId, selectedObject);

       } catch (error) {
           console.error('Error regenerating image:', error);
           if (window.showToast) window.showToast(`Failed to regenerate image: ${error.message}`, 'error');
           else alert(`Error regenerating image: ${error.message}`);
       } finally {
           regenerateBtn.disabled = false;
           regenerateBtn.textContent = 'Regenerate';
       }
   }

   // --- Automatic Background Removal for Regenerated Images ---
   async function performAutomaticBackgroundRemoval(imageUrl, generationId, selectedObject) {
       try {
           console.log('Starting automatic background removal for:', imageUrl);

           // Call background removal API
           const response = await fetch('/api/images/bgremove', {
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json'
               },
               credentials: 'include',
               body: JSON.stringify({
                   imageUrl: imageUrl,
                   generationId: generationId
               })
           });

           const data = await response.json();

           if (!response.ok) {
               throw new Error(data.error || data.details || 'Background removal failed');
           }

           const newImageUrl = data.imageUrl; // URL of the BG-removed image
           console.log('Background removed successfully. New URL:', newImageUrl);

           // Load the new background-removed image and replace the current one
           const newImg = new Image();
           newImg.onload = () => {
               console.log('New background-removed image loaded successfully');
               selectedObject.image = newImg;
               // 🎯 FIX: Store proxied URL instead of direct B2 URL to avoid CORS issues when saving/loading projects
               selectedObject.imageUrl = getProxiedImageUrlIfNeeded(newImageUrl);
               selectedObject.originalWidth = newImg.naturalWidth;
               selectedObject.originalHeight = newImg.naturalHeight;
               selectedObject.backgroundRemoved = true; // Mark as background removed
               console.log('🎯 Stored proxied URL for project saving:', selectedObject.imageUrl);

               // Update Remove Background button
               const removeBgBtn = document.getElementById('removeBgBtn');
               if (removeBgBtn) {
                   removeBgBtn.disabled = true;
                   removeBgBtn.textContent = 'Background Removed';
               }

               update(); // Redraw canvas
               if (window.showToast) window.showToast('Image regenerated and background removed successfully!', 'success');
           };
           newImg.onerror = () => {
               console.error('Failed to load the background-removed image:', newImageUrl);
               if (window.showToast) window.showToast('Failed to load background-removed image', 'error');

               // Fallback: load the original generated image without background removal
               loadOriginalGeneratedImage(imageUrl, selectedObject);
           };
           newImg.src = getProxiedImageUrlIfNeeded(newImageUrl);

       } catch (error) {
           console.error('Error in automatic background removal:', error);
           if (window.showToast) window.showToast(`Background removal failed: ${error.message}`, 'warning');

           // Fallback: load the original generated image without background removal
           loadOriginalGeneratedImage(imageUrl, selectedObject);
       }
   }

   // --- Fallback function to load original generated image ---
   function loadOriginalGeneratedImage(imageUrl, selectedObject) {
       console.log('Loading original generated image as fallback:', imageUrl);

       const newImg = new Image();
       newImg.onload = () => {
           console.log('Original generated image loaded successfully');
           selectedObject.image = newImg;
           // 🎯 FIX: Store proxied URL instead of direct B2 URL to avoid CORS issues when saving/loading projects
           selectedObject.imageUrl = getProxiedImageUrlIfNeeded(imageUrl);
           selectedObject.originalWidth = newImg.naturalWidth;
           selectedObject.originalHeight = newImg.naturalHeight;
           selectedObject.backgroundRemoved = false; // Reset background removal status
           console.log('🎯 Stored proxied URL for project saving (fallback):', selectedObject.imageUrl);

           // Reset Remove Background button
           const removeBgBtn = document.getElementById('removeBgBtn');
           if (removeBgBtn) {
               removeBgBtn.disabled = false;
               removeBgBtn.textContent = 'Remove Background';
           }

           update(); // Redraw canvas
           if (window.showToast) window.showToast('Image regenerated successfully! (Background removal failed)', 'success');
       };
       newImg.onerror = () => {
           console.error('Failed to load the original generated image:', imageUrl);
           if (window.showToast) window.showToast('Failed to load regenerated image', 'error');
       };
       newImg.src = getProxiedImageUrlIfNeeded(imageUrl);
   }

   // --- Restyle Image Function ---
   async function handleRestyleClick() {
       console.log('🎨 Restyle button clicked - function called successfully!');

       if (selectedObjectIndex === -1) {
           console.log('🎨 No image selected, selectedObjectIndex:', selectedObjectIndex);
           if (window.showToast) window.showToast('No image selected', 'error');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       console.log('🎨 Selected object:', selectedObject);

       if (selectedObject.type !== 'image') {
           console.log('🎨 Selected object is not an image, type:', selectedObject.type);
           if (window.showToast) window.showToast('Selected object is not an image', 'error');
           return;
       }

       // Save target image reference for replacement
       window.targetImageIndexForReplacement = selectedObjectIndex;
       console.log('🎯 Saved target image index for replacement:', selectedObjectIndex);

       // Get admin data for the original object
       const adminOriginalObject = document.getElementById('adminOriginalObject');
       console.log('🎨 Admin original object element:', adminOriginalObject);
       console.log('🎨 Admin original object value:', adminOriginalObject?.value);

       if (!adminOriginalObject || !adminOriginalObject.value.trim()) {
           console.log('🎨 No original object data found for restyling');
           if (window.showToast) window.showToast('No original object data found for restyling', 'error');
           return;
       }

       const originalObject = adminOriginalObject.value.trim();
       console.log('🎨 Restyling with original object:', originalObject);

       // Open AI Generator sidebar in Restyle mode
       console.log('🎨 Calling openAIGeneratorForRestyle...');
       openAIGeneratorForRestyle(originalObject);
   }

   // --- Replace Image Function ---
   async function handleReplaceClick() {
       console.log('🔄 Replace button clicked - function called successfully!');

       if (selectedObjectIndex === -1) {
           console.log('🔄 No image selected, selectedObjectIndex:', selectedObjectIndex);
           if (window.showToast) window.showToast('No image selected', 'error');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];
       console.log('🔄 Selected object:', selectedObject);

       if (selectedObject.type !== 'image') {
           console.log('🔄 Selected object is not an image, type:', selectedObject.type);
           if (window.showToast) window.showToast('Selected object is not an image', 'error');
           return;
       }

       // Save target image reference for replacement
       window.targetImageIndexForReplacement = selectedObjectIndex;
       console.log('🎯 Saved target image index for replacement:', selectedObjectIndex);

       // For Replace mode, we don't need existing admin data - user can create completely new content
       console.log('🔄 Opening AI Generator for complete replacement');

       // Open AI Generator sidebar in Replace mode
       console.log('🔄 Calling openAIGeneratorForReplace...');
       openAIGeneratorForReplace();
   }

   // --- Open AI Generator Sidebar for Restyle ---
   function openAIGeneratorForRestyle(originalObject) {
       console.log('🎨 Opening AI Generator sidebar for restyle with object:', originalObject);

       // Set flag to prevent reset when opening for restyle
       window.isOpeningForRestyle = true;

       // Get AI Generator elements
       const aiGeneratorSidebar = document.getElementById('ai-generator-sidebar');
       const aiGeneratorMenuItem = document.querySelector('[data-sidebar="ai-generator-sidebar"]');

       console.log('🎨 AI Generator elements found:', {
           sidebar: !!aiGeneratorSidebar,
           menuItem: !!aiGeneratorMenuItem,
           sidebarId: aiGeneratorSidebar?.id,
           menuItemDataSidebar: aiGeneratorMenuItem?.getAttribute('data-sidebar')
       });

       if (aiGeneratorSidebar && aiGeneratorMenuItem) {
           // Log initial state
           console.log('🎨 Initial sidebar state:', {
               sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
               menuItemHasActive: aiGeneratorMenuItem.classList.contains('active'),
               sidebarClasses: Array.from(aiGeneratorSidebar.classList),
               menuItemClasses: Array.from(aiGeneratorMenuItem.classList)
           });

           // Directly open the AI Generator sidebar (no need to close others since we're protected)
           console.log('🎨 Opening AI Generator sidebar directly...');
           aiGeneratorSidebar.classList.add('active');
           aiGeneratorMenuItem.classList.add('active');

           // Log state after adding active classes
           console.log('🎨 State after adding active classes:', {
               sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
               menuItemHasActive: aiGeneratorMenuItem.classList.contains('active')
           });

           // Initialize the AI Generator
           if (window.initializeAIGeneratorSidebar) {
               console.log('🎨 Calling initializeAIGeneratorSidebar...');
               window.initializeAIGeneratorSidebar();
               console.log('🎨 initializeAIGeneratorSidebar completed');
           }

           // Wait a moment for the sidebar to fully initialize, then configure for restyle mode
           setTimeout(() => {
               // Log state before configuring
               console.log('🎨 State before configuring (after 300ms):', {
                   sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
                   menuItemHasActive: aiGeneratorMenuItem.classList.contains('active')
               });

               // Clear the flag after opening
               window.isOpeningForRestyle = false;
               configureAIGeneratorForRestyle(originalObject);
           }, 300);
       } else {
           console.error('🎨 Could not find AI Generator sidebar or menu item');
           window.isOpeningForRestyle = false;
       }
   }

   // --- Open AI Generator Sidebar for Replace ---
   function openAIGeneratorForReplace() {
       console.log('🔄 Opening AI Generator sidebar for replace mode');

       // Set flag to prevent reset when opening for replace
       window.isOpeningForReplace = true;

       // Get AI Generator elements
       const aiGeneratorSidebar = document.getElementById('ai-generator-sidebar');
       const aiGeneratorMenuItem = document.querySelector('[data-sidebar="ai-generator-sidebar"]');

       console.log('🔄 AI Generator elements found:', {
           sidebar: !!aiGeneratorSidebar,
           menuItem: !!aiGeneratorMenuItem,
           sidebarId: aiGeneratorSidebar?.id,
           menuItemDataSidebar: aiGeneratorMenuItem?.getAttribute('data-sidebar')
       });

       if (aiGeneratorSidebar && aiGeneratorMenuItem) {
           // Log initial state
           console.log('🔄 Initial sidebar state:', {
               sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
               menuItemHasActive: aiGeneratorMenuItem.classList.contains('active'),
               sidebarClasses: Array.from(aiGeneratorSidebar.classList),
               menuItemClasses: Array.from(aiGeneratorMenuItem.classList)
           });

           // Directly open the AI Generator sidebar
           console.log('🔄 Opening AI Generator sidebar directly...');
           aiGeneratorSidebar.classList.add('active');
           aiGeneratorMenuItem.classList.add('active');

           // Log state after adding active classes
           console.log('🔄 State after adding active classes:', {
               sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
               menuItemHasActive: aiGeneratorMenuItem.classList.contains('active')
           });

           // Initialize the AI Generator
           if (window.initializeAIGeneratorSidebar) {
               console.log('🔄 Calling initializeAIGeneratorSidebar...');
               window.initializeAIGeneratorSidebar();
               console.log('🔄 initializeAIGeneratorSidebar completed');
           }

           // Wait a moment for the sidebar to fully initialize, then configure for replace mode
           setTimeout(() => {
               // Log state before configuring
               console.log('🔄 State before configuring (after 300ms):', {
                   sidebarHasActive: aiGeneratorSidebar.classList.contains('active'),
                   menuItemHasActive: aiGeneratorMenuItem.classList.contains('active')
               });

               // Clear the flag after opening
               window.isOpeningForReplace = false;
               configureAIGeneratorForReplace();
           }, 300);
       } else {
           console.error('🔄 Could not find AI Generator sidebar or menu item');
           window.isOpeningForReplace = false;
       }
   }

   // --- Configure AI Generator for Restyle Mode ---
   function configureAIGeneratorForRestyle(originalObject) {
       console.log('🎨 Configuring AI Generator for restyle mode with object:', originalObject);

       // Check if AI Generator sidebar is actually open
       const aiGeneratorSidebar = document.getElementById('ai-generator-sidebar');
       console.log('🎨 Detailed sidebar check:', {
           sidebarExists: !!aiGeneratorSidebar,
           sidebarId: aiGeneratorSidebar?.id,
           hasActiveClass: aiGeneratorSidebar?.classList.contains('active'),
           allClasses: aiGeneratorSidebar ? Array.from(aiGeneratorSidebar.classList) : 'N/A',
           sidebarDisplay: aiGeneratorSidebar ? getComputedStyle(aiGeneratorSidebar).display : 'N/A',
           sidebarVisibility: aiGeneratorSidebar ? getComputedStyle(aiGeneratorSidebar).visibility : 'N/A'
       });

       if (!aiGeneratorSidebar || !aiGeneratorSidebar.classList.contains('active')) {
           console.error('🎨 AI Generator sidebar is not open, cannot configure for restyle mode');
           console.error('🎨 Sidebar state:', {
               exists: !!aiGeneratorSidebar,
               hasActive: aiGeneratorSidebar?.classList.contains('active')
           });
           return;
       }

       // Hide the object input section for restyle mode
       const objectSection = document.querySelector('#ai-generator-sidebar .section-title');
       const objectFormGroup = document.querySelector('#ai-generator-sidebar .form-group');

       console.log('🎨 Found elements for hiding:', {
           objectSection: !!objectSection,
           objectFormGroup: !!objectFormGroup,
           objectSectionText: objectSection?.textContent
       });

       if (objectSection && objectSection.textContent.includes('What would you like to create?')) {
           objectSection.style.display = 'none';
           console.log('🎨 Hidden object section title');
       }
       if (objectFormGroup && objectFormGroup.querySelector('#aiObjectInput')) {
           objectFormGroup.style.display = 'none';
           console.log('🎨 Hidden object input form group');
       }

       // Set the object input value (hidden) for generation
       const aiObjectInput = document.getElementById('aiObjectInput');
       if (aiObjectInput) {
           aiObjectInput.value = originalObject;
           console.log('🎨 Set object input value to:', originalObject);
       }

       // Enable the "Replace All Texts" checkbox for Restyle mode
       const replaceAllTextsCheckbox = document.getElementById('replaceAllTextsCheckboxform');
       if (replaceAllTextsCheckbox) {
           replaceAllTextsCheckbox.disabled = false;
           console.log('🎨 Enabled "Replace All Texts" checkbox for Restyle mode');
       }

       // Add restyle mode indicator (this also sets window.isRestyleMode = true)
       addRestyleModeIndicator();

       // Initialize AI Generator if needed
       if (window.initializeAIGeneratorSidebar) {
           window.initializeAIGeneratorSidebar();
       }

       console.log('🎨 AI Generator sidebar configured for Restyle mode');
   }

   // --- Configure AI Generator for Replace Mode ---
   function configureAIGeneratorForReplace() {
       console.log('🔄 Configuring AI Generator for replace mode');

       // Check if AI Generator sidebar is actually open
       const aiGeneratorSidebar = document.getElementById('ai-generator-sidebar');
       console.log('🔄 Detailed sidebar check:', {
           sidebarExists: !!aiGeneratorSidebar,
           sidebarId: aiGeneratorSidebar?.id,
           hasActiveClass: aiGeneratorSidebar?.classList.contains('active'),
           allClasses: aiGeneratorSidebar ? Array.from(aiGeneratorSidebar.classList) : 'N/A',
           sidebarDisplay: aiGeneratorSidebar ? getComputedStyle(aiGeneratorSidebar).display : 'N/A',
           sidebarVisibility: aiGeneratorSidebar ? getComputedStyle(aiGeneratorSidebar).visibility : 'N/A'
       });

       if (!aiGeneratorSidebar || !aiGeneratorSidebar.classList.contains('active')) {
           console.error('🔄 AI Generator sidebar is not open, cannot configure for replace mode');
           console.error('🔄 Sidebar state:', {
               exists: !!aiGeneratorSidebar,
               hasActive: aiGeneratorSidebar?.classList.contains('active')
           });
           return;
       }

       // For Replace mode, KEEP the object input section visible (unlike Restyle)
       const objectSection = document.querySelector('#ai-generator-sidebar .section-title');
       const objectFormGroup = document.querySelector('#ai-generator-sidebar .form-group');

       console.log('🔄 Found elements for showing:', {
           objectSection: !!objectSection,
           objectFormGroup: !!objectFormGroup,
           objectSectionText: objectSection?.textContent
       });

       // Make sure object input section is visible
       if (objectSection && objectSection.textContent.includes('What would you like to create?')) {
           objectSection.style.display = 'block';
           console.log('🔄 Ensured object section title is visible');
       }
       if (objectFormGroup && objectFormGroup.querySelector('#aiObjectInput')) {
           objectFormGroup.style.display = 'block';
           console.log('🔄 Ensured object input form group is visible');
       }

       // Clear the object input for user to enter new object
       const aiObjectInput = document.getElementById('aiObjectInput');
       if (aiObjectInput) {
           aiObjectInput.value = '';
           aiObjectInput.placeholder = 'Enter what you want to create (e.g., dog, car, flower)';
           console.log('🔄 Cleared object input for new entry');
       }

       // Enable the "Replace All Texts" checkbox for Replace mode
       const replaceAllTextsCheckbox = document.getElementById('replaceAllTextsCheckboxform');
       if (replaceAllTextsCheckbox) {
           replaceAllTextsCheckbox.disabled = false;
           console.log('🔄 Enabled "Replace All Texts" checkbox for Replace mode');
       }

       // Add replace mode indicator (this also sets window.isReplaceMode = true)
       addReplaceModeIndicator();

       // Initialize AI Generator if needed
       if (window.initializeAIGeneratorSidebar) {
           window.initializeAIGeneratorSidebar();
       }

       console.log('🔄 AI Generator sidebar configured for Replace mode');
   }

   // --- Add Restyle Mode Indicator ---
   function addRestyleModeIndicator() {
       // Remove any existing mode indicators
       const existingIndicator = document.querySelector('.restyle-mode-indicator, .replace-mode-indicator');
       if (existingIndicator) {
           existingIndicator.remove();
       }

       // Add new restyle mode indicator
       const aiGeneratorHeader = document.querySelector('#ai-generator-sidebar .left-sidebar-header h3');
       if (aiGeneratorHeader) {
           aiGeneratorHeader.textContent = 'Restyle';

           // Add a subtitle to explain restyle mode
           const subtitle = document.createElement('div');
           subtitle.className = 'restyle-mode-indicator';
           subtitle.style.cssText = 'font-size: 0.8em; color: #666; margin-top: 4px; font-weight: normal;';
           subtitle.textContent = 'Choose a new style for your image';
           aiGeneratorHeader.parentNode.appendChild(subtitle);
       }

       // Set global flag for restyle mode
       window.isRestyleMode = true;
       window.isReplaceMode = false;

       // Update text tone dropdown visibility for Restyle mode
       updateTextToneDropdownVisibility();
   }

   // --- Add Replace Mode Indicator ---
   function addReplaceModeIndicator() {
       // Remove any existing mode indicators
       const existingIndicator = document.querySelector('.restyle-mode-indicator, .replace-mode-indicator');
       if (existingIndicator) {
           existingIndicator.remove();
       }

       // Add new replace mode indicator
       const aiGeneratorHeader = document.querySelector('#ai-generator-sidebar .left-sidebar-header h3');
       if (aiGeneratorHeader) {
           aiGeneratorHeader.textContent = 'Replace';

           // Add a subtitle to explain replace mode
           const subtitle = document.createElement('div');
           subtitle.className = 'replace-mode-indicator';
           subtitle.style.cssText = 'font-size: 0.8em; color: #666; margin-top: 4px; font-weight: normal;';
           subtitle.textContent = 'Create a completely new image';
           aiGeneratorHeader.parentNode.appendChild(subtitle);
       }

       // Set global flag for replace mode
       window.isReplaceMode = true;
       window.isRestyleMode = false;

       // Update text tone dropdown visibility for Replace mode
       updateTextToneDropdownVisibility();
   }

   // --- Reset AI Generator to Normal Mode ---
   function resetAIGeneratorToNormalMode() {
       console.log('🎨 Resetting AI Generator to normal mode');

       // Remove any mode indicators
       const existingIndicator = document.querySelector('.restyle-mode-indicator, .replace-mode-indicator');
       if (existingIndicator) {
           existingIndicator.remove();
       }

       // Reset header title
       const aiGeneratorHeader = document.querySelector('#ai-generator-sidebar .left-sidebar-header h3');
       if (aiGeneratorHeader) {
           aiGeneratorHeader.textContent = 'AI Generator';
       }

       // Show the object input section
       const objectSection = document.querySelector('#ai-generator-sidebar .section-title');
       const objectFormGroup = document.querySelector('#ai-generator-sidebar .form-group');

       if (objectSection && objectSection.textContent.includes('What would you like to create?')) {
           objectSection.style.display = 'block';
       }
       if (objectFormGroup && objectFormGroup.querySelector('#aiObjectInput')) {
           objectFormGroup.style.display = 'block';
       }

       // Clear the object input and reset placeholder
       const aiObjectInput = document.getElementById('aiObjectInput');
       if (aiObjectInput) {
           aiObjectInput.value = '';
           aiObjectInput.placeholder = 'Enter what you want to create';
       }

       // Disable the "Replace All Texts" checkbox in normal mode
       const replaceAllTextsCheckbox = document.getElementById('replaceAllTextsCheckboxform');
       if (replaceAllTextsCheckbox) {
           replaceAllTextsCheckbox.disabled = true;
           replaceAllTextsCheckbox.checked = false;
           console.log('🎨 Disabled "Replace All Texts" checkbox for normal mode');
       }

       // Clear global flags for both modes
       window.isRestyleMode = false;
       window.isReplaceMode = false;

       // Update text tone dropdown visibility for normal mode
       updateTextToneDropdownVisibility();
   }

   // --- Update Text Tone Dropdown Visibility ---
   function updateTextToneDropdownVisibility() {
       const textToneContainer = document.getElementById('textToneContainer');

       if (!textToneContainer) {
           console.log('🎯 Text tone container not found');
           return;
       }

       // Show text tone dropdown for Restyle mode, hide for Replace mode
       if (window.isRestyleMode) {
           textToneContainer.style.display = 'block';
           console.log('🎨 Showing text tone dropdown for Restyle mode');
       } else if (window.isReplaceMode) {
           textToneContainer.style.display = 'none';
           console.log('🔄 Hiding text tone dropdown for Replace mode (using unified tone)');
       } else {
           textToneContainer.style.display = 'block';
           console.log('🎯 Showing text tone dropdown for normal mode');
       }
   }

   // Make resetAIGeneratorToNormalMode globally accessible
   window.resetAIGeneratorToNormalMode = resetAIGeneratorToNormalMode;

   // --- Replace Selected Image with Generated Image (for Restyle mode) ---
   async function replaceSelectedImageWithGenerated(imageUrl) {
       console.log('🎨 Replacing selected image with generated image:', imageUrl);

       // Use saved target image reference if available, fallback to current selection
       let targetObjectIndex = window.targetImageIndexForReplacement;
       let targetObject = null;

       if (targetObjectIndex !== undefined && targetObjectIndex !== -1 &&
           canvasObjects[targetObjectIndex] && canvasObjects[targetObjectIndex].type === 'image') {
           targetObject = canvasObjects[targetObjectIndex];
           console.log('🎯 Using saved target image reference:', {
               targetIndex: targetObjectIndex,
               targetId: targetObject.id,
               targetUrl: targetObject.imageUrl
           });
       } else if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex] &&
                  canvasObjects[selectedObjectIndex].type === 'image') {
           targetObjectIndex = selectedObjectIndex;
           targetObject = canvasObjects[selectedObjectIndex];
           console.log('🎯 Using current selection as target:', {
               targetIndex: targetObjectIndex,
               targetId: targetObject.id
           });
       } else {
           console.error('🎨 No valid target image found for replacement');
           if (window.showToast) window.showToast('Target image lost - please select image and try again', 'error');
           return;
       }

       try {
           // Load the new generated image
           const newImg = new Image();

           return new Promise((resolve, reject) => {
               newImg.onload = () => {
                   console.log('🎨 New generated image loaded successfully');

                   // Replace the image properties while preserving position, scale, etc.
                   targetObject.image = newImg;
                   targetObject.imageUrl = imageUrl;
                   targetObject.originalWidth = newImg.naturalWidth;
                   targetObject.originalHeight = newImg.naturalHeight;
                   targetObject.backgroundRemoved = true; // Mark as background removed since we processed it
                   targetObject.isFromGeneration = true; // Mark as generated image

                   // Update Remove Background button state
                   const removeBgBtn = document.getElementById('removeBgBtn');
                   if (removeBgBtn) {
                       removeBgBtn.disabled = true;
                       removeBgBtn.textContent = 'Background Removed';
                   }

                   // Redraw canvas to show the new image
                   update();

                   // Clear target image reference after successful replacement
                   window.targetImageIndexForReplacement = undefined;
                   console.log('🎯 Cleared target image reference after successful replacement');

                   // Auto-close sidebar after successful replacement
                   setTimeout(() => {
                       if (window.closeAllSidebars) {
                           console.log('🎯 Auto-closing sidebar after successful image replacement');
                           window.closeAllSidebars();
                       }
                   }, 500); // Small delay to let user see the replacement

                   console.log('🎨 Image replacement completed successfully');
                   resolve();
               };

               newImg.onerror = () => {
                   console.error('🎨 Failed to load the generated image:', imageUrl);
                   if (window.showToast) window.showToast('Failed to load generated image', 'error');
                   reject(new Error('Failed to load generated image'));
               };

               // Load the image with proxy if needed
               newImg.src = getProxiedImageUrlIfNeeded(imageUrl);
           });

       } catch (error) {
           console.error('🎨 Error replacing selected image:', error);
           if (window.showToast) window.showToast(`Failed to replace image: ${error.message}`, 'error');
           throw error;
       }
   }

   // Make replaceSelectedImageWithGenerated globally accessible
   window.replaceSelectedImageWithGenerated = replaceSelectedImageWithGenerated;

   // --- Image Masking Functions ---
   function handleMaskImageClick() {
       console.log('[Masking] Mask button clicked');

       if (selectedObjectIndex === -1 || canvasObjects[selectedObjectIndex].type !== 'image') {
           console.warn('[Masking] No image selected for masking');
           return;
       }

       const selectedImage = canvasObjects[selectedObjectIndex];
       if (selectedImage.isMasked) {
           console.warn('[Masking] Image is already masked');
           return;
       }

       // Check if there are any shapes available for masking
       const availableShapes = canvasObjects.filter(obj =>
           obj.type === 'image' &&
           obj.id !== selectedImage.id &&
           obj.imageUrl &&
           (obj.imageUrl.includes('.svg') || obj.imageUrl.includes('/shapes/'))
       );

       if (availableShapes.length === 0) {
           alert('No shapes available for masking. Please add some shapes from the Elements sidebar first.');
           return;
       }

       // Enter mask selection mode
       isMaskSelectionMode = true;
       pendingMaskImage = selectedImage;

       console.log('[Masking] 🎭 Starting mask selection for image:', {
           id: selectedImage.id,
           x: selectedImage.x,
           y: selectedImage.y,
           width: selectedImage.originalWidth * selectedImage.scale,
           height: selectedImage.originalHeight * selectedImage.scale,
           imageUrl: selectedImage.imageUrl,
           isMasked: selectedImage.isMasked
       });

       console.log('[Masking] 🎭 Available shapes for masking:', availableShapes.map(shape => ({
           id: shape.id,
           x: shape.x,
           y: shape.y,
           width: shape.originalWidth * shape.scale,
           height: shape.originalHeight * shape.scale,
           imageUrl: shape.imageUrl
       })));

       // Update UI to show mask selection mode
       updateMaskSelectionUI(true);

       // Show instruction message
       if (window.showToast) {
           window.showToast('Click on a shape to use as mask, or press ESC to cancel', 'info');
       }

       console.log('[Masking] 🎭 Entered mask selection mode');
   }

   function handleUnmaskImageClick() {
       console.log('[Masking] 🎭 Unmask button clicked');

       if (selectedObjectIndex === -1 || canvasObjects[selectedObjectIndex].type !== 'image') {
           console.warn('[Masking] 🎭 No image selected for unmasking');
           return;
       }

       const selectedImage = canvasObjects[selectedObjectIndex];
       if (!selectedImage.isMasked) {
           console.warn('[Masking] 🎭 Image is not masked');
           if (window.showToast) {
               window.showToast('Image is not masked', 'warning');
           }
           return;
       }

       unmaskImage(selectedImage);
   }

   function updateMaskSelectionUI(inSelectionMode) {
       if (inSelectionMode) {
           // Change cursor to indicate selection mode
           canvas.style.cursor = 'crosshair';

           // Add visual feedback class to canvas
           canvas.classList.add('mask-selection-mode');

           // Highlight available shapes
           highlightAvailableShapes(true);
       } else {
           // Reset cursor
           canvas.style.cursor = 'default';

           // Remove visual feedback class
           canvas.classList.remove('mask-selection-mode');

           // Remove shape highlighting
           highlightAvailableShapes(false);
       }
   }

   function highlightAvailableShapes(highlight) {
       // This function could add visual highlighting to available shapes
       // For now, we'll just update the canvas
       update();
   }

   function exitMaskSelectionMode() {
       isMaskSelectionMode = false;
       pendingMaskImage = null;
       updateMaskSelectionUI(false);

       console.log('[Masking] Exited mask selection mode');
   }

   function applyMaskToImage(imageObject, maskShape) {
       console.log('[Masking] 🎭 Applying mask to image:', {
           imageId: imageObject.id,
           imagePos: { x: imageObject.x, y: imageObject.y },
           imageSize: {
               width: imageObject.originalWidth * imageObject.scale,
               height: imageObject.originalHeight * imageObject.scale
           },
           maskId: maskShape.id,
           maskPos: { x: maskShape.x, y: maskShape.y },
           maskSize: {
               width: maskShape.originalWidth * maskShape.scale,
               height: maskShape.originalHeight * maskShape.scale
           }
       });

       // Set masking properties on the image
       imageObject.isMasked = true;
       imageObject.maskShapeId = maskShape.id;
       imageObject.maskShape = maskShape; // Store reference for runtime use

       // Hide the mask shape (it should not be visible anymore)
       maskShape.isVisible = false;
       maskShape.isMaskShape = true; // Mark it as a mask shape

       console.log('[Masking] 🎭 Mask properties set:', {
           imageIsMasked: imageObject.isMasked,
           maskShapeId: imageObject.maskShapeId,
           maskShapeHidden: !maskShape.isVisible,
           maskShapeMarked: maskShape.isMaskShape
       });

       // Update UI
       updateUIFromSelectedObject();
       update();

       if (window.showToast) {
           window.showToast('Mask applied successfully!', 'success');
       }

       console.log('[Masking] 🎭 Mask applied successfully');
   }



   function restoreMaskRelationships() {
       console.log('[Masking] 🎭 Starting enhanced mask relationship restoration after template load');

       let maskedImagesFound = 0;
       let maskRelationshipsRestored = 0;
       let brokenRelationships = 0;
       let generatedMaskedImages = 0;

       // First, identify all available mask shapes for reference
       const availableMaskShapes = canvasObjects.filter(obj =>
           obj.type === 'image' && (obj.isMaskShape === true || obj.isVisible === false)
       );

       console.log('[Masking] 🎭 Available mask shapes:', availableMaskShapes.map(shape => ({
           id: shape.id,
           url: shape.imageUrl,
           isMaskShape: shape.isMaskShape,
           isVisible: shape.isVisible
       })));

       canvasObjects.forEach((obj, index) => {
           if (obj.type === 'image' && obj.isMasked && obj.maskShapeId) {
               maskedImagesFound++;

               // Track if this is a generated image
               if (obj.isFromGeneration) {
                   generatedMaskedImages++;
               }

               console.log(`[Masking] 🎭 Processing masked image ${maskedImagesFound}:`, {
                   id: obj.id,
                   imageUrl: obj.imageUrl,
                   templateId: obj.templateId,
                   maskShapeId: obj.maskShapeId,
                   isFromGeneration: obj.isFromGeneration || false,
                   objectIndex: index
               });

               // Find the mask shape by ID with enhanced validation
               const maskShape = canvasObjects.find(shape =>
                   shape.type === 'image' && shape.id === obj.maskShapeId
               );

               if (maskShape) {
                   // Validate mask shape properties
                   const isValidMaskShape = maskShape.isMaskShape === true || maskShape.isVisible === false;

                   if (isValidMaskShape) {
                       obj.maskShape = maskShape; // Restore the reference
                       maskRelationshipsRestored++;

                       console.log(`[Masking] 🎭 ✅ Successfully restored mask relationship:`, {
                           imageId: obj.id,
                           imageTemplateId: obj.templateId,
                           maskId: maskShape.id,
                           maskUrl: maskShape.imageUrl,
                           maskVisible: maskShape.isVisible,
                           maskIsMaskShape: maskShape.isMaskShape,
                           isGeneratedImage: obj.isFromGeneration || false
                       });

                       // Ensure mask shape properties are correct
                       if (maskShape.isVisible !== false) {
                           maskShape.isVisible = false;
                           console.log(`[Masking] 🎭 🔧 Fixed mask shape visibility for ${maskShape.id}`);
                       }
                       if (maskShape.isMaskShape !== true) {
                           maskShape.isMaskShape = true;
                           console.log(`[Masking] 🎭 🔧 Fixed mask shape flag for ${maskShape.id}`);
                       }
                   } else {
                       brokenRelationships++;
                       console.warn(`[Masking] 🎭 ⚠️ Found mask shape but it's not properly marked as mask:`, {
                           imageId: obj.id,
                           maskShapeId: obj.maskShapeId,
                           maskIsMaskShape: maskShape.isMaskShape,
                           maskIsVisible: maskShape.isVisible
                       });

                       // Clean up invalid mask relationship
                       obj.isMasked = false;
                       obj.maskShapeId = null;
                       obj.maskShape = null;
                   }
               } else {
                   brokenRelationships++;
                   console.error(`[Masking] 🎭 ❌ Could not find mask shape with ID: ${obj.maskShapeId} for image ${obj.id}`);
                   console.error(`[Masking] 🎭 Available image objects:`, canvasObjects
                       .filter(o => o.type === 'image')
                       .map(o => ({
                           id: o.id,
                           url: o.imageUrl?.substring(0, 50) + '...',
                           isMaskShape: o.isMaskShape,
                           isVisible: o.isVisible,
                           templateId: o.templateId
                       }))
                   );

                   // Clean up broken mask relationship
                   obj.isMasked = false;
                   obj.maskShapeId = null;
                   obj.maskShape = null;
                   console.log(`[Masking] 🎭 🧹 Cleaned up broken mask relationship for image ${obj.id}`);
               }
           }
       });

       // Enhanced summary logging
       console.log(`[Masking] 🎭 ✅ Enhanced mask restoration complete:`, {
           maskedImagesFound,
           maskRelationshipsRestored,
           brokenRelationships,
           generatedMaskedImages,
           successRate: maskedImagesFound > 0 ? `${Math.round((maskRelationshipsRestored / maskedImagesFound) * 100)}%` : 'N/A',
           availableMaskShapes: availableMaskShapes.length
       });

       if (brokenRelationships > 0) {
           console.warn(`[Masking] 🎭 ⚠️ ${brokenRelationships} mask relationship(s) could not be restored`);
       }

       if (generatedMaskedImages > 0) {
           console.log(`[Masking] 🎭 🎯 Successfully processed ${generatedMaskedImages} generated masked image(s)`);
       }
   }

   function unmaskImage(imageObject) {
       console.log('[Masking] 🎭 Unmasking image:', imageObject.id);

       if (!imageObject.isMasked || !imageObject.maskShape) {
           console.warn('[Masking] 🎭 Image is not masked or mask shape not found');
           return;
       }

       const maskShape = imageObject.maskShape;

       console.log('[Masking] 🎭 Removing mask from image:', {
           imageId: imageObject.id,
           maskId: maskShape.id,
           maskWasVisible: maskShape.isVisible
       });

       // Remove masking properties from image
       imageObject.isMasked = false;
       imageObject.maskShapeId = null;
       imageObject.maskShape = null;

       // Make the mask shape visible again
       maskShape.isVisible = true;
       maskShape.isMaskShape = false;

       console.log('[Masking] 🎭 Mask removed, shape is now visible again');

       // Update UI
       updateUIFromSelectedObject();
       update();

       if (window.showToast) {
           window.showToast('Mask removed successfully!', 'success');
       }
   }

   // --- Initial State ---
   function initialize() {
       console.log('🚀 INITIALIZE: Starting initialization');
       scale = Math.min(canvas.clientWidth / w, canvas.clientHeight / h) * 0.8;
       offsetX = (canvas.clientWidth - w * scale) / 2;
       offsetY = (canvas.clientHeight - h * scale) / 2;

       const initialObject = createTextObject({ text: "DESIGN", isSelected: false, x: w / 2 - 150, y: h / 2, fontSize: 200, color: '#3b82f6' });
       console.log('🚀 INITIALIZE: Created initial DESIGN object:', initialObject.id);

       canvasObjects.push(initialObject);
       selectedObjectIndex = -1;
       console.log('🚀 INITIALIZE: Set selectedObjectIndex to -1, canvasObjects.length =', canvasObjects.length);

       syncGlobalReferences();
       applyFontStylesToOptions();
       updateUIFromSelectedObject();
       update();

       console.log('🚀 INITIALIZE: Initialization complete');

       // Check for ID collisions
       checkForIdCollisions();
   }

   // Helper function to check for ID collisions
   function checkForIdCollisions() {
       console.log('🔍 ID COLLISION CHECK: Starting...');
       const ids = canvasObjects.map(obj => obj.id);
       const uniqueIds = [...new Set(ids)];

       if (ids.length !== uniqueIds.length) {
           console.error('🚨 ID COLLISION DETECTED!');
           console.error('🚨 Total objects:', ids.length);
           console.error('🚨 Unique IDs:', uniqueIds.length);
           console.error('🚨 All IDs:', ids);

           // Find duplicates
           const duplicates = ids.filter((id, index) => ids.indexOf(id) !== index);
           console.error('🚨 Duplicate IDs:', [...new Set(duplicates)]);
       } else {
           console.log('✅ ID COLLISION CHECK: No collisions found');
           console.log('✅ Objects:', ids.length, 'IDs:', ids);
       }
   }
   // initialize(); // Initialization is now handled by DOMContentLoaded logic
   // --- Helper to get proxied URL if needed ---
   function getProxiedImageUrlIfNeeded(imageUrl) {
       if (!imageUrl) return null;

       // Handle blob URLs - these are local uploads and should be used as-is
       if (imageUrl.startsWith('blob:')) {
           console.log(`[ProxyHelper] Blob URL detected, using as-is: ${imageUrl}`);
           return imageUrl;
       }

       // Check if URL is already proxied to avoid double-proxying
       if (imageUrl.startsWith('/api/image-proxy')) {
           console.log(`[ProxyHelper] Already proxied URL detected, using as-is: ${imageUrl}`);
           return imageUrl;
       }

       try {
           const url = new URL(imageUrl);
           if (url.hostname.endsWith('backblazeb2.com')) {
               const pathSegments = url.pathname.split('/');
               const bucketName = 'stickers-replicate-app'; // Adjust if dynamic
               const bucketNameIndex = pathSegments.indexOf(bucketName);
               if (bucketNameIndex !== -1 && bucketNameIndex + 1 < pathSegments.length) {
                   const fileName = pathSegments.slice(bucketNameIndex + 1).join('/');
                   const proxiedUrl = `/api/image-proxy?fileName=${encodeURIComponent(fileName)}`;
                   console.log(`[ProxyHelper] Using proxy for B2 URL: ${imageUrl} -> ${proxiedUrl}`);
                   return proxiedUrl;
               } else {
                   console.warn('[ProxyHelper] Could not extract filename from B2 URL for proxy:', imageUrl);
                   return imageUrl; // Return original if parsing fails
               }
           }
           return imageUrl; // Not a B2 URL, return original
       } catch (urlError) {
           console.warn('[ProxyHelper] Could not parse URL, assuming relative or already proxied:', imageUrl, urlError);
           // For local paths (like /stock/shapes/...), don't use proxy - serve directly
           if (!imageUrl.startsWith('http') && imageUrl.includes('/')) {
                // Check if it's a local path that should be served directly
                if (imageUrl.startsWith('/stock/') || imageUrl.startsWith('/public/') || imageUrl.startsWith('/images/')) {
                    console.log('[ProxyHelper] Local path detected, serving directly:', imageUrl);
                    return imageUrl; // Serve local paths directly
                }
                // Only proxy if it looks like an external path that needs proxying
                const proxiedUrl = `/api/image-proxy?fileName=${encodeURIComponent(imageUrl)}`;
                console.log('[ProxyHelper] Assuming external path needs proxy:', proxiedUrl);
                return proxiedUrl;
           }
           return imageUrl; // Return original if it's not a URL and doesn't look like a path
       }
   }

   // --- Load Image from URL Parameter ---
   function loadImageFromUrlParam() {
       const params = new URLSearchParams(window.location.search);
       const imageUrlParam = params.get('imageUrl') || params.get('image');
       const generationIdParam = params.get('generationId'); // Get generationId

       if (imageUrlParam) {
           try {
               const decodedImageUrl = decodeURIComponent(imageUrlParam);
               const finalImageUrl = getProxiedImageUrlIfNeeded(decodedImageUrl); // Use helper

               if (!finalImageUrl) {
                    console.error('Could not determine final image URL for loading.');
                    return;
               }

               const img = new Image();
               img.crossOrigin = 'anonymous';
               img.onload = () => {
                   const canvas = document.getElementById('demo');
                   if (!canvas) return;
                   const ctx = canvas.getContext('2d');
                   if (!ctx) return;

                   const scaleFactor = Math.min(canvas.width / img.width, canvas.height / img.height, 1) * 0.8;
                   const centerX = w / 2;
                   const centerY = h / 2;

                   const imageObj = createImageObject(img, {
                       x: centerX,
                       y: centerY,
                       scale: scaleFactor,
                       isSelected: true,
                       imageUrl: finalImageUrl, // Store the potentially proxied URL
                       generationId: generationIdParam || null, // Store generationId if present
                       isFromGeneration: !!generationIdParam // Set flag if generationId exists
                   });

                   // Replace existing image or add new
                   const existingImageIndex = canvasObjects.findIndex(obj => obj.type === 'image');
                   if (existingImageIndex !== -1) {
                       canvasObjects[existingImageIndex] = imageObj;
                       selectedObjectIndex = existingImageIndex;
                   } else {
                       canvasObjects.push(imageObj);
                       selectedObjectIndex = canvasObjects.length - 1;
                   }
                   updateUIFromSelectedObject();
                   update();
               };
               img.onerror = (err) => {
                   console.error('Failed to load image:', finalImageUrl, err);
                   alert(`Failed to load image from URL: ${decodedImageUrl}`);
               };
               img.src = finalImageUrl;

           } catch (e) {
               console.error('Error processing image URL parameter:', e);
           }
       }
   }

   // --- Load Admin Data from URL Parameter ---
   function loadAdminDataFromUrlParam() {
        const params = new URLSearchParams(window.location.search);
        const imageUrl = params.get('imageUrl'); // Use specific param name
        const model = params.get('model');
        const prompt = params.get('prompt');
        const palette = params.get('palette');
        const originalObject = params.get('originalObject');
        const inspirationId = params.get('inspirationId');

        console.log('=== DESIGN EDITOR URL PARAMS DEBUG ===');
        console.log('Raw URL:', window.location.search);
        console.log('imageUrl param:', imageUrl);
        console.log('model param:', model);
        console.log('prompt param:', prompt);
        console.log('prompt param length:', prompt ? prompt.length : 'null/undefined');
        console.log('palette param:', palette);
        console.log('originalObject param:', originalObject);
        console.log('inspirationId param:', inspirationId);
        console.log('=== END URL PARAMS DEBUG ===');

        if (imageUrl || model || prompt || palette || originalObject || inspirationId) {
            console.log('Admin data found in URL parameters.');

            // Safe decode function to handle malformed URLs
            function safeDecodeURIComponent(str) {
                if (!str) return '';
                try {
                    return decodeURIComponent(str);
                } catch (e) {
                    console.warn('Failed to decode URI component:', str, e);
                    return str; // Return original string if decoding fails
                }
            }

            const decodedPrompt = safeDecodeURIComponent(prompt || '');
            console.log('Decoded prompt:', decodedPrompt);
            console.log('Decoded prompt length:', decodedPrompt.length);

            document.getElementById('adminImageUrl').value = safeDecodeURIComponent(imageUrl || '');
            document.getElementById('adminModel').value = safeDecodeURIComponent(model || '');
            document.getElementById('adminPrompt').value = decodedPrompt;
            document.getElementById('adminPalette').value = safeDecodeURIComponent(palette || '');
            document.getElementById('adminOriginalObject').value = safeDecodeURIComponent(originalObject || '');
            document.getElementById('adminInspirationId').value = safeDecodeURIComponent(inspirationId || '');

            // Optionally switch to the Admin tab if data is present
            const adminTabButton = document.querySelector('.sidebar-tab[data-tab="admin-tab-content"]');
            const adminTabContent = document.getElementById('admin-tab-content');
            if (adminTabButton && adminTabContent) {
                sidebarTabs.forEach(t => t.classList.remove('active'));
                sidebarContents.forEach(c => c.classList.remove('active'));
                adminTabButton.classList.add('active');
                adminTabContent.classList.add('active');
            }
        } else {
            console.log('No admin data found in URL parameters.');
        }
   }

   // --- Update Editor UI from Restored State ---
   function updateEditorUIFromState() {
       console.log('[UpdateUI] Updating editor UI from restored state');

       // Update zoom level display
       const zoomLevelSpan = document.getElementById('zoomLevel');
       if (zoomLevelSpan) {
           zoomLevelSpan.textContent = Math.round(scale * 100) + '%';
       }

       // Update canvas background color picker if it exists
       const colorPickerElement = document.getElementById('canvasBgColorPicker');
       if (colorPickerElement && window.pickrInstance) {
           try {
               window.pickrInstance.setColor(canvasBackgroundColor);
           } catch (e) {
               console.warn('[UpdateUI] Could not update color picker:', e);
           }
       }

       // Update any other UI elements that reflect editor state
       console.log('[UpdateUI] Editor UI updated with:', {
           scale: scale,
           offsetX: offsetX,
           offsetY: offsetY,
           canvasBackgroundColor: canvasBackgroundColor,
           selectedObjectIndex: selectedObjectIndex,
           nextId: nextId
       });
   }



   // --- Load Template from Either Collection ---
   async function loadTemplateFromEitherCollection(templateId) {
       console.log(`[LoadTemplate] Attempting to load template from either collection: ${templateId}`);

       // First try DesignTemplate collection
       try {
           console.log('[LoadTemplate] Trying DesignTemplate collection...');
           const response = await fetch(`/api/design-templates/${templateId}`, { credentials: 'include' });
           if (response.ok) {
               const template = await response.json();
               console.log('[LoadTemplate] Found in DesignTemplate collection:', template);
               await loadTemplateData(templateId); // Use existing function
               return;
           }
       } catch (error) {
           console.log('[LoadTemplate] Not found in DesignTemplate collection:', error.message);
       }

       // If not found, try PromptTemplate collection (inspiration templates)
       try {
           console.log('[LoadTemplate] Trying PromptTemplate collection...');
           const response = await fetch(`/api/templates/${templateId}`, { credentials: 'include' });
           if (response.ok) {
               const template = await response.json();
               console.log('[LoadTemplate] Found in PromptTemplate collection:', template);
               await loadInspirationTemplate(template); // Use new function for inspiration templates
               return;
           }
       } catch (error) {
           console.log('[LoadTemplate] Not found in PromptTemplate collection:', error.message);
       }

       // If not found in either collection
       throw new Error(`Template ${templateId} not found in either DesignTemplate or PromptTemplate collections`);
   }

   // --- CSS Filter State Restoration ---
   function restoreCSSFilterState(cssFilterState) {
       console.log('[LoadTemplate] 🎨 Restoring CSS filter state...');

       if (!cssFilterState || typeof cssFilterState !== 'object') {
           console.log('[LoadTemplate] 🎨 No CSS filter state found, using defaults');
           return;
       }

       const filterControls = [
           { id: 'iImageBlur', key: 'blur', defaultValue: 0 },
           { id: 'iImageBrightness', key: 'brightness', defaultValue: 1 },
           { id: 'iImageContrast', key: 'contrast', defaultValue: 1 },
           { id: 'iImageSaturation', key: 'saturate', defaultValue: 1 },
           { id: 'iImageHue', key: 'hueRotate', defaultValue: 0 },
           { id: 'iImageGrayscale', key: 'grayscale', defaultValue: 0 },
           { id: 'iImageSepia', key: 'sepia', defaultValue: 0 },
           { id: 'iImageInvert', key: 'invert', defaultValue: 0 }
       ];

       filterControls.forEach(control => {
           const element = document.getElementById(control.id);
           if (element) {
               const savedValue = cssFilterState[control.key];
               const valueToSet = savedValue !== undefined ? savedValue : control.defaultValue;

               element.value = valueToSet;
               console.log(`[LoadTemplate] 🎨 Restored ${control.key}: ${valueToSet}`);

               // Update the display value using the proper formatting function
               if (typeof updateFilterValueDisplay === 'function') {
                   updateFilterValueDisplay(control.id, valueToSet);
                   console.log(`[LoadTemplate] 🎨 Updated display for ${control.key} with proper formatting`);
               } else {
                   // Fallback to simple text update if function not available
                   const displayId = control.id + 'Value';
                   const displayElement = document.getElementById(displayId);
                   if (displayElement) {
                       displayElement.textContent = valueToSet;
                       console.log(`[LoadTemplate] 🎨 Updated display for ${control.key} (fallback)`);
                   }
               }
           } else {
               console.log(`[LoadTemplate] 🎨 Control ${control.id} not found, skipping`);
           }
       });

       // Restore duotone state
       const duotoneEnabled = document.getElementById('duotoneEnabled');
       const duotoneColorControls = document.getElementById('duotone-color-controls');
       const duotoneColor1 = document.getElementById('duotoneColor1');
       const duotoneColor1Text = document.getElementById('duotoneColor1Text');
       const duotoneColor2 = document.getElementById('duotoneColor2');
       const duotoneColor2Text = document.getElementById('duotoneColor2Text');

       if (duotoneEnabled) {
           const enabledValue = cssFilterState.duotoneEnabled !== undefined ? cssFilterState.duotoneEnabled : false;
           duotoneEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored duotoneEnabled: ${enabledValue}`);

           if (duotoneColorControls) {
               duotoneColorControls.style.display = enabledValue ? 'block' : 'none';
           }
       }

       if (duotoneColor1) {
           const color1Value = cssFilterState.duotoneColor1 || '#3B82F6';
           duotoneColor1.value = color1Value;
           console.log(`[LoadTemplate] 🎨 Restored duotoneColor1: ${color1Value}`);

           if (duotoneColor1Text) {
               duotoneColor1Text.value = color1Value;
           }
       }

       if (duotoneColor2) {
           const color2Value = cssFilterState.duotoneColor2 || '#EAB308';
           duotoneColor2.value = color2Value;
           console.log(`[LoadTemplate] 🎨 Restored duotoneColor2: ${color2Value}`);

           if (duotoneColor2Text) {
               duotoneColor2Text.value = color2Value;
           }
       }

       // Restore glitch effects state
       const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
       const paletteReductionControls = document.getElementById('palette-reduction-controls');
       const colorShiftEnabled = document.getElementById('colorShiftEnabled');
       const colorShiftControls = document.getElementById('color-shift-controls');
       const waveDeformEnabled = document.getElementById('waveDeformEnabled');
       const waveDeformControls = document.getElementById('wave-deform-controls');
       const displacementEnabled = document.getElementById('displacementEnabled');
       const displacementControls = document.getElementById('displacement-controls');
       const pixelSortEnabled = document.getElementById('pixelSortEnabled');
       const pixelSortControls = document.getElementById('pixel-sort-controls');

       // Palette Reduction
       if (paletteReductionEnabled) {
           const enabledValue = cssFilterState.paletteReductionEnabled !== undefined ? cssFilterState.paletteReductionEnabled : false;
           paletteReductionEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored paletteReductionEnabled: ${enabledValue}`);

           if (paletteReductionControls) {
               paletteReductionControls.style.display = enabledValue ? 'block' : 'none';
           }

           if (enabledValue) {
               const paletteSelect = document.getElementById('paletteName');
               const distanceSelect = document.getElementById('distanceMode');
               const ditheringCheckbox = document.getElementById('useDithering');
               if (paletteSelect && cssFilterState.paletteName) {
                   paletteSelect.value = cssFilterState.paletteName;
               }
               if (distanceSelect && cssFilterState.distanceMode) {
                   distanceSelect.value = cssFilterState.distanceMode;
               }
               if (ditheringCheckbox && cssFilterState.useDithering !== undefined) {
                   ditheringCheckbox.checked = cssFilterState.useDithering;
               }
           }
       }

       // Color Shift
       if (colorShiftEnabled) {
           const enabledValue = cssFilterState.colorShiftEnabled !== undefined ? cssFilterState.colorShiftEnabled : false;
           colorShiftEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored colorShiftEnabled: ${enabledValue}`);

           if (colorShiftControls) {
               colorShiftControls.style.display = enabledValue ? 'block' : 'none';
           }

           if (enabledValue) {
               const intensitySlider = document.getElementById('colorShiftIntensity');
               const amountSlider = document.getElementById('colorShiftAmount');
               if (intensitySlider && cssFilterState.colorShiftIntensity !== undefined) {
                   intensitySlider.value = cssFilterState.colorShiftIntensity;
                   const display = document.getElementById('vColorShiftIntensity');
                   if (display) display.textContent = Math.round(cssFilterState.colorShiftIntensity * 100) + '%';
               }
               if (amountSlider && cssFilterState.colorShiftAmount !== undefined) {
                   amountSlider.value = cssFilterState.colorShiftAmount;
                   const display = document.getElementById('vColorShiftAmount');
                   if (display) display.textContent = cssFilterState.colorShiftAmount + 'px';
               }
           }
       }

       // Wave Deform
       if (waveDeformEnabled) {
           const enabledValue = cssFilterState.waveDeformEnabled !== undefined ? cssFilterState.waveDeformEnabled : false;
           waveDeformEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored waveDeformEnabled: ${enabledValue}`);

           if (waveDeformControls) {
               waveDeformControls.style.display = enabledValue ? 'block' : 'none';
           }

           if (enabledValue) {
               const directionSelect = document.getElementById('waveDirection');
               const amplitudeSlider = document.getElementById('waveAmplitude');
               const frequencySlider = document.getElementById('waveFrequency');
               if (directionSelect && cssFilterState.waveDirection) {
                   directionSelect.value = cssFilterState.waveDirection;
               }
               if (amplitudeSlider && cssFilterState.waveAmplitude !== undefined) {
                   amplitudeSlider.value = cssFilterState.waveAmplitude;
                   const display = document.getElementById('vWaveAmplitude');
                   if (display) display.textContent = cssFilterState.waveAmplitude + 'px';
               }
               if (frequencySlider && cssFilterState.waveFrequency !== undefined) {
                   frequencySlider.value = cssFilterState.waveFrequency;
                   const display = document.getElementById('vWaveFrequency');
                   if (display) display.textContent = cssFilterState.waveFrequency.toFixed(2);
               }
           }
       }

       // Displacement
       if (displacementEnabled) {
           const enabledValue = cssFilterState.displacementEnabled !== undefined ? cssFilterState.displacementEnabled : false;
           displacementEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored displacementEnabled: ${enabledValue}`);

           if (displacementControls) {
               displacementControls.style.display = enabledValue ? 'block' : 'none';
           }

           if (enabledValue) {
               const modeSelect = document.getElementById('displacementMode');
               const intensitySlider = document.getElementById('displacementIntensity');
               const sizeSlider = document.getElementById('displacementSize');
               if (modeSelect && cssFilterState.displacementMode) {
                   modeSelect.value = cssFilterState.displacementMode;
               }
               if (intensitySlider && cssFilterState.displacementIntensity !== undefined) {
                   intensitySlider.value = cssFilterState.displacementIntensity;
                   const display = document.getElementById('vDisplacementIntensity');
                   if (display) display.textContent = cssFilterState.displacementIntensity;
               }
               if (sizeSlider && cssFilterState.displacementSize !== undefined) {
                   sizeSlider.value = cssFilterState.displacementSize;
                   const display = document.getElementById('vDisplacementSize');
                   if (display) display.textContent = cssFilterState.displacementSize;
               }
           }
       }

       // Pixel Sort
       if (pixelSortEnabled) {
           const enabledValue = cssFilterState.pixelSortEnabled !== undefined ? cssFilterState.pixelSortEnabled : false;
           pixelSortEnabled.checked = enabledValue;
           console.log(`[LoadTemplate] 🎨 Restored pixelSortEnabled: ${enabledValue}`);

           if (pixelSortControls) {
               pixelSortControls.style.display = enabledValue ? 'block' : 'none';
           }

           if (enabledValue) {
               const directionSelect = document.getElementById('pixelSortDirection');
               const blockSizeSlider = document.getElementById('pixelSortBlockSize');
               const frequencySlider = document.getElementById('pixelSortFrequency');
               if (directionSelect && cssFilterState.pixelSortDirection) {
                   directionSelect.value = cssFilterState.pixelSortDirection;
               }
               if (blockSizeSlider && cssFilterState.pixelSortBlockSize !== undefined) {
                   blockSizeSlider.value = cssFilterState.pixelSortBlockSize;
                   const display = document.getElementById('vPixelSortBlockSize');
                   if (display) display.textContent = cssFilterState.pixelSortBlockSize;
               }
               if (frequencySlider && cssFilterState.pixelSortFrequency !== undefined) {
                   frequencySlider.value = cssFilterState.pixelSortFrequency;
                   const display = document.getElementById('vPixelSortFrequency');
                   if (display) display.textContent = Math.round(cssFilterState.pixelSortFrequency * 100) + '%';
               }
           }
       }

       console.log('[LoadTemplate] 🎨 CSS filter state restoration complete');

       // Apply the restored filters to any selected images
       console.log('[LoadTemplate] 🎨 Applying restored CSS filters to images...');
       if (typeof applyImageFilters === 'function') {
           applyImageFilters();
           console.log('[LoadTemplate] 🎨 CSS filters applied to images');
       } else {
           console.log('[LoadTemplate] 🎨 applyImageFilters function not available, filters will apply when image is selected');
       }
   }

   // Make the function globally available for sessionStorage loading
   window.restoreCSSFilterState = restoreCSSFilterState;

   // --- Duotone Effect State Restoration ---
   function restoreDuotoneState(duotoneState) {
       console.log('[LoadTemplate] 🎨 Restoring duotone effect state...');

       if (!duotoneState || typeof duotoneState !== 'object') {
           console.log('[LoadTemplate] 🎨 No duotone state found, using defaults');
           return;
       }

       // Restore duotone enabled state
       const duotoneEnabled = document.getElementById('duotoneEnabled');
       if (duotoneEnabled) {
           duotoneEnabled.checked = duotoneState.enabled || false;
           console.log(`[LoadTemplate] 🎨 Restored duotoneEnabled: ${duotoneEnabled.checked}`);
       }

       // Restore duotone colors if enabled
       if (duotoneState.enabled && duotoneState.color1 && duotoneState.color2) {
           const color1Input = document.getElementById('duotoneColor1');
           const color2Input = document.getElementById('duotoneColor2');

           if (color1Input) {
               color1Input.value = duotoneState.color1;
               console.log(`[LoadTemplate] 🎨 Restored duotoneColor1: ${duotoneState.color1}`);
           }

           if (color2Input) {
               color2Input.value = duotoneState.color2;
               console.log(`[LoadTemplate] 🎨 Restored duotoneColor2: ${duotoneState.color2}`);
           }

           // Apply the duotone effect
           setTimeout(() => {
               if (typeof window.applyDuotoneEffect === 'function') {
                   console.log('[LoadTemplate] 🎨 Applying restored duotone effect...');
                   window.applyDuotoneEffect();
               } else {
                   console.log('[LoadTemplate] 🎨 applyDuotoneEffect function not available');
               }
           }, 100);
       }

       console.log('[LoadTemplate] 🎨 Duotone state restoration complete');
   }

   // Make the function globally available for sessionStorage loading
   window.restoreDuotoneState = restoreDuotoneState;

   // --- Glitch Effect State Restoration ---
   function restoreGlitchState(glitchState) {
       console.log('[LoadTemplate] 🎨 Restoring glitch effect state...');

       if (!glitchState || typeof glitchState !== 'object') {
           console.log('[LoadTemplate] 🎨 No glitch state found, using defaults');
           return;
       }

       // Restore palette reduction
       if (glitchState.paletteReduction) {
           const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
           if (paletteReductionEnabled) {
               paletteReductionEnabled.checked = glitchState.paletteReduction.enabled;
               console.log(`[LoadTemplate] 🎨 Restored paletteReductionEnabled: ${glitchState.paletteReduction.enabled}`);
           }

           if (glitchState.paletteReduction.enabled) {
               const paletteSelect = document.getElementById('paletteName');
               const distanceSelect = document.getElementById('distanceMode');
               const ditheringCheckbox = document.getElementById('useDithering');

               if (paletteSelect) {
                   paletteSelect.value = glitchState.paletteReduction.paletteName;
                   console.log(`[LoadTemplate] 🎨 Restored paletteName: ${glitchState.paletteReduction.paletteName}`);
               }
               if (distanceSelect) {
                   distanceSelect.value = glitchState.paletteReduction.distanceMode;
                   console.log(`[LoadTemplate] 🎨 Restored distanceMode: ${glitchState.paletteReduction.distanceMode}`);
               }
               if (ditheringCheckbox) {
                   ditheringCheckbox.checked = glitchState.paletteReduction.useDithering;
                   console.log(`[LoadTemplate] 🎨 Restored useDithering: ${glitchState.paletteReduction.useDithering}`);
               }
           }
       }

       // Restore color shift
       if (glitchState.colorShift) {
           const colorShiftEnabled = document.getElementById('colorShiftEnabled');
           if (colorShiftEnabled) {
               colorShiftEnabled.checked = glitchState.colorShift.enabled;
               console.log(`[LoadTemplate] 🎨 Restored colorShiftEnabled: ${glitchState.colorShift.enabled}`);
           }

           if (glitchState.colorShift.enabled) {
               const intensitySlider = document.getElementById('colorShiftIntensity');
               const amountSlider = document.getElementById('colorShiftAmount');

               if (intensitySlider) {
                   intensitySlider.value = glitchState.colorShift.intensity;
                   console.log(`[LoadTemplate] 🎨 Restored colorShiftIntensity: ${glitchState.colorShift.intensity}`);
               }
               if (amountSlider) {
                   amountSlider.value = glitchState.colorShift.shiftAmount;
                   console.log(`[LoadTemplate] 🎨 Restored colorShiftAmount: ${glitchState.colorShift.shiftAmount}`);
               }
           }
       }

       // Restore wave deform
       if (glitchState.waveDeform) {
           const waveDeformEnabled = document.getElementById('waveDeformEnabled');
           if (waveDeformEnabled) {
               waveDeformEnabled.checked = glitchState.waveDeform.enabled;
               console.log(`[LoadTemplate] 🎨 Restored waveDeformEnabled: ${glitchState.waveDeform.enabled}`);
           }

           if (glitchState.waveDeform.enabled) {
               const directionSelect = document.getElementById('waveDirection');
               const amplitudeSlider = document.getElementById('waveAmplitude');
               const frequencySlider = document.getElementById('waveFrequency');

               if (directionSelect) {
                   directionSelect.value = glitchState.waveDeform.direction;
                   console.log(`[LoadTemplate] 🎨 Restored waveDirection: ${glitchState.waveDeform.direction}`);
               }
               if (amplitudeSlider) {
                   amplitudeSlider.value = glitchState.waveDeform.amplitude;
                   console.log(`[LoadTemplate] 🎨 Restored waveAmplitude: ${glitchState.waveDeform.amplitude}`);
               }
               if (frequencySlider) {
                   frequencySlider.value = glitchState.waveDeform.frequency;
                   console.log(`[LoadTemplate] 🎨 Restored waveFrequency: ${glitchState.waveDeform.frequency}`);
               }
           }
       }

       // Restore displacement
       if (glitchState.displacement) {
           const displacementEnabled = document.getElementById('displacementEnabled');
           if (displacementEnabled) {
               displacementEnabled.checked = glitchState.displacement.enabled;
               console.log(`[LoadTemplate] 🎨 Restored displacementEnabled: ${glitchState.displacement.enabled}`);
           }

           if (glitchState.displacement.enabled) {
               const modeSelect = document.getElementById('displacementMode');
               const intensitySlider = document.getElementById('displacementIntensity');
               const sizeSlider = document.getElementById('displacementSize');

               if (modeSelect) {
                   modeSelect.value = glitchState.displacement.mode;
                   console.log(`[LoadTemplate] 🎨 Restored displacementMode: ${glitchState.displacement.mode}`);
               }
               if (intensitySlider) {
                   intensitySlider.value = glitchState.displacement.displacementIntensity;
                   console.log(`[LoadTemplate] 🎨 Restored displacementIntensity: ${glitchState.displacement.displacementIntensity}`);
               }
               if (sizeSlider) {
                   sizeSlider.value = glitchState.displacement.displacementSize;
                   console.log(`[LoadTemplate] 🎨 Restored displacementSize: ${glitchState.displacement.displacementSize}`);
               }
           }
       }

       // Restore pixel sort
       if (glitchState.pixelSort) {
           const pixelSortEnabled = document.getElementById('pixelSortEnabled');
           if (pixelSortEnabled) {
               pixelSortEnabled.checked = glitchState.pixelSort.enabled;
               console.log(`[LoadTemplate] 🎨 Restored pixelSortEnabled: ${glitchState.pixelSort.enabled}`);
           }

           if (glitchState.pixelSort.enabled) {
               const directionSelect = document.getElementById('pixelSortDirection');
               const blockSizeSlider = document.getElementById('pixelSortBlockSize');
               const frequencySlider = document.getElementById('pixelSortFrequency');

               if (directionSelect) {
                   directionSelect.value = glitchState.pixelSort.direction;
                   console.log(`[LoadTemplate] 🎨 Restored pixelSortDirection: ${glitchState.pixelSort.direction}`);
               }
               if (blockSizeSlider) {
                   blockSizeSlider.value = glitchState.pixelSort.blockSize;
                   console.log(`[LoadTemplate] 🎨 Restored pixelSortBlockSize: ${glitchState.pixelSort.blockSize}`);
               }
               if (frequencySlider) {
                   frequencySlider.value = glitchState.pixelSort.frequency;
                   console.log(`[LoadTemplate] 🎨 Restored pixelSortFrequency: ${glitchState.pixelSort.frequency}`);
               }
           }
       }

       // Apply the glitch effects
       setTimeout(() => {
           if (typeof window.applyGlinchEffects === 'function') {
               console.log('[LoadTemplate] 🎨 Applying restored glitch effects...');
               window.applyGlinchEffects();
           } else {
               console.log('[LoadTemplate] 🎨 applyGlinchEffects function not available');
           }
       }, 200);

       console.log('[LoadTemplate] 🎨 Glitch state restoration complete');
   }

   // Make the function globally available for sessionStorage loading
   window.restoreGlitchState = restoreGlitchState;

   // --- Load Template Data ---
   async function loadTemplateData(templateId) {
       console.log(`[LoadTemplate] Fetching template data for ID: ${templateId}`);

       // Set flag to indicate template is being loaded via URL parameter
       window._templateAlreadyLoaded = true;
       console.log('[LoadTemplate] Set _templateAlreadyLoaded = true');

       try {
           const response = await fetch(`/api/design-templates/${templateId}`, { credentials: 'include' });
           if (!response.ok) {
               throw new Error(`Failed to fetch template: ${response.statusText}`);
           }
           const template = await response.json();
           console.log('[LoadTemplate] Received template data:', template);

           canvasObjects = [];
           selectedObjectIndex = -1;

           // Restore editor state if available
           if (template.editorState) {
               console.log('[LoadTemplate] Restoring editor state:', template.editorState);

               // Restore canvas background color
               if (template.editorState.canvasBackgroundColor) {
                   canvasBackgroundColor = template.editorState.canvasBackgroundColor;
                   // 🎯 FIX: Sync to global variable for save function
                   window.canvasBackgroundColor = canvasBackgroundColor;
                   console.log('[LoadTemplate] Restored canvas background color:', canvasBackgroundColor);
               }

               // Restore zoom and positioning
               if (template.editorState.zoom) {
                   scale = template.editorState.zoom.scale || 1.0;
                   offsetX = template.editorState.zoom.offsetX || 0;
                   offsetY = template.editorState.zoom.offsetY || 0;
                   // 🎯 FIX: Sync to global variables for save function
                   window.scale = scale;
                   window.offsetX = offsetX;
                   window.offsetY = offsetY;
                   console.log('[LoadTemplate] Restored zoom/position:', { scale, offsetX, offsetY });
                   console.log('[LoadTemplate] ✅ Synced global variables for project saving');
               }

               // Restore nextId to avoid ID conflicts
               if (template.editorState.nextId) {
                   nextId = template.editorState.nextId;
                   console.log('[LoadTemplate] Restored nextId:', nextId);
               }

               // Restore other editor settings
               if (template.editorState.editorSettings) {
                   // Apply any additional editor settings
                   console.log('[LoadTemplate] Additional editor settings:', template.editorState.editorSettings);
               }
           } else {
               console.log('[LoadTemplate] No editor state found, using defaults');
           }

           if (template.artboard) {
               artboard = {
                   x: Number(template.artboard.x),
                   y: Number(template.artboard.y),
                   width: Number(template.artboard.width),
                   height: Number(template.artboard.height),
                   isSelected: true
               };
               console.log('[LoadTemplate] Restored artboard:', artboard);
               // 🎯 FIX: Set window.artboard so save project can find it
               window.artboard = artboard;
               console.log('[LoadTemplate] ✅ Set window.artboard for project saving');
           } else {
               artboard = null;
               window.artboard = null;
               console.log('[LoadTemplate] No artboard data found in template.');
           }

           if (template.adminData) {
               document.getElementById('adminImageUrl').value = template.adminData.imageUrl || '';
               document.getElementById('adminModel').value = template.adminData.model || '';
               document.getElementById('adminPrompt').value = template.adminData.prompt || '';
               document.getElementById('adminPalette').value = template.adminData.palette || '';
               // PRIORITIZE USER'S INPUT from adminData.object over template.originalObject
               const userSelectedObject = template.adminData?.object;
               const templateOriginalObject = template.originalObject;
               document.getElementById('adminOriginalObject').value = userSelectedObject || templateOriginalObject || '';
               console.log('[LoadTemplate] 🎯 Set Original Object field:', userSelectedObject || templateOriginalObject || 'empty');
               // backgroundType element was removed, skip setting it
               // document.getElementById('backgroundType').value = template.adminData.backgroundType || 'light';
               document.getElementById('adminInspirationId').value = template._id || '';
               console.log('[LoadTemplate] Restored admin data.');
           }

           // Populate Original Palette field - PRIORITIZE USER'S INPUT from adminData.palette over template.originalPalette
           const originalPaletteField = document.getElementById('adminOriginalPalette');
           if (originalPaletteField) {
               // Use USER'S selected palette from adminData.palette if available, otherwise fall back to template.originalPalette
               const userSelectedPalette = template.adminData?.palette;
               const templateOriginalPalette = template.originalPalette;

               if (userSelectedPalette) {
                   originalPaletteField.value = userSelectedPalette;
                   console.log('[LoadTemplate] 🎯 Restored USER SELECTED palette:', userSelectedPalette);
               } else if (templateOriginalPalette) {
                   originalPaletteField.value = templateOriginalPalette;
                   console.log('[LoadTemplate] Restored template original palette:', templateOriginalPalette);
               }
           }

           // Load font styles and decor styles from template
           console.log('[LoadTemplate] 🎯 Loading font styles and decor styles...');

           // Load font styles (check both top-level and adminData) - CRITICAL: Check for content, not just existence
           console.log('[LoadTemplate] 🎯 🔍 FONT STYLES LOADING - Checking for font styles...');
           console.log('[LoadTemplate] 🎯 🔍 template.fontStylesList:', template.fontStylesList);
           console.log('[LoadTemplate] 🎯 🔍 template.adminData?.fontStylesList:', template.adminData?.fontStylesList);

           // Use the one that has content, not just exists (following documentation pattern)
           const fontStylesList = (template.fontStylesList && template.fontStylesList.length > 0)
               ? template.fontStylesList
               : template.adminData?.fontStylesList;

           console.log('[LoadTemplate] 🎯 🔍 Combined fontStylesList:', fontStylesList);

           if (fontStylesList && Array.isArray(fontStylesList) && fontStylesList.length > 0) {
               console.log('[LoadTemplate] 🎯 ✅ FONT STYLES FOUND - Loading into window.fontStylesList...', fontStylesList.length, 'styles');
               window.fontStylesList = fontStylesList;
               window._templateSpecificFontStylesLoaded = true;
               console.log('[LoadTemplate] 🎯 ✅ Set _templateSpecificFontStylesLoaded = true');

               // Protect the data
               if (window._fontStylesProtection) {
                   window._fontStylesProtection.protect(fontStylesList);
                   console.log('[LoadTemplate] 🎯 🛡️ Font styles protected');
               }

               // Populate admin field
               const adminFontStylesField = document.getElementById('adminFontStyles');
               if (adminFontStylesField) {
                   adminFontStylesField.value = JSON.stringify(fontStylesList, null, 2);
                   console.log('[LoadTemplate] 🎯 ✅ Populated adminFontStyles field');
               }
           } else {
               console.log('[LoadTemplate] 🎯 ❌ NO FONT STYLES FOUND in template - template has empty or no font styles');
               window.fontStylesList = [];
               window._templateSpecificFontStylesLoaded = true;
               console.log('[LoadTemplate] 🎯 ❌ Set _templateSpecificFontStylesLoaded = true (no data found)');
           }

           // Load decor styles (check both top-level and adminData) - CRITICAL: Check for content, not just existence
           console.log('[LoadTemplate] 🎯 🔍 DECOR STYLES LOADING - Checking for decor styles...');
           console.log('[LoadTemplate] 🎯 🔍 template.decorStylesList:', template.decorStylesList);
           console.log('[LoadTemplate] 🎯 🔍 template.adminData?.decorStylesList:', template.adminData?.decorStylesList);

           // Use the one that has content, not just exists (following documentation pattern)
           const decorStylesList = (template.decorStylesList && template.decorStylesList.length > 0)
               ? template.decorStylesList
               : template.adminData?.decorStylesList;

           console.log('[LoadTemplate] 🎯 🔍 Combined decorStylesList:', decorStylesList);

           if (decorStylesList && Array.isArray(decorStylesList) && decorStylesList.length > 0) {
               console.log('[LoadTemplate] 🎯 ✅ DECOR STYLES FOUND - Loading into window.decorStylesList...', decorStylesList.length, 'styles');
               window.decorStylesList = decorStylesList;
               window._templateSpecificDecorStylesLoaded = true;
               console.log('[LoadTemplate] 🎯 ✅ Set _templateSpecificDecorStylesLoaded = true');

               // Protect the data
               if (window._decorStylesProtection) {
                   window._decorStylesProtection.protect(decorStylesList);
                   console.log('[LoadTemplate] 🎯 🛡️ Decor styles protected');
               }

               // Populate admin field
               const adminDecorStylesField = document.getElementById('adminDecorStyles');
               if (adminDecorStylesField) {
                   adminDecorStylesField.value = JSON.stringify(decorStylesList, null, 2);
                   console.log('[LoadTemplate] 🎯 ✅ Populated adminDecorStyles field');
               }
           } else {
               console.log('[LoadTemplate] 🎯 ❌ NO DECOR STYLES FOUND in template - template has empty or no decor styles');
               window.decorStylesList = [];
               window._templateSpecificDecorStylesLoaded = true;
               console.log('[LoadTemplate] 🎯 ❌ Set _templateSpecificDecorStylesLoaded = true (no data found)');
           }

           // CSS filter restoration moved to end of loading process (after canvas objects are loaded)

           // Store template name for updates
           currentTemplateName = template.name;

           // Update save buttons for existing template
           updateSaveButtonsForExistingTemplate(template._id, template.name);

           if (template.canvasObjects && Array.isArray(template.canvasObjects)) {
               console.log('[LoadTemplate] 🚀 LAYER ORDER FIX - Starting to restore canvas objects...');
               console.log('[LoadTemplate] Raw template objects count:', template.canvasObjects.length);

               // Log raw objects as received from database
               template.canvasObjects.forEach((obj, index) => {
                   console.log(`[LoadTemplate] Raw object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", layerOrder=${obj.layerOrder}, zIndex=${obj.zIndex}, id=${obj.id}`);
               });

               // Sort objects by layerOrder/zIndex BEFORE processing them
               const sortedObjects = template.canvasObjects.slice().sort((a, b) => {
                   const aOrder = a.layerOrder !== undefined ? a.layerOrder : a.zIndex !== undefined ? a.zIndex : 0;
                   const bOrder = b.layerOrder !== undefined ? b.layerOrder : b.zIndex !== undefined ? b.zIndex : 0;
                   console.log(`[LoadTemplate] Sorting: ${a.type}(${aOrder}) vs ${b.type}(${bOrder}) = ${aOrder - bOrder}`);
                   return aOrder - bOrder;
               });

               console.log('[LoadTemplate] ===== AFTER SORTING =====');
               sortedObjects.forEach((obj, index) => {
                   console.log(`[LoadTemplate] Sorted object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", layerOrder=${obj.layerOrder}, zIndex=${obj.zIndex}`);
               });

               // Create a temporary array to collect objects in the correct order
               const tempCanvasObjects = [];

               const objectPromises = sortedObjects.map((objData, sortedIndex) => {
                   return new Promise((resolve, reject) => {
                       if (objData.type === 'text') {
                           const textObj = createTextObject(objData);
                           textObj.id = objData.id ?? nextId++;
                           // Insert at the correct position to maintain layer order
                           tempCanvasObjects[sortedIndex] = textObj;
                           console.log(`[LoadTemplate] Created text object at position ${sortedIndex}: "${textObj.text}"`);
                           resolve();
                       } else if (objData.type === 'image' && objData.imageUrl) {
                           // Check if this is a blob URL from an old template
                           if (objData.imageUrl.startsWith('blob:')) {
                               console.warn(`[LoadTemplate] Detected blob URL for object ${objData.id}: ${objData.imageUrl}`);
                               console.warn(`[LoadTemplate] Skipping object with invalid blob URL - this was likely an SVG that was recolored in an old template`);
                               resolve(); // Skip this object
                               return;
                           }

                           const img = new Image();
                           img.crossOrigin = 'anonymous';
                           const finalImageUrl = getProxiedImageUrlIfNeeded(objData.imageUrl); // Proxy if needed
                           img.onload = () => {
                               const imageObj = createImageObject(img, objData);
                               imageObj.id = objData.id ?? nextId++;
                               imageObj.imageUrl = finalImageUrl; // Store the potentially proxied URL
                               // Insert at the correct position to maintain layer order
                               tempCanvasObjects[sortedIndex] = imageObj;
                               console.log(`[LoadTemplate] ✅ IMAGE LOADED SUCCESSFULLY at position ${sortedIndex}: "${imageObj.imageUrl}"`);
                               console.log(`[LoadTemplate] ✅ Image dimensions: ${img.width}x${img.height}, naturalDimensions: ${img.naturalWidth}x${img.naturalHeight}`);
                               resolve();
                           };
                           img.onerror = (err) => {
                               console.error(`[LoadTemplate] ❌ FAILED TO LOAD IMAGE for object ${objData.id}: ${finalImageUrl}`, err);
                               console.error(`[LoadTemplate] ❌ Image URL length: ${finalImageUrl.length} characters`);
                               console.error(`[LoadTemplate] ❌ Is base64 data URL: ${finalImageUrl.startsWith('data:')}`);

                               // For very large base64 images, create a placeholder image object
                               if (finalImageUrl.startsWith('data:') && finalImageUrl.length > 100000) {
                                   console.warn(`[LoadTemplate] ⚠️ Creating placeholder for large base64 image (${finalImageUrl.length} chars)`);

                                   // Create a minimal placeholder image object
                                   const placeholderObj = {
                                       id: objData.id ?? nextId++,
                                       type: 'image',
                                       x: objData.x || 0,
                                       y: objData.y || 0,
                                       rotation: objData.rotation || 0,
                                       scale: objData.scale || 1,
                                       opacity: objData.opacity || 100,
                                       imageUrl: finalImageUrl,
                                       originalWidth: objData.originalWidth || 100,
                                       originalHeight: objData.originalHeight || 100,
                                       isSelected: false,
                                       image: null // Will be loaded later
                                   };

                                   // Copy other properties
                                   Object.keys(objData).forEach(key => {
                                       if (!placeholderObj.hasOwnProperty(key)) {
                                           placeholderObj[key] = objData[key];
                                       }
                                   });

                                   tempCanvasObjects[sortedIndex] = placeholderObj;
                                   console.log(`[LoadTemplate] ⚠️ Created placeholder image object at position ${sortedIndex}`);
                               }

                               resolve();
                           };
                           img.src = finalImageUrl;
                       } else {
                           console.warn('[LoadTemplate] Skipping unknown or invalid object data:', objData);
                           resolve();
                       }
                   });
               });

               await Promise.all(objectPromises);

               // Now assign the correctly ordered array to canvasObjects
               canvasObjects = tempCanvasObjects.filter(obj => obj !== undefined);

               console.log('[LoadTemplate] ===== FINAL CANVAS OBJECTS ARRAY =====');
               canvasObjects.forEach((obj, index) => {
                   console.log(`[LoadTemplate] Final array ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", id=${obj.id}`);
               });
               console.log('[LoadTemplate] 🚀 LAYER ORDER FIX - Restored canvas objects with correct layer order:', canvasObjects.length);

               // Restore mask relationships after all objects are loaded
               restoreMaskRelationships();

               // Auto-apply masks after restoration
               autoApplyMasksAfterLoad();

               // Apply SVG colors for objects that have svgColor set (from smart color system)
               console.log('[LoadTemplate] 🎨 Checking for SVG objects with svgColor to recolor...');
               canvasObjects.forEach(async (obj, index) => {
                   if (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg') && obj.svgColor) {
                       console.log(`[LoadTemplate] 🎨 Found SVG object with svgColor: ${obj.svgColor}, triggering recoloring...`);
                       try {
                           await recolorSVG(obj, obj.svgColor);
                           console.log(`[LoadTemplate] 🎨 Successfully recolored SVG object ${obj.id}`);
                       } catch (error) {
                           console.error(`[LoadTemplate] 🎨 Error recoloring SVG object ${obj.id}:`, error);
                       }
                   }
               });

               // Initialize mesh warp handlers for text objects with mesh effect
               canvasObjects.forEach(obj => {
                   if (obj.type === 'text' && obj.effectMode === 'mesh' && obj.meshWarp) {
                       console.log('[LoadTemplate] Initializing mesh warp handler for text object:', obj.text);
                       console.log('[LoadTemplate] Mesh warp data:', obj.meshWarp);
                       try {
                           // Restore control points from saved data BEFORE creating handler
                           // This prevents initMeshGrid from resetting hasCustomDistortion
                           let savedControlPoints = null;
                           let savedInitialControlPoints = null;
                           let savedRelativeControlPoints = null;
                           let savedHasCustomDistortion = false;
                           let savedShowGrid = true;
                           let savedGridRect = null;

                           if (obj.meshWarp.controlPoints && obj.meshWarp.controlPoints.length > 0) {
                               console.log('[LoadTemplate] Preparing to restore control points:', obj.meshWarp.controlPoints.length, 'points');
                               savedControlPoints = obj.meshWarp.controlPoints.map(p => ({ ...p }));
                               savedInitialControlPoints = obj.meshWarp.initialControlPoints.map(p => ({ ...p }));
                               savedRelativeControlPoints = obj.meshWarp.relativeControlPoints.map(p => ({ ...p }));
                               savedHasCustomDistortion = obj.meshWarp.hasCustomDistortion;
                               savedShowGrid = obj.meshWarp.showGrid;
                               savedGridRect = obj.meshWarp.gridRect ? { ...obj.meshWarp.gridRect } : null;
                               console.log('[LoadTemplate] Saved hasCustomDistortion:', savedHasCustomDistortion);
                           }

                           // Create a new mesh warp handler for this object
                           const meshHandler = new MeshWarpHandler(
                               document.getElementById('demo'),
                               obj
                           );

                           // Now restore the saved data to the handler
                           if (savedControlPoints) {
                               console.log('[LoadTemplate] Restoring control points to handler');
                               meshHandler.controlPoints = savedControlPoints;
                               meshHandler.initialControlPoints = savedInitialControlPoints;
                               meshHandler.relativeControlPoints = savedRelativeControlPoints;
                               meshHandler.hasCustomDistortion = savedHasCustomDistortion;
                               meshHandler.showGrid = savedShowGrid;
                               meshHandler.initialGridRect = savedGridRect;
                               console.log('[LoadTemplate] Restored mesh warp control points for:', obj.text, 'Points:', meshHandler.controlPoints.length);
                               console.log('[LoadTemplate] First control point:', meshHandler.controlPoints[0]);
                               console.log('[LoadTemplate] hasCustomDistortion:', meshHandler.hasCustomDistortion);
                           } else {
                               console.warn('[LoadTemplate] No control points found in mesh warp data for:', obj.text);
                           }

                           // Store the handler reference (we'll only keep one active at a time)
                           obj._meshWarpHandler = meshHandler;
                           console.log('[LoadTemplate] Stored mesh handler reference in obj._meshWarpHandler for:', obj.text);
                       } catch (error) {
                           console.error('[LoadTemplate] Error initializing mesh warp handler for:', obj.text, error);
                       }
                   } else if (obj.type === 'text' && obj.effectMode === 'grid-distort') {
                       console.log('[GridDistortLoad] 🔧 ===== STARTING GRID DISTORT LOAD =====');
                       console.log('[GridDistortLoad] 🔧 Object details:', {
                           text: obj.text,
                           effectMode: obj.effectMode,
                           hasGridDistortData: !!obj.gridDistortData,
                           hasGridDistort: !!obj.gridDistort,
                           hasMeshWarp: !!obj.meshWarp,
                           allProperties: Object.keys(obj)
                       });

                       try {
                           // Check if we have saved Grid Distort data (new system)
                           if (obj.gridDistortData) {
                               console.log('[GridDistortLoad] 🔧 ✅ Found saved gridDistortData, analyzing...');
                               console.log('[GridDistortLoad] 🔧 gridDistortData structure:', {
                                   gridCols: obj.gridDistortData.gridCols,
                                   gridRows: obj.gridDistortData.gridRows,
                                   gridPadding: obj.gridDistortData.gridPadding,
                                   intensity: obj.gridDistortData.intensity,
                                   showGrid: obj.gridDistortData.showGrid,
                                   lastText: obj.gridDistortData.lastText,
                                   lastFontSize: obj.gridDistortData.lastFontSize,
                                   verticalOnly: obj.gridDistortData.verticalOnly,
                                   controlPointsLength: obj.gridDistortData.controlPoints ? obj.gridDistortData.controlPoints.length : 0,
                                   relativeControlPointsLength: obj.gridDistortData.relativeControlPoints ? obj.gridDistortData.relativeControlPoints.length : 0,
                                   hasGridBounds: !!obj.gridDistortData.gridBounds
                               });

                               // Log the actual control points for debugging
                               if (obj.gridDistortData.relativeControlPoints && obj.gridDistortData.relativeControlPoints.length > 0) {
                                   console.log('[GridDistortLoad] 🔧 Relative control points sample:', obj.gridDistortData.relativeControlPoints[0]);
                               }

                               // Restore the complete Grid Distort object from saved data
                               obj.gridDistort = {
                                   gridCols: obj.gridDistortData.gridCols || 3,
                                   gridRows: obj.gridDistortData.gridRows || 2,
                                   gridPadding: obj.gridDistortData.gridPadding || 120,
                                   intensity: obj.gridDistortData.intensity || 1,
                                   showGrid: obj.gridDistortData.showGrid || false,
                                   lastText: obj.gridDistortData.lastText || obj.text,
                                   lastFontSize: obj.gridDistortData.lastFontSize || obj.fontSize,
                                   verticalOnly: obj.gridDistortData.verticalOnly || false,

                                   // Critical: Restore the control points that define the distortion
                                   controlPoints: obj.gridDistortData.controlPoints ?
                                       obj.gridDistortData.controlPoints.map(row =>
                                           row.map(point => ({ x: point.x, y: point.y }))
                                       ) : [],

                                   // Critical: Restore the relative control points for preserving distortion
                                   relativeControlPoints: obj.gridDistortData.relativeControlPoints ?
                                       obj.gridDistortData.relativeControlPoints.map(row =>
                                           row.map(point => ({ x: point.x, y: point.y }))
                                       ) : [],

                                   // Restore grid bounds
                                   gridBounds: obj.gridDistortData.gridBounds ? {
                                       width: obj.gridDistortData.gridBounds.width,
                                       height: obj.gridDistortData.gridBounds.height,
                                       padding: obj.gridDistortData.gridBounds.padding
                                   } : null
                               };

                               console.log('[GridDistortLoad] 🔧 ✅ Successfully restored Grid Distort object:', {
                                   controlPointsCount: obj.gridDistort.controlPoints.length,
                                   relativeControlPointsCount: obj.gridDistort.relativeControlPoints.length,
                                   hasGridBounds: !!obj.gridDistort.gridBounds,
                                   gridCols: obj.gridDistort.gridCols,
                                   gridRows: obj.gridDistort.gridRows
                               });

                               // Clean up the temporary gridDistortData property
                               delete obj.gridDistortData;
                               console.log('[GridDistortLoad] 🔧 Cleaned up temporary gridDistortData property');

                           } else if (obj.gridDistort) {
                               // Legacy system - object already has gridDistort data
                               console.log('[GridDistortLoad] 🔧 Found legacy gridDistort data');
                               console.log('[GridDistortLoad] 🔧 Legacy Grid Distort data:', {
                                   gridCols: obj.gridDistort.gridCols,
                                   gridRows: obj.gridDistort.gridRows,
                                   controlPointsLength: obj.gridDistort.controlPoints ? obj.gridDistort.controlPoints.length : 0,
                                   relativeControlPointsLength: obj.gridDistort.relativeControlPoints ? obj.gridDistort.relativeControlPoints.length : 0
                               });

                           } else {
                               console.log('[GridDistortLoad] 🔧 ❌ No gridDistortData or gridDistort found, creating default Grid Distort object');

                               // Create default Grid Distort object
                               obj.gridDistort = {
                                   gridCols: 3,
                                   gridRows: 2,
                                   gridPadding: 120,
                                   intensity: 1,
                                   showGrid: false,
                                   lastText: obj.text,
                                   lastFontSize: obj.fontSize,
                                   verticalOnly: false,
                                   controlPoints: [],
                                   relativeControlPoints: [],
                                   gridBounds: null
                               };
                               console.log('[GridDistortLoad] 🔧 Created default Grid Distort object');
                           }

                           console.log('[GridDistortLoad] 🔧 ✅ Grid Distort data loaded for text object:', obj.text);
                           console.log('[GridDistortLoad] 🔧 Final gridDistort object:', {
                               hasControlPoints: obj.gridDistort.controlPoints && obj.gridDistort.controlPoints.length > 0,
                               hasRelativeControlPoints: obj.gridDistort.relativeControlPoints && obj.gridDistort.relativeControlPoints.length > 0,
                               gridCols: obj.gridDistort.gridCols,
                               gridRows: obj.gridDistort.gridRows
                           });
                           console.log('[GridDistortLoad] 🔧 ===== FINISHED GRID DISTORT LOAD =====');
                       } catch (error) {
                           console.error('[GridDistortLoad] 🔧 ❌ Error loading Grid Distort data for:', obj.text, error);
                       }
                   } else {
                       console.log('[LoadTemplate] Skipping object:', obj.text || obj.type, 'effectMode:', obj.effectMode, 'hasMeshWarp:', !!obj.meshWarp, 'hasGridDistort:', !!obj.gridDistort);
                   }
               });
           }

           // Auto-activate mesh warp handlers for immediate visual feedback
           setTimeout(() => {
               let meshTextFound = false;
               canvasObjects.forEach((obj, index) => {
                   if (obj.type === 'text' && obj.effectMode === 'mesh' && obj._meshWarpHandler && !meshTextFound) {
                       console.log('[LoadTemplate] Auto-activating mesh warp for immediate display:', obj.text);

                       // Temporarily select the object to activate mesh warp
                       const previousSelection = selectedObjectIndex;
                       selectedObjectIndex = index;
                       obj.isSelected = true;

                       // Activate the mesh warp handler
                       activeMeshWarpHandler = obj._meshWarpHandler;
                       activeMeshWarpHandler.selectedTextObject = obj;

                       // Force a redraw to show the distortion
                       update();

                       // After a brief moment, restore the previous selection state
                       setTimeout(() => {
                           if (previousSelection === -1) {
                               // No previous selection, deselect everything
                               selectedObjectIndex = -1;
                               obj.isSelected = false;
                               console.log('[LoadTemplate] Auto-deselected mesh text for clean display');
                           } else {
                               // Restore previous selection
                               selectedObjectIndex = previousSelection;
                               obj.isSelected = false;
                               if (canvasObjects[previousSelection]) {
                                   canvasObjects[previousSelection].isSelected = true;
                               }
                               console.log('[LoadTemplate] Restored previous selection:', previousSelection);
                           }

                           // Update UI to reflect the final selection state
                           updateUIFromSelectedObject();
                           update();
                       }, 100); // Very brief selection - just enough to activate mesh warp

                       meshTextFound = true; // Only auto-activate the first mesh text found
                   }
               });

               if (!meshTextFound) {
                   console.log('[LoadTemplate] No mesh warp text objects found for auto-activation');
               }
           }, 200); // Small delay to ensure everything is fully loaded

           // Sync global references to ensure window.canvasObjects points to the current array
           syncGlobalReferences();
           console.log('[LoadTemplate] Synced global references. window.canvasObjects length:', window.canvasObjects.length);

           // 🎨 NOW restore CSS filter state (after canvas objects are loaded and synced)
           if (template.cssFilterState) {
               console.log('[LoadTemplate] 🎨 Found CSS filter state in template:', template.cssFilterState);
               console.log('[LoadTemplate] 🎨 Restoring CSS filters AFTER canvas objects are loaded...');
               restoreCSSFilterState(template.cssFilterState);

               // 🎯 VERIFICATION AND AUTO-APPLICATION (following docs pattern)
               setTimeout(() => {
                   console.log('[LoadTemplate] 🎨 Verifying CSS filter application...');

                   // Check if any image has the restored filters applied
                   let filtersApplied = false;
                   let firstImageIndex = -1;

                   if (window.canvasObjects) {
                       for (let i = 0; i < window.canvasObjects.length; i++) {
                           const obj = window.canvasObjects[i];
                           if (obj.type === 'image') {
                               if (firstImageIndex === -1) firstImageIndex = i; // Remember first image

                               if (obj.cssFilterString && obj.cssFilterString !== 'none') {
                                   filtersApplied = true;
                                   console.log(`[LoadTemplate] 🎨 ✅ Filters already applied to image ${i}:`, obj.cssFilterString);
                                   break;
                               }
                           }
                       }
                   }

                   // If no filters applied, force application with auto-selection
                   if (!filtersApplied && firstImageIndex !== -1) {
                       console.log('[LoadTemplate] 🎨 ⚠️ No filters detected on images, forcing application...');
                       console.log(`[LoadTemplate] 🎨 Auto-selecting image at index ${firstImageIndex} for filter application`);

                       // Auto-select the first image
                       if (window.canvasObjects[firstImageIndex]) {
                           // Clear all selections first
                           window.canvasObjects.forEach(obj => obj.isSelected = false);

                           // Select the first image
                           window.canvasObjects[firstImageIndex].isSelected = true;
                           window.selectedObjectIndex = firstImageIndex;

                           console.log('[LoadTemplate] 🎨 Image auto-selected, applying filters...');

                           // Apply filters to the selected image
                           if (typeof window.applyImageFilters === 'function') {
                               window.applyImageFilters();
                               console.log('[LoadTemplate] 🎨 ✅ Forced CSS filter application complete');

                               // Optionally deselect after application (uncomment if desired)
                               // setTimeout(() => {
                               //     window.canvasObjects[firstImageIndex].isSelected = false;
                               //     window.selectedObjectIndex = -1;
                               //     console.log('[LoadTemplate] 🎨 Image deselected after filter application');
                               // }, 100);
                           }
                       }
                   } else if (filtersApplied) {
                       console.log('[LoadTemplate] 🎨 ✅ CSS filters already applied, no action needed');
                   } else {
                       console.log('[LoadTemplate] 🎨 ℹ️ No images found to apply filters to');
                   }
               }, 300); // Small delay to ensure everything is fully processed
           } else {
               console.log('[LoadTemplate] 🎨 No CSS filter state found in template, using defaults');
               restoreCSSFilterState({}); // This will set all filters to default values
           }

           // 🎨 Restore duotone effect state (after CSS filters)
           if (template.duotoneState) {
               console.log('[LoadTemplate] 🎨 Found duotone state in template:', template.duotoneState);
               console.log('[LoadTemplate] 🎨 Restoring duotone effects AFTER CSS filters...');
               setTimeout(() => {
                   restoreDuotoneState(template.duotoneState);
               }, 400);
           } else {
               console.log('[LoadTemplate] 🎨 No duotone state found in template, using defaults');
           }

           // 🎨 Restore glitch effect state (after duotone)
           if (template.glitchState) {
               console.log('[LoadTemplate] 🎨 Found glitch state in template:', template.glitchState);
               console.log('[LoadTemplate] 🎨 Restoring glitch effects AFTER duotone...');
               setTimeout(() => {
                   restoreGlitchState(template.glitchState);
               }, 600);
           } else {
               console.log('[LoadTemplate] 🎨 No glitch state found in template, using defaults');
           }

           // 🎨 Restore halftone effect state (after glitch)
           if (template.halftoneState) {
               console.log('[LoadTemplate] 🎨 Found halftone state in template:', template.halftoneState);
               console.log('[LoadTemplate] 🎨 Restoring halftone effects AFTER glitch...');
               setTimeout(() => {
                   console.log('[LoadTemplate] 🎨 ⏰ HALFTONE RESTORATION TIMER TRIGGERED - Checking image state...');

                   // Check if images are loaded
                   const imageObjects = canvasObjects.filter(obj => obj.type === 'image');
                   console.log(`[LoadTemplate] 🎨 📊 Found ${imageObjects.length} image objects for halftone restoration`);

                   imageObjects.forEach((obj, index) => {
                       console.log(`[LoadTemplate] 🎨 📊 Image ${index}: URL=${obj.imageUrl}, hasImage=${!!obj.image}, imageComplete=${obj.image?.complete}, naturalWidth=${obj.image?.naturalWidth}`);
                   });

                   if (typeof window.restoreHalftoneState === 'function') {
                       console.log('[LoadTemplate] 🎨 ⏰ CALLING restoreHalftoneState with data:', template.halftoneState);
                       window.restoreHalftoneState(template.halftoneState);

                       // Add a retry mechanism for halftone restoration in case images are still loading
                       setTimeout(() => {
                           console.log('[LoadTemplate] 🎨 ⏰ RETRY: Re-applying halftone state after additional delay...');
                           if (typeof window.restoreHalftoneState === 'function') {
                               window.restoreHalftoneState(template.halftoneState);
                           }
                       }, 2000); // Additional 2 second delay
                   } else {
                       console.log('[LoadTemplate] 🎨 ❌ restoreHalftoneState function not available');
                   }

                   // Restore guidelines state
                   if (template.guidelinesState && typeof window.restoreGuidelinesState === 'function') {
                       console.log('[LoadTemplate] 📏 ⏰ CALLING restoreGuidelinesState with data:', template.guidelinesState);
                       window.restoreGuidelinesState(template.guidelinesState);
                   } else {
                       console.log('[LoadTemplate] 📏 No guidelines state found in template or function not available');
                   }

                   // Restore layout rectangles state
                   if (template.layoutRectanglesState && typeof window.restoreLayoutRectanglesState === 'function') {
                       console.log('[LoadTemplate] 📐 ⏰ CALLING restoreLayoutRectanglesState with data:', template.layoutRectanglesState);
                       window.restoreLayoutRectanglesState(template.layoutRectanglesState);
                   } else {
                       console.log('[LoadTemplate] 📐 No layout rectangles state found in template or function not available');
                   }
               }, 700);
           } else {
               console.log('[LoadTemplate] 🎨 No halftone state found in template, using defaults');
           }

           // Re-initialize Elements accordion to restore shape click handlers
           if (typeof window.reinitializeElementsAccordion === 'function') {
               window.reinitializeElementsAccordion();
           }

           // Update UI elements to reflect restored editor state
           updateEditorUIFromState();
           updateUIFromSelectedObject();
           update();
           alert('Template loaded successfully!');

       } catch (error) {
           console.error('[LoadTemplate] Error loading template:', error);
           alert(`Error loading template: ${error.message}`);
           canvasObjects = [];
           selectedObjectIndex = -1;
           artboard = null;
           updateUIFromSelectedObject();
           update();
       }
   }

   // --- Load Inspiration Template (PromptTemplate) ---
   async function loadInspirationTemplate(template) {
       console.log('[LoadInspiration] Loading inspiration template:', template);
       try {
           // Clear current state
           canvasObjects = [];
           selectedObjectIndex = -1;
           artboard = null;

           // Populate Admin tab with inspiration template data
           if (template.adminData) {
               document.getElementById('adminImageUrl').value = template.adminData.imageUrl || '';
               document.getElementById('adminModel').value = template.adminData.model || '';
               document.getElementById('adminPrompt').value = template.adminData.prompt || '';
               document.getElementById('adminPalette').value = template.adminData.palette || '';
               // PRIORITIZE USER'S INPUT from adminData.object over template.originalObject
               const userSelectedObject = template.adminData?.object;
               const templateOriginalObject = template.originalObject;
               document.getElementById('adminOriginalObject').value = userSelectedObject || templateOriginalObject || '';
               console.log('[LoadInspiration] 🎯 Set Original Object field:', userSelectedObject || templateOriginalObject || 'empty');
               document.getElementById('adminInspirationId').value = template._id || '';
               console.log('[LoadInspiration] Restored admin data.');
           }

           // Populate Original Palette field - PRIORITIZE USER'S INPUT from adminData.palette over template.originalPalette
           const originalPaletteField = document.getElementById('adminOriginalPalette');
           if (originalPaletteField) {
               // Use USER'S selected palette from adminData.palette if available, otherwise fall back to template.originalPalette
               const userSelectedPalette = template.adminData?.palette;
               const templateOriginalPalette = template.originalPalette;

               if (userSelectedPalette) {
                   originalPaletteField.value = userSelectedPalette;
                   console.log('[LoadInspiration] 🎯 Restored USER SELECTED palette:', userSelectedPalette);
               } else if (templateOriginalPalette) {
                   originalPaletteField.value = templateOriginalPalette;
                   console.log('[LoadInspiration] Restored template original palette:', templateOriginalPalette);
               }
           }

           // Load canvas objects if available
           if (template.canvasObjects && Array.isArray(template.canvasObjects)) {
               console.log('[LoadInspiration] Loading canvas objects:', template.canvasObjects.length);

               // Sort objects by layerOrder/zIndex
               const sortedObjects = template.canvasObjects.slice().sort((a, b) => {
                   const aOrder = a.layerOrder !== undefined ? a.layerOrder : a.zIndex !== undefined ? a.zIndex : 0;
                   const bOrder = b.layerOrder !== undefined ? b.layerOrder : b.zIndex !== undefined ? b.zIndex : 0;
                   return aOrder - bOrder;
               });

               const tempCanvasObjects = [];
               const objectPromises = sortedObjects.map((objData, sortedIndex) => {
                   return new Promise((resolve, reject) => {
                       if (objData.type === 'text') {
                           const textObj = createTextObject(objData);
                           textObj.id = objData.id ?? nextId++;
                           tempCanvasObjects[sortedIndex] = textObj;
                           console.log(`[LoadInspiration] Created text object: "${textObj.text}"`);
                           resolve();
                       } else if (objData.type === 'image' && objData.imageUrl) {
                           const img = new Image();
                           img.crossOrigin = 'anonymous';
                           const finalImageUrl = getProxiedImageUrlIfNeeded(objData.imageUrl);
                           img.onload = () => {
                               const imageObj = createImageObject(img, objData);
                               imageObj.id = objData.id ?? nextId++;
                               imageObj.imageUrl = finalImageUrl;
                               tempCanvasObjects[sortedIndex] = imageObj;
                               console.log(`[LoadInspiration] Created image object: "${imageObj.imageUrl}"`);
                               resolve();
                           };
                           img.onerror = (err) => {
                               console.error(`[LoadInspiration] Failed to load image: ${finalImageUrl}`, err);
                               resolve();
                           };
                           img.src = finalImageUrl;
                       } else {
                           console.warn('[LoadInspiration] Skipping unknown object:', objData);
                           resolve();
                       }
                   });
               });

               await Promise.all(objectPromises);
               canvasObjects = tempCanvasObjects.filter(obj => obj !== undefined);
               console.log('[LoadInspiration] Loaded canvas objects:', canvasObjects.length);
           }

           // Load artboard if available
           if (template.artboard) {
               artboard = {
                   x: Number(template.artboard.x),
                   y: Number(template.artboard.y),
                   width: Number(template.artboard.width),
                   height: Number(template.artboard.height),
                   isSelected: true
               };
               console.log('[LoadInspiration] Restored artboard:', artboard);
               // 🎯 FIX: Set window.artboard so save project can find it
               window.artboard = artboard;
               console.log('[LoadInspiration] ✅ Set window.artboard for project saving');
           } else {
               console.log('[LoadInspiration] No artboard data, creating default');
               // Create a default artboard for inspiration templates
               artboard = {
                   x: 100,
                   y: 100,
                   width: 400,
                   height: 400,
                   isSelected: true
               };
               // 🎯 FIX: Set window.artboard so save project can find it
               window.artboard = artboard;
               console.log('[LoadInspiration] ✅ Set window.artboard for project saving');
           }

           // Restore editor state if available
           if (template.editorState) {
               if (template.editorState.canvasBackgroundColor) {
                   canvasBackgroundColor = template.editorState.canvasBackgroundColor;
                   // 🎯 FIX: Sync to global variable for save function
                   window.canvasBackgroundColor = canvasBackgroundColor;
                   console.log('[LoadInspiration] Restored canvas background color:', canvasBackgroundColor);
               }
               if (template.editorState.zoom) {
                   scale = template.editorState.zoom.scale || 1.0;
                   offsetX = template.editorState.zoom.offsetX || 0;
                   offsetY = template.editorState.zoom.offsetY || 0;
                   // 🎯 FIX: Sync to global variables for save function
                   window.scale = scale;
                   window.offsetX = offsetX;
                   window.offsetY = offsetY;
                   console.log('[LoadInspiration] Restored zoom/position:', { scale, offsetX, offsetY });
                   console.log('[LoadInspiration] ✅ Synced global variables for project saving');
               }
               if (template.editorState.nextId) {
                   nextId = template.editorState.nextId;
               }
           }

           // Store template name for updates
           currentTemplateName = template.name;

           // Update save buttons for existing template
           updateSaveButtonsForExistingTemplate(template._id, template.name);

           // Sync global references
           syncGlobalReferences();

           // Restore guidelines state
           if (template.guidelinesState && typeof window.restoreGuidelinesState === 'function') {
               console.log('[LoadInspiration] 📏 Restoring guidelines state:', template.guidelinesState);
               window.restoreGuidelinesState(template.guidelinesState);
           } else {
               console.log('[LoadInspiration] 📏 No guidelines state found in template or function not available');
           }

           // Restore layout rectangles state
           if (template.layoutRectanglesState && typeof window.restoreLayoutRectanglesState === 'function') {
               console.log('[LoadInspiration] 📐 Restoring layout rectangles state:', template.layoutRectanglesState);
               window.restoreLayoutRectanglesState(template.layoutRectanglesState);
           } else {
               console.log('[LoadInspiration] 📐 No layout rectangles state found in template or function not available');
           }

           // Update UI
           updateEditorUIFromState();
           updateUIFromSelectedObject();
           update();
           alert('Inspiration template loaded successfully!');

       } catch (error) {
           console.error('[LoadInspiration] Error loading inspiration template:', error);
           alert(`Error loading inspiration template: ${error.message}`);
           canvasObjects = [];
           selectedObjectIndex = -1;
           artboard = null;
           updateUIFromSelectedObject();
           update();
       }
   }

   // --- New function to load and merge generated design data ---
   async function loadGeneratedDesign(templateId, newImageUrl, userTexts, templateReplacements = null, modifiedTemplate = null) {
       console.log(`[LoadGenerated] Loading template ${templateId} and merging with new image/text`);
       console.log(`[LoadGenerated] Template replacements:`, templateReplacements);
       console.log(`🎨 [LoadGenerated] Modified template with smart colors:`, modifiedTemplate ? 'Available' : 'Not available');
       try {
           let template;

           // Use modified template if available, otherwise fetch original
           if (modifiedTemplate) {
               console.log('🎨 [LoadGenerated] Using modified template with smart text colors');
               template = modifiedTemplate;
           } else {
               console.log('[LoadGenerated] Fetching original template data');
               // 1. Fetch the original template data
               const response = await fetch(`/api/design-templates/${templateId}`, { credentials: 'include' });
               if (!response.ok) {
                   throw new Error(`Failed to fetch original template: ${response.statusText}`);
               }
               template = await response.json();
           }
           console.log('[LoadGenerated] Using template data:', template);

           canvasObjects = [];
           selectedObjectIndex = -1;

           // Restore editor state if available (same as loadTemplateData)
           if (template.editorState) {
               console.log('[LoadGenerated] Restoring editor state:', template.editorState);

               // Restore canvas background color
               if (template.editorState.canvasBackgroundColor) {
                   canvasBackgroundColor = template.editorState.canvasBackgroundColor;
                   // 🎯 FIX: Sync to global variable for save function
                   window.canvasBackgroundColor = canvasBackgroundColor;
                   console.log('[LoadGenerated] Restored canvas background color:', canvasBackgroundColor);
               }

               // Restore zoom and positioning
               if (template.editorState.zoom) {
                   scale = template.editorState.zoom.scale || 1.0;
                   offsetX = template.editorState.zoom.offsetX || 0;
                   offsetY = template.editorState.zoom.offsetY || 0;
                   // 🎯 FIX: Sync to global variables for save function
                   window.scale = scale;
                   window.offsetX = offsetX;
                   window.offsetY = offsetY;
                   console.log('[LoadGenerated] Restored zoom/position:', { scale, offsetX, offsetY });
                   console.log('[LoadGenerated] ✅ Synced global variables for project saving');
               }

               // Restore nextId to avoid ID conflicts
               if (template.editorState.nextId) {
                   nextId = template.editorState.nextId;
                   console.log('[LoadGenerated] Restored nextId:', nextId);
               }
           } else {
               console.log('[LoadGenerated] No editor state found, using defaults');
           }

           if (template.artboard) {
               artboard = {
                   x: Number(template.artboard.x),
                   y: Number(template.artboard.y),
                   width: Number(template.artboard.width),
                   height: Number(template.artboard.height),
                   isSelected: true
               };
               console.log('[LoadGenerated] Restored artboard:', artboard);
               // 🎯 FIX: Set window.artboard so save project can find it
               window.artboard = artboard;
               console.log('[LoadGenerated] ✅ Set window.artboard for project saving');
           } else {
               artboard = null;
               window.artboard = null;
               console.warn('[LoadGenerated] Original template has no artboard data!');
           }

           if (template.adminData) {
               document.getElementById('adminImageUrl').value = template.adminData.imageUrl || '';
               document.getElementById('adminModel').value = template.adminData.model || '';
               document.getElementById('adminPrompt').value = template.adminData.prompt || '';
               document.getElementById('adminPalette').value = template.adminData.palette || '';
               // PRIORITIZE USER'S INPUT from adminData.object over template.originalObject
               const userSelectedObject = template.adminData?.object;
               const templateOriginalObject = template.originalObject;
               document.getElementById('adminOriginalObject').value = userSelectedObject || templateOriginalObject || '';
               console.log('[LoadGenerated] 🎯 Set Original Object field:', userSelectedObject || templateOriginalObject || 'empty');
               // backgroundType element was removed, skip setting it
               // document.getElementById('backgroundType').value = template.adminData.backgroundType || 'light';
               document.getElementById('adminInspirationId').value = template._id || '';
               console.log('[LoadGenerated] Restored admin data.');
           }

           // Populate Original Palette field - PRIORITIZE USER'S INPUT from adminData.palette over template.originalPalette
           const originalPaletteField = document.getElementById('adminOriginalPalette');
           if (originalPaletteField) {
               // Use USER'S selected palette from adminData.palette if available, otherwise fall back to template.originalPalette
               const userSelectedPalette = template.adminData?.palette;
               const templateOriginalPalette = template.originalPalette;

               if (userSelectedPalette) {
                   originalPaletteField.value = userSelectedPalette;
                   console.log('[LoadGenerated] 🎯 Restored USER SELECTED palette:', userSelectedPalette);
               } else if (templateOriginalPalette) {
                   originalPaletteField.value = templateOriginalPalette;
                   console.log('[LoadGenerated] Restored template original palette:', templateOriginalPalette);
               }
           }

           // Store template name for updates
           currentTemplateName = template.name;

           // Update save buttons for existing template
           updateSaveButtonsForExistingTemplate(template._id, template.name);

           if (template.canvasObjects && Array.isArray(template.canvasObjects)) {
               console.log('[LoadGenerated] 🚀 LAYER ORDER FIX - Starting to restore and modify canvas objects...');
               console.log('[LoadGenerated] Raw template objects count:', template.canvasObjects.length);

               // Log raw objects as received from database
               template.canvasObjects.forEach((obj, index) => {
                   console.log(`[LoadGenerated] Raw object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", layerOrder=${obj.layerOrder}, zIndex=${obj.zIndex}, id=${obj.id}`);
               });

               // Sort objects by layerOrder/zIndex BEFORE processing them
               const sortedObjects = template.canvasObjects.slice().sort((a, b) => {
                   const aOrder = a.layerOrder !== undefined ? a.layerOrder : a.zIndex !== undefined ? a.zIndex : 0;
                   const bOrder = b.layerOrder !== undefined ? b.layerOrder : b.zIndex !== undefined ? b.zIndex : 0;
                   console.log(`[LoadGenerated] Sorting: ${a.type}(${aOrder}) vs ${b.type}(${bOrder}) = ${aOrder - bOrder}`);
                   return aOrder - bOrder;
               });

               console.log('[LoadGenerated] ===== AFTER SORTING =====');
               sortedObjects.forEach((obj, index) => {
                   console.log(`[LoadGenerated] Sorted object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", layerOrder=${obj.layerOrder}, zIndex=${obj.zIndex}`);
               });

               // Create a temporary array to collect objects in the correct order
               const tempCanvasObjects = [];
               let textIndex = 0;

               const objectPromises = sortedObjects.map((objData, sortedIndex) => {
                   return new Promise((resolve, reject) => {
                       if (objData.type === 'text') {
                           const textObj = createTextObject(objData);
                           textObj.id = objData.id ?? nextId++;

                           // Check if we have template ID-based replacements
                           if (templateReplacements && objData.templateId && templateReplacements[objData.templateId]) {
                               textObj.text = templateReplacements[objData.templateId];
                               console.log(`[LoadGenerated] Template ID replacement: ${objData.templateId} -> "${textObj.text}"`);
                           } else if (userTexts && textIndex < userTexts.length && userTexts[textIndex]) {
                               // Fallback to legacy numbered replacement
                               textObj.text = userTexts[textIndex];
                               console.log(`[LoadGenerated] Legacy replacement for object ${textObj.id} to: "${textObj.text}"`);
                           } else {
                               console.log(`[LoadGenerated] Keeping original text for object ${textObj.id}: "${textObj.text}" (No replacement available)`);
                           }
                           textIndex++;
                           // Insert at the correct position to maintain layer order
                           tempCanvasObjects[sortedIndex] = textObj;
                           console.log(`[LoadGenerated] Created text object at position ${sortedIndex}: "${textObj.text}"`);
                           resolve();
                       } else if (objData.type === 'image' && objData.imageUrl) {
                           // Check if this is a blob URL from an old template
                           if (objData.imageUrl.startsWith('blob:')) {
                               console.warn(`[LoadGenerated] Detected blob URL for object ${objData.id}: ${objData.imageUrl}`);
                               console.warn(`[LoadGenerated] Skipping object with invalid blob URL - this was likely an SVG that was recolored in an old template`);
                               resolve(); // Skip this object
                               return;
                           }

                           // Image objects: Check if this image should be replaced based on template ID
                           let imageUrlToUse = objData.imageUrl; // Default to original

                           if (objData.templateId === 'i01') {
                               // Main image (i01) gets replaced with the new generated image
                               imageUrlToUse = newImageUrl;
                               console.log(`[LoadGenerated] 🎯 Main image (i01) replacement initiated`);

                               // Enhanced masking information logging and validation
                               if (objData.isMasked) {
                                   console.log(`[LoadGenerated] 🎭 Main image (i01) is masked - validating mask relationship:`, {
                                       isMasked: objData.isMasked,
                                       maskShapeId: objData.maskShapeId,
                                       originalImageUrl: objData.imageUrl,
                                       newImageUrl: imageUrlToUse,
                                       objectIndex: sortedIndex
                                   });

                                   // Pre-validate that mask shape exists in template
                                   const maskShapeExists = sortedObjects.some(obj =>
                                       obj.type === 'image' && obj.id === objData.maskShapeId && obj.isMaskShape === true
                                   );

                                   if (maskShapeExists) {
                                       console.log(`[LoadGenerated] 🎭 ✅ Mask shape validation passed for ${objData.maskShapeId}`);
                                   } else {
                                       console.warn(`[LoadGenerated] 🎭 ⚠️ Mask shape validation failed - shape ${objData.maskShapeId} not found or not marked as mask`);
                                       console.warn(`[LoadGenerated] 🎭 Available mask shapes:`, sortedObjects
                                           .filter(obj => obj.type === 'image' && obj.isMaskShape === true)
                                           .map(obj => ({ id: obj.id, url: obj.imageUrl }))
                                       );
                                   }
                               } else {
                                   console.log(`[LoadGenerated] 🎯 Main image (i01) is not masked - standard replacement`);
                               }
                           } else if (objData.templateId && objData.templateId.match(/^i0[2-5]$/)) {
                               // Other images (i02-i05) keep their original content
                               console.log(`[LoadGenerated] Image ${objData.templateId} will keep original content`);
                           } else {
                               console.log(`[LoadGenerated] Image without template ID will keep original URL: ${objData.imageUrl}`);
                           }

                           const newImgEl = new Image();
                           newImgEl.crossOrigin = 'anonymous';
                           const finalImageUrl = getProxiedImageUrlIfNeeded(imageUrlToUse); // Proxy the selected URL
                           console.log(`[LoadGenerated] Attempting to load image via URL: ${finalImageUrl}`);

                           newImgEl.onload = () => {
                               console.log(`[LoadGenerated] Successfully loaded NEW image: ${finalImageUrl}`); // DEBUG
                               // Create the canvas object using the NEW image element (newImgEl)
                               // but pass the original objData to retain layout (x, y, scale, rotation)
                               const imageObj = createImageObject(newImgEl, objData);
                               imageObj.id = objData.id ?? nextId++; // Ensure ID exists

                           // Explicitly set the imageUrl property to the new URL for serialization
                           imageObj.imageUrl = finalImageUrl;
                           // Get generationId from sessionStorage
                           const storedGenerationId = sessionStorage.getItem('generationId');
                           imageObj.generationId = storedGenerationId || null;
                           imageObj.isFromGeneration = !!storedGenerationId; // Mark as generated if we have the ID from storage

                           // Enhanced masking properties preservation with validation
                           if (objData.isMasked && objData.maskShapeId) {
                               imageObj.isMasked = true;
                               imageObj.maskShapeId = objData.maskShapeId;
                               imageObj.isFromGeneration = true; // Mark as generated for debugging

                               // Note: maskShape reference will be restored later by restoreMaskRelationships()
                               console.log(`[LoadGenerated] 🎭 ✅ Preserved masking properties for replaced image:`, {
                                   id: imageObj.id,
                                   templateId: objData.templateId,
                                   isMasked: imageObj.isMasked,
                                   maskShapeId: imageObj.maskShapeId,
                                   isFromGeneration: imageObj.isFromGeneration,
                                   originalImageUrl: objData.imageUrl,
                                   newImageUrl: imageObj.imageUrl
                               });
                           } else if (objData.isMasked && !objData.maskShapeId) {
                               // Handle case where isMasked is true but maskShapeId is missing
                               console.warn(`[LoadGenerated] 🎭 ⚠️ Image marked as masked but missing maskShapeId:`, {
                                   id: imageObj.id,
                                   templateId: objData.templateId,
                                   isMasked: objData.isMasked,
                                   maskShapeId: objData.maskShapeId
                               });
                               // Don't preserve broken masking state
                               imageObj.isMasked = false;
                               imageObj.maskShapeId = null;
                           } else {
                               // Not masked - ensure clean state
                               imageObj.isMasked = false;
                               imageObj.maskShapeId = null;
                               console.log(`[LoadGenerated] 🎯 Image not masked - clean state preserved for ${imageObj.id}`);
                           }

                           // The imageObj.image property already holds the loaded newImgEl,
                           // and createImageObject uses its natural dimensions with the scale from objData.

                           console.log(`[LoadGenerated] Created image object ${imageObj.id} with NEW image URL: ${finalImageUrl}, GenID: ${imageObj.generationId}, IsGen: ${imageObj.isFromGeneration}`);
                           // Insert at the correct position to maintain layer order
                           tempCanvasObjects[sortedIndex] = imageObj;
                           console.log(`[LoadGenerated] Created image object at position ${sortedIndex}: "${imageObj.imageUrl}"`);
                           resolve();
                       };
                       newImgEl.onerror = (err) => {
                               console.error(`[LoadGenerated] ERROR loading NEW image for object ${objData.id}: ${finalImageUrl}. Falling back. Error:`, err); // DEBUG
                               // Fallback: Try loading the original image from the template (also proxied)
                               const originalImgEl = new Image();
                               originalImgEl.crossOrigin = 'anonymous';
                               const originalFinalUrl = getProxiedImageUrlIfNeeded(objData.imageUrl);
                               originalImgEl.onload = () => {
                                    const imageObj = createImageObject(originalImgEl, objData); // Create with original image
                                    imageObj.id = objData.id ?? nextId++;
                                    // Ensure imageUrl property reflects the actual source used
                                    imageObj.imageUrl = originalFinalUrl;

                                    // Enhanced masking properties preservation for fallback case
                                    if (objData.isMasked && objData.maskShapeId) {
                                        imageObj.isMasked = true;
                                        imageObj.maskShapeId = objData.maskShapeId;
                                        imageObj.isFromGeneration = false; // Mark as fallback for debugging

                                        console.log(`[LoadGenerated] 🎭 ✅ Preserved masking properties for fallback image:`, {
                                            id: imageObj.id,
                                            templateId: objData.templateId,
                                            isMasked: imageObj.isMasked,
                                            maskShapeId: imageObj.maskShapeId,
                                            isFromGeneration: imageObj.isFromGeneration,
                                            fallbackReason: 'Generated image load failed'
                                        });
                                    } else if (objData.isMasked && !objData.maskShapeId) {
                                        console.warn(`[LoadGenerated] 🎭 ⚠️ Fallback image marked as masked but missing maskShapeId`);
                                        imageObj.isMasked = false;
                                        imageObj.maskShapeId = null;
                                    } else {
                                        imageObj.isMasked = false;
                                        imageObj.maskShapeId = null;
                                    }

                                    console.warn(`[LoadGenerated] Falling back to original image for object ${imageObj.id}`);
                                    // Insert at the correct position to maintain layer order
                                    tempCanvasObjects[sortedIndex] = imageObj;
                                    console.log(`[LoadGenerated] Created fallback image object at position ${sortedIndex}: "${imageObj.imageUrl}"`);
                                    resolve();
                               };
                               originalImgEl.onerror = (origErr) => {
                                    console.error(`[LoadGenerated] Failed to load ORIGINAL image as fallback for object ${objData.id}: ${originalFinalUrl}`, origErr);
                                    resolve();
                               };
                               originalImgEl.src = originalFinalUrl; // Load original (proxied)
                           };
                           newImgEl.src = finalImageUrl; // Start loading the NEW (potentially proxied) image
                       } else {
                           console.warn('[LoadGenerated] Skipping unknown or invalid object data:', objData);
                           resolve();
                       }
                   });
               });

               await Promise.all(objectPromises);

               // Now assign the correctly ordered array to canvasObjects
               canvasObjects = tempCanvasObjects.filter(obj => obj !== undefined);

               console.log('[LoadGenerated] ===== FINAL CANVAS OBJECTS ARRAY =====');
               canvasObjects.forEach((obj, index) => {
                   console.log(`[LoadGenerated] Final array ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", id=${obj.id}`);
               });
               console.log('[LoadGenerated] 🚀 LAYER ORDER FIX - Restored and modified canvas objects with correct layer order:', canvasObjects.length);

               // Restore mask relationships after all objects are loaded
               restoreMaskRelationships();

               // Auto-apply masks after restoration
               autoApplyMasksAfterLoad();

               // Apply SVG colors for objects that have svgColor set (from smart color system)
               console.log('[LoadGenerated] 🎨 Checking for SVG objects with svgColor to recolor...');
               canvasObjects.forEach(async (obj, index) => {
                   if (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg') && obj.svgColor) {
                       console.log(`[LoadGenerated] 🎨 Found SVG object with svgColor: ${obj.svgColor}, triggering recoloring...`);
                       try {
                           await recolorSVG(obj, obj.svgColor);
                           console.log(`[LoadGenerated] 🎨 Successfully recolored SVG object ${obj.id}`);
                       } catch (error) {
                           console.error(`[LoadGenerated] 🎨 Error recoloring SVG object ${obj.id}:`, error);
                       }
                   }
               });

               // Initialize mesh warp handlers for text objects with mesh effect
               canvasObjects.forEach(obj => {
                   if (obj.type === 'text' && obj.effectMode === 'mesh' && obj.meshWarp) {
                       console.log('[LoadGenerated] Initializing mesh warp handler for text object:', obj.text);
                       try {
                           // Create a new mesh warp handler for this object
                           const meshHandler = new MeshWarpHandler(
                               document.getElementById('demo'),
                               obj
                           );

                           // Restore control points from saved data
                           if (obj.meshWarp.controlPoints && obj.meshWarp.controlPoints.length > 0) {
                               meshHandler.controlPoints = obj.meshWarp.controlPoints.map(p => ({ ...p }));
                               meshHandler.initialControlPoints = obj.meshWarp.initialControlPoints.map(p => ({ ...p }));
                               meshHandler.relativeControlPoints = obj.meshWarp.relativeControlPoints.map(p => ({ ...p }));
                               meshHandler.hasCustomDistortion = obj.meshWarp.hasCustomDistortion;
                               meshHandler.showGrid = obj.meshWarp.showGrid;
                               meshHandler.initialGridRect = obj.meshWarp.gridRect ? { ...obj.meshWarp.gridRect } : null;
                               console.log('[LoadGenerated] Restored mesh warp control points for:', obj.text, 'Points:', meshHandler.controlPoints.length);
                           }

                           // Store the handler reference (we'll only keep one active at a time)
                           obj._meshWarpHandler = meshHandler;
                       } catch (error) {
                           console.error('[LoadGenerated] Error initializing mesh warp handler for:', obj.text, error);
                       }
                   } else if (obj.type === 'text' && obj.effectMode === 'grid-distort') {
                       console.log('[GridDistortLoad] 🔧 Loading Grid Distort for generated design text object:', obj.text);
                       try {
                           // Check if we have saved Grid Distort data (new system)
                           if (obj.gridDistortData) {
                               console.log('[GridDistortLoad] 🔧 Found saved gridDistortData in generated design, restoring...');

                               // Restore the complete Grid Distort object from saved data
                               obj.gridDistort = {
                                   gridCols: obj.gridDistortData.gridCols || 3,
                                   gridRows: obj.gridDistortData.gridRows || 2,
                                   gridPadding: obj.gridDistortData.gridPadding || 120,
                                   intensity: obj.gridDistortData.intensity || 1,
                                   showGrid: obj.gridDistortData.showGrid || false,
                                   lastText: obj.gridDistortData.lastText || obj.text,
                                   lastFontSize: obj.gridDistortData.lastFontSize || obj.fontSize,
                                   verticalOnly: obj.gridDistortData.verticalOnly || false,

                                   // Critical: Restore the control points that define the distortion
                                   controlPoints: obj.gridDistortData.controlPoints ?
                                       obj.gridDistortData.controlPoints.map(row =>
                                           row.map(point => ({ x: point.x, y: point.y }))
                                       ) : [],

                                   // Critical: Restore the relative control points for preserving distortion
                                   relativeControlPoints: obj.gridDistortData.relativeControlPoints ?
                                       obj.gridDistortData.relativeControlPoints.map(row =>
                                           row.map(point => ({ x: point.x, y: point.y }))
                                       ) : [],

                                   // Restore grid bounds
                                   gridBounds: obj.gridDistortData.gridBounds ? {
                                       width: obj.gridDistortData.gridBounds.width,
                                       height: obj.gridDistortData.gridBounds.height,
                                       padding: obj.gridDistortData.gridBounds.padding
                                   } : null
                               };

                               console.log('[GridDistortLoad] 🔧 Restored Grid Distort data for generated design:', {
                                   controlPointsCount: obj.gridDistort.controlPoints.length,
                                   relativeControlPointsCount: obj.gridDistort.relativeControlPoints.length,
                                   hasGridBounds: !!obj.gridDistort.gridBounds,
                                   gridCols: obj.gridDistort.gridCols,
                                   gridRows: obj.gridDistort.gridRows
                               });

                               // Clean up the temporary gridDistortData property
                               delete obj.gridDistortData;

                           } else if (obj.gridDistort) {
                               // Legacy system - object already has gridDistort data
                               console.log('[GridDistortLoad] 🔧 Found legacy gridDistort data in generated design');
                               console.log('[GridDistortLoad] 🔧 Legacy Grid Distort data:', obj.gridDistort);

                               // Validate control points structure
                               const isValidStructure = Array.isArray(obj.gridDistort.controlPoints) &&
                                   obj.gridDistort.controlPoints.every(row =>
                                       Array.isArray(row) && row.every(point =>
                                           point && typeof point.x === 'number' && typeof point.y === 'number'
                                       )
                                   );

                               if (isValidStructure) {
                                   console.log('[LoadGenerated] ✅ Grid Distort control points structure is valid');
                               } else {
                                   console.warn('[LoadGenerated] ⚠️ Grid Distort control points structure is invalid, will reinitialize');
                                   obj.gridDistort.controlPoints = [];
                                   obj.gridDistort.relativeControlPoints = [];
                               }
                           }

                           // Restore relative control points if available
                           if (obj.gridDistort.relativeControlPoints && obj.gridDistort.relativeControlPoints.length > 0) {
                               console.log('[LoadGenerated] Restoring Grid Distort relative control points:', obj.gridDistort.relativeControlPoints.length, 'rows');
                               console.log('[LoadGenerated] Grid Distort relative control points structure:', obj.gridDistort.relativeControlPoints);
                           } else {
                               console.log('[LoadGenerated] No relative control points found for Grid Distort, will be generated when needed');
                           }

                           // Ensure grid bounds are restored if available
                           if (obj.gridDistort.gridBounds) {
                               console.log('[LoadGenerated] Restored Grid Distort bounds:', obj.gridDistort.gridBounds);
                           }

                           console.log('[LoadGenerated] ✅ Grid Distort data restored for text object:', obj.text);
                       } catch (error) {
                           console.error('[LoadGenerated] Error restoring Grid Distort data for:', obj.text, error);
                       }
                   }
               });
           }

           // Auto-activate mesh warp handlers for immediate visual feedback
           setTimeout(() => {
               let meshTextFound = false;
               canvasObjects.forEach((obj, index) => {
                   if (obj.type === 'text' && obj.effectMode === 'mesh' && obj._meshWarpHandler && !meshTextFound) {
                       console.log('[LoadGenerated] Auto-activating mesh warp for immediate display:', obj.text);

                       // Temporarily select the object to activate mesh warp
                       const previousSelection = selectedObjectIndex;
                       selectedObjectIndex = index;
                       obj.isSelected = true;

                       // Activate the mesh warp handler
                       activeMeshWarpHandler = obj._meshWarpHandler;
                       activeMeshWarpHandler.selectedTextObject = obj;

                       // Force a redraw to show the distortion
                       update();

                       // After a brief moment, restore the previous selection state
                       setTimeout(() => {
                           if (previousSelection === -1) {
                               // No previous selection, deselect everything
                               selectedObjectIndex = -1;
                               obj.isSelected = false;
                               console.log('[LoadGenerated] Auto-deselected mesh text for clean display');
                           } else {
                               // Restore previous selection
                               selectedObjectIndex = previousSelection;
                               obj.isSelected = false;
                               if (canvasObjects[previousSelection]) {
                                   canvasObjects[previousSelection].isSelected = true;
                               }
                               console.log('[LoadGenerated] Restored previous selection:', previousSelection);
                           }

                           // Update UI to reflect the final selection state
                           updateUIFromSelectedObject();
                           update();
                       }, 100); // Very brief selection - just enough to activate mesh warp

                       meshTextFound = true; // Only auto-activate the first mesh text found
                   }
               });

               if (!meshTextFound) {
                   console.log('[LoadGenerated] No mesh warp text objects found for auto-activation');
               }
           }, 200); // Small delay to ensure everything is fully loaded

           // Sync global references to ensure window.canvasObjects points to the current array
           syncGlobalReferences();
           console.log('[LoadGenerated] Synced global references. window.canvasObjects length:', window.canvasObjects.length);

           // Re-initialize Elements accordion to restore shape click handlers
           if (typeof window.reinitializeElementsAccordion === 'function') {
               window.reinitializeElementsAccordion();
           }

           // Restore guidelines state
           if (template.guidelinesState && typeof window.restoreGuidelinesState === 'function') {
               console.log('[LoadGenerated] 📏 Restoring guidelines state:', template.guidelinesState);
               window.restoreGuidelinesState(template.guidelinesState);
           } else {
               console.log('[LoadGenerated] 📏 No guidelines state found in template or function not available');
           }

           // Restore layout rectangles state
           if (template.layoutRectanglesState && typeof window.restoreLayoutRectanglesState === 'function') {
               console.log('[LoadGenerated] 📐 Restoring layout rectangles state:', template.layoutRectanglesState);
               window.restoreLayoutRectanglesState(template.layoutRectanglesState);
           } else {
               console.log('[LoadGenerated] 📐 No layout rectangles state found in template or function not available');
           }

           // Update UI elements to reflect restored editor state
           updateEditorUIFromState();
           updateUIFromSelectedObject();
           update();
           alert('Generated design loaded into editor!');

       } catch (error) {
           console.error('[LoadGenerated] Error loading generated design:', error);
           alert(`Error loading generated design: ${error.message}`);
           canvasObjects = [];
           selectedObjectIndex = -1;
           artboard = null;
           updateUIFromSelectedObject();
           update();
       }
   }

   // --- Function to load template directly from API ---
   async function loadTemplateDirectly(templateId) {
       console.log('[LoadTemplateDirect] 🎯 Loading template directly:', templateId);
       try {
           // Fetch the template data from API
           const response = await fetch(`/api/design-templates/${templateId}`, { credentials: 'include' });
           if (!response.ok) {
               throw new Error(`Failed to fetch template: ${response.statusText}`);
           }
           const template = await response.json();
           console.log('[LoadTemplateDirect] 🎯 Template data received:', template);

           // Store template data in sessionStorage for the existing loading logic
           sessionStorage.setItem('modifiedTemplate', JSON.stringify(template));
           console.log('[LoadTemplateDirect] 🎯 Template stored in sessionStorage');

           // Initialize the editor first
           initialize();

           // Load the template data using existing logic
           if (window.loadTemplateFromSessionStorage) {
               console.log('[LoadTemplateDirect] 🎯 Calling loadTemplateFromSessionStorage...');
               window.loadTemplateFromSessionStorage();
           } else {
               console.log('[LoadTemplateDirect] 🎯 loadTemplateFromSessionStorage not available, loading directly...');

               // Load template data directly
               canvasObjects = [];
               selectedObjectIndex = -1;

               // Restore editor state if available
               if (template.editorState) {
                   console.log('[LoadTemplateDirect] 🎯 Restoring editor state:', template.editorState);

                   // Restore canvas background color
                   if (template.editorState.canvasBackgroundColor) {
                       canvasBackgroundColor = template.editorState.canvasBackgroundColor;
                       window.canvasBackgroundColor = canvasBackgroundColor;
                   }

                   // Restore artboard settings
                   if (template.editorState.artboard) {
                       artboard = template.editorState.artboard;
                       window.artboard = artboard;
                   }
               }

               // Load canvas objects
               if (template.canvasObjects && Array.isArray(template.canvasObjects)) {
                   console.log('[LoadTemplateDirect] 🎯 Loading canvas objects:', template.canvasObjects.length);
                   canvasObjects = template.canvasObjects;
               }

               // Load admin data including font styles
               if (template.adminData) {
                   console.log('[LoadTemplateDirect] 🎯 Loading admin data:', template.adminData);

                   // Load font styles
                   if (template.adminData.fontStylesList && Array.isArray(template.adminData.fontStylesList)) {
                       console.log('[LoadTemplateDirect] 🎯 Loading font styles:', template.adminData.fontStylesList.length);
                       window.fontStylesList = template.adminData.fontStylesList;

                       // Protect the font styles data
                       if (window._fontStylesProtection) {
                           window._fontStylesProtection.protect(template.adminData.fontStylesList);
                           console.log('[LoadTemplateDirect] 🛡️ Font styles protected');
                       }

                       // Update the admin field
                       setTimeout(() => {
                           const adminFontStylesField = document.getElementById('adminFontStyles');
                           if (adminFontStylesField) {
                               adminFontStylesField.value = JSON.stringify(template.adminData.fontStylesList, null, 2);
                               console.log('[LoadTemplateDirect] 🎯 Admin font styles field populated');
                           }
                       }, 100);
                   }

                   // Load other admin fields
                   if (template.adminData.object) {
                       const adminObjectField = document.getElementById('adminOriginalObject');
                       if (adminObjectField) {
                           adminObjectField.value = template.adminData.object;
                       }
                   }

                   if (template.adminData.palette) {
                       const adminPaletteField = document.getElementById('adminOriginalPalette');
                       if (adminPaletteField) {
                           adminPaletteField.value = template.adminData.palette;
                       }
                   }
               }

               updateUIFromSelectedObject();
               update();
           }

           console.log('[LoadTemplateDirect] 🎯 Template loading completed');
       } catch (error) {
           console.error('[LoadTemplateDirect] 🎯 Failed to load template:', error);
           alert(`Failed to load template: ${error.message}\n\nInitializing default editor instead.`);
           initialize();
       }
   }


   // ===== INITIALIZE FONT/DECOR STYLES MANAGEMENT BEFORE DOM LOADING =====
   // This must happen BEFORE DOMContentLoaded so that project loading can restore styles properly

   // --- Font Styles Management ---
   console.log('[FontStyles] 🎯 Initializing font styles management...');

   // Global variables for font styles
   let currentFontStyleIndex = -1;
   window.fontStylesList = window.fontStylesList || [];

   // Protection system for font styles
   window._fontStylesProtection = {
       originalData: null,
       protect: function(data) {
           this.originalData = JSON.parse(JSON.stringify(data));
           console.log('[FontStyles] 🛡️ Data protected:', this.originalData.length, 'styles');
       },
       restore: function() {
           if (this.originalData) {
               window.fontStylesList = JSON.parse(JSON.stringify(this.originalData));
               console.log('[FontStyles] 🛡️ Data restored:', window.fontStylesList.length, 'styles');
               return true;
           }
           return false;
       }
   };

   // --- Decor Styles Management ---
   console.log('[DecorStyles] 🎯 Initializing decor styles management...');

   // Global variables for decor styles
   let currentDecorStyleIndex = -1;
   window.decorStylesList = window.decorStylesList || [];

   // Protection system for decor styles
   window._decorStylesProtection = {
       originalData: null,
       protect: function(data) {
           this.originalData = JSON.parse(JSON.stringify(data));
           console.log('[DecorStyles] 🛡️ Data protected:', this.originalData.length, 'styles');
       },
       restore: function() {
           if (this.originalData) {
               window.decorStylesList = JSON.parse(JSON.stringify(this.originalData));
               console.log('[DecorStyles] 🛡️ Data restored:', window.decorStylesList.length, 'styles');
               return true;
           }
           return false;
       }
   };

   // Add the actual font/decor styles functions
   function saveFontStyle() {
       console.log('[FontStyles] 🎨 ===== SAVE FONT STYLE CALLED =====');
       console.log('[FontStyles] 🎨 Current window.canvasObjects:', window.canvasObjects);
       console.log('[FontStyles] 🎨 Current window.canvasObjects length:', window.canvasObjects?.length);

       // Capture current font configuration of all text objects
       const fontStyleConfig = [];

       if (!window.canvasObjects || !Array.isArray(window.canvasObjects)) {
           console.log('[FontStyles] ❌ window.canvasObjects is not available or not an array');
           alert('Error: Canvas objects not available. Please try again.');
           return;
       }

       console.log('[FontStyles] 🎨 Processing', window.canvasObjects.length, 'canvas objects...');
       window.canvasObjects.forEach((obj, index) => {
           console.log(`[FontStyles] 🔍 Object ${index}:`, {
               type: obj.type,
               text: obj.text,
               id: obj.id,
               fontFamily: obj.fontFamily,
               fontSize: obj.fontSize
           });

           if (obj.type === 'text') {
               const fontConfig = {
                   id: obj.id,
                   fontFamily: obj.fontFamily || 'Arial',
                   fontSize: obj.fontSize || 24,
                   letterSpacing: obj.letterSpacing || 0
               };
               fontStyleConfig.push(fontConfig);
               console.log(`[FontStyles] ✅ Captured font config for text "${obj.text}":`, fontConfig);
           } else {
               console.log(`[FontStyles] ⏭️ Skipping non-text object type: ${obj.type}`);
           }
       });

       if (fontStyleConfig.length === 0) {
           alert('No text objects found to save font styles');
           return;
       }

       console.log('[FontStyles] 🎨 Final fontStyleConfig array:', fontStyleConfig);
       console.log('[FontStyles] 🎨 fontStyleConfig length:', fontStyleConfig.length);
       console.log('[FontStyles] 🎨 Current window.fontStylesList before push:', window.fontStylesList);

       // Add to fontStylesList array
       window.fontStylesList.push(fontStyleConfig);
       console.log(`[FontStyles] ✅ Saved font style ${window.fontStylesList.length}:`, fontStyleConfig);
       console.log('[FontStyles] 🎨 Updated window.fontStylesList:', window.fontStylesList);

       // Update UI status and admin display
       updateFontStylesStatus();
       updateAdminFontStylesDisplay();

       alert(`Font style ${window.fontStylesList.length} saved! (${fontStyleConfig.length} text objects)`);
   }

   function cycleFontStyles() {
       console.log('[FontStyles] 🔄 ===== CYCLE FONT STYLES CALLED =====');
       console.log('[FontStyles] 🔄 Current window.fontStylesList:', window.fontStylesList);
       console.log('[FontStyles] 🔄 window.fontStylesList.length:', window.fontStylesList.length);
       console.log('[FontStyles] 🔄 currentFontStyleIndex before increment:', currentFontStyleIndex);

       if (window.fontStylesList.length === 0) {
           console.log('[FontStyles] ❌ No saved font styles available');
           console.log('[FontStyles] ❌ Checking if protection system can restore...');

           // Try to restore from protection system
           if (window._fontStylesProtection) {
               const restored = window._fontStylesProtection.restore();
               if (restored && window.fontStylesList.length > 0) {
                   console.log('[FontStyles] 🛡️ Font styles restored from protection system, retrying...');
                   // Retry the function now that data is restored
                   cycleFontStyles();
                   return;
               }
           }

           alert('No saved font styles to cycle through. Save a font style first.');
           return;
       }

       // Increment index and loop back to 0 if at end
       currentFontStyleIndex = (currentFontStyleIndex + 1) % window.fontStylesList.length;
       console.log('[FontStyles] 🔄 currentFontStyleIndex after increment:', currentFontStyleIndex);

       const currentStyle = window.fontStylesList[currentFontStyleIndex];
       console.log(`[FontStyles] 🎯 Selected font style ${currentFontStyleIndex + 1}/${window.fontStylesList.length}:`, currentStyle);
       console.log('[FontStyles] 🎯 currentStyle type:', typeof currentStyle);
       console.log('[FontStyles] 🎯 currentStyle isArray:', Array.isArray(currentStyle));
       console.log('[FontStyles] 🎯 currentStyle length:', currentStyle?.length);

       // Check if a text object is currently selected
       const isTextSelected = selectedObjectIndex !== -1 &&
                             window.canvasObjects[selectedObjectIndex] &&
                             window.canvasObjects[selectedObjectIndex].type === 'text';

       console.log('[FontStyles] 🎯 Selection check:', {
           selectedObjectIndex: selectedObjectIndex,
           isTextSelected: isTextSelected,
           selectedObject: isTextSelected ? window.canvasObjects[selectedObjectIndex] : null
       });

       let targetTextObjects = [];
       let operationMode = '';

       if (isTextSelected) {
           // Apply font style only to the selected text object
           targetTextObjects = [window.canvasObjects[selectedObjectIndex]];
           operationMode = 'selected text';
           console.log('[FontStyles] 🎯 Mode: Selected text only -', targetTextObjects[0].text);
       } else {
           // Apply font style to all text objects (original behavior)
           targetTextObjects = window.canvasObjects.filter(obj => obj.type === 'text');
           operationMode = 'all text objects';
           console.log(`[FontStyles] 🎯 Mode: All text objects - found ${targetTextObjects.length} objects`);
       }

       if (targetTextObjects.length === 0) {
           const message = isTextSelected ?
               'Selected object is not a text element.' :
               'No text objects found on canvas to apply font styles to.';
           alert(message);
           return;
       }

       // Apply the font style to target text objects
       let appliedCount = 0;

       // If we have saved configurations for specific IDs, try to match them first
       const appliedIds = new Set();
       currentStyle.forEach(fontConfig => {
           const textObj = targetTextObjects.find(obj => obj.id === fontConfig.id);
           if (textObj) {
               textObj.fontFamily = fontConfig.fontFamily;
               textObj.fontSize = fontConfig.fontSize;
               textObj.letterSpacing = fontConfig.letterSpacing;
               appliedIds.add(textObj.id);
               appliedCount++;
               console.log(`[FontStyles] ✅ Applied specific font config to text "${textObj.text}":`, fontConfig);
           }
       });

       // For any remaining text objects (not matched by ID), apply the first font config
       if (currentStyle.length > 0) {
           const defaultFontConfig = currentStyle[0]; // Use first config as default
           targetTextObjects.forEach(textObj => {
               if (!appliedIds.has(textObj.id)) {
                   textObj.fontFamily = defaultFontConfig.fontFamily;
                   textObj.fontSize = defaultFontConfig.fontSize;
                   textObj.letterSpacing = defaultFontConfig.letterSpacing;
                   appliedCount++;
                   console.log(`[FontStyles] ✅ Applied default font config to text "${textObj.text}":`, defaultFontConfig);
               }
           });
       }

       // Update canvas
       if (window.update && typeof window.update === 'function') {
           window.update();
           console.log('[FontStyles] 🎨 Canvas updated after font style change');
       }

       console.log(`[FontStyles] 🎨 Applied font style ${currentFontStyleIndex + 1} to ${appliedCount} ${operationMode}`);
   }

   function saveDecorStyle() {
       console.log('[DecorStyles] 🎨 Saving current decor style configuration...');

       // Capture current shadow and decoration configuration of all text and shape objects
       const decorStyleConfig = [];

       window.canvasObjects.forEach(obj => {
           if (obj.type === 'text' || obj.type === 'shape') {
               const decorConfig = {
                   id: obj.id,
                   type: obj.type,
                   // Shadow properties
                   shadowMode: obj.shadowMode || 'noShadow',
                   shadowColor: obj.shadowColor || '#000000',
                   shadowOffsetX: obj.shadowOffsetX || 0,
                   shadowOffsetY: obj.shadowOffsetY || 0,
                   shadowBlur: obj.shadowBlur || 0,
                   shadowOpacity: obj.shadowOpacity || 1,
                   // Decoration properties
                   decorationMode: obj.decorationMode || 'noDecoration',
                   decorationColor: obj.decorationColor || '#000000',
                   decorationOpacity: obj.decorationOpacity || 1,
                   decorationSpacing: obj.decorationSpacing || 10,
                   decorationThickness: obj.decorationThickness || 2,
                   decorationAngle: obj.decorationAngle || 0
               };
               decorStyleConfig.push(decorConfig);
               console.log(`[DecorStyles] 📝 Captured decor config for ${obj.type} "${obj.text || obj.id}":`, decorConfig);
           }
       });

       if (decorStyleConfig.length === 0) {
           alert('No text or shape objects found to save decor styles');
           return;
       }

       // Add to decorStylesList array
       window.decorStylesList.push(decorStyleConfig);
       console.log(`[DecorStyles] ✅ Saved decor style ${window.decorStylesList.length}:`, decorStyleConfig);

       // Update UI status and admin display
       updateDecorStylesStatus();
       updateAdminDecorStylesDisplay();

       alert(`Decor style ${window.decorStylesList.length} saved! (${decorStyleConfig.length} objects)`);
   }

   function cycleDecorStyles() {
       console.log('[DecorStyles] 🔄 ===== CYCLE DECOR STYLES CALLED =====');
       console.log('[DecorStyles] 🔄 Current window.decorStylesList:', window.decorStylesList);
       console.log('[DecorStyles] 🔄 window.decorStylesList.length:', window.decorStylesList.length);

       if (window.decorStylesList.length === 0) {
           console.log('[DecorStyles] ❌ No saved decor styles available');
           console.log('[DecorStyles] ❌ Checking if protection system can restore...');

           // Try to restore from protection system
           if (window._decorStylesProtection) {
               const restored = window._decorStylesProtection.restore();
               if (restored && window.decorStylesList.length > 0) {
                   console.log('[DecorStyles] 🛡️ Decor styles restored from protection system, retrying...');
                   // Retry the function now that data is restored
                   cycleDecorStyles();
                   return;
               }
           }

           alert('No saved decor styles to cycle through. Save a decor style first.');
           return;
       }

       // Increment index and loop back to 0 if at end
       currentDecorStyleIndex = (currentDecorStyleIndex + 1) % window.decorStylesList.length;
       const currentStyle = window.decorStylesList[currentDecorStyleIndex];

       console.log(`[DecorStyles] 🎨 Applying decor style ${currentDecorStyleIndex + 1} of ${window.decorStylesList.length}:`, currentStyle);

       // Check if a text or shape object is currently selected
       const isTargetObjectSelected = selectedObjectIndex !== -1 &&
                                     window.canvasObjects[selectedObjectIndex] &&
                                     (window.canvasObjects[selectedObjectIndex].type === 'text' ||
                                      window.canvasObjects[selectedObjectIndex].type === 'shape');

       console.log('[DecorStyles] 🎯 Selection check:', {
           selectedObjectIndex: selectedObjectIndex,
           isTargetObjectSelected: isTargetObjectSelected,
           selectedObject: isTargetObjectSelected ? window.canvasObjects[selectedObjectIndex] : null
       });

       let targetObjects = [];
       let operationMode = '';

       if (isTargetObjectSelected) {
           // Apply decoration style only to the selected text/shape object
           targetObjects = [window.canvasObjects[selectedObjectIndex]];
           operationMode = `selected ${window.canvasObjects[selectedObjectIndex].type}`;
           console.log('[DecorStyles] 🎯 Mode: Selected object only -', targetObjects[0].text || targetObjects[0].id);
       } else {
           // Apply decoration style to all text and shape objects (original behavior)
           targetObjects = window.canvasObjects.filter(obj => obj.type === 'text' || obj.type === 'shape');
           operationMode = 'all text/shape objects';
           console.log(`[DecorStyles] 🎯 Mode: All text/shape objects - found ${targetObjects.length} objects`);
       }

       if (targetObjects.length === 0) {
           const message = isTargetObjectSelected ?
               'Selected object is not a text or shape element.' :
               'No text or shape objects found on canvas to apply decor styles to.';
           alert(message);
           return;
       }

       // Apply the decor style to target objects
       let appliedCount = 0;

       // If we have saved configurations for specific IDs, try to match them first
       const appliedIds = new Set();
       currentStyle.forEach(decorConfig => {
           const targetObj = targetObjects.find(obj => obj.id === decorConfig.id);
           if (targetObj) {
               // Apply shadow properties
               targetObj.shadowMode = decorConfig.shadowMode;
               targetObj.shadowColor = decorConfig.shadowColor;
               targetObj.shadowOffsetX = decorConfig.shadowOffsetX;
               targetObj.shadowOffsetY = decorConfig.shadowOffsetY;
               targetObj.shadowBlur = decorConfig.shadowBlur;
               targetObj.shadowOpacity = decorConfig.shadowOpacity;

               // Apply decoration properties
               targetObj.decorationMode = decorConfig.decorationMode;
               targetObj.decorationColor = decorConfig.decorationColor;
               targetObj.decorationOpacity = decorConfig.decorationOpacity;
               targetObj.decorationSpacing = decorConfig.decorationSpacing;
               targetObj.decorationThickness = decorConfig.decorationThickness;
               targetObj.decorationAngle = decorConfig.decorationAngle;

               appliedIds.add(targetObj.id);
               appliedCount++;
               console.log(`[DecorStyles] ✅ Applied specific decor config to ${targetObj.type} "${targetObj.text || targetObj.id}":`, decorConfig);
           }
       });

       // For any remaining objects (not matched by ID), apply the first decor config
       if (currentStyle.length > 0) {
           const defaultDecorConfig = currentStyle[0]; // Use first config as default
           targetObjects.forEach(targetObj => {
               if (!appliedIds.has(targetObj.id)) {
                   // Apply shadow properties
                   targetObj.shadowMode = defaultDecorConfig.shadowMode;
                   targetObj.shadowColor = defaultDecorConfig.shadowColor;
                   targetObj.shadowOffsetX = defaultDecorConfig.shadowOffsetX;
                   targetObj.shadowOffsetY = defaultDecorConfig.shadowOffsetY;
                   targetObj.shadowBlur = defaultDecorConfig.shadowBlur;
                   targetObj.shadowOpacity = defaultDecorConfig.shadowOpacity;

                   // Apply decoration properties
                   targetObj.decorationMode = defaultDecorConfig.decorationMode;
                   targetObj.decorationColor = defaultDecorConfig.decorationColor;
                   targetObj.decorationOpacity = defaultDecorConfig.decorationOpacity;
                   targetObj.decorationSpacing = defaultDecorConfig.decorationSpacing;
                   targetObj.decorationThickness = defaultDecorConfig.decorationThickness;
                   targetObj.decorationAngle = defaultDecorConfig.decorationAngle;

                   appliedCount++;
                   console.log(`[DecorStyles] ✅ Applied default decor config to ${targetObj.type} "${targetObj.text || targetObj.id}":`, defaultDecorConfig);
               }
           });
       }

       // Update canvas
       if (window.update && typeof window.update === 'function') {
           window.update();
           console.log('[DecorStyles] 🎨 Canvas updated after decor style change');
       }

       console.log(`[DecorStyles] 🎨 Applied decor style ${currentDecorStyleIndex + 1} to ${appliedCount} ${operationMode}`);
   }

   // Add admin display update functions
   function updateFontStylesStatus() {
       const statusElement = document.getElementById('fontStylesStatus');
       if (statusElement) {
           if (window.fontStylesList.length === 0) {
               statusElement.textContent = 'No saved font styles';
               statusElement.style.backgroundColor = '#f8f9fa';
           } else {
               const currentDisplay = currentFontStyleIndex >= 0 ? ` (Current: ${currentFontStyleIndex + 1})` : '';
               statusElement.textContent = `${window.fontStylesList.length} saved font style(s)${currentDisplay}`;
               statusElement.style.backgroundColor = '#e7f3ff';
           }
       }
   }

   function updateAdminFontStylesDisplay() {
       console.log('🎯 📝 updateAdminFontStylesDisplay called');
       const adminFontStylesField = document.getElementById('adminFontStyles');
       console.log('🎯 📝 adminFontStylesField found:', !!adminFontStylesField);
       console.log('🎯 📝 window.fontStylesList:', window.fontStylesList);
       console.log('🎯 📝 window.fontStylesList.length:', window.fontStylesList?.length);

       if (adminFontStylesField) {
           if (!window.fontStylesList || window.fontStylesList.length === 0) {
               adminFontStylesField.value = '';
               adminFontStylesField.placeholder = 'No saved font styles';
               console.log('🎯 📝 Set empty value and placeholder');
           } else {
               const jsonValue = JSON.stringify(window.fontStylesList, null, 2);
               adminFontStylesField.value = jsonValue;
               console.log('🎯 📝 Set adminFontStyles value:', jsonValue);

               // Verify the value was actually set
               setTimeout(() => {
                   const currentValue = adminFontStylesField.value;
                   console.log('🎯 🔍 VERIFICATION - adminFontStyles field value after 100ms:', currentValue);
                   if (currentValue !== jsonValue) {
                       console.log('🎯 ❌ VALUE WAS CHANGED! Something else is clearing the field');
                       console.log('🎯 ❌ Expected:', jsonValue);
                       console.log('🎯 ❌ Actual:', currentValue);
                       // Try setting it again
                       adminFontStylesField.value = jsonValue;
                       console.log('🎯 🔄 Re-set the value');
                   } else {
                       console.log('🎯 ✅ Value is correct in the field');
                   }
               }, 100);
           }
       } else {
           console.log('🎯 ❌ adminFontStyles field not found!');
       }
   }

   function updateDecorStylesStatus() {
       const statusElement = document.getElementById('decorStylesStatus');
       if (statusElement) {
           if (window.decorStylesList.length === 0) {
               statusElement.textContent = 'No saved decor styles';
               statusElement.style.backgroundColor = '#f8f9fa';
           } else {
               const currentDisplay = currentDecorStyleIndex >= 0 ? ` (Current: ${currentDecorStyleIndex + 1})` : '';
               statusElement.textContent = `${window.decorStylesList.length} saved decor style(s)${currentDisplay}`;
               statusElement.style.backgroundColor = '#e7f3ff';
           }
       }
   }

   function updateAdminDecorStylesDisplay() {
       console.log('🎯 📝 updateAdminDecorStylesDisplay called');
       const adminDecorStylesField = document.getElementById('adminDecorStyles');
       console.log('🎯 📝 adminDecorStylesField found:', !!adminDecorStylesField);
       console.log('🎯 📝 window.decorStylesList:', window.decorStylesList);
       console.log('🎯 📝 window.decorStylesList.length:', window.decorStylesList?.length);

       if (adminDecorStylesField) {
           if (!window.decorStylesList || window.decorStylesList.length === 0) {
               adminDecorStylesField.value = '';
               adminDecorStylesField.placeholder = 'No saved decor styles';
               console.log('🎯 📝 Set empty value and placeholder');
           } else {
               const jsonValue = JSON.stringify(window.decorStylesList, null, 2);
               adminDecorStylesField.value = jsonValue;
               console.log('🎯 📝 Set adminDecorStyles value:', jsonValue);

               // Verify the value was actually set
               setTimeout(() => {
                   const currentValue = adminDecorStylesField.value;
                   console.log('🎯 🔍 VERIFICATION - adminDecorStyles field value after 100ms:', currentValue);
                   if (currentValue !== jsonValue) {
                       console.log('🎯 ❌ VALUE WAS CHANGED! Something else is clearing the field');
                       console.log('🎯 ❌ Expected:', jsonValue);
                       console.log('🎯 ❌ Actual:', currentValue);
                       // Try setting it again
                       adminDecorStylesField.value = jsonValue;
                       console.log('🎯 🔄 Re-set the value');
                   } else {
                       console.log('🎯 ✅ Value is correct in the field');
                   }
               }, 100);
           }
       } else {
           console.log('🎯 ❌ adminDecorStyles field not found!');
       }
   }

   // Add Change Colors functionality
   function changeColors() {
       console.log('[ChangeColors] 🌈 ===== CHANGE COLORS CALLED =====');

       // Get the color palette selector component
       const paletteSelector = document.getElementById('aiColorPaletteSelector');
       if (!paletteSelector) {
           console.error('[ChangeColors] ❌ Color palette selector not found');
           alert('Color palette selector not available. Please try again.');
           return;
       }

       // Get all available palettes from the selector
       const dropdown = paletteSelector.shadowRoot?.getElementById('palette-dropdown');
       if (!dropdown) {
           console.error('[ChangeColors] ❌ Palette dropdown not found in shadow DOM');
           alert('Palette dropdown not available. Please try again.');
           return;
       }

       const paletteOptions = dropdown.querySelectorAll('.palette-option[data-id]');
       if (!paletteOptions || paletteOptions.length === 0) {
           console.error('[ChangeColors] ❌ No palette options found');
           alert('No color palettes available. Please try again.');
           return;
       }

       // Filter out 'original' palette and get valid palette IDs
       const availablePaletteIds = Array.from(paletteOptions)
           .map(option => option.dataset.id)
           .filter(id => id && id !== 'original');

       if (availablePaletteIds.length === 0) {
           console.error('[ChangeColors] ❌ No valid palettes found (excluding original)');
           alert('No color palettes available for random selection.');
           return;
       }

       console.log('[ChangeColors] 🎯 Available palettes:', availablePaletteIds);

       // Randomly select a palette
       const randomIndex = Math.floor(Math.random() * availablePaletteIds.length);
       const selectedPaletteId = availablePaletteIds[randomIndex];

       console.log('[ChangeColors] 🎲 Randomly selected palette:', selectedPaletteId);

       // Update the palette selector to show the selected palette
       paletteSelector.selectedPaletteId = selectedPaletteId;

       // Apply colors using the existing color application system
       applyPaletteColorsToTexts(selectedPaletteId);

       // Update status display
       updateColorChangeStatus(selectedPaletteId);
   }

   function applyPaletteColorsToTexts(paletteId) {
       console.log('[ChangeColors] 🎨 Applying palette colors to texts and shapes:', paletteId);

       try {
           // Check if we have canvas objects and the required functions
           if (!window.canvasObjects || !Array.isArray(window.canvasObjects)) {
               console.log('[ChangeColors] ❌ No canvas objects found');
               alert('No canvas objects found to apply colors to.');
               return;
           }

           if (!window.getTextColorForPalette) {
               console.error('[ChangeColors] ❌ getTextColorForPalette function not available');
               alert('Color application system not available. Please try again.');
               return;
           }

           let updatedCount = 0;

           // Loop through all canvas objects and update colors for texts and shapes
           window.canvasObjects.forEach((obj, index) => {
               // Process text objects
               if (obj.type === 'text') {
                   // Get the color intensity assignment for this text
                   let colorIntensity = obj.newColorIntensity;

                   // If text doesn't have color intensity assigned, assign a default one
                   if (!colorIntensity || colorIntensity === 'N/A') {
                       // Auto-assign color intensity based on text position/index for variety (5 options)
                       const intensityOptions = ['lightest', 'light', 'medium', 'dark', 'darkest'];
                       colorIntensity = intensityOptions[index % intensityOptions.length];
                       obj.newColorIntensity = colorIntensity;
                       console.log(`[ChangeColors] 🎨 Auto-assigned color intensity "${colorIntensity}" to text "${obj.text}"`);
                   }

                   // Skip texts with 'no-change' setting
                   if (colorIntensity === 'no-change') {
                       console.log(`[ChangeColors] 🎨 Text "${obj.text}" has 'no-change' color intensity, preserving original color`);
                       return;
                   }

                   // Get the appropriate color for this palette and intensity
                   const newColor = window.getTextColorForPalette(paletteId, colorIntensity);

                   if (newColor) {
                       const oldColor = obj.color;
                       obj.color = newColor;

                       // Force the object to recognize the color change
                       obj.needsUpdate = true;
                       obj.colorChanged = true;

                       updatedCount++;
                       console.log(`[ChangeColors] 🎨 Updated text "${obj.text}" color using intensity (${colorIntensity}): ${oldColor} → ${newColor}`);
                   } else {
                       console.warn(`[ChangeColors] 🎨 Could not get color for palette ${paletteId} with intensity ${colorIntensity}`);
                   }
               }
               // Process shape objects (SVG shapes)
               else if (obj.type === 'shape' || (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg'))) {
                   // Get the color intensity assignment for this shape
                   const colorIntensity = obj.newColorIntensity;

                   // Skip shapes without intensity assignment or with 'no-change'
                   if (!colorIntensity || colorIntensity === 'N/A' || colorIntensity === 'no-change') {
                       console.log(`[ChangeColors] 🎨 Shape "${obj.id || obj.imageUrl}" has no color intensity assignment (${colorIntensity}), preserving original color`);
                       return;
                   }

                   // Get the appropriate color for this palette and intensity
                   const newColor = window.getTextColorForPalette(paletteId, colorIntensity);

                   if (newColor) {
                       let oldColor = null;
                       let colorProperty = null;

                       // Determine which color property to update based on object type
                       if (obj.type === 'shape') {
                           if (obj.svgColor !== undefined) {
                               oldColor = obj.svgColor;
                               obj.svgColor = newColor;
                               colorProperty = 'svgColor';
                           } else if (obj.color !== undefined) {
                               oldColor = obj.color;
                               obj.color = newColor;
                               colorProperty = 'color';
                           }
                       } else if (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg')) {
                           oldColor = obj.svgColor;
                           obj.svgColor = newColor;
                           colorProperty = 'svgColor';
                       }

                       if (colorProperty) {
                           // Force the object to recognize the color change
                           obj.needsUpdate = true;
                           obj.colorChanged = true;

                           updatedCount++;
                           console.log(`[ChangeColors] 🎨 Updated ${obj.type} "${obj.id || obj.imageUrl}" ${colorProperty} using intensity (${colorIntensity}): ${oldColor} → ${newColor}`);
                       }
                   } else {
                       console.warn(`[ChangeColors] 🎨 Could not get color for palette ${paletteId} with intensity ${colorIntensity}`);
                   }
               }
           });

           console.log(`[ChangeColors] 🎨 Applied palette colors to ${updatedCount} texts and shapes with assigned intensities`);

           // Clear any current selection to ensure colors apply to all objects
           if (window.selectedObjectIndex !== undefined) {
               console.log('[ChangeColors] 🎯 Clearing selection to ensure all objects update');
               window.selectedObjectIndex = -1;
           }

           // Force update all text and shape objects individually
           window.canvasObjects.forEach((obj, index) => {
               if (obj.type === 'text' || obj.type === 'shape' || (obj.type === 'image' && obj.imageUrl && obj.imageUrl.toLowerCase().endsWith('.svg'))) {
                   // Force object to recognize color changes
                   if (obj.type === 'text' && obj.color) {
                       console.log(`[ChangeColors] 🔄 Force updating text "${obj.text}" with color ${obj.color}`);
                   } else if ((obj.type === 'shape' || obj.type === 'image') && obj.svgColor) {
                       console.log(`[ChangeColors] 🔄 Force updating shape/SVG "${obj.id || obj.imageUrl}" with color ${obj.svgColor}`);
                   }
               }
           });

           // Multiple canvas update attempts to ensure rendering
           console.log('[ChangeColors] 🎨 Attempting multiple canvas update methods...');

           // Method 1: Standard update function
           if (window.update && typeof window.update === 'function') {
               window.update();
               console.log('[ChangeColors] 🎨 Method 1: window.update() called');
           }

           // Method 2: Redraw canvas function
           if (window.redrawCanvas && typeof window.redrawCanvas === 'function') {
               window.redrawCanvas();
               console.log('[ChangeColors] 🎨 Method 2: window.redrawCanvas() called');
           }

           // Method 3: Force render function
           if (window.render && typeof window.render === 'function') {
               window.render();
               console.log('[ChangeColors] 🎨 Method 3: window.render() called');
           }

           // Method 4: Draw function
           if (window.draw && typeof window.draw === 'function') {
               window.draw();
               console.log('[ChangeColors] 🎨 Method 4: window.draw() called');
           }

           // Method 5: Force a small delay and update again
           setTimeout(() => {
               console.log('[ChangeColors] 🎨 Method 5: Delayed update after 100ms');
               if (window.update && typeof window.update === 'function') {
                   window.update();
               }
           }, 100);

           // Show success message
           if (updatedCount > 0) {
               alert(`Successfully applied "${paletteId}" palette colors to ${updatedCount} objects!`);
           } else {
               alert('No objects were updated. Make sure your text and shape objects have color intensity assignments.');
           }

       } catch (error) {
           console.error('[ChangeColors] ❌ Error applying palette colors:', error);
           alert('Error applying colors. Please check the console for details.');
       }
   }

   function updateColorChangeStatus(paletteId) {
       const statusElement = document.getElementById('colorChangeStatus');
       if (statusElement) {
           if (paletteId) {
               statusElement.textContent = `Last applied: "${paletteId}" palette`;
               statusElement.style.backgroundColor = '#fef3c7';
           } else {
               statusElement.textContent = 'Ready to apply random palette colors';
               statusElement.style.backgroundColor = '#f8f9fa';
           }
       }
   }

   // Make functions globally available
   window.saveFontStyle = saveFontStyle;
   window.cycleFontStyles = cycleFontStyles;
   window.saveDecorStyle = saveDecorStyle;
   window.cycleDecorStyles = cycleDecorStyles;
   window.changeColors = changeColors;
   window.updateFontStylesStatus = updateFontStylesStatus;
   window.updateAdminFontStylesDisplay = updateAdminFontStylesDisplay;
   window.updateDecorStylesStatus = updateDecorStylesStatus;
   window.updateAdminDecorStylesDisplay = updateAdminDecorStylesDisplay;

   // Set up button event listeners
   document.addEventListener('DOMContentLoaded', function() {
       // Font styles buttons
       const saveFontStyleBtn = document.getElementById('saveFontStyleBtn');
       const changeFontsBtn = document.getElementById('changeFontsBtn');

       if (saveFontStyleBtn) {
           saveFontStyleBtn.addEventListener('click', function() {
               console.log('[FontStyles] Save Font Style button clicked');
               saveFontStyle();
           });
       }

       if (changeFontsBtn) {
           changeFontsBtn.addEventListener('click', function() {
               console.log('[FontStyles] Change Fonts button clicked');
               cycleFontStyles();
           });
       }

       // Decor styles buttons
       const saveDecorStyleBtn = document.getElementById('saveDecorStyleBtn');
       const changeDecorBtn = document.getElementById('changeDecorBtn');

       if (saveDecorStyleBtn) {
           saveDecorStyleBtn.addEventListener('click', function() {
               console.log('[DecorStyles] Save Decor Style button clicked');
               saveDecorStyle();
           });
       }

       if (changeDecorBtn) {
           changeDecorBtn.addEventListener('click', function() {
               console.log('[DecorStyles] Change Decor button clicked');
               cycleDecorStyles();
           });
       }

       // Change Colors button
       const changeColorsBtn = document.getElementById('changeColorsBtn');

       if (changeColorsBtn) {
           // Ensure the button is enabled (remove any disabled attribute)
           changeColorsBtn.disabled = false;
           changeColorsBtn.removeAttribute('disabled');
           console.log('[ChangeColors] Change Colors button enabled and ready');

           changeColorsBtn.addEventListener('click', function() {
               console.log('[ChangeColors] Change Colors button clicked');
               changeColors();
           });
       } else {
           console.error('[ChangeColors] Change Colors button not found in DOM');
       }
   });

   console.log('[FontStyles] 🎯 Font/Decor styles management initialized BEFORE DOMContentLoaded');

   // --- DOMContentLoaded Listener ---
   document.addEventListener('DOMContentLoaded', async () => { // Make async
       console.log('[EditorLoad] 🎯 DOMContentLoaded fired!');
       console.log('[EditorLoad] 🎯 Current URL:', window.location.href);
       console.log('[EditorLoad] 🎯 Search params:', window.location.search);

       // 🔧 CRITICAL FIX: Initialize CSS filter state with defaults to ensure pipeline always works
       if (!window.cssFilterState) {
           window.cssFilterState = {
               blur: 0,
               brightness: 1,
               contrast: 1,
               saturate: 1,
               hueRotate: 0,
               grayscale: 0,
               sepia: 0,
               invert: 0
           };
           console.log('[EditorLoad] 🔧 Initialized default CSS filter state:', window.cssFilterState);
       } else {
           console.log('[EditorLoad] 🔧 CSS filter state already exists:', window.cssFilterState);
       }

       const params = new URLSearchParams(window.location.search);
       const templateId = params.get('templateId');
       const source = params.get('source');
       const projectId = params.get('projectId');

       console.log('[EditorLoad] 🎯 Parsed params:', {
           templateId,
           source,
           projectId
       });

       if (source === 'generation' && templateId) {
           console.log('[EditorLoad] Source is generation, attempting to load merged data.');
           const newImageUrl = sessionStorage.getItem('generatedImageUrl');
           const userTextsRaw = sessionStorage.getItem('userTexts');
           const originalTemplateId = sessionStorage.getItem('originalTemplateId'); // Should match templateId from URL
           const templateReplacementsRaw = sessionStorage.getItem('templateTextReplacements');
           const modifiedTemplateRaw = sessionStorage.getItem('modifiedTemplate'); // Get modified template with smart colors

           console.log('[EditorLoad] SessionStorage check:', {
               newImageUrl: !!newImageUrl,
               userTextsRaw: !!userTextsRaw,
               originalTemplateId,
               templateId,
               idsMatch: originalTemplateId === templateId
           });

           if (newImageUrl && userTextsRaw && originalTemplateId === templateId) {
               try {
                   const userTexts = JSON.parse(userTextsRaw);
                   let templateReplacements = null;

                   // Parse template replacements if available
                   if (templateReplacementsRaw) {
                       try {
                           templateReplacements = JSON.parse(templateReplacementsRaw);
                           console.log('[EditorLoad] Template replacements loaded:', templateReplacements);
                       } catch (e) {
                           console.warn('[EditorLoad] Failed to parse template replacements:', e);
                       }
                   }

                   // Parse modified template with smart colors if available
                   let modifiedTemplate = null;
                   if (modifiedTemplateRaw) {
                       try {
                           modifiedTemplate = JSON.parse(modifiedTemplateRaw);
                           console.log('🎨 [EditorLoad] Modified template with smart colors loaded:', modifiedTemplate);
                       } catch (e) {
                           console.warn('🎨 [EditorLoad] Failed to parse modified template:', e);
                       }
                   }

                   await loadGeneratedDesign(templateId, newImageUrl, userTexts, templateReplacements, modifiedTemplate);
                   // Clear session storage after successful load (including generationId)
                   sessionStorage.removeItem('generatedImageUrl');
                   sessionStorage.removeItem('userTexts');
                   sessionStorage.removeItem('originalTemplateId');
                   sessionStorage.removeItem('templateTextReplacements');
                   sessionStorage.removeItem('templateAnalysis');
                   sessionStorage.removeItem('generationId'); // <-- Clear generationId
                   sessionStorage.removeItem('modifiedTemplate'); // <-- Clear modified template
               } catch (e) {
                   console.error("Error parsing sessionStorage data or loading generated design:", e);
                   alert("Error loading generated design data. Initializing default editor.");
                   initialize(); // Fallback to default init
               }
           } else {
               console.warn("[EditorLoad] Missing data in sessionStorage for generated design. Loading original template instead.");
               // Fallback to loading the original template if session data is missing
               await loadTemplateData(templateId);
           }

       } else if (templateId) {
           console.log('[EditorLoad] Loading template directly:', templateId);
           try {
               await loadTemplateFromEitherCollection(templateId);
           } catch (error) {
               console.error('[EditorLoad] Failed to load template:', templateId, error);
               alert(`Failed to load template: ${error.message}\n\nInitializing default editor instead.`);
               initialize(); // Fallback to default state
           }
       } else if (projectId) {
           console.log('[EditorLoad] 🎯 PROJECT ID DETECTED:', projectId);
           console.log('[EditorLoad] 🎯 Calling loadProjectFromId function...');
           await loadProjectFromId(projectId);
           console.log('[EditorLoad] 🎯 loadProjectFromId completed');

           // Mark system as fully loaded to stop protection loops
           if (window.markAsFullyLoaded) {
               window.markAsFullyLoaded();
           }
       } else if (templateId) {
           console.log('[EditorLoad] 🎯 TEMPLATE ID DETECTED (direct load):', templateId);
           await loadTemplateDirectly(templateId);
       } else {
           console.log('[EditorLoad] No templateId, projectId, or generation source found, initializing default state.');
           // Handle other loading methods (e.g., from admin inspiration) or initialize default
           loadImageFromUrlParam();
           loadAdminDataFromUrlParam();
           // If neither template nor generation source, initialize might be called here or within the other load functions if they don't find params
           if (!params.has('templateId') && !params.has('imageUrl') && !params.has('image') && !params.has('projectId')) {
                initialize(); // Ensure default state if no params load anything
           }
       }

       // ALWAYS try to load admin data from URL parameters, regardless of other loading methods
       // This ensures that data from images-generated.html "Send" button is always loaded
       console.log('[EditorLoad] Always checking for admin data in URL parameters...');
       loadAdminDataFromUrlParam();

       // Initialize layout UI state
       updateLayoutSelectionUI();

       // Note: Save Template button listener is added in DOMContentLoaded section to avoid duplicates

       // Initialize Pickr for background color on the dedicated div
       // Make sure DOM is fully loaded before initializing Pickr
       function initializePickr() {
           const colorPickerElement = document.getElementById('canvasBgColorPicker');
           if (!colorPickerElement) {
               console.error('Canvas background color picker element not found');
               return;
           }

           try {
               // Wait for Pickr library to be fully loaded
               if (typeof Pickr === 'undefined') {
                   console.log('Pickr not loaded yet, retrying in 200ms');
                   setTimeout(initializePickr, 200);
                   return;
               }

               const pickr = Pickr.create({
                   el: colorPickerElement,
                   theme: 'nano',
                   default: canvasBackgroundColor,
                   swatches: [
                       '#ffffff', '#f4f7fc', '#d1d5db', '#9ca3af', '#6b7280', '#4b5563', '#374151', '#1f2937', '#111827', '#000000',
                       '#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'
                   ],
                   components: {
                       preview: true,
                       opacity: true,
                       hue: true,
                       interaction: {
                           hex: true,
                           rgba: true,
                           input: true,
                           clear: false,
                           save: true
                       }
                   }
               });

               pickr.on('save', (color, instance) => {
                   const newColor = color.toHEXA().toString();
                   console.log('Pickr save event:', newColor);
                   canvasBackgroundColor = newColor; // Update the local variable
                   window.canvasBackgroundColor = newColor; // Update the global variable
                   update(); // Redraw canvas
                   pickr.hide(); // Hide picker after saving
               });

               // Store pickr instance globally for access by updateEditorUIFromState
               window.pickrInstance = pickr;
               console.log('Pickr initialized successfully');
           } catch (error) {
               console.error('Error initializing Pickr:', error);
           }
       }

       // Start the initialization process with a delay to ensure DOM is ready
       setTimeout(initializePickr, 300);

       // Add event listeners for move buttons
       const moveForwardBtn = document.getElementById('moveForwardBtn');
       const moveBackwardBtn = document.getElementById('moveBackwardBtn');
       if (moveForwardBtn) {
           moveForwardBtn.addEventListener('click', moveObjectForward);
       }
       if (moveBackwardBtn) {
           moveBackwardBtn.addEventListener('click', moveObjectBackward);
       }

       // Lock and Hide button event listeners
       const lockObjectBtn = document.getElementById('lockObjectBtn');
       const hideObjectBtn = document.getElementById('hideObjectBtn');
       const unlockAllBtn = document.getElementById('unlockAllBtn');
       const unhideAllBtn = document.getElementById('unhideAllBtn');
       const hideLayoutBtn = document.getElementById('hideLayoutBtn');
       const testObjectBtn = document.getElementById('testObjectBtn');

       console.log('[EventListeners] lockObjectBtn found:', !!lockObjectBtn);
       console.log('[EventListeners] hideObjectBtn found:', !!hideObjectBtn);
       console.log('[EventListeners] unlockAllBtn found:', !!unlockAllBtn);
       console.log('[EventListeners] unhideAllBtn found:', !!unhideAllBtn);
       console.log('[EventListeners] hideLayoutBtn found:', !!hideLayoutBtn);
       console.log('[EventListeners] testObjectBtn found:', !!testObjectBtn);

       if (lockObjectBtn) {
           lockObjectBtn.addEventListener('click', lockSelectedObject);
           console.log('[EventListeners] ✅ Lock button event listener added');
       }
       if (hideObjectBtn) {
           hideObjectBtn.addEventListener('click', hideSelectedObject);
           console.log('[EventListeners] ✅ Hide button event listener added');
       }
       if (unlockAllBtn) {
           unlockAllBtn.addEventListener('click', unlockAllObjects);
           console.log('[EventListeners] ✅ Unlock All button event listener added');
       }
       if (unhideAllBtn) {
           unhideAllBtn.addEventListener('click', unhideAllObjects);
           console.log('[EventListeners] ✅ Unhide All button event listener added');
       }
       if (hideLayoutBtn) {
           hideLayoutBtn.addEventListener('click', hideSelectedLayout);
           console.log('[EventListeners] ✅ Hide Layout button event listener added');
       }
       if (testObjectBtn) {
           testObjectBtn.addEventListener('click', addTestObject);
           console.log('[EventListeners] ✅ Test button event listener added');
       }

   });

   // Make loadTemplateData available globally for URL parameter loading
   window.loadTemplateData = loadTemplateData;

   // --- Mask Relationship Validation Function ---
   function validateMaskRelationships() {
       console.log('[MaskValidation] 🎭 Starting mask relationship validation');

       const maskedImages = canvasObjects.filter(obj => obj.type === 'image' && obj.isMasked);
       const maskShapes = canvasObjects.filter(obj => obj.type === 'image' && obj.isMaskShape);
       const allImages = canvasObjects.filter(obj => obj.type === 'image');

       console.log('[MaskValidation] 🎭 Overview:', {
           totalImages: allImages.length,
           maskedImages: maskedImages.length,
           maskShapes: maskShapes.length
       });

       const validationResults = {
           totalMaskedImages: maskedImages.length,
           validRelationships: 0,
           brokenRelationships: 0,
           orphanedMasks: 0,
           issues: []
       };

       // Validate each masked image
       maskedImages.forEach((maskedImage, index) => {
           const validation = {
               imageId: maskedImage.id,
               templateId: maskedImage.templateId,
               maskShapeId: maskedImage.maskShapeId,
               hasRuntimeReference: !!maskedImage.maskShape,
               isValid: false,
               issues: []
           };

           if (!maskedImage.maskShapeId) {
               validation.issues.push('Missing maskShapeId');
           } else {
               const maskShape = canvasObjects.find(obj => obj.id === maskedImage.maskShapeId);
               if (!maskShape) {
                   validation.issues.push(`Mask shape ${maskedImage.maskShapeId} not found`);
               } else if (maskShape.type !== 'image') {
                   validation.issues.push(`Mask shape ${maskedImage.maskShapeId} is not an image`);
               } else if (!maskShape.isMaskShape) {
                   validation.issues.push(`Shape ${maskedImage.maskShapeId} not marked as mask shape`);
               } else if (maskShape.isVisible !== false) {
                   validation.issues.push(`Mask shape ${maskedImage.maskShapeId} is visible (should be hidden)`);
               } else {
                   validation.isValid = true;
                   validationResults.validRelationships++;
               }
           }

           if (!validation.isValid) {
               validationResults.brokenRelationships++;
           }

           validationResults.issues.push(validation);

           console.log(`[MaskValidation] 🎭 Masked image ${index + 1}:`, validation);
       });

       // Check for orphaned mask shapes
       maskShapes.forEach(maskShape => {
           const isUsed = maskedImages.some(img => img.maskShapeId === maskShape.id);
           if (!isUsed) {
               validationResults.orphanedMasks++;
               console.warn(`[MaskValidation] 🎭 ⚠️ Orphaned mask shape found: ${maskShape.id}`);
           }
       });

       console.log('[MaskValidation] 🎭 Validation complete:', validationResults);

       return validationResults;
   }

   // Make validation function globally available
   window.validateMaskRelationships = validateMaskRelationships;

   // --- Test Mask Serialization Function ---
   function testMaskSerialization() {
       console.log('[MaskTest] 🎭 Testing mask serialization...');

       const maskedImages = canvasObjects.filter(obj => obj.type === 'image' && obj.isMasked);
       const maskShapes = canvasObjects.filter(obj => obj.type === 'image' && obj.isMaskShape);

       console.log('[MaskTest] 🎭 Current state:', {
           totalImages: canvasObjects.filter(obj => obj.type === 'image').length,
           maskedImages: maskedImages.length,
           maskShapes: maskShapes.length
       });

       if (maskedImages.length === 0) {
           console.log('[MaskTest] 🎭 No masked images found to test');
           return;
       }

       // Test serialization of each masked image
       maskedImages.forEach((img, index) => {
           console.log(`[MaskTest] 🎭 Testing masked image ${index + 1}:`);
           console.log(`[MaskTest] 🎭 Original:`, {
               id: img.id,
               isMasked: img.isMasked,
               maskShapeId: img.maskShapeId,
               imageUrl: img.imageUrl?.substring(0, 50) + '...'
           });

           // Test design-editor.js cleaning function
           const cleanedByDesignEditor = cleanObjectForSerialization(img);
           console.log(`[MaskTest] 🎭 Cleaned by design-editor.js:`, {
               id: cleanedByDesignEditor.id,
               isMasked: cleanedByDesignEditor.isMasked,
               maskShapeId: cleanedByDesignEditor.maskShapeId,
               imageUrl: cleanedByDesignEditor.imageUrl?.substring(0, 50) + '...'
           });

           // Verify properties are preserved
           const designEditorPreserved = cleanedByDesignEditor.isMasked === img.isMasked &&
                                       cleanedByDesignEditor.maskShapeId === img.maskShapeId;
           console.log(`[MaskTest] 🎭 Design editor preservation: ${designEditorPreserved ? '✅ PASS' : '❌ FAIL'}`);
       });

       // Test mask shapes
       maskShapes.forEach((shape, index) => {
           console.log(`[MaskTest] 🎭 Testing mask shape ${index + 1}:`);
           console.log(`[MaskTest] 🎭 Original:`, {
               id: shape.id,
               isMaskShape: shape.isMaskShape,
               isVisible: shape.isVisible,
               imageUrl: shape.imageUrl?.substring(0, 50) + '...'
           });

           const cleanedShape = cleanObjectForSerialization(shape);
           console.log(`[MaskTest] 🎭 Cleaned:`, {
               id: cleanedShape.id,
               isMaskShape: cleanedShape.isMaskShape,
               isVisible: cleanedShape.isVisible,
               imageUrl: cleanedShape.imageUrl?.substring(0, 50) + '...'
           });

           const shapePreserved = cleanedShape.isMaskShape === shape.isMaskShape &&
                                cleanedShape.isVisible === shape.isVisible;
           console.log(`[MaskTest] 🎭 Mask shape preservation: ${shapePreserved ? '✅ PASS' : '❌ FAIL'}`);
       });
   }

   // Make test function globally available
   window.testMaskSerialization = testMaskSerialization;

   // --- Auto-Apply Masks After Load Function ---
   function autoApplyMasksAfterLoad() {
       console.log('[AutoMask] 🎭 Starting auto-mask application after template load');

       const maskedImages = canvasObjects.filter(obj => obj.type === 'image' && obj.isMasked && obj.maskShape);

       if (maskedImages.length === 0) {
           console.log('[AutoMask] 🎭 No masked images found to auto-apply');
           return;
       }

       console.log(`[AutoMask] 🎭 Found ${maskedImages.length} masked image(s) to auto-apply`);

       maskedImages.forEach((maskedImage, index) => {
           console.log(`[AutoMask] 🎭 Auto-applying mask ${index + 1}:`, {
               imageId: maskedImage.id,
               templateId: maskedImage.templateId,
               maskShapeId: maskedImage.maskShapeId,
               maskShapeUrl: maskedImage.maskShape?.imageUrl
           });

           try {
               // Force the mask to be applied visually
               // This ensures the mask is properly rendered even if it wasn't during loading
               if (maskedImage.maskShape) {
                   // Ensure mask shape is hidden
                   maskedImage.maskShape.isVisible = false;
                   maskedImage.maskShape.isMaskShape = true;

                   console.log(`[AutoMask] 🎭 ✅ Auto-applied mask for image ${maskedImage.id}`);
               } else {
                   console.warn(`[AutoMask] 🎭 ⚠️ Mask shape reference missing for image ${maskedImage.id}`);
               }
           } catch (error) {
               console.error(`[AutoMask] 🎭 ❌ Error auto-applying mask for image ${maskedImage.id}:`, error);
           }
       });

       // Force a redraw to ensure masks are visually applied
       update();

       console.log('[AutoMask] 🎭 Auto-mask application complete');
   }

   // Make auto-apply function globally available
   window.autoApplyMasksAfterLoad = autoApplyMasksAfterLoad;

   // --- Save Button Management ---
   function updateSaveButtonsForExistingTemplate(templateId, templateName) {
       console.log('[SaveButtons] Updating buttons for existing template:', templateId, templateName);

       const saveTemplateBtn = document.getElementById('saveTemplateBtn');
       const updateTemplateBtn = document.getElementById('updateTemplateBtn');
       const saveAsTemplateBtn = document.getElementById('saveAsTemplateBtn');

       if (templateId) {
           // Hide "Save as Inspiration" button
           if (saveTemplateBtn) saveTemplateBtn.style.display = 'none';

           // Show "Save" and "Save As New" buttons
           if (updateTemplateBtn) {
               updateTemplateBtn.style.display = 'inline-block';
               updateTemplateBtn.textContent = `💾 Save "${templateName || 'Template'}"`;
           }
           if (saveAsTemplateBtn) {
               saveAsTemplateBtn.style.display = 'inline-block';
           }

           console.log('[SaveButtons] Switched to existing template mode');
       } else {
           // Show "Save as Inspiration" button
           if (saveTemplateBtn) saveTemplateBtn.style.display = 'inline-block';

           // Hide "Save" and "Save As New" buttons
           if (updateTemplateBtn) updateTemplateBtn.style.display = 'none';
           if (saveAsTemplateBtn) saveAsTemplateBtn.style.display = 'none';

           console.log('[SaveButtons] Switched to new template mode');
       }
   }

   // --- CSS Filter State Capture ---
   function captureCSSFilterState() {
       console.log('[SaveTemplate] 🎨 Capturing CSS filter state...');

       const filterControls = [
           { id: 'iImageBlur', key: 'blur', defaultValue: 0 },
           { id: 'iImageBrightness', key: 'brightness', defaultValue: 1 },
           { id: 'iImageContrast', key: 'contrast', defaultValue: 1 },
           { id: 'iImageSaturation', key: 'saturate', defaultValue: 1 },
           { id: 'iImageHue', key: 'hueRotate', defaultValue: 0 },
           { id: 'iImageGrayscale', key: 'grayscale', defaultValue: 0 },
           { id: 'iImageSepia', key: 'sepia', defaultValue: 0 },
           { id: 'iImageInvert', key: 'invert', defaultValue: 0 }
       ];

       const filterState = {};

       filterControls.forEach(control => {
           const element = document.getElementById(control.id);
           if (element) {
               const value = parseFloat(element.value) || control.defaultValue;
               filterState[control.key] = value;
               console.log(`[SaveTemplate] 🎨 Captured ${control.key}: ${value}`);
           } else {
               // Use default value if control not found
               filterState[control.key] = control.defaultValue;
               console.log(`[SaveTemplate] 🎨 Control ${control.id} not found, using default: ${control.defaultValue}`);
           }
       });

       // Capture duotone state
       const duotoneEnabled = document.getElementById('duotoneEnabled');
       const duotoneColor1 = document.getElementById('duotoneColor1');
       const duotoneColor2 = document.getElementById('duotoneColor2');

       if (duotoneEnabled) {
           filterState.duotoneEnabled = duotoneEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured duotoneEnabled: ${duotoneEnabled.checked}`);
       }

       if (duotoneColor1) {
           filterState.duotoneColor1 = duotoneColor1.value || '#3B82F6';
           console.log(`[SaveTemplate] 🎨 Captured duotoneColor1: ${filterState.duotoneColor1}`);
       }

       if (duotoneColor2) {
           filterState.duotoneColor2 = duotoneColor2.value || '#EAB308';
           console.log(`[SaveTemplate] 🎨 Captured duotoneColor2: ${filterState.duotoneColor2}`);
       }

       // Capture glitch effects state
       const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
       const colorShiftEnabled = document.getElementById('colorShiftEnabled');
       const waveDeformEnabled = document.getElementById('waveDeformEnabled');
       const displacementEnabled = document.getElementById('displacementEnabled');
       const pixelSortEnabled = document.getElementById('pixelSortEnabled');

       if (paletteReductionEnabled) {
           filterState.paletteReductionEnabled = paletteReductionEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured paletteReductionEnabled: ${paletteReductionEnabled.checked}`);

           if (paletteReductionEnabled.checked) {
               const paletteSelect = document.getElementById('paletteName');
               const distanceSelect = document.getElementById('distanceMode');
               const ditheringCheckbox = document.getElementById('useDithering');
               if (paletteSelect) {
                   filterState.paletteName = paletteSelect.value;
                   console.log(`[SaveTemplate] 🎨 Captured paletteName: ${filterState.paletteName}`);
               }
               if (distanceSelect) {
                   filterState.distanceMode = distanceSelect.value;
                   console.log(`[SaveTemplate] 🎨 Captured distanceMode: ${filterState.distanceMode}`);
               }
               if (ditheringCheckbox) {
                   filterState.useDithering = ditheringCheckbox.checked;
                   console.log(`[SaveTemplate] 🎨 Captured useDithering: ${filterState.useDithering}`);
               }
           }
       }

       if (colorShiftEnabled) {
           filterState.colorShiftEnabled = colorShiftEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured colorShiftEnabled: ${colorShiftEnabled.checked}`);

           if (colorShiftEnabled.checked) {
               const intensitySlider = document.getElementById('colorShiftIntensity');
               const amountSlider = document.getElementById('colorShiftAmount');
               if (intensitySlider) {
                   filterState.colorShiftIntensity = parseFloat(intensitySlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured colorShiftIntensity: ${filterState.colorShiftIntensity}`);
               }
               if (amountSlider) {
                   filterState.colorShiftAmount = parseFloat(amountSlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured colorShiftAmount: ${filterState.colorShiftAmount}`);
               }
           }
       }

       if (waveDeformEnabled) {
           filterState.waveDeformEnabled = waveDeformEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured waveDeformEnabled: ${waveDeformEnabled.checked}`);

           if (waveDeformEnabled.checked) {
               const directionSelect = document.getElementById('waveDirection');
               const amplitudeSlider = document.getElementById('waveAmplitude');
               const frequencySlider = document.getElementById('waveFrequency');
               if (directionSelect) {
                   filterState.waveDirection = directionSelect.value;
                   console.log(`[SaveTemplate] 🎨 Captured waveDirection: ${filterState.waveDirection}`);
               }
               if (amplitudeSlider) {
                   filterState.waveAmplitude = parseFloat(amplitudeSlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured waveAmplitude: ${filterState.waveAmplitude}`);
               }
               if (frequencySlider) {
                   filterState.waveFrequency = parseFloat(frequencySlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured waveFrequency: ${filterState.waveFrequency}`);
               }
           }
       }

       if (displacementEnabled) {
           filterState.displacementEnabled = displacementEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured displacementEnabled: ${displacementEnabled.checked}`);

           if (displacementEnabled.checked) {
               const modeSelect = document.getElementById('displacementMode');
               const intensitySlider = document.getElementById('displacementIntensity');
               const sizeSlider = document.getElementById('displacementSize');
               if (modeSelect) {
                   filterState.displacementMode = modeSelect.value;
                   console.log(`[SaveTemplate] 🎨 Captured displacementMode: ${filterState.displacementMode}`);
               }
               if (intensitySlider) {
                   filterState.displacementIntensity = parseFloat(intensitySlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured displacementIntensity: ${filterState.displacementIntensity}`);
               }
               if (sizeSlider) {
                   filterState.displacementSize = parseFloat(sizeSlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured displacementSize: ${filterState.displacementSize}`);
               }
           }
       }

       if (pixelSortEnabled) {
           filterState.pixelSortEnabled = pixelSortEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured pixelSortEnabled: ${pixelSortEnabled.checked}`);

           if (pixelSortEnabled.checked) {
               const directionSelect = document.getElementById('pixelSortDirection');
               const blockSizeSlider = document.getElementById('pixelSortBlockSize');
               const frequencySlider = document.getElementById('pixelSortFrequency');
               if (directionSelect) {
                   filterState.pixelSortDirection = directionSelect.value;
                   console.log(`[SaveTemplate] 🎨 Captured pixelSortDirection: ${filterState.pixelSortDirection}`);
               }
               if (blockSizeSlider) {
                   filterState.pixelSortBlockSize = parseFloat(blockSizeSlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured pixelSortBlockSize: ${filterState.pixelSortBlockSize}`);
               }
               if (frequencySlider) {
                   filterState.pixelSortFrequency = parseFloat(frequencySlider.value);
                   console.log(`[SaveTemplate] 🎨 Captured pixelSortFrequency: ${filterState.pixelSortFrequency}`);
               }
           }
       }

       console.log('[SaveTemplate] 🎨 Complete filter state captured:', filterState);
       return filterState;
   }

   // --- Duotone Effect State Capture ---
   function captureDuotoneState() {
       console.log('[SaveTemplate] 🎨 Capturing duotone effect state...');

       const duotoneState = {};

       // Capture duotone enabled state
       const duotoneEnabled = document.getElementById('duotoneEnabled');
       console.log(`[SaveTemplate] 🎨 duotoneEnabled element:`, duotoneEnabled);

       if (duotoneEnabled) {
           duotoneState.enabled = duotoneEnabled.checked;
           console.log(`[SaveTemplate] 🎨 Captured duotoneEnabled: ${duotoneEnabled.checked}`);

           if (duotoneEnabled.checked) {
               // Capture duotone colors
               const color1Input = document.getElementById('duotoneColor1');
               const color2Input = document.getElementById('duotoneColor2');

               console.log(`[SaveTemplate] 🎨 color1Input element:`, color1Input);
               console.log(`[SaveTemplate] 🎨 color2Input element:`, color2Input);

               if (color1Input) {
                   duotoneState.color1 = color1Input.value;
                   console.log(`[SaveTemplate] 🎨 Captured duotoneColor1: ${color1Input.value}`);
               }

               if (color2Input) {
                   duotoneState.color2 = color2Input.value;
                   console.log(`[SaveTemplate] 🎨 Captured duotoneColor2: ${color2Input.value}`);
               }

               // Generate and capture the matrix values
               if (duotoneState.color1 && duotoneState.color2) {
                   const matrixValues = generateDuotoneMatrix(duotoneState.color1, duotoneState.color2);
                   if (matrixValues) {
                       duotoneState.matrix = matrixValues;
                       console.log(`[SaveTemplate] 🎨 Captured duotone matrix values:`, matrixValues);
                   }
               }
           }
       } else {
           console.log(`[SaveTemplate] 🎨 ⚠️ duotoneEnabled element not found!`);
       }

       console.log('[SaveTemplate] 🎨 Complete duotone state captured:', duotoneState);
       return duotoneState;
   }

   // --- Glitch Effect State Capture ---
   function captureGlitchState() {
       console.log('[SaveTemplate] 🎨 Capturing glitch effect state...');

       const glitchState = {};

       // Capture palette reduction
       const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
       console.log(`[SaveTemplate] 🎨 paletteReductionEnabled element:`, paletteReductionEnabled);

       if (paletteReductionEnabled && paletteReductionEnabled.checked) {
           glitchState.paletteReduction = {
               enabled: true,
               paletteName: document.getElementById('paletteName')?.value || 'desert',
               distanceMode: document.getElementById('distanceMode')?.value || 'accurate',
               useDithering: document.getElementById('useDithering')?.checked || true
           };
           console.log(`[SaveTemplate] 🎨 Captured palette reduction:`, glitchState.paletteReduction);
       }

       // Capture color shift
       const colorShiftEnabled = document.getElementById('colorShiftEnabled');
       if (colorShiftEnabled && colorShiftEnabled.checked) {
           glitchState.colorShift = {
               enabled: true,
               intensity: parseFloat(document.getElementById('colorShiftIntensity')?.value || 1),
               shiftAmount: parseFloat(document.getElementById('colorShiftAmount')?.value || 20)
           };
           console.log(`[SaveTemplate] 🎨 Captured color shift:`, glitchState.colorShift);
       }

       // Capture wave deform
       const waveDeformEnabled = document.getElementById('waveDeformEnabled');
       if (waveDeformEnabled && waveDeformEnabled.checked) {
           glitchState.waveDeform = {
               enabled: true,
               direction: document.getElementById('waveDirection')?.value || 'horizontal',
               amplitude: parseFloat(document.getElementById('waveAmplitude')?.value || 10),
               frequency: parseFloat(document.getElementById('waveFrequency')?.value || 0.05)
           };
           console.log(`[SaveTemplate] 🎨 Captured wave deform:`, glitchState.waveDeform);
       }

       // Capture displacement
       const displacementEnabled = document.getElementById('displacementEnabled');
       if (displacementEnabled && displacementEnabled.checked) {
           glitchState.displacement = {
               enabled: true,
               mode: document.getElementById('displacementMode')?.value || 'horizontal',
               displacementIntensity: parseFloat(document.getElementById('displacementIntensity')?.value || 8),
               displacementSize: parseFloat(document.getElementById('displacementSize')?.value || 18),
               displacementFrequency: 0.5
           };
           console.log(`[SaveTemplate] 🎨 Captured displacement:`, glitchState.displacement);
       }

       // Capture pixel sort
       const pixelSortEnabled = document.getElementById('pixelSortEnabled');
       if (pixelSortEnabled && pixelSortEnabled.checked) {
           glitchState.pixelSort = {
               enabled: true,
               direction: document.getElementById('pixelSortDirection')?.value || 'horizontal',
               blockSize: parseFloat(document.getElementById('pixelSortBlockSize')?.value || 5),
               frequency: parseFloat(document.getElementById('pixelSortFrequency')?.value || 0.5)
           };
           console.log(`[SaveTemplate] 🎨 Captured pixel sort:`, glitchState.pixelSort);
       }

       console.log('[SaveTemplate] 🎨 Complete glitch state captured:', glitchState);
       return glitchState;
   }

   // --- Guidelines State Capture ---
   function captureGuidelinesState() {
       console.log('[SaveTemplate] 📏 Capturing guidelines state...');

       const guidelinesState = {
           guidelines: [],
           totalCount: 0
       };

       // Capture canvas-based guidelines
       if (guidelines && Array.isArray(guidelines)) {
           guidelinesState.guidelines = guidelines.map(guideline => ({
               type: guideline.type,
               worldPosition: guideline.worldPosition,
               color: guideline.color,
               lineWidth: guideline.lineWidth,
               // Don't save screen position as it changes with zoom/pan
               position: guideline.position // Keep for compatibility but worldPosition is primary
           }));
           guidelinesState.totalCount = guidelines.length;
           console.log(`[SaveTemplate] 📏 Captured ${guidelines.length} canvas-based guidelines`);
       }

       // Capture DOM-based guidelines if any exist
       const domGuidelines = [];
       if (guidelinesContainer) {
           const domGuidelineElements = guidelinesContainer.querySelectorAll('.guideline');
           domGuidelineElements.forEach(element => {
               const type = element.dataset.type;
               const worldPosition = parseFloat(element.dataset.worldPosition);
               if (type && !isNaN(worldPosition)) {
                   domGuidelines.push({
                       type: type,
                       worldPosition: worldPosition,
                       color: '#007bff', // Default color for DOM guidelines
                       lineWidth: 1
                   });
               }
           });
           console.log(`[SaveTemplate] 📏 Captured ${domGuidelines.length} DOM-based guidelines`);
       }

       // Merge canvas and DOM guidelines, avoiding duplicates
       const allGuidelines = [...guidelinesState.guidelines];
       domGuidelines.forEach(domGuideline => {
           const isDuplicate = allGuidelines.some(existing =>
               existing.type === domGuideline.type &&
               Math.abs(existing.worldPosition - domGuideline.worldPosition) < 1
           );
           if (!isDuplicate) {
               allGuidelines.push(domGuideline);
           }
       });

       guidelinesState.guidelines = allGuidelines;
       guidelinesState.totalCount = allGuidelines.length;

       console.log('[SaveTemplate] 📏 Complete guidelines state captured:', guidelinesState);
       return guidelinesState;
   }

   // --- Layout Rectangles State Capture ---
   function captureLayoutRectanglesState() {
       console.log('[SaveTemplate] 📐 Capturing layout rectangles state...');

       const layoutRectanglesState = {
           rectangles: [],
           totalCount: 0
       };

       // Capture layout rectangles from the global array
       if (layoutRectangles && Array.isArray(layoutRectangles)) {
           layoutRectanglesState.rectangles = layoutRectangles.map(rect => ({
               id: rect.id,
               x: rect.x,
               y: rect.y,
               width: rect.width,
               height: rect.height,
               isSelected: rect.isSelected || false,
               // Capture any additional properties
               color: rect.color || 'rgba(0, 123, 255, 0.3)',
               borderColor: rect.borderColor || '#007bff',
               borderWidth: rect.borderWidth || 2
           }));
           layoutRectanglesState.totalCount = layoutRectangles.length;
           console.log(`[SaveTemplate] 📐 Captured ${layoutRectangles.length} layout rectangles`);
       }

       console.log('[SaveTemplate] 📐 Complete layout rectangles state captured:', layoutRectanglesState);
       return layoutRectanglesState;
   }

   // --- Halftone State Capture ---
   function captureHalftoneState() {
       console.log('[SaveTemplate] 🎨 Capturing halftone state...');

       const halftoneState = {};

       // Capture halftone enabled state
       const halftoneEnabled = document.getElementById('halftoneEnabled')?.checked || false;
       halftoneState.enabled = halftoneEnabled;

       if (halftoneEnabled) {
           // Capture all halftone settings
           halftoneState.dotSize = parseFloat(document.getElementById('halftoneDotSize')?.value || 0.4);
           halftoneState.dotColor = document.getElementById('halftoneDotColor')?.value || '#333333';
           halftoneState.lineContrast = parseFloat(document.getElementById('halftoneLineContrast')?.value || 1050);
           halftoneState.photoBrightness = parseFloat(document.getElementById('halftonePhotoBrightness')?.value || 70);
           halftoneState.photoContrast = parseFloat(document.getElementById('halftonePhotoContrast')?.value || 100);
           halftoneState.photoBlur = parseFloat(document.getElementById('halftonePhotoBlur')?.value || 0);
           halftoneState.blendMode = document.getElementById('halftoneBlendMode')?.value || 'hard-light';
           halftoneState.grayscale = document.getElementById('halftoneGrayscale')?.checked || false;

           // Capture custom halftone image if available
           if (window.halftoneCustomImage) {
               console.log('[SaveTemplate] 🎨 Capturing custom halftone image...');
               try {
                   // Convert custom image to base64 for storage
                   const canvas = document.createElement('canvas');
                   const ctx = canvas.getContext('2d');
                   canvas.width = window.halftoneCustomImage.width;
                   canvas.height = window.halftoneCustomImage.height;
                   ctx.drawImage(window.halftoneCustomImage, 0, 0);
                   halftoneState.customImageData = canvas.toDataURL('image/png');
                   halftoneState.customImageWidth = window.halftoneCustomImage.width;
                   halftoneState.customImageHeight = window.halftoneCustomImage.height;
                   console.log('[SaveTemplate] 🎨 Custom halftone image captured as base64');
               } catch (error) {
                   console.error('[SaveTemplate] 🎨 Error capturing custom halftone image:', error);
               }
           }

           console.log('[SaveTemplate] 🎨 Halftone settings captured:', {
               dotSize: halftoneState.dotSize,
               dotColor: halftoneState.dotColor,
               lineContrast: halftoneState.lineContrast,
               photoBrightness: halftoneState.photoBrightness,
               photoContrast: halftoneState.photoContrast,
               photoBlur: halftoneState.photoBlur,
               blendMode: halftoneState.blendMode,
               grayscale: halftoneState.grayscale,
               hasCustomImage: !!halftoneState.customImageData
           });
       }

       console.log('[SaveTemplate] 🎨 Complete halftone state captured:', halftoneState);
       return halftoneState;
   }

   // --- Halftone State Restoration ---
   function restoreHalftoneState(halftoneState) {
       console.log('[SaveTemplate] 🎨 Restoring halftone state:', halftoneState);
       console.log('[SaveTemplate] 🎨 Halftone state type:', typeof halftoneState);
       console.log('[SaveTemplate] 🎨 Halftone state keys:', Object.keys(halftoneState || {}));

       if (!halftoneState || typeof halftoneState !== 'object') {
           console.log('[SaveTemplate] 🎨 No valid halftone state to restore');
           return;
       }

       // Restore halftone enabled state
       const halftoneEnabled = document.getElementById('halftoneEnabled');
       const halftoneControls = document.getElementById('halftone-effect-controls');

       if (halftoneEnabled) {
           halftoneEnabled.checked = halftoneState.enabled || false;
           if (halftoneControls) {
               halftoneControls.style.display = halftoneState.enabled ? 'block' : 'none';
           }
       }

       // Restore halftone settings if enabled
       if (halftoneState.enabled) {
           // Restore all halftone control values
           const dotSizeSlider = document.getElementById('halftoneDotSize');
           const dotColorPicker = document.getElementById('halftoneDotColor');
           const lineContrastSlider = document.getElementById('halftoneLineContrast');
           const photoBrightnessSlider = document.getElementById('halftonePhotoBrightness');
           const photoContrastSlider = document.getElementById('halftonePhotoContrast');
           const photoBlurSlider = document.getElementById('halftonePhotoBlur');
           const blendModeSelect = document.getElementById('halftoneBlendMode');
           const grayscaleToggle = document.getElementById('halftoneGrayscale');

           if (dotSizeSlider && halftoneState.dotSize !== undefined) {
               dotSizeSlider.value = halftoneState.dotSize;
               const display = document.getElementById('vHalftoneDotSize');
               if (display) display.textContent = halftoneState.dotSize + 'em';
           }
           if (dotColorPicker && halftoneState.dotColor) {
               dotColorPicker.value = halftoneState.dotColor;
           }
           if (lineContrastSlider && halftoneState.lineContrast !== undefined) {
               lineContrastSlider.value = halftoneState.lineContrast;
               const display = document.getElementById('vHalftoneLineContrast');
               if (display) display.textContent = halftoneState.lineContrast + '%';
           }
           if (photoBrightnessSlider && halftoneState.photoBrightness !== undefined) {
               photoBrightnessSlider.value = halftoneState.photoBrightness;
               const display = document.getElementById('vHalftonePhotoBrightness');
               if (display) display.textContent = halftoneState.photoBrightness + '%';
           }
           if (photoContrastSlider && halftoneState.photoContrast !== undefined) {
               photoContrastSlider.value = halftoneState.photoContrast;
               const display = document.getElementById('vHalftonePhotoContrast');
               if (display) display.textContent = halftoneState.photoContrast + '%';
           }
           if (photoBlurSlider && halftoneState.photoBlur !== undefined) {
               photoBlurSlider.value = halftoneState.photoBlur;
               const display = document.getElementById('vHalftonePhotoBlur');
               if (display) display.textContent = halftoneState.photoBlur + 'px';
           }
           if (blendModeSelect && halftoneState.blendMode) {
               blendModeSelect.value = halftoneState.blendMode;
           }
           if (grayscaleToggle && halftoneState.grayscale !== undefined) {
               grayscaleToggle.checked = halftoneState.grayscale;
               console.log('[SaveTemplate] 🎨 ✅ RESTORED GRAYSCALE CHECKBOX (design-editor.js):', halftoneState.grayscale, 'Element checked:', grayscaleToggle.checked);
           } else {
               console.log('[SaveTemplate] 🎨 ❌ FAILED TO RESTORE GRAYSCALE (design-editor.js) - Element:', !!grayscaleToggle, 'Value:', halftoneState.grayscale);
           }

           // Restore custom halftone image if available
           if (halftoneState.customImageData) {
               console.log('[SaveTemplate] 🎨 Restoring custom halftone image...');
               try {
                   const img = new Image();
                   img.onload = function() {
                       window.halftoneCustomImage = img;
                       console.log('[SaveTemplate] 🎨 Custom halftone image restored successfully');

                       // Update UI to show the restored image
                       const imagePreview = document.getElementById('halftoneImagePreview');
                       const imagePreviewImg = document.getElementById('halftoneImagePreviewImg');
                       if (imagePreview && imagePreviewImg) {
                           imagePreviewImg.src = halftoneState.customImageData;
                           imagePreview.style.display = 'block';
                       }
                   };
                   img.onerror = function() {
                       console.error('[SaveTemplate] 🎨 Failed to restore custom halftone image');
                   };
                   img.src = halftoneState.customImageData;
               } catch (error) {
                   console.error('[SaveTemplate] 🎨 Error restoring custom halftone image:', error);
               }
           }
       }

       console.log('[SaveTemplate] 🎨 Halftone state restored successfully');
   }

   // --- Guidelines State Restoration ---
   function restoreGuidelinesState(guidelinesState) {
       console.log('[LoadTemplate] 📏 Restoring guidelines state:', guidelinesState);

       if (!guidelinesState || typeof guidelinesState !== 'object') {
           console.log('[LoadTemplate] 📏 No valid guidelines state to restore');
           return;
       }

       // Clear existing guidelines first
       clearAllGuidelines();

       // Restore guidelines from saved state
       if (guidelinesState.guidelines && Array.isArray(guidelinesState.guidelines)) {
           guidelinesState.guidelines.forEach((savedGuideline, index) => {
               const guideline = {
                   type: savedGuideline.type,
                   worldPosition: savedGuideline.worldPosition,
                   color: savedGuideline.color || '#007bff',
                   lineWidth: savedGuideline.lineWidth || 1,
                   position: savedGuideline.position || 0 // For compatibility
               };

               guidelines.push(guideline);
               console.log(`[LoadTemplate] 📏 Restored guideline ${index + 1}: ${guideline.type} at world position ${guideline.worldPosition}`);
           });

           console.log(`[LoadTemplate] 📏 Successfully restored ${guidelinesState.guidelines.length} guidelines`);
       }

       // Trigger canvas redraw to show restored guidelines
       update();
   }

   // --- Layout Rectangles State Restoration ---
   function restoreLayoutRectanglesState(layoutRectanglesState) {
       console.log('[LoadTemplate] 📐 Restoring layout rectangles state:', layoutRectanglesState);

       if (!layoutRectanglesState || typeof layoutRectanglesState !== 'object') {
           console.log('[LoadTemplate] 📐 No valid layout rectangles state to restore');
           return;
       }

       // Clear existing layout rectangles first
       if (typeof clearLayoutRectangles === 'function') {
           clearLayoutRectangles();
       } else {
           // Fallback: clear the array directly
           if (layoutRectangles && Array.isArray(layoutRectangles)) {
               layoutRectangles.length = 0;
           }
       }

       // Restore layout rectangles from saved state
       if (layoutRectanglesState.rectangles && Array.isArray(layoutRectanglesState.rectangles)) {
           layoutRectanglesState.rectangles.forEach((savedRect, index) => {
               const rect = {
                   id: savedRect.id || Date.now() + index,
                   x: savedRect.x,
                   y: savedRect.y,
                   width: savedRect.width,
                   height: savedRect.height,
                   isSelected: false, // Reset selection state
                   color: savedRect.color || 'rgba(0, 123, 255, 0.3)',
                   borderColor: savedRect.borderColor || '#007bff',
                   borderWidth: savedRect.borderWidth || 2
               };

               if (!layoutRectangles) {
                   layoutRectangles = [];
               }
               layoutRectangles.push(rect);
               console.log(`[LoadTemplate] 📐 Restored layout rectangle ${index + 1}: ${rect.width}x${rect.height} at (${rect.x}, ${rect.y})`);
           });

           console.log(`[LoadTemplate] 📐 Successfully restored ${layoutRectanglesState.rectangles.length} layout rectangles`);
       }

       // Trigger canvas redraw to show restored layout rectangles
       update();
   }

   // Make halftone functions globally accessible
   window.restoreHalftoneState = restoreHalftoneState;

   // Make guidelines and layout rectangles functions globally accessible
   window.restoreGuidelinesState = restoreGuidelinesState;
   window.restoreLayoutRectanglesState = restoreLayoutRectanglesState;
   window.captureGuidelinesState = captureGuidelinesState;
   window.captureLayoutRectanglesState = captureLayoutRectanglesState;

   // --- Save Template Logic ---
   async function handleSaveTemplate() {
       console.log('[SaveTemplate] 🎭 CACHE REFRESH TEST - NEW CODE LOADED - Clicked at', new Date().toISOString());
       if (!artboard) {
           alert('Cannot save template without an Artboard defined.');
           return;
       }

       // 1. Get Admin Data (including original palette and object for Restyle functionality)
       const adminData = {
           imageUrl: document.getElementById('adminImageUrl')?.value || '',
           model: document.getElementById('adminModel')?.value || '',
           prompt: document.getElementById('adminPrompt')?.value || '',
           palette: document.getElementById('adminPalette')?.value || '',
           backgroundType: document.getElementById('backgroundType')?.value || 'light',
           originalPalette: document.getElementById('adminOriginalPalette')?.value || '',
           originalObject: document.getElementById('adminOriginalObject')?.value || '',
           fontStylesList: window.fontStylesList || [], // Added for Font Styles functionality
           decorStylesList: window.decorStylesList || [], // Added for Decor Styles functionality
           cssFilterState: captureCSSFilterState() || {}, // Added for CSS Filters functionality
           duotoneState: captureDuotoneState() || {}, // Added for Duotone Effects functionality
           glitchState: captureGlitchState() || {}, // Added for Glitch Effects functionality
           halftoneState: captureHalftoneState() || {} // Added for Halftone Effects functionality
       };
       const inspirationId = document.getElementById('adminInspirationId')?.value || null;

       // 2. Wait for all images to load before generating preview
       console.log('[SaveTemplate] Checking image loading status...');
       const imageObjects = canvasObjects.filter(obj => obj.type === 'image');
       console.log('[SaveTemplate] Found', imageObjects.length, 'image objects');

       const imageLoadPromises = [];

       imageObjects.forEach(obj => {
           console.log(`[SaveTemplate] Checking image loading for object ${obj.id}`);
           console.log(`[SaveTemplate] Image object ${obj.id} has image property:`, !!obj.image);

           if (obj.image) {
               console.log(`[SaveTemplate] Image object ${obj.id} image.complete:`, obj.image.complete);
               console.log(`[SaveTemplate] Image object ${obj.id} image.naturalWidth:`, obj.image.naturalWidth);
               console.log(`[SaveTemplate] Image object ${obj.id} image.naturalHeight:`, obj.image.naturalHeight);

               if (!obj.image.complete || obj.image.naturalWidth === 0) {
                   console.log(`[SaveTemplate] Image ${obj.id} is NOT fully loaded, creating load promise...`);

                   const promise = new Promise((resolve) => {
                       // Check if it loads within the next few milliseconds
                       const checkLoaded = () => {
                           if (obj.image.complete && obj.image.naturalWidth > 0) {
                               console.log(`[SaveTemplate] Image ${obj.id} is now loaded (${obj.image.naturalWidth}x${obj.image.naturalHeight})`);
                               resolve();
                           } else {
                               console.log(`[SaveTemplate] Image ${obj.id} still loading, setting up event listeners...`);
                               obj.image.onload = () => {
                                   console.log(`[SaveTemplate] Image ${obj.id} finished loading via onload event`);
                                   resolve();
                               };
                               obj.image.onerror = () => {
                                   console.log(`[SaveTemplate] Image ${obj.id} failed to load via onerror event`);
                                   resolve(); // Continue anyway
                               };

                               // Timeout after 5 seconds
                               setTimeout(() => {
                                   console.log(`[SaveTemplate] Image ${obj.id} load timeout, continuing anyway`);
                                   resolve();
                               }, 5000);
                           }
                       };

                       // Check immediately, then after a small delay
                       setTimeout(checkLoaded, 10);
                   });
                   imageLoadPromises.push(promise);
               } else {
                   console.log(`[SaveTemplate] Image ${obj.id} is already loaded (${obj.image.naturalWidth}x${obj.image.naturalHeight})`);
               }
           } else {
               console.log(`[SaveTemplate] Image object ${obj.id} has no image property`);
           }
       });

       if (imageLoadPromises.length > 0) {
           console.log(`[SaveTemplate] Waiting for ${imageLoadPromises.length} images to load...`);
           await Promise.all(imageLoadPromises);
           console.log('[SaveTemplate] All images loaded, generating preview...');
       } else {
           console.log('[SaveTemplate] All images already loaded');
       }

       // 3. Generate Preview Image (HIGH RESOLUTION for better modal display)
       const exportCanvas = document.createElement('canvas');
       // Use higher resolution for better quality in modal views, maintaining aspect ratio
       const previewWidth = 800; // Increased from 300 to 800 for better definition
       const previewHeight = artboard.height * (previewWidth / artboard.width);
       exportCanvas.width = previewWidth;
       exportCanvas.height = previewHeight;
       const exportCtx = exportCanvas.getContext('2d');

       // TEMPLATE PREVIEW: Fill with canvas background color (unlike Add to Collection which uses transparent)
       exportCtx.fillStyle = canvasBackgroundColor || '#ffffff';
       exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
       console.log('[SaveTemplate] Template preview background set to:', canvasBackgroundColor || '#ffffff');

       exportCtx.save();
       // Scale the drawing to fit the preview canvas
       exportCtx.scale(previewWidth / artboard.width, previewHeight / artboard.height);
       // Translate context so drawing happens relative to artboard's top-left
       exportCtx.translate(-artboard.x, -artboard.y);

       // Draw objects onto exportCtx (passing the context)
       console.log('[SaveTemplate] 🎨 Starting to draw', canvasObjects.length, 'canvas objects');
       for (let index = 0; index < canvasObjects.length; index++) {
           const obj = canvasObjects[index];
           console.log(`[SaveTemplate] 🎨 Processing object ${index + 1}/${canvasObjects.length}: ID=${obj.id}, type=${obj.type}`);

           const bounds = calculateObjectBounds(obj); // Check bounds relative to original artboard
           console.log(`[SaveTemplate] 🎨 Object ${obj.id} bounds:`, bounds);
           console.log(`[SaveTemplate] 🎨 Artboard bounds: x=${artboard.x}, y=${artboard.y}, width=${artboard.width}, height=${artboard.height}`);

           const isInBounds = bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
                             bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height;
           console.log(`[SaveTemplate] 🎨 Object ${obj.id} is in bounds:`, isInBounds);

           if (isInBounds) {
               // Skip drawing mask shapes that are being used as masks (they should be invisible)
               if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                   console.log('[SaveTemplate] 🎭 Skipping drawing of mask shape in template preview:', obj.id);
                   return; // Skip this object
               }

               if (obj.type === 'text') {
                   console.log(`[SaveTemplate] 🎨 Drawing text object ${obj.id}`);
                   drawTextObject(obj, exportCtx);
                   console.log(`[SaveTemplate] 🎨 Text object ${obj.id} drawn successfully`);
               } else if (obj.type === 'image') {
                   console.log(`[SaveTemplate] 🎨 Drawing image object ${obj.id} with UNIFIED effects pipeline`);
                   console.log(`[SaveTemplate] 🎨 Image object ${obj.id} details:`, {
                       hasImage: !!obj.image,
                       imageComplete: obj.image?.complete,
                       naturalWidth: obj.image?.naturalWidth,
                       naturalHeight: obj.image?.naturalHeight,
                       imageUrl: obj.imageUrl,
                       x: obj.x,
                       y: obj.y,
                       width: obj.width,
                       height: obj.height
                   });

                   // Use the unified effects pipeline from the HTML file
                   if (typeof window.drawImageObject === 'function') {
                       console.log(`[SaveTemplate] 🎨 Calling window.drawImageObject for ${obj.id} (ASYNC)`);
                       try {
                           await window.drawImageObject(obj, exportCtx);
                           console.log(`[SaveTemplate] 🎨 Image object ${obj.id} drawn successfully via unified pipeline`);
                       } catch (error) {
                           console.error(`[SaveTemplate] 🎨 Error drawing image object ${obj.id} via unified pipeline:`, error);
                       }
                   } else {
                       console.log(`[SaveTemplate] 🎨 window.drawImageObject not available, using fallback for ${obj.id}`);
                       // Fallback to basic drawing if unified pipeline not available
                       try {
                           drawImageObject(obj, exportCtx);
                           console.log(`[SaveTemplate] 🎨 Image object ${obj.id} drawn successfully via fallback`);
                       } catch (error) {
                           console.error(`[SaveTemplate] 🎨 Error drawing image object ${obj.id} via fallback:`, error);
                       }
                   }
               } else {
                   console.log(`[SaveTemplate] 🎨 Unknown object type for ${obj.id}: ${obj.type}`);
               }
           } else {
               console.log(`[SaveTemplate] 🎨 Object ${obj.id} is outside artboard bounds, skipping`);
           }
       }
       console.log('[SaveTemplate] 🎨 Finished drawing all objects');
       exportCtx.restore();

       console.log('[SaveTemplate] 🎨 Canvas drawing complete, generating data URL...');
       console.log('[SaveTemplate] 🎨 Export canvas dimensions:', exportCanvas.width, 'x', exportCanvas.height);

       const previewDataUrl = exportCanvas.toDataURL('image/png');
       console.log('[SaveTemplate] 🎨 Preview data URL generated, length:', previewDataUrl.length);
       console.log('[SaveTemplate] 🎨 Preview data URL starts with:', previewDataUrl.substring(0, 100));

       // Log canvas content for debugging
       const imageData = exportCtx.getImageData(0, 0, Math.min(exportCanvas.width, 100), Math.min(exportCanvas.height, 100));
       const hasNonTransparentPixels = Array.from(imageData.data).some((value, index) => index % 4 === 3 && value > 0);
       console.log('[SaveTemplate] 🎨 Canvas has non-transparent pixels in top-left 100x100:', hasNonTransparentPixels);

       // 4. Upload Preview Image
       let previewImageUrl = '';
       try {
           console.log('[SaveTemplate] Uploading preview image...');
           const blob = await (await fetch(previewDataUrl)).blob();
           const formData = new FormData();
           formData.append('image', blob, 'template_preview.png');

           const response = await fetch('/api/images/upload', { // Use the existing image upload endpoint
               method: 'POST',
               body: formData
           });

           if (!response.ok) {
               const errorText = await response.text();
               throw new Error(`Preview upload failed: ${response.statusText} - ${errorText}`);
           }
           const result = await response.json();
           previewImageUrl = result.imageUrl || result.url || result.fileUrl;
           if (!previewImageUrl || typeof previewImageUrl !== 'string') {
                throw new Error('Invalid or missing imageUrl in preview upload response.');
           }
           console.log('[SaveTemplate] Preview image uploaded:', previewImageUrl);

       } catch (e) {
           console.error('[SaveTemplate] Error uploading preview image:', e);
           alert(`Error uploading preview image: ${e.message}`);
           return; // Stop if preview upload fails
       }

       // 4. Prepare Canvas Objects Data (Remove non-serializable parts, add layer order, and assign template IDs)
       console.log('[SaveTemplate] 🚀 LAYER ORDER FIX - ===== SAVING LAYER ORDER DEBUG =====');
       console.log('[SaveTemplate] 🎭 TEMPLATE ID ASSIGNMENT - ===== ASSIGNING TEMPLATE IDs =====');
       console.log('[SaveTemplate] Current canvasObjects array length:', canvasObjects.length);

       // Track template ID assignments
       let textIdCounter = 1;
       let imageIdCounter = 1;
       let maskIdCounter = 1;

       // 🎭 PRIORITIZE MAIN IMAGE (i01) - Find the first non-mask image for main replacement
       const firstNonMaskImage = canvasObjects.find(obj => obj.type === 'image' && !obj.isMaskShape);
       if (firstNonMaskImage) {
           console.log(`[SaveTemplate] 🎭 Main image candidate found:`, {
               imageUrl: firstNonMaskImage.imageUrl,
               isMasked: firstNonMaskImage.isMasked || false,
               maskShapeId: firstNonMaskImage.maskShapeId || null
           });
       }

       // 🎭 CRITICAL FIX: Remove duplicate objects before saving
       console.log('[SaveTemplate] 🎭 DUPLICATE CHECK - Checking for duplicate objects...');
       const uniqueObjects = [];
       const seenIds = new Set();

       canvasObjects.forEach((obj, index) => {
           console.log(`[SaveTemplate] Object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", id=${obj.id}, isMasked=${obj.isMasked || false}, isMaskShape=${obj.isMaskShape || false}`);

           // Check for duplicates by ID and type
           const objectKey = `${obj.id}-${obj.type}-${obj.imageUrl}`;
           if (!seenIds.has(objectKey)) {
               seenIds.add(objectKey);
               uniqueObjects.push(obj);
               console.log(`[SaveTemplate] 🎭 ✅ Object ${index} added (unique)`);
           } else {
               console.warn(`[SaveTemplate] 🎭 ⚠️ Object ${index} is duplicate, skipping:`, {
                   id: obj.id,
                   type: obj.type,
                   imageUrl: obj.imageUrl?.substring(0, 50) + '...'
               });
           }
       });

       console.log(`[SaveTemplate] 🎭 DUPLICATE CHECK COMPLETE: ${canvasObjects.length} -> ${uniqueObjects.length} objects`);

       // Use unique objects for serialization
       const objectsToSerialize = uniqueObjects;

       const serializableObjects = objectsToSerialize.map((obj, index) => {
           // Sync mesh warp data from active handler before saving
           if (obj.type === 'text' && obj.effectMode === 'mesh' &&
               typeof activeMeshWarpHandler !== 'undefined' && activeMeshWarpHandler &&
               activeMeshWarpHandler.selectedTextObject === obj) {
               console.log('[SaveTemplate] Syncing mesh warp data from active handler for:', obj.text);
               activeMeshWarpHandler.syncControlPointsToTextObject();
           }

           // 🎭 DEBUG: Log original object properties before cleaning
           console.log(`[SaveTemplate] 🎭 BEFORE CLEANING - Object ${index}:`, {
               type: obj.type,
               id: obj.id,
               imageUrl: obj.imageUrl,
               isMasked: obj.isMasked,
               maskShapeId: obj.maskShapeId,
               isMaskShape: obj.isMaskShape,
               isVisible: obj.isVisible
           });

           // Use the cleaning function to avoid circular references
           const cleanObj = cleanObjectForSerialization(obj);

           // 🎭 DEBUG: Log cleaned object properties after cleaning
           console.log(`[SaveTemplate] 🎭 AFTER CLEANING - Object ${index}:`, {
               type: cleanObj.type,
               id: cleanObj.id,
               imageUrl: cleanObj.imageUrl,
               isMasked: cleanObj.isMasked,
               maskShapeId: cleanObj.maskShapeId,
               isMaskShape: cleanObj.isMaskShape,
               isVisible: cleanObj.isVisible
           });

           // 🎭 CRITICAL: Verify masking properties are preserved
           if (obj.isMasked && !cleanObj.isMasked) {
               console.error(`[SaveTemplate] 🎭 ❌ CRITICAL: isMasked property lost during cleaning for object ${index}!`);
               console.error(`[SaveTemplate] 🎭 Original:`, { isMasked: obj.isMasked, maskShapeId: obj.maskShapeId });
               console.error(`[SaveTemplate] 🎭 Cleaned:`, { isMasked: cleanObj.isMasked, maskShapeId: cleanObj.maskShapeId });
           }
           if (obj.maskShapeId && !cleanObj.maskShapeId) {
               console.error(`[SaveTemplate] 🎭 ❌ CRITICAL: maskShapeId property lost during cleaning for object ${index}!`);
           }
           if (obj.isMaskShape && !cleanObj.isMaskShape) {
               console.error(`[SaveTemplate] 🎭 ❌ CRITICAL: isMaskShape property lost during cleaning for object ${index}!`);
           }

           // Add explicit layer order information (index 0 = bottom layer, higher index = top layer)
           cleanObj.layerOrder = index;
           cleanObj.zIndex = index; // Alternative property name for clarity

           // 🎭 ASSIGN TEMPLATE IDs FOR REPLACEABLE ELEMENTS
           if (cleanObj.type === 'text') {
               // Assign template ID for text elements (t01, t02, t03, t04, t05)
               if (textIdCounter <= 5) {
                   cleanObj.templateId = `t0${textIdCounter}`;
                   console.log(`[SaveTemplate] 🎭 Assigned template ID ${cleanObj.templateId} to text: "${cleanObj.text}"`);
                   textIdCounter++;
               }
           } else if (cleanObj.type === 'image') {
               // Handle mask shapes with special template IDs
               if (cleanObj.isMaskShape) {
                   // Assign mask template ID for mask shapes (mask01, mask02, mask03)
                   if (maskIdCounter <= 3) {
                       cleanObj.templateId = `mask0${maskIdCounter}`;
                       console.log(`[SaveTemplate] 🎭 Assigned mask template ID ${cleanObj.templateId} to mask shape: ${cleanObj.imageUrl}`);
                       maskIdCounter++;
                   }
                   // Ensure mask shapes are properly marked and hidden
                   cleanObj.isVisible = false;
                   cleanObj.isMaskShape = true;
               } else {
                   // Assign template ID for regular image elements (i01, i02, i03, i04, i05)
                   if (imageIdCounter <= 5) {
                       cleanObj.templateId = `i0${imageIdCounter}`;
                       console.log(`[SaveTemplate] 🎭 Assigned template ID ${cleanObj.templateId} to image: ${cleanObj.imageUrl}`);

                       // 🎭 HANDLE MASKED IMAGES
                       if (cleanObj.isMasked && cleanObj.maskShapeId) {
                           console.log(`[SaveTemplate] 🎭 Image ${cleanObj.templateId} is masked with shape ${cleanObj.maskShapeId}`);
                           console.log(`[SaveTemplate] 🎭 Masked image properties:`, {
                               templateId: cleanObj.templateId,
                               isMasked: cleanObj.isMasked,
                               maskShapeId: cleanObj.maskShapeId,
                               imageUrl: cleanObj.imageUrl
                           });
                       }

                       imageIdCounter++;
                   }
               }
           }

           console.log(`[SaveTemplate] Saving object ${index}: type=${cleanObj.type}, text="${cleanObj.text || cleanObj.imageUrl || 'N/A'}", templateId=${cleanObj.templateId || 'none'}, layerOrder=${index}, zIndex=${index}, isMasked=${cleanObj.isMasked || false}, has meshWarp=${!!cleanObj.meshWarp}`);
           return cleanObj;
       });

       console.log('[SaveTemplate] ===== SERIALIZABLE OBJECTS =====');
       serializableObjects.forEach((obj, index) => {
           console.log(`[SaveTemplate] Serialized ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", templateId=${obj.templateId || 'none'}, layerOrder=${obj.layerOrder}, zIndex=${obj.zIndex}, isMasked=${obj.isMasked || false}`);
       });

       // 🎭 TEMPLATE ID ASSIGNMENT SUMMARY
       const assignedTextIds = serializableObjects.filter(obj => obj.type === 'text' && obj.templateId).map(obj => obj.templateId);
       const assignedImageIds = serializableObjects.filter(obj => obj.type === 'image' && obj.templateId && !obj.templateId.startsWith('mask')).map(obj => obj.templateId);
       const assignedMaskIds = serializableObjects.filter(obj => obj.type === 'image' && obj.templateId && obj.templateId.startsWith('mask')).map(obj => obj.templateId);
       const maskedImages = serializableObjects.filter(obj => obj.type === 'image' && obj.isMasked);

       console.log('[SaveTemplate] 🎭 TEMPLATE ID ASSIGNMENT SUMMARY:');
       console.log('[SaveTemplate] 🎭 Text IDs assigned:', assignedTextIds);
       console.log('[SaveTemplate] 🎭 Image IDs assigned:', assignedImageIds);
       console.log('[SaveTemplate] 🎭 Mask IDs assigned:', assignedMaskIds);
       console.log('[SaveTemplate] 🎭 Masked images found:', maskedImages.length);
       maskedImages.forEach(img => {
           console.log(`[SaveTemplate] 🎭 Masked image: ${img.templateId} -> maskShapeId: ${img.maskShapeId}`);
       });

       // 5. Prepare Complete Editor State
       const editorState = {
           canvasBackgroundColor: canvasBackgroundColor,
           zoom: {
               scale: scale,
               offsetX: offsetX,
               offsetY: offsetY
           },
           selectedObjectIndex: selectedObjectIndex,
           nextId: nextId,
           editorSettings: {
               // Add any additional editor settings that affect the design
               artboardEditMode: isArtboardEditMode,
               // Store any UI state that affects the template
               lastUpdateTimestamp: Date.now()
           }
       };

       // 6. Prepare Template Data Payload
       // Check if we have a predefined name (from update function) or prompt user
       const templateName = window.predefinedTemplateName || prompt('Enter a name for this template (optional):') || 'Untitled Template';

       // Get original palette and original object from Admin tab (correct field IDs)
       let originalPalette = document.getElementById('editOriginalPalette')?.value || '';
       let originalObject = document.getElementById('editOriginalObject')?.value || '';

       console.log('[SaveTemplate] 🎯 Reading from correct Admin fields:', {
           'editOriginalPalette value': originalPalette,
           'editOriginalObject value': originalObject,
           'editOriginalPalette element': document.getElementById('editOriginalPalette'),
           'editOriginalObject element': document.getElementById('editOriginalObject')
       });

       // If original fields are empty (new template), auto-populate with sensible defaults
       if (!originalPalette) {
           // Try to get from current admin palette, or create a default
           const adminPalette = document.getElementById('adminPalette')?.value || '';
           if (adminPalette) {
               originalPalette = adminPalette;
               console.log('[SaveTemplate] 🎯 Using current admin palette as original:', originalPalette);
           } else {
               // Create a generic palette description
               originalPalette = 'vibrant colors, professional design palette';
               console.log('[SaveTemplate] 🎯 Using default palette description:', originalPalette);
           }

           // Auto-populate the field for future reference
           const editOriginalPaletteField = document.getElementById('editOriginalPalette');
           if (editOriginalPaletteField) {
               editOriginalPaletteField.value = originalPalette;
               console.log('[SaveTemplate] 🎯 Auto-populated editOriginalPalette field');
           }
       }

       if (!originalObject) {
           // Try to extract object from the prompt or use a default
           const adminPrompt = document.getElementById('adminPrompt')?.value || '';
           if (adminPrompt.includes('[input-object]')) {
               // This is a template prompt, use a generic default
               originalObject = 'design subject';
               console.log('[SaveTemplate] 🎯 Using generic object for template prompt');
           } else if (adminPrompt) {
               // Use the first sentence of the prompt as the object
               originalObject = adminPrompt.split('.')[0].trim() || 'design subject';
               console.log('[SaveTemplate] 🎯 Using prompt-derived object:', originalObject);
           } else {
               originalObject = 'design subject';
               console.log('[SaveTemplate] 🎯 Using fallback object:', originalObject);
           }

           // Auto-populate the field for future reference
           const editOriginalObjectField = document.getElementById('editOriginalObject');
           if (editOriginalObjectField) {
               editOriginalObjectField.value = originalObject;
               console.log('[SaveTemplate] 🎯 Auto-populated editOriginalObject field');
           }
       }

       console.log('[SaveTemplate] Original values from Admin tab (CORRECTED):', {
           originalPalette: originalPalette,
           originalObject: originalObject,
           editOriginalPaletteElement: document.getElementById('editOriginalPalette'),
           editOriginalObjectElement: document.getElementById('editOriginalObject')
       });

       console.log('[SaveTemplate] Admin data object being created:', {
           imageUrl: adminData.imageUrl,
           model: adminData.model,
           prompt: adminData.prompt,
           palette: adminData.palette,
           backgroundType: adminData.backgroundType,
           originalPalette: adminData.originalPalette,
           originalObject: adminData.originalObject
       });

       console.log('[SaveTemplate] 🔍 DETAILED ADMIN DATA DEBUG:', {
           'adminData.originalPalette': adminData.originalPalette,
           'adminData.originalObject': adminData.originalObject,
           'originalPalette variable': originalPalette,
           'originalObject variable': originalObject,
           'adminData keys': Object.keys(adminData),
           'adminData full object': adminData
       });

       // Final check of variables before creating templateData
       console.log('🎯 FINAL VARIABLE CHECK before templateData creation:', {
           'originalPalette': originalPalette,
           'originalObject': originalObject,
           'typeof originalPalette': typeof originalPalette,
           'typeof originalObject': typeof originalObject
       });

       // 7. Capture CSS Filter State
       const cssFilterState = captureCSSFilterState();

       // 8. Capture Duotone Effect State
       const duotoneState = captureDuotoneState();

       // 9. Capture Glitch Effect State
       const glitchState = captureGlitchState();

       // 10. Capture Halftone Effect State
       const halftoneState = captureHalftoneState();

       // 11. Capture Guidelines State
       const guidelinesState = captureGuidelinesState();

       // 12. Capture Layout Rectangles State
       const layoutRectanglesState = captureLayoutRectanglesState();

       const templateData = {
           name: templateName,
           inspirationId: inspirationId,
           previewImageUrl: previewImageUrl,
           // Correctly assign the global artboard object
           artboard: artboard ? {
               x: artboard.x,
               y: artboard.y,
               width: artboard.width,
               height: artboard.height
           } : null, // Send null if artboard doesn't exist
           canvasObjects: serializableObjects,
           adminData: adminData,
           editorState: editorState, // Include complete editor state
           originalPalette: originalPalette, // Add original palette
           originalObject: originalObject, // Add original object
           fontStylesList: window.fontStylesList || [], // Add font styles list as top-level field
           decorStylesList: window.decorStylesList || [], // Add decor styles list as top-level field
           cssFilterState: cssFilterState, // Add CSS filter state for persistence
           duotoneState: duotoneState, // Add duotone effect state for persistence
           glitchState: glitchState, // Add glitch effect state for persistence
           halftoneState: halftoneState, // Add halftone effect state for persistence
           guidelinesState: guidelinesState, // Add guidelines state for persistence
           layoutRectanglesState: layoutRectanglesState // Add layout rectangles state for persistence
       };

       // Verify templateData contains the fields
       console.log('🎯 TEMPLATE DATA VERIFICATION after creation:', {
           'templateData.originalPalette': templateData.originalPalette,
           'templateData.originalObject': templateData.originalObject,
           'templateData.cssFilterState': templateData.cssFilterState,
           'templateData.duotoneState': templateData.duotoneState,
           'templateData.glitchState': templateData.glitchState,
           'templateData.halftoneState': templateData.halftoneState,
           'templateData keys': Object.keys(templateData)
       });

       // Add console log to inspect the data being sent
       console.log('[SaveTemplate] Editor state being saved:', editorState);
       console.log('[SaveTemplate] Canvas objects being saved:', serializableObjects);

       // Log the critical original data fields
       console.log('[SaveTemplate] 🎯 CRITICAL ORIGINAL DATA CHECK:', {
           'templateData.originalPalette': templateData.originalPalette,
           'templateData.originalObject': templateData.originalObject,
           'templateData.adminData.originalPalette': templateData.adminData.originalPalette,
           'templateData.adminData.originalObject': templateData.adminData.originalObject
       });

       console.log('[SaveTemplate] 🎨 CSS FILTER DATA CHECK:', {
           'templateData.cssFilterState': templateData.cssFilterState,
           'templateData.adminData.cssFilterState': templateData.adminData.cssFilterState,
           'cssFilterState keys': templateData.cssFilterState ? Object.keys(templateData.cssFilterState) : 'no cssFilterState',
           'adminData cssFilterState keys': templateData.adminData.cssFilterState ? Object.keys(templateData.adminData.cssFilterState) : 'no adminData cssFilterState'
       });

       // 🎭 FINAL VERIFICATION: Check masking properties in final data
       const finalMaskedImages = serializableObjects.filter(obj => obj.isMasked);
       const finalMaskShapes = serializableObjects.filter(obj => obj.isMaskShape);
       console.log('[SaveTemplate] 🎭 FINAL VERIFICATION - Masked images in final data:', finalMaskedImages.length);
       console.log('[SaveTemplate] 🎭 FINAL VERIFICATION - Mask shapes in final data:', finalMaskShapes.length);
       finalMaskedImages.forEach((img, index) => {
           console.log(`[SaveTemplate] 🎭 FINAL MASKED IMAGE ${index + 1}:`, {
               templateId: img.templateId,
               isMasked: img.isMasked,
               maskShapeId: img.maskShapeId,
               imageUrl: img.imageUrl?.substring(0, 50) + '...'
           });
       });
       finalMaskShapes.forEach((shape, index) => {
           console.log(`[SaveTemplate] 🎭 FINAL MASK SHAPE ${index + 1}:`, {
               id: shape.id,
               isMaskShape: shape.isMaskShape,
               isVisible: shape.isVisible,
               imageUrl: shape.imageUrl?.substring(0, 50) + '...'
           });
       });

       console.log('[SaveTemplate] Full template data:', JSON.stringify(templateData, null, 2));

       // 7. Send Data to Backend
       try {
           // console.log('[SaveTemplate] Saving template data to /api/design-templates:', templateData); // Log above is more detailed
           const saveResponse = await fetch('/api/design-templates', { // Use the new endpoint
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json'
               },
               body: JSON.stringify(templateData)
           });

           if (!saveResponse.ok) {
                const errorText = await saveResponse.text();
                throw new Error(`Save template failed: ${saveResponse.statusText} - ${errorText}`);
           }

           const savedTemplate = await saveResponse.json();
           console.log('[SaveTemplate] Template saved successfully:', savedTemplate);

           // Verify the saved template has original data
           console.log('🎯 VERIFICATION - Saved template original data:', {
               'savedTemplate.originalPalette': savedTemplate.originalPalette,
               'savedTemplate.originalObject': savedTemplate.originalObject,
               'savedTemplate.adminData.originalPalette': savedTemplate.adminData?.originalPalette,
               'savedTemplate.adminData.originalObject': savedTemplate.adminData?.originalObject
           });

           alert('Template saved successfully!');

       } catch (e) {
            console.error('[SaveTemplate] Error saving template data:', e);
            alert(`Error saving template: ${e.message}`);
       }
   }

   // --- Update Existing Template Logic (Replace with New Template) ---
   async function handleUpdateTemplate() {
       console.log('[UpdateTemplate] Replacing template with new version...');

       const templateId = document.getElementById('adminInspirationId')?.value;
       if (!templateId) {
           alert('No template ID found. Cannot update template.');
           return;
       }

       if (!artboard) {
           alert('Cannot update template without an Artboard defined.');
           return;
       }

       // Get the existing template to preserve its name and admin data
       let existingTemplate = null;
       try {
           console.log('[UpdateTemplate] Fetching existing template...');
           const templateResponse = await fetch(`/api/design-templates/${templateId}`);
           if (templateResponse.ok) {
               existingTemplate = await templateResponse.json();
               console.log('[UpdateTemplate] Existing template found:', existingTemplate.name);
           }
       } catch (e) {
           console.warn('[UpdateTemplate] Could not fetch existing template:', e);
       }

       // Use the same logic as save template but with PUT method
       const adminData = {
           imageUrl: document.getElementById('adminImageUrl')?.value || '',
           model: document.getElementById('adminModel')?.value || '',
           prompt: document.getElementById('adminPrompt')?.value || '',
           palette: document.getElementById('adminPalette')?.value || '',
           backgroundType: document.getElementById('backgroundType')?.value || 'light',
           originalPalette: document.getElementById('adminOriginalPalette')?.value || '',
           originalObject: document.getElementById('adminOriginalObject')?.value || '',
           fontStylesList: window.fontStylesList || [], // Added for Font Styles functionality
           decorStylesList: window.decorStylesList || [], // Added for Decor Styles functionality
           cssFilterState: captureCSSFilterState() || {}, // Added for CSS Filters functionality
           duotoneState: captureDuotoneState() || {}, // Added for Duotone Effects functionality
           glitchState: captureGlitchState() || {}, // Added for Glitch Effects functionality
           halftoneState: captureHalftoneState() || {} // Added for Halftone Effects functionality
       };

       // Force a canvas redraw to ensure all changes are reflected
       console.log('[UpdateTemplate] Forcing canvas redraw before preview generation...');
       update();

       // Small delay to ensure redraw is complete
       await new Promise(resolve => setTimeout(resolve, 100));

       // Wait for all images to load before generating preview (same as save template)
       console.log('[UpdateTemplate] Checking image loading status...');
       const imageObjects = canvasObjects.filter(obj => obj.type === 'image');
       console.log('[UpdateTemplate] Found', imageObjects.length, 'image objects');

       const imageLoadPromises = [];

       imageObjects.forEach(obj => {
           console.log(`[UpdateTemplate] Checking image loading for object ${obj.id}`);
           console.log(`[UpdateTemplate] Image object ${obj.id} has image property:`, !!obj.image);

           if (obj.image) {
               console.log(`[UpdateTemplate] Image object ${obj.id} image.complete:`, obj.image.complete);
               console.log(`[UpdateTemplate] Image object ${obj.id} image.naturalWidth:`, obj.image.naturalWidth);
               console.log(`[UpdateTemplate] Image object ${obj.id} image.naturalHeight:`, obj.image.naturalHeight);

               if (!obj.image.complete || obj.image.naturalWidth === 0) {
                   console.log(`[UpdateTemplate] Image ${obj.id} is NOT fully loaded, creating load promise...`);

                   const promise = new Promise((resolve) => {
                       const checkLoaded = () => {
                           if (obj.image.complete && obj.image.naturalWidth > 0) {
                               console.log(`[UpdateTemplate] Image ${obj.id} is now loaded (${obj.image.naturalWidth}x${obj.image.naturalHeight})`);
                               resolve();
                           } else {
                               console.log(`[UpdateTemplate] Image ${obj.id} still loading, setting up event listeners...`);
                               obj.image.onload = () => {
                                   console.log(`[UpdateTemplate] Image ${obj.id} finished loading via onload event`);
                                   resolve();
                               };
                               obj.image.onerror = () => {
                                   console.log(`[UpdateTemplate] Image ${obj.id} failed to load via onerror event`);
                                   resolve(); // Continue anyway
                               };

                               // Timeout after 5 seconds
                               setTimeout(() => {
                                   console.log(`[UpdateTemplate] Image ${obj.id} load timeout, continuing anyway`);
                                   resolve();
                               }, 5000);
                           }
                       };

                       // Check immediately, then after a small delay
                       setTimeout(checkLoaded, 10);
                   });
                   imageLoadPromises.push(promise);
               } else {
                   console.log(`[UpdateTemplate] Image ${obj.id} is already loaded (${obj.image.naturalWidth}x${obj.image.naturalHeight})`);
               }
           } else {
               console.log(`[UpdateTemplate] Image object ${obj.id} has no image property`);
           }
       });

       if (imageLoadPromises.length > 0) {
           console.log(`[UpdateTemplate] Waiting for ${imageLoadPromises.length} images to load...`);
           await Promise.all(imageLoadPromises);
           console.log('[UpdateTemplate] All images loaded, generating preview...');
       } else {
           console.log('[UpdateTemplate] All images already loaded');
       }

       // Generate Preview Image (HIGH RESOLUTION for better modal display)
       const exportCanvas = document.createElement('canvas');
       const previewWidth = 800; // Increased from 300 to 800 for better definition
       const previewHeight = artboard.height * (previewWidth / artboard.width);
       exportCanvas.width = previewWidth;
       exportCanvas.height = previewHeight;
       const exportCtx = exportCanvas.getContext('2d');

       // TEMPLATE PREVIEW: Fill with canvas background color (unlike Add to Collection which uses transparent)
       exportCtx.fillStyle = canvasBackgroundColor || '#ffffff';
       exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
       console.log('[UpdateTemplate] Template preview background set to:', canvasBackgroundColor || '#ffffff');

       exportCtx.save();
       // Scale the drawing to fit the preview canvas
       exportCtx.scale(previewWidth / artboard.width, previewHeight / artboard.height);
       // Translate context so drawing happens relative to artboard's top-left
       exportCtx.translate(-artboard.x, -artboard.y);

       // Draw objects onto exportCtx (using exact same logic as save template)
       for (let index = 0; index < canvasObjects.length; index++) {
           const obj = canvasObjects[index];
           const bounds = calculateObjectBounds(obj); // Check bounds relative to original artboard
            if (bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
               bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height) {

               // Skip drawing mask shapes that are being used as masks (they should be invisible)
               if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                   console.log('[UpdateTemplate] 🎭 Skipping drawing of mask shape in template preview:', obj.id);
                   continue; // Skip this object
               }

               if (obj.type === 'text') {
                   drawTextObject(obj, exportCtx);
               } else if (obj.type === 'image') {
                   console.log('[UpdateTemplate] 🎨 Drawing image object with UNIFIED effects pipeline');
                   // Use the unified effects pipeline from the HTML file
                   if (typeof window.drawImageObject === 'function') {
                       await window.drawImageObject(obj, exportCtx);
                   } else {
                       // Fallback to basic drawing if unified pipeline not available
                       drawImageObject(obj, exportCtx);
                   }
               }
           }
       }
       exportCtx.restore();

       const previewDataUrl = exportCanvas.toDataURL('image/png');

       // Prepare serializable objects (same logic as save)
       const serializableObjects = canvasObjects.map((obj, index) => {
           const cleanObj = cleanObjectForSerialization(obj);
           cleanObj.layerOrder = index;
           cleanObj.zIndex = index;
           return cleanObj;
       });

       // Prepare editor state
       const editorState = {
           canvasBackgroundColor: canvasBackgroundColor,
           zoom: { scale: scale, offsetX: offsetX, offsetY: offsetY },
           nextId: nextId,
           editorSettings: {}
       };

       // Use the stored template name or fallback to existing template name
       const templateName = currentTemplateName || existingTemplate?.name || 'Updated Template';
       console.log('[UpdateTemplate] Using template name:', templateName);

       // SIMPLE APPROACH: Create new template and delete old one
       try {
           console.log('[UpdateTemplate] Creating new template to replace old one...');

           // Store the original template ID
           const originalTemplateId = templateId;

           // Clear the template ID temporarily to create a new template
           document.getElementById('adminInspirationId').value = '';

           // Set a global variable to pass the template name to handleSaveTemplate
           window.predefinedTemplateName = templateName;
           console.log('[UpdateTemplate] Set predefined template name:', templateName);

           // Call the regular save template function (creates new template)
           await handleSaveTemplate();

           // Clear the predefined name after use
           delete window.predefinedTemplateName;

           // After successful creation, delete the old template
           console.log('[UpdateTemplate] Deleting old template:', originalTemplateId);
           try {
               const deleteResponse = await fetch(`/api/design-templates/${originalTemplateId}`, {
                   method: 'DELETE'
               });

               if (deleteResponse.ok) {
                   console.log('[UpdateTemplate] Old template deleted successfully');
               } else {
                   console.warn('[UpdateTemplate] Failed to delete old template, but new template was created');
               }
           } catch (deleteError) {
               console.warn('[UpdateTemplate] Error deleting old template:', deleteError);
               // Don't fail the update if deletion fails
           }

           // Show success message
           const message = `Template "${templateName}" updated successfully!\n\nA new version has been created and the old version has been removed.`;
           alert(message);

           // Try to post a message to other windows/tabs to refresh
           try {
               if (window.opener) {
                   window.opener.postMessage({
                       type: 'TEMPLATE_UPDATED',
                       templateId: originalTemplateId,
                       templateName: templateName,
                       action: 'replaced'
                   }, '*');
               }
               // Also broadcast to other tabs
               if (typeof BroadcastChannel !== 'undefined') {
                   const channel = new BroadcastChannel('template-updates');
                   channel.postMessage({
                       type: 'TEMPLATE_UPDATED',
                       templateId: originalTemplateId,
                       templateName: templateName,
                       action: 'replaced'
                   });
                   channel.close();
                   console.log('[UpdateTemplate] Broadcasted replacement notification to other tabs');
               }
           } catch (e) {
               console.log('[UpdateTemplate] Could not notify other windows:', e);
           }

       } catch (e) {
           console.error('[UpdateTemplate] Error replacing template:', e);
           alert(`Error updating template: ${e.message}`);
           // Restore the original template ID
           document.getElementById('adminInspirationId').value = templateId;
       }
   }

   // --- Save As New Template Logic ---
   async function handleSaveAsTemplate() {
       console.log('[SaveAsTemplate] Saving as new template...');

       // Clear the template ID to force creation of new template
       document.getElementById('adminInspirationId').value = '';

       // Call the regular save template function
       await handleSaveTemplate();

       // After successful save, the new template ID should be available
       // We could update the UI to reflect the new template, but for now just notify user
   }

   // --- Project Loading Logic ---
   async function loadProjectFromId(projectId) {
       console.log('[LoadProject] 🎯 FUNCTION CALLED - Loading project with ID:', projectId);

       try {
           console.log('[LoadProject] 🎯 Making API request to /api/projects/' + projectId);
           const response = await fetch(`/api/projects/${projectId}`);
           if (!response.ok) {
               throw new Error(`Failed to load project: ${response.statusText}`);
           }

           const project = await response.json();
           console.log('[LoadProject] 🎯 Project loaded from API:', project);
           console.log('[LoadProject] 🎯 Project adminData:', project.adminData);

           // Store project info for updates (both local and global)
           currentProjectId = project._id;
           currentProjectTitle = project.title;
           currentProjectFolderId = project.folderId;

           // IMPORTANT: Set on window object so left-menu.js can access them
           window.currentProjectId = currentProjectId;
           window.currentProjectTitle = currentProjectTitle;
           window.currentProjectFolderId = currentProjectFolderId;

           console.log('[LoadProject] Stored project info:', {
               id: currentProjectId,
               title: currentProjectTitle,
               folderId: currentProjectFolderId
           });

           console.log('[LoadProject] ===== GLOBAL VARIABLES SET =====');
           console.log('[LoadProject] window.currentProjectId:', window.currentProjectId);
           console.log('[LoadProject] window.currentProjectTitle:', window.currentProjectTitle);
           console.log('[LoadProject] window.currentProjectFolderId:', window.currentProjectFolderId);

           // Load the project data into the editor
           await loadProjectData(project);

           // Update the left menu to show save options
           updateProjectSaveButtons(true);

       } catch (error) {
           console.error('[LoadProject] Error loading project:', error);
           alert(`Error loading project: ${error.message}`);
       }
   }



   // --- Project Save Button Management ---
   function updateProjectSaveButtons(hasProject) {
       console.log('[ProjectButtons] Updating project save buttons, hasProject:', hasProject);

       // This will be handled in left-menu.js
       // We'll dispatch an event to notify the left menu
       const event = new CustomEvent('projectLoaded', {
           detail: {
               hasProject: hasProject,
               projectId: currentProjectId,
               projectTitle: currentProjectTitle,
               folderId: currentProjectFolderId
           }
       });

       document.dispatchEvent(event);
   }

   // --- Update Existing Project Logic ---
   async function handleUpdateProject() {
       console.log('[UpdateProject] Updating existing project...');

       if (!currentProjectId) {
           alert('No project ID found. Cannot update project.');
           return;
       }

       if (!artboard) {
           alert('Cannot update project without an Artboard defined.');
           return;
       }

       try {
           console.log('[UpdateProject] Creating new project to replace old one...');

           // 🔧 CRITICAL FIX: Set flag to prevent CSS filter restoration during update
           window._isProjectUpdate = true;
           console.log('[UpdateProject] 🔧 Set project update flag to preserve current CSS filter state');

           // Store the original project info
           const originalProjectId = currentProjectId;
           const originalProjectTitle = currentProjectTitle;
           const originalProjectFolderId = currentProjectFolderId;

           // Clear the current project info temporarily to create a new project
           currentProjectId = null;
           currentProjectTitle = null;
           currentProjectFolderId = null;

           // Also clear global variables
           window.currentProjectId = null;
           window.currentProjectTitle = null;
           window.currentProjectFolderId = null;

           console.log('[UpdateProject] ===== CREATING NEW PROJECT DIRECTLY =====');
           console.log('[UpdateProject] Title:', originalProjectTitle);
           console.log('[UpdateProject] FolderId:', originalProjectFolderId);

           // Create the project data directly without going through the modal
           const projectData = await createProjectDataDirectly(originalProjectTitle, originalProjectFolderId);

           // Save the project directly to the API
           const savedProject = await saveProjectDirectly(projectData);
           console.log('[UpdateProject] New project created:', savedProject);

           // After successful creation, delete the old project
           console.log('[UpdateProject] Deleting old project:', originalProjectId);
           try {
               const deleteResponse = await fetch(`/api/projects/${originalProjectId}`, {
                   method: 'DELETE'
               });

               if (deleteResponse.ok) {
                   console.log('[UpdateProject] Old project deleted successfully');
               } else {
                   console.warn('[UpdateProject] Failed to delete old project, but new project was created');
               }
           } catch (deleteError) {
               console.warn('[UpdateProject] Error deleting old project:', deleteError);
               // Don't fail the update if deletion fails
           }

           // Update the current project info to the new project
           currentProjectId = savedProject.id;
           currentProjectTitle = savedProject.title;
           currentProjectFolderId = savedProject.folderId;

           // Also update global variables
           window.currentProjectId = savedProject.id;
           window.currentProjectTitle = savedProject.title;
           window.currentProjectFolderId = savedProject.folderId;

           // 🎯 CRITICAL FIX: Don't reload project data - this clears effects temporarily
           // The editor already has the current state, and reloading causes effects to disappear
           console.log('[UpdateProject] Skipping project data reload to preserve effects...');

           // Update the project save buttons
           updateProjectSaveButtons(true);

           // Show success message
           const message = `Project "${originalProjectTitle}" updated successfully!\n\nThe editor has been refreshed with the latest version.`;
           alert(message);

           // 🔧 CRITICAL FIX: Clear project update flag
           window._isProjectUpdate = false;
           console.log('[UpdateProject] 🔧 Cleared project update flag');

       } catch (e) {
           console.error('[UpdateProject] Error replacing project:', e);
           alert(`Error updating project: ${e.message}`);

           // 🔧 CRITICAL FIX: Clear project update flag even on error
           window._isProjectUpdate = false;
           console.log('[UpdateProject] 🔧 Cleared project update flag (error case)');

           // Restore the original project info
           currentProjectId = originalProjectId;
           currentProjectTitle = originalProjectTitle;
           currentProjectFolderId = originalProjectFolderId;

           // Also restore global variables
           window.currentProjectId = originalProjectId;
           window.currentProjectTitle = originalProjectTitle;
           window.currentProjectFolderId = originalProjectFolderId;
       }
   }

   // --- Generate Artboard Preview Function ---
   async function generateArtboardPreview() {
       console.log('[GeneratePreview] Creating artboard-cropped preview...');

       if (!artboard) {
           throw new Error('Cannot generate preview without artboard');
       }

       // Create offscreen canvas for export (same logic as templates)
       const exportCanvas = document.createElement('canvas');
       exportCanvas.width = artboard.width;
       exportCanvas.height = artboard.height;
       const exportCtx = exportCanvas.getContext('2d');

       // Fill with background color
       exportCtx.fillStyle = canvasBackgroundColor || '#ffffff';
       exportCtx.fillRect(0, 0, artboard.width, artboard.height);

       // Save context state
       exportCtx.save();

       // Clip to artboard dimensions
       exportCtx.beginPath();
       exportCtx.rect(0, 0, artboard.width, artboard.height);
       exportCtx.clip();

       // Translate context so drawing happens relative to artboard's top-left
       exportCtx.translate(-artboard.x, -artboard.y);

       // Draw objects that are within the artboard
       canvasObjects.forEach((obj) => {
           // Basic check if object might be within artboard bounds
           const bounds = calculateObjectBounds(obj);
           if (bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
               bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height) {

               // Skip drawing mask shapes that are being used as masks (they should be invisible)
               if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                   console.log('[GeneratePreview] 🎭 Skipping drawing of mask shape:', obj.id);
                   return; // Skip this object
               }

               // Call drawing functions with exportCtx as the target
               if (obj.type === 'text') {
                   drawTextObject(obj, exportCtx);
               } else if (obj.type === 'image') {
                   drawImageObject(obj, exportCtx);
               }
           }
       });

       // Restore context state
       exportCtx.restore();

       const dataUrl = exportCanvas.toDataURL('image/png');
       console.log('[GeneratePreview] Artboard preview generated, length:', dataUrl.length);
       return dataUrl;
   }

   // --- Object Serialization Function ---
   function cleanObjectForSerialization(obj) {
       console.log(`[CleanObject] 🔧 ===== CLEANING OBJECT FOR SERIALIZATION =====`);
       console.log(`[CleanObject] 🔧 Object type: ${obj.type}, text: "${obj.text || 'N/A'}", effectMode: "${obj.effectMode || 'none'}"`);
       console.log(`[CleanObject] 🔧 Object has:`, {
           meshWarp: !!obj.meshWarp,
           gridDistort: !!obj.gridDistort,
           effectMode: obj.effectMode
       });

       // Create a clean copy without circular references (same as left-menu.js)
       const cleanObj = {};

       // Copy basic properties
       const basicProps = ['id', 'type', 'text', 'x', 'y', 'fontSize', 'fontFamily', 'color', 'bold', 'italic',
                          'rotation', 'scale', 'opacity', 'letterSpacing', 'effectMode', 'skewX', 'skewY',
                          'layerOrder', 'zIndex', 'templateId', 'generationId', 'isFromGeneration', 'newColorIntensity'];

       basicProps.forEach(prop => {
           if (obj.hasOwnProperty(prop)) {
               cleanObj[prop] = obj[prop];
           }
       });

       // Copy decoration properties for text objects
       if (obj.type === 'text') {
           const decorationProps = [
               'decorationMode', 'strokeMode', 'shadowMode',
               // Horizontal Lines decoration
               'hLineWeight', 'hLineDist', 'hLineColor', 'hLineOpacity', 'hLineCoverage',
               // Color Cut decoration
               'ccDist', 'ccColor', 'ccOpacity', 'ccFillDir', 'ccCoverage',
               // Oblique Lines decoration
               'oLineWeight', 'oLineDist', 'oLineColor', 'oOpacity', 'oCoverage',
               // Fading Lines decoration
               'flcDist', 'flcDir', 'flcColor', 'flcOpacity', 'flcWeight', 'flcSpacing', 'flcCoverage',
               // Stroke properties
               'strokeWidth', 'strokeColor', 'strokeOpacity',
               // Shadow properties
               'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'shadowBlur',
               // Other text properties
               'curveAmount', 'curveKerning', 'curveFlip', 'diameter', 'kerning', 'flip'
           ];

           decorationProps.forEach(prop => {
               if (obj.hasOwnProperty(prop)) {
                   cleanObj[prop] = obj[prop];
               }
           });
       }

       // Copy image-specific properties
       if (obj.type === 'image') {
           if (obj.imageUrl) cleanObj.imageUrl = obj.imageUrl;
           if (obj.src) cleanObj.src = obj.src;
           if (obj.width !== undefined) cleanObj.width = obj.width;
           if (obj.height !== undefined) cleanObj.height = obj.height;

           // 🎭 PRESERVE MASKING PROPERTIES FOR IMAGES
           if (obj.isMasked !== undefined) {
               cleanObj.isMasked = obj.isMasked;
               console.log(`[CreateProjectDirect] 🎭 Preserved isMasked=${obj.isMasked} for object ${obj.id}`);
           }
           if (obj.maskShapeId !== undefined) {
               cleanObj.maskShapeId = obj.maskShapeId;
               console.log(`[CreateProjectDirect] 🎭 Preserved maskShapeId=${obj.maskShapeId} for object ${obj.id}`);
           }
           if (obj.isMaskShape !== undefined) {
               cleanObj.isMaskShape = obj.isMaskShape;
               console.log(`[CreateProjectDirect] 🎭 Preserved isMaskShape=${obj.isMaskShape} for object ${obj.id}`);
           }
           if (obj.isVisible !== undefined) {
               cleanObj.isVisible = obj.isVisible;
               console.log(`[CreateProjectDirect] 🎭 Preserved isVisible=${obj.isVisible} for object ${obj.id}`);
           }
       }

       // Handle text-specific effect data (Grid Distort and Mesh Warp)
       if (obj.type === 'text') {

           // 🔧 GRID DISTORT SAVE - Save Grid Distort data separately from Mesh Warp
           if (obj.effectMode === 'grid-distort') {
               console.log(`[GridDistortSave] 🔧 ===== STARTING GRID DISTORT SAVE =====`);
               console.log(`[GridDistortSave] 🔧 Object details:`, {
                   text: obj.text,
                   effectMode: obj.effectMode,
                   hasGridDistort: !!obj.gridDistort,
                   hasMeshWarp: !!obj.meshWarp
               });

               // Save Grid Distort specific properties
               if (obj.gridDistortCols !== undefined) {
                   cleanObj.gridDistortCols = obj.gridDistortCols;
                   console.log(`[GridDistortSave] 🔧 Saved gridDistortCols: ${obj.gridDistortCols}`);
               }
               if (obj.gridDistortRows !== undefined) {
                   cleanObj.gridDistortRows = obj.gridDistortRows;
                   console.log(`[GridDistortSave] 🔧 Saved gridDistortRows: ${obj.gridDistortRows}`);
               }
               if (obj.gridDistortPadding !== undefined) {
                   cleanObj.gridDistortPadding = obj.gridDistortPadding;
                   console.log(`[GridDistortSave] 🔧 Saved gridDistortPadding: ${obj.gridDistortPadding}`);
               }
               if (obj.gridDistortIntensity !== undefined) {
                   cleanObj.gridDistortIntensity = obj.gridDistortIntensity;
                   console.log(`[GridDistortSave] 🔧 Saved gridDistortIntensity: ${obj.gridDistortIntensity}`);
               }
               if (obj.gridDistortVerticalOnly !== undefined) {
                   cleanObj.gridDistortVerticalOnly = obj.gridDistortVerticalOnly;
                   console.log(`[GridDistortSave] 🔧 Saved gridDistortVerticalOnly: ${obj.gridDistortVerticalOnly}`);
               }

               // Save the complete Grid Distort object with control points
               if (obj.gridDistort) {
                   console.log(`[GridDistortSave] 🔧 Found gridDistort object, analyzing...`);
                   console.log(`[GridDistortSave] 🔧 gridDistort structure:`, {
                       gridCols: obj.gridDistort.gridCols,
                       gridRows: obj.gridDistort.gridRows,
                       gridPadding: obj.gridDistort.gridPadding,
                       intensity: obj.gridDistort.intensity,
                       showGrid: obj.gridDistort.showGrid,
                       lastText: obj.gridDistort.lastText,
                       lastFontSize: obj.gridDistort.lastFontSize,
                       verticalOnly: obj.gridDistort.verticalOnly,
                       controlPointsLength: obj.gridDistort.controlPoints ? obj.gridDistort.controlPoints.length : 0,
                       relativeControlPointsLength: obj.gridDistort.relativeControlPoints ? obj.gridDistort.relativeControlPoints.length : 0,
                       hasGridBounds: !!obj.gridDistort.gridBounds
                   });

                   cleanObj.gridDistortData = {
                       gridCols: obj.gridDistort.gridCols || 3,
                       gridRows: obj.gridDistort.gridRows || 2,
                       gridPadding: obj.gridDistort.gridPadding || 120,
                       intensity: obj.gridDistort.intensity || 1,
                       showGrid: obj.gridDistort.showGrid || false,
                       lastText: obj.gridDistort.lastText || obj.text,
                       lastFontSize: obj.gridDistort.lastFontSize || obj.fontSize,
                       verticalOnly: obj.gridDistort.verticalOnly || false,

                       // Critical: Save the control points that define the distortion
                       controlPoints: obj.gridDistort.controlPoints ?
                           obj.gridDistort.controlPoints.map(row =>
                               row.map(point => ({ x: point.x, y: point.y }))
                           ) : [],

                       // Critical: Save the relative control points for preserving distortion
                       relativeControlPoints: obj.gridDistort.relativeControlPoints ?
                           obj.gridDistort.relativeControlPoints.map(row =>
                               row.map(point => ({ x: point.x, y: point.y }))
                           ) : [],

                       // Save grid bounds for proper restoration
                       gridBounds: obj.gridDistort.gridBounds ? {
                           width: obj.gridDistort.gridBounds.width,
                           height: obj.gridDistort.gridBounds.height,
                           padding: obj.gridDistort.gridBounds.padding
                       } : null
                   };

                   console.log(`[GridDistortSave] 🔧 ✅ Successfully created gridDistortData:`, {
                       controlPointsCount: cleanObj.gridDistortData.controlPoints.length,
                       relativeControlPointsCount: cleanObj.gridDistortData.relativeControlPoints.length,
                       hasGridBounds: !!cleanObj.gridDistortData.gridBounds,
                       gridCols: cleanObj.gridDistortData.gridCols,
                       gridRows: cleanObj.gridDistortData.gridRows
                   });

                   // Log the actual control points for debugging
                   if (cleanObj.gridDistortData.relativeControlPoints.length > 0) {
                       console.log(`[GridDistortSave] 🔧 Relative control points sample:`, cleanObj.gridDistortData.relativeControlPoints[0]);
                   }

               } else {
                   console.log(`[GridDistortSave] 🔧 ❌ No gridDistort object found for text "${obj.text}"`);
                   console.log(`[GridDistortSave] 🔧 Object properties:`, Object.keys(obj));
               }

               // Do NOT save meshWarp data for Grid Distort objects
               console.log(`[GridDistortSave] 🔧 Skipping meshWarp data for Grid Distort object`);
               console.log(`[GridDistortSave] 🔧 ===== FINISHED GRID DISTORT SAVE =====`);
           }

           // IMPORTANT: Only save effect data that matches the current effectMode
           // This prevents Grid Distort objects from having Mesh Warp data and vice versa

           if (obj.effectMode === 'grid-distort') {
               // Handle Grid Distort properties ONLY for grid-distort effect mode
               if (obj.gridDistortCols !== undefined) cleanObj.gridDistortCols = obj.gridDistortCols;
               if (obj.gridDistortRows !== undefined) cleanObj.gridDistortRows = obj.gridDistortRows;
               if (obj.gridDistortPadding !== undefined) cleanObj.gridDistortPadding = obj.gridDistortPadding;
               if (obj.gridDistortIntensity !== undefined) cleanObj.gridDistortIntensity = obj.gridDistortIntensity;
               if (obj.gridDistortVerticalOnly !== undefined) cleanObj.gridDistortVerticalOnly = obj.gridDistortVerticalOnly;

               // Handle Grid Distort object with control points
               if (obj.gridDistort) {
                   cleanObj.gridDistort = {
                       gridCols: obj.gridDistort.gridCols,
                       gridRows: obj.gridDistort.gridRows,
                       gridPadding: obj.gridDistort.gridPadding,
                       intensity: obj.gridDistort.intensity,
                       showGrid: obj.gridDistort.showGrid,
                       lastText: obj.gridDistort.lastText,
                       lastFontSize: obj.gridDistort.lastFontSize,
                       verticalOnly: obj.gridDistort.verticalOnly,
                       // Deep copy control points
                       controlPoints: obj.gridDistort.controlPoints ?
                           obj.gridDistort.controlPoints.map(row =>
                               row.map(point => ({ x: point.x, y: point.y }))
                           ) : [],
                       // Deep copy relative control points (critical for preserving distortion)
                       relativeControlPoints: obj.gridDistort.relativeControlPoints ?
                           obj.gridDistort.relativeControlPoints.map(row =>
                               row.map(point => ({ x: point.x, y: point.y }))
                           ) : [],
                       // Copy grid bounds if available
                       gridBounds: obj.gridDistort.gridBounds ? {
                           width: obj.gridDistort.gridBounds.width,
                           height: obj.gridDistort.gridBounds.height,
                           padding: obj.gridDistort.gridBounds.padding
                       } : null
                   };
                   console.log(`[CleanObject] Preserved Grid Distort data for text "${obj.text}":`, {
                       effectMode: obj.effectMode,
                       controlPointsCount: cleanObj.gridDistort.controlPoints.length,
                       relativeControlPointsCount: cleanObj.gridDistort.relativeControlPoints.length,
                       hasGridBounds: !!cleanObj.gridDistort.gridBounds
                   });
               }
               // DO NOT save meshWarp data for grid-distort objects

           } else if (obj.effectMode === 'mesh') {
               // Handle Mesh Warp properties ONLY for mesh effect mode
               console.log(`[MeshWarpSave] 🔧 Saving Mesh Warp data for text "${obj.text}"`);

               if (obj.meshWarp) {
                   cleanObj.meshWarp = {
                       controlPoints: obj.meshWarp.controlPoints ? obj.meshWarp.controlPoints.map(p => ({ ...p })) : [],
                       initialControlPoints: obj.meshWarp.initialControlPoints ? obj.meshWarp.initialControlPoints.map(p => ({ ...p })) : [],
                       relativeControlPoints: obj.meshWarp.relativeControlPoints ? obj.meshWarp.relativeControlPoints.map(p => ({ ...p })) : [],
                       hasCustomDistortion: obj.meshWarp.hasCustomDistortion || false,
                       showGrid: obj.meshWarp.showGrid !== undefined ? obj.meshWarp.showGrid : true,
                       gridRect: obj.meshWarp.gridRect ? { ...obj.meshWarp.gridRect } : null,
                       initialized: obj.meshWarp.initialized || false
                   };
                   console.log(`[MeshWarpSave] 🔧 Saved Mesh Warp data:`, {
                       effectMode: obj.effectMode,
                       controlPointsCount: cleanObj.meshWarp.controlPoints.length,
                       hasCustomDistortion: cleanObj.meshWarp.hasCustomDistortion
                   });
               } else {
                   console.log(`[MeshWarpSave] 🔧 No meshWarp object found for text "${obj.text}"`);
               }

               // Do NOT save gridDistortData for Mesh Warp objects
               console.log(`[MeshWarpSave] 🔧 Skipping gridDistortData for Mesh Warp object`);

           } else {
               // For other effect modes (none, curve, skew, etc.), don't save either effect data
               console.log(`[CleanObject] Text "${obj.text}" has effectMode "${obj.effectMode}" - not saving Grid Distort or Mesh Warp data`);
           }
       }

       // Remove any circular references or handlers
       delete cleanObj._meshWarpHandler;
       delete cleanObj.isSelected;
       delete cleanObj.image; // Remove actual Image object
       delete cleanObj.maskShape; // Remove runtime mask shape reference (but keep maskShapeId)

       console.log(`[CleanObject] 🔧 ===== SERIALIZATION COMPLETE =====`);
       console.log(`[CleanObject] 🔧 Final cleaned object for "${cleanObj.text || cleanObj.type}":`, {
           type: cleanObj.type,
           effectMode: cleanObj.effectMode,
           hasGridDistortData: !!cleanObj.gridDistortData,
           hasMeshWarp: !!cleanObj.meshWarp,
           hasGridDistort: !!cleanObj.gridDistort
       });

       return cleanObj;
   }

   // --- Direct Project Creation Functions ---
   async function createProjectDataDirectly(title, folderId) {
       console.log('[CreateProjectDirect] Creating project data directly...');

       if (!artboard) {
           throw new Error('Cannot create project without an Artboard defined.');
       }

       // 🎯 CRITICAL FIX: Force effect re-rendering before preview capture (same as left-menu.js)
       console.log('[CreateProjectDirect] 🎨 Forcing effect re-rendering before preview...');

       // 🎯 CRITICAL FIX: Apply effects to ALL images, not just selected ones
       console.log('[CreateProjectDirect] 🎨 Applying effects to ALL images for preview...');

       // Store current selection states
       const originalSelections = canvasObjects.map(obj => obj.isSelected);
       const originalSelectedIndex = selectedObjectIndex;

       // Clear all selections first
       canvasObjects.forEach(obj => obj.isSelected = false);

       // Apply effects to each image object
       canvasObjects.forEach((obj, index) => {
           if (obj.type === 'image') {
               console.log(`[CreateProjectDirect] 🎨 Applying effects to image ${index}...`);

               // Temporarily select this image (both ways for compatibility)
               obj.isSelected = true;
               selectedObjectIndex = index;

               // Apply all effects to this image
               if (typeof window.applyImageFilters === 'function') {
                   console.log(`[CreateProjectDirect] 🎨 Applying CSS filters to image ${index}...`);
                   window.applyImageFilters();
               }

               if (typeof window.applyDuotoneEffect === 'function') {
                   console.log(`[CreateProjectDirect] 🎨 Applying duotone effect to image ${index}...`);
                   window.applyDuotoneEffect();
               }

               if (typeof window.applyGlinchEffects === 'function') {
                   console.log(`[CreateProjectDirect] 🎨 Applying glitch effects to image ${index}...`);
                   window.applyGlinchEffects();
               }

               // Clear selection after applying effects
               obj.isSelected = false;
           }
       });

       // Restore original selection states
       canvasObjects.forEach((obj, index) => {
           obj.isSelected = originalSelections[index];
       });
       selectedObjectIndex = originalSelectedIndex;
       console.log('[CreateProjectDirect] 🎨 Effects applied to all images, selections restored');

       // Force main canvas update
       if (typeof window.update === 'function') {
           window.update();
           console.log('[CreateProjectDirect] 🎨 Canvas updated via window.update()');
       } else if (typeof window.redrawCanvas === 'function') {
           window.redrawCanvas();
           console.log('[CreateProjectDirect] 🎨 Canvas updated via window.redrawCanvas()');
       }

       // Wait for effects to render
       console.log('[CreateProjectDirect] 🎨 Waiting for effects to render...');
       await new Promise(resolve => setTimeout(resolve, 1500));

       // Generate preview image cropped to artboard (same logic as templates)
       const previewDataUrl = await generateArtboardPreview();

       // Upload preview image
       const blob = await (await fetch(previewDataUrl)).blob();
       const formData = new FormData();
       formData.append('image', blob, 'project_preview.png');

       const uploadResponse = await fetch('/api/images/upload', {
           method: 'POST',
           body: formData
       });

       if (!uploadResponse.ok) {
           throw new Error(`Preview upload failed: ${uploadResponse.statusText}`);
       }

       const uploadResult = await uploadResponse.json();
       const previewImageUrl = uploadResult.imageUrl || uploadResult.url || uploadResult.fileUrl;

       // Prepare serializable objects
       console.log('[CreateProjectDirect] Current canvasObjects count:', canvasObjects.length);
       console.log('[CreateProjectDirect] Objects being saved:', canvasObjects.map(obj => ({ type: obj.type, text: obj.text, id: obj.id })));

       // 🎭 CRITICAL FIX: Remove duplicate objects before saving (SAME AS left-menu.js)
       console.log('[CreateProjectDirect] 🎭 DUPLICATE CHECK - Checking for duplicate objects...');
       const uniqueObjects = [];
       const seenIds = new Set();

       canvasObjects.forEach((obj, index) => {
           console.log(`[CreateProjectDirect] Object ${index}: type=${obj.type}, text="${obj.text || obj.imageUrl || 'N/A'}", id=${obj.id}`);

           // Check for duplicates by ID and type
           const objectKey = `${obj.id}-${obj.type}-${obj.imageUrl}`;
           if (!seenIds.has(objectKey)) {
               seenIds.add(objectKey);
               uniqueObjects.push(obj);
               console.log(`[CreateProjectDirect] 🎭 ✅ Object ${index} added (unique)`);
           } else {
               console.warn(`[CreateProjectDirect] 🎭 ⚠️ Object ${index} is duplicate, skipping:`, {
                   id: obj.id,
                   type: obj.type,
                   imageUrl: obj.imageUrl?.substring(0, 50) + '...'
               });
           }
       });

       console.log(`[CreateProjectDirect] 🎭 DUPLICATE CHECK COMPLETE: ${canvasObjects.length} -> ${uniqueObjects.length} objects`);

       // Use unique objects for serialization
       const objectsToSerialize = uniqueObjects;

       const serializableObjects = objectsToSerialize.map((obj, index) => {
           const cleanObj = cleanObjectForSerialization(obj);
           cleanObj.layerOrder = index;
           cleanObj.zIndex = index;
           return cleanObj;
       });

       // Prepare editor state
       const editorState = {
           canvasBackgroundColor: canvasBackgroundColor || '#ffffff',
           zoom: {
               scale: scale || 1.0,
               offsetX: offsetX || 0,
               offsetY: offsetY || 0
           },
           selectedObjectIndex: selectedObjectIndex || -1,
           nextId: nextId || 0,
           editorSettings: {
               lastUpdateTimestamp: Date.now()
           }
       };

       // Validate artboard
       const validatedArtboard = {
           x: typeof artboard.x === 'number' ? artboard.x : 0,
           y: typeof artboard.y === 'number' ? artboard.y : 0,
           width: typeof artboard.width === 'number' ? artboard.width : 600,
           height: typeof artboard.height === 'number' ? artboard.height : 600
       };

       // 🎯 CRITICAL FIX: Capture effect states (same as left-menu.js)
       console.log('[CreateProjectDirect] 🎨 Capturing effect states...');

       // Capture CSS filter state
       const cssFilterState = window.captureCSSFilterState ? window.captureCSSFilterState() : (window.cssFilterState || {});
       console.log('[CreateProjectDirect] 🎨 CSS filter state captured:', cssFilterState);

       // Capture duotone state
       const duotoneState = window.captureDuotoneState ? window.captureDuotoneState() : {};
       console.log('[CreateProjectDirect] 🎨 Duotone state captured:', duotoneState);

       // Capture glitch state
       const glitchState = window.captureGlitchState ? window.captureGlitchState() : {};
       console.log('[CreateProjectDirect] 🎨 Glitch state captured:', glitchState);

       const projectData = {
           title: title,
           description: '',
           editorState: editorState,
           adminData: window.adminData || {},
           previewImageUrl: previewImageUrl,
           artboard: validatedArtboard,
           canvasObjects: serializableObjects,
           folderId: folderId,
           status: 'draft',
           // 🎯 ADD: Store font/decor styles at top-level (same as left-menu.js pattern)
           fontStylesList: window.fontStylesList || [],
           decorStylesList: window.decorStylesList || [],
           // 🎯 ADD: Store effect states (same as left-menu.js pattern)
           cssFilterState: cssFilterState,
           duotoneState: duotoneState,
           glitchState: glitchState
       };

       console.log('[CreateProjectDirect] Project data created:', projectData);
       return projectData;
   }

   async function saveProjectDirectly(projectData) {
       console.log('[SaveProjectDirect] Saving project directly to API...');

       const response = await fetch('/api/projects', {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           credentials: 'include',
           body: JSON.stringify(projectData)
       });

       if (!response.ok) {
           const errorText = await response.text();
           throw new Error(`Failed to save project: ${response.status} - ${errorText}`);
       }

       const savedProject = await response.json();
       console.log('[SaveProjectDirect] Project saved successfully:', savedProject);
       return savedProject;
   }

   // Make project functions globally available
   window.handleUpdateProject = handleUpdateProject;
   window.loadProjectFromId = loadProjectFromId;
   window.createProjectDataDirectly = createProjectDataDirectly;
   window.saveProjectDirectly = saveProjectDirectly;

   // SVG Export Function
   async function generateSVGFromCanvas() {
       if (!artboard) {
           throw new Error('No artboard defined');
       }

       console.log('[SVG Export] Starting SVG generation...');

       // Create SVG element
       const svgNS = "http://www.w3.org/2000/svg";
       const svg = document.createElementNS(svgNS, "svg");

       // Use rounded dimensions like PNG export for consistency
       const svgWidth = Math.round(artboard.width);
       const svgHeight = Math.round(artboard.height);

       svg.setAttribute("width", svgWidth);
       svg.setAttribute("height", svgHeight);
       svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
       svg.setAttribute("xmlns", svgNS);

       console.log(`[SVG Export] SVG dimensions: ${svgWidth}x${svgHeight} (rounded from ${artboard.width}x${artboard.height})`);

       // SVG exports have transparent background by default (like PNG exports)
       // No background rectangle is added, making the SVG transparent
       console.log('[SVG Export] Using transparent background for SVG export');

       // Process canvas objects within artboard bounds
       console.log('[SVG Export] Artboard bounds:', artboard);

       // REPLICATE PNG EXPORT FLOW: Process objects sequentially like PNG export
       for (const obj of canvasObjects) {
           const bounds = calculateObjectBounds(obj);
           const intersects = bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
               bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height;

           const adjustedX = obj.x - artboard.x;
           const adjustedY = obj.y - artboard.y;

           console.log(`[SVG Export] Object ${obj.id} (${obj.type}):`, {
               bounds: bounds,
               intersects: intersects,
               position: { x: obj.x, y: obj.y },
               adjustedPosition: { x: adjustedX, y: adjustedY },
               artboardPos: { x: artboard.x, y: artboard.y },
               exportSVGSize: { width: artboard.width, height: artboard.height }
           });

           // Check if object intersects with artboard (same logic as PNG)
           if (intersects) {
               // Skip drawing mask shapes that are invisible (same as PNG)
               if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                   console.log('[SVG Export] Skipping mask shape:', obj.id);
                   continue;
               }

               console.log(`[SVG Export] Drawing ${obj.type} object:`, obj.id);
               console.log(`[SVG Export] Adjusted coordinates: x=${adjustedX}, y=${adjustedY} (SVG: ${artboard.width}x${artboard.height})`);

               // Create a copy of the object with adjusted coordinates (same as PNG)
               const adjustedObj = { ...obj };
               adjustedObj.x = adjustedX;
               adjustedObj.y = adjustedY;

               try {
                   if (obj.type === 'text') {
                       addTextToSVG(svg, adjustedObj, svgNS);
                   } else if (obj.type === 'image') {
                       await addImageToSVG(svg, adjustedObj, svgNS);
                   }
               } catch (error) {
                   console.warn('[SVG Export] Error adding object to SVG:', error, obj);
               }
           } else {
               console.log(`[SVG Export] Object ${obj.id} (${obj.type}) is outside artboard bounds - skipping`);
           }
       }

       // Convert SVG to string
       const serializer = new XMLSerializer();
       const svgString = serializer.serializeToString(svg);

       console.log('[SVG Export] SVG generated successfully, length:', svgString.length);
       return svgString;
   }

   // Add text object to SVG
   function addTextToSVG(svg, textObj, svgNS) {
       const textElement = document.createElementNS(svgNS, "text");

       // Use the already adjusted coordinates (no need to subtract artboard position again)
       const x = textObj.x;
       const y = textObj.y; // Use exact coordinates like PNG export - no baseline adjustment needed

       console.log(`[SVG Export] Text "${textObj.text}" - Final SVG coordinates: x=${x}, y=${y}, fontSize=${textObj.fontSize}`);
       console.log(`[SVG Export] Text object details:`, {
           inputX: textObj.x,
           inputY: textObj.y,
           finalSVGX: x,
           finalSVGY: y,
           fontSize: textObj.fontSize,
           text: textObj.text,
           fontFamily: textObj.fontFamily,
           color: textObj.color
       });

       // CRITICAL FIX: Replicate Canvas drawImage centering behavior
       // PNG export uses: translate(x, y) + drawImage(..., dx=-dw/2, dy=-dh/2, ...)
       // This centers the rasterized text around the translated position
       // SVG needs to replicate this centering behavior

       // Create temporary canvas to measure text dimensions (like PNG export does)
       const tempCanvas = document.createElement('canvas');
       const tempCtx = tempCanvas.getContext('2d');
       tempCtx.font = `${textObj.fontSize || 16}px ${textObj.fontFamily || 'Arial'}`;
       if (textObj.fontWeight && textObj.fontWeight !== 'normal') {
           tempCtx.font = `${textObj.fontWeight} ${tempCtx.font}`;
       }

       // Measure text to get dimensions (like PNG export metrics)
       const textMetrics = tempCtx.measureText(textObj.text);
       const textWidth = textMetrics.width;
       const textHeight = textObj.fontSize || 16;

       // Apply the same centering logic as PNG export: dx=-dw/2, dy=-dh/2
       const centerOffsetX = -textWidth / 2;
       const centerOffsetY = -textHeight / 2;

       // CRITICAL FIX: SVG text positioning should match PNG exactly
       // Using SVG dominant-baseline="central" to match Canvas textBaseline="middle"
       // Fine-tuned adjustment to perfectly align with Canvas rendering
       const svgBaselineAdjust = textHeight * 0.4; // Move down 40% of font size

       const finalX = x + centerOffsetX;
       const finalY = y + centerOffsetY + svgBaselineAdjust;

       console.log(`[SVG Export] CANVAS REPLICATION: Measured text ${textWidth}x${textHeight}`);
       console.log(`[SVG Export] CANVAS REPLICATION: Center offsets: (${centerOffsetX}, ${centerOffsetY})`);
       console.log(`[SVG Export] CANVAS REPLICATION: SVG baseline adjust: ${svgBaselineAdjust} (32% adjustment - FIXED FILE LOADED)`);
       console.log(`[SVG Export] CANVAS REPLICATION: Final position: (${finalX}, ${finalY})`);

       textElement.setAttribute("x", finalX);
       textElement.setAttribute("y", finalY);
       textElement.setAttribute("font-family", textObj.fontFamily || "Arial");
       textElement.setAttribute("font-size", textObj.fontSize || 16);
       textElement.setAttribute("fill", textObj.color || "#000000");

       // CRITICAL: Match Canvas textBaseline = "middle" behavior
       // Canvas textBaseline="middle" centers text at geometric center
       // SVG dominant-baseline="central" is closer to Canvas middle than "middle"
       textElement.setAttribute("dominant-baseline", "central");
       textElement.setAttribute("text-anchor", "start"); // Default to start like Canvas

       // Handle text styling
       if (textObj.fontWeight && textObj.fontWeight !== 'normal') {
           textElement.setAttribute("font-weight", textObj.fontWeight);
       }
       if (textObj.fontStyle && textObj.fontStyle !== 'normal') {
           textElement.setAttribute("font-style", textObj.fontStyle);
       }
       // Override text-anchor if textAlign is specified
       if (textObj.textAlign) {
           textElement.setAttribute("text-anchor",
               textObj.textAlign === 'center' ? 'middle' :
               textObj.textAlign === 'right' ? 'end' : 'start');
       }

       // Handle rotation
       if (textObj.rotation && textObj.rotation !== 0) {
           const centerX = x + (textObj.width || 0) / 2;
           const centerY = y - (textObj.fontSize || 16) / 2;
           textElement.setAttribute("transform", `rotate(${textObj.rotation} ${centerX} ${centerY})`);
       }

       // Add text content
       textElement.textContent = textObj.text || "";

       svg.appendChild(textElement);
       console.log('[SVG Export] Added text element:', textObj.text);
   }

   // Add image object to SVG
   async function addImageToSVG(svg, imageObj, svgNS) {
       // Use the already adjusted coordinates (no need to subtract artboard position again)
       const x = imageObj.x;
       const y = imageObj.y;

       // Calculate scaled dimensions
       const scaledWidth = imageObj.originalWidth * imageObj.scale;
       const scaledHeight = imageObj.originalHeight * imageObj.scale;

       // Set image source - try multiple possible sources
       let imageSrc = null;
       if (imageObj.image && imageObj.image.src) {
           imageSrc = imageObj.image.src;
       } else if (imageObj.src) {
           imageSrc = imageObj.src;
       } else if (imageObj.imageUrl) {
           imageSrc = imageObj.imageUrl;
       }

       if (!imageSrc) {
           console.warn('[SVG Export] No image source found for object:', imageObj.id);
           return;
       }

       console.log('[SVG Export] Processing image source:', imageSrc);
       console.log(`[SVG Export] Image "${imageObj.id}" - Adjusted coordinates: x=${x}, y=${y}, scaledWidth=${scaledWidth}, scaledHeight=${scaledHeight}`);
       console.log(`[SVG Export] Image object details:`, {
           originalX: imageObj.x,
           originalY: imageObj.y,
           adjustedX: x,
           adjustedY: y,
           originalWidth: imageObj.originalWidth,
           originalHeight: imageObj.originalHeight,
           scale: imageObj.scale
       });

       // Check if the source is an SVG file
       if (imageSrc.toLowerCase().endsWith('.svg')) {
           try {
               // Fetch the SVG content
               const response = await fetch(imageSrc);
               const svgContent = await response.text();

               // Parse the SVG content
               const parser = new DOMParser();
               const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
               const sourceSvg = svgDoc.documentElement;

               // Create a group to contain the embedded SVG
               const groupElement = document.createElementNS(svgNS, "g");

               // CRITICAL FIX: Apply PNG centering logic to SVG images
               // PNG uses: translate(x, y) + drawImage(..., -scaledWidth/2, -scaledHeight/2, ...)
               // SVG needs to replicate this centering behavior

               // Calculate center offsets (like PNG export does)
               const centerOffsetX = -scaledWidth / 2;
               const centerOffsetY = -scaledHeight / 2;

               // Apply transformations to the group with centering
               let transform = `translate(${x + centerOffsetX}, ${y + centerOffsetY})`;

               // Calculate scale factors
               const sourceWidth = parseFloat(sourceSvg.getAttribute('width')) || parseFloat(sourceSvg.getAttribute('viewBox')?.split(' ')[2]) || 100;
               const sourceHeight = parseFloat(sourceSvg.getAttribute('height')) || parseFloat(sourceSvg.getAttribute('viewBox')?.split(' ')[3]) || 100;
               const scaleX = scaledWidth / sourceWidth;
               const scaleY = scaledHeight / sourceHeight;

               transform += ` scale(${scaleX}, ${scaleY})`;

               // Handle rotation
               if (imageObj.rotation && imageObj.rotation !== 0) {
                   const centerX = sourceWidth / 2;
                   const centerY = sourceHeight / 2;
                   transform += ` rotate(${imageObj.rotation} ${centerX} ${centerY})`;
               }

               console.log(`[SVG Export] SVG IMAGE CENTERING: Applied center offsets (${centerOffsetX}, ${centerOffsetY}) to position (${x}, ${y})`);

               groupElement.setAttribute("transform", transform);

               // Copy all child elements from the source SVG
               for (const child of sourceSvg.children) {
                   const clonedChild = child.cloneNode(true);
                   groupElement.appendChild(clonedChild);
               }

               svg.appendChild(groupElement);
               console.log('[SVG Export] Added embedded SVG element:', imageObj.id);

           } catch (error) {
               console.error('[SVG Export] Failed to embed SVG:', error);
               // Fallback to image element
               addImageElementToSVG(svg, imageObj, svgNS, imageSrc, x, y, scaledWidth, scaledHeight);
           }
       } else {
           // For non-SVG images, use the image element
           addImageElementToSVG(svg, imageObj, svgNS, imageSrc, x, y, scaledWidth, scaledHeight);
       }
   }

   // Helper function to add regular image element
   function addImageElementToSVG(svg, imageObj, svgNS, imageSrc, x, y, scaledWidth, scaledHeight) {
       const imageElement = document.createElementNS(svgNS, "image");

       // CRITICAL FIX: Apply PNG centering logic to regular images too
       // PNG uses: translate(x, y) + drawImage(..., -scaledWidth/2, -scaledHeight/2, ...)
       const centerOffsetX = -scaledWidth / 2;
       const centerOffsetY = -scaledHeight / 2;

       imageElement.setAttribute("x", x + centerOffsetX);
       imageElement.setAttribute("y", y + centerOffsetY);
       imageElement.setAttribute("width", scaledWidth);
       imageElement.setAttribute("height", scaledHeight);

       console.log(`[SVG Export] REGULAR IMAGE CENTERING: Applied center offsets (${centerOffsetX}, ${centerOffsetY}) to position (${x}, ${y})`);

       // Handle rotation
       if (imageObj.rotation && imageObj.rotation !== 0) {
           const centerX = x + scaledWidth / 2;
           const centerY = y + scaledHeight / 2;
           imageElement.setAttribute("transform", `rotate(${imageObj.rotation} ${centerX} ${centerY})`);
       }

       imageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", imageSrc);
       svg.appendChild(imageElement);
       console.log('[SVG Export] Added image element:', imageObj.id);
   }
   // Setup export format dropdown
   let selectedExportFormat = 'png'; // Default format

   // Restore original functionality - main button does PNG export to collection
   document.getElementById('addToCollectionBtn').addEventListener('click', async (e) => {
       e.stopPropagation();
       console.log('[AddToCollection] Main button clicked - performing PNG export');
       // Hide modal if open
       hideExportModal();
       // Perform default PNG export to collection (original behavior)
       await performExportToCollection('png');
   });

   // New dropdown button for additional options
   document.getElementById('exportOptionsBtn').addEventListener('click', (e) => {
       e.stopPropagation();
       showExportModal();
   });

   function showExportModal() {
       const overlay = document.querySelector('.export-overlay');
       const dropdown = document.querySelector('.export-format-dropdown');

       // Show overlay and dropdown
       overlay.style.display = 'block';
       dropdown.style.display = 'block';

       // Trigger animation after display is set
       setTimeout(() => {
           overlay.classList.add('show');
           dropdown.classList.add('show');
       }, 10);
   }

   function hideExportModal() {
       const overlay = document.querySelector('.export-overlay');
       const dropdown = document.querySelector('.export-format-dropdown');

       overlay.classList.remove('show');
       dropdown.classList.remove('show');

       setTimeout(() => {
           overlay.style.display = 'none';
           dropdown.style.display = 'none';
       }, 300); // Wait for animation to complete
   }

   // Handle format selection
   document.querySelectorAll('.format-btn').forEach(btn => {
       btn.addEventListener('click', async (e) => {
           e.stopPropagation();
           const action = btn.getAttribute('data-format');

           // Update button appearance
           document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('selected'));
           btn.classList.add('selected');

           // Hide modal
           hideExportModal();

           // Determine action type
           if (action.startsWith('download-')) {
               const format = action.replace('download-', '');
               await performDirectDownload(format);
           } else {
               await performExportToCollection(action);
           }
       });
   });

   // Close modal when clicking overlay
   document.querySelector('.export-overlay').addEventListener('click', () => {
       hideExportModal();
   });

   // Close modal when clicking outside dropdown but not on overlay
   document.addEventListener('click', (e) => {
       if (!e.target.closest('.export-group') && !e.target.closest('.export-format-dropdown')) {
           const dropdown = document.querySelector('.export-format-dropdown');
           if (dropdown.classList.contains('show')) {
               hideExportModal();
           }
       }
   });

   // Main export function
   async function performExportToCollection(format) {
       console.log(`[AddToCollection] Starting export in ${format.toUpperCase()} format`);

       if (!artboard) {
           if (window.showToast) window.showToast('No Artboard defined', 'error');
           else alert('No Artboard defined');
           return;
       }

       let exportData;
       let filename;
       let mimeType;

       if (format === 'svg') {
           // Generate SVG
           try {
               const svgString = await generateSVGFromCanvas();
               exportData = svgString;
               filename = 'design.svg';
               mimeType = 'image/svg+xml';
               console.log('[AddToCollection] SVG generated successfully');
           } catch (error) {
               console.error('[AddToCollection] SVG generation failed:', error);
               if (window.showToast) window.showToast('SVG export failed: ' + error.message, 'error');
               return;
           }
       } else {
           // Generate PNG (existing logic)
           const canvasEl = document.getElementById('demo');
           const ctxMain = canvasEl.getContext('2d');

           // Create offscreen canvas for export
           const exportCanvas = document.createElement('canvas');
           exportCanvas.width = artboard.width;
           exportCanvas.height = artboard.height;
           const exportCtx = exportCanvas.getContext('2d');

           console.log(`[AddToCollection] Export canvas created: ${exportCanvas.width}x${exportCanvas.height}`);
           if (!exportCtx) {
               console.error('[AddToCollection] Failed to get 2D context for export canvas');
               if (window.showToast) window.showToast('Export failed: Canvas too large', 'error');
               return;
           }

           // Clear export canvas with transparent background
           exportCtx.save();
           const exportTransform = exportCtx.getTransform();
           const exportScaleFactor = exportTransform.a;
           exportCtx.setTransform(exportScaleFactor, 0, 0, exportScaleFactor, 0, 0);
           exportCtx.clearRect(0, 0, exportCanvas.width / exportScaleFactor, exportCanvas.height / exportScaleFactor);
           exportCtx.restore();

           exportCtx.save();
           // Clip to artboard dimensions
           exportCtx.beginPath();
           exportCtx.rect(0, 0, artboard.width, artboard.height);
           exportCtx.clip();

           // Draw objects directly onto exportCtx with coordinate adjustment
           console.log('[AddToCollection] Artboard bounds:', artboard);
           for (const obj of canvasObjects) {
               const bounds = calculateObjectBounds(obj);
               const intersects = bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
                   bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height;

               const adjustedX = obj.x - artboard.x;
               const adjustedY = obj.y - artboard.y;

               console.log(`[AddToCollection] Object ${obj.id} (${obj.type}):`, {
                   bounds: bounds,
                   intersects: intersects,
                   position: { x: obj.x, y: obj.y },
                   adjustedPosition: { x: adjustedX, y: adjustedY },
                   artboardPos: { x: artboard.x, y: artboard.y },
                   exportCanvasSize: { width: artboard.width, height: artboard.height }
               });

               // Check if object intersects with artboard
               if (intersects) {
                   // Skip drawing mask shapes that are invisible
                   if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                       console.log('[AddToCollection] Skipping mask shape:', obj.id);
                       return;
                   }

                   console.log(`[AddToCollection] Drawing ${obj.type} object:`, obj.id);
                   console.log(`[AddToCollection] Adjusted coordinates: x=${adjustedX}, y=${adjustedY} (canvas: ${artboard.width}x${artboard.height})`);

                   // Create a copy of the object with adjusted coordinates
                   const adjustedObj = { ...obj };
                   adjustedObj.x = adjustedX;
                   adjustedObj.y = adjustedY;

                   // DETAILED PNG EXPORT LOGGING
                   console.log(`[PNG Export] BEFORE drawTextObject - Object details:`, {
                       originalObj: { x: obj.x, y: obj.y, text: obj.text, fontSize: obj.fontSize },
                       adjustedObj: { x: adjustedObj.x, y: adjustedObj.y, text: adjustedObj.text, fontSize: adjustedObj.fontSize },
                       artboard: { x: artboard.x, y: artboard.y, width: artboard.width, height: artboard.height },
                       canvasSize: { width: exportCtx.canvas.width, height: exportCtx.canvas.height }
                   });

                   // Call drawing functions with exportCtx as the target and adjusted coordinates
                   if (obj.type === 'text') {
                       console.log(`[PNG Export] CALLING drawTextObject with adjusted coordinates: x=${adjustedX}, y=${adjustedY}`);
                       drawTextObject(adjustedObj, exportCtx);
                   } else if (obj.type === 'image') {
                       // Use the global window.drawImageObject with effects pipeline (same as project save)
                       if (typeof window.drawImageObject === 'function') {
                           console.log(`[AddToCollection] 🎨 Using window.drawImageObject with effects pipeline for ${obj.id}`);
                           await window.drawImageObject(adjustedObj, exportCtx);
                       } else {
                           console.log(`[AddToCollection] 🎨 Fallback to local drawImageObject for ${obj.id}`);
                           drawImageObject(adjustedObj, exportCtx);
                       }
                   }
               } else {
                   console.log(`[AddToCollection] Object ${obj.id} (${obj.type}) is outside artboard bounds - skipping`);
               }
           }

           exportCtx.restore();

           exportData = exportCanvas.toDataURL('image/png');
           filename = 'design.png';
           mimeType = 'image/png';
           console.log('[AddToCollection] PNG generated, data URL length:', exportData.length);
       }

       // Find or create collection modal
       let modal = document.querySelector('collection-modal');
       if (!modal) {
           modal = document.createElement('collection-modal');
           document.body.appendChild(modal);
       }

       // Generate a prompt from text objects
       let generatedPrompt = canvasObjects
           .filter(obj => obj.type === 'text')
           .map(obj => obj.text)
           .join(' ') || `Design Editor ${format.toUpperCase()}`;

       // Show loading state
       if (window.showToast) window.showToast(`Uploading ${format.toUpperCase()} design...`, 'info');

       // Upload file
       console.log(`[AddToCollection] Uploading ${format.toUpperCase()}...`);
       try {
           let blob;
           if (format === 'svg') {
               // Create SVG blob
               blob = new Blob([exportData], { type: mimeType });
           } else {
               // Create PNG blob from data URL
               blob = await (await fetch(exportData)).blob();
           }

           const formData = new FormData();
           formData.append('image', blob, filename);

           const response = await fetch('/api/images/upload', {
               method: 'POST',
               body: formData
           });

           if (!response.ok) {
               const errorText = await response.text();
               console.error(`[AddToCollection] ${format.toUpperCase()} upload failed:`, response.status, errorText);
               throw new Error(`Upload failed: ${response.statusText} - ${errorText}`);
           }

           const result = await response.json();
           console.log(`[AddToCollection] ${format.toUpperCase()} upload response:`, result);

           // Verify imageUrl exists and is a string
           const uploadedUrl = result.imageUrl || result.url || result.fileUrl;
           if (!uploadedUrl || typeof uploadedUrl !== 'string') {
                console.error('[AddToCollection] Invalid or missing imageUrl in upload response:', result);
                throw new Error('Failed to get valid image URL after upload.');
           }
           console.log(`[AddToCollection] Uploaded ${format.toUpperCase()} URL:`, uploadedUrl);

           // Set modal data with the valid uploaded URL and generated prompt
           if (modal.setImageData) {
               console.log('[AddToCollection] Using setImageData() with uploaded URL:', uploadedUrl);
               modal.setImageData({
                   imageUrl: uploadedUrl,
                   prompt: generatedPrompt,
                   generationId: null, // Not a generation
                   format: format // Include format info
               });
           } else {
               // Fallback if method doesn't exist
               console.warn('[AddToCollection] setImageData method not found on modal. Setting attribute as fallback.');
               modal.setAttribute('image-url', uploadedUrl);
           }

           // Show modal only after successful upload and data setting
           if (modal.show) {
               console.log('[AddToCollection] Calling modal.show()');
               modal.show();
           } else {
               console.warn('[AddToCollection] show method not found on modal. Setting display:block as fallback.');
               modal.style.display = 'block';
           }

           // Show success message
           if (window.showToast) {
               window.showToast(`${format.toUpperCase()} design uploaded successfully!`, 'success');
           }

       } catch (e) {
           console.error(`[AddToCollection] Error during ${format.toUpperCase()} upload or modal setup:`, e);
           if (window.showToast) window.showToast(`Error preparing collection add: ${e.message}`, 'error');
           else alert(`Error preparing collection add: ${e.message}`);
       }
   }

   // Direct download function
   async function performDirectDownload(format) {
       console.log(`[DirectDownload] Starting ${format.toUpperCase()} download`);

       if (!artboard) {
           if (window.showToast) window.showToast('No Artboard defined', 'error');
           else alert('No Artboard defined');
           return;
       }

       try {
           let exportData;
           let filename;
           let mimeType;

           if (format === 'svg') {
               // Generate SVG
               const svgString = await generateSVGFromCanvas();
               exportData = svgString;
               filename = `design-${Date.now()}.svg`;
               mimeType = 'image/svg+xml';

               // Create blob and download
               const blob = new Blob([exportData], { type: mimeType });
               const url = URL.createObjectURL(blob);

               const link = document.createElement('a');
               link.href = url;
               link.download = filename;
               document.body.appendChild(link);
               link.click();
               document.body.removeChild(link);
               URL.revokeObjectURL(url);

               console.log('[DirectDownload] SVG downloaded successfully');
               if (window.showToast) window.showToast('SVG downloaded successfully!', 'success');

           } else {
               // Generate PNG (reuse existing logic)
               const canvasEl = document.getElementById('demo');
               const exportCanvas = document.createElement('canvas');
               exportCanvas.width = artboard.width;
               exportCanvas.height = artboard.height;
               const exportCtx = exportCanvas.getContext('2d');

               // Clear and setup canvas
               exportCtx.save();
               const exportTransform = exportCtx.getTransform();
               const exportScaleFactor = exportTransform.a;
               exportCtx.setTransform(exportScaleFactor, 0, 0, exportScaleFactor, 0, 0);
               exportCtx.clearRect(0, 0, exportCanvas.width / exportScaleFactor, exportCanvas.height / exportScaleFactor);
               exportCtx.restore();

               exportCtx.save();
               exportCtx.beginPath();
               exportCtx.rect(0, 0, artboard.width, artboard.height);
               exportCtx.clip();
               exportCtx.translate(-artboard.x, -artboard.y);

               // Draw objects
               canvasObjects.forEach((obj) => {
                   const bounds = calculateObjectBounds(obj);
                   if (bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
                       bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height) {

                       if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                           return;
                       }

                       if (obj.type === 'text') {
                           drawTextObject(obj, exportCtx);
                       } else if (obj.type === 'image') {
                           drawImageObject(obj, exportCtx);
                       }
                   }
               });

               exportCtx.restore();

               // Download PNG
               filename = `design-${Date.now()}.png`;
               const link = document.createElement('a');
               link.href = exportCanvas.toDataURL('image/png');
               link.download = filename;
               document.body.appendChild(link);
               link.click();
               document.body.removeChild(link);

               console.log('[DirectDownload] PNG downloaded successfully');
               if (window.showToast) window.showToast('PNG downloaded successfully!', 'success');
           }

       } catch (error) {
           console.error(`[DirectDownload] ${format.toUpperCase()} download failed:`, error);
           if (window.showToast) window.showToast(`${format.toUpperCase()} download failed: ${error.message}`, 'error');
           else alert(`${format.toUpperCase()} download failed: ${error.message}`);
       }
   }

   // --- Copy/Paste Functionality ---
   let copiedElement = null;

   // Copy Element Function
   function copySelectedElement() {
       if (selectedObjectIndex === -1) {
           console.log('No element selected to copy');
           if (window.showToast) window.showToast('No element selected to copy', 'warning');
           return;
       }

       const selectedObject = canvasObjects[selectedObjectIndex];

       // Create a deep copy of the selected object
       copiedElement = JSON.parse(JSON.stringify(selectedObject));

       // Remove selection state from the copy
       copiedElement.isSelected = false;

       // Special handling for linked objects
       if (selectedObject.type === 'text' && selectedObject.linkedRectangleId) {
           console.log('📋 COPY: Text has linked rectangle, copying both objects');

           // Find and copy the linked rectangle
           const linkedRectangle = canvasObjects.find(obj => obj.id === selectedObject.linkedRectangleId);
           if (linkedRectangle) {
               copiedElement.linkedRectangleData = JSON.parse(JSON.stringify(linkedRectangle));
               copiedElement.linkedRectangleData.isSelected = false;
               console.log('📋 COPY: Linked rectangle data stored with text');
           }
       } else if (selectedObject.type === 'rectangle' && selectedObject.linkedTextId) {
           console.log('📋 COPY: Rectangle has linked text, copying both objects');

           // Find and copy the linked text
           const linkedText = canvasObjects.find(obj => obj.id === selectedObject.linkedTextId);
           if (linkedText) {
               copiedElement.linkedTextData = JSON.parse(JSON.stringify(linkedText));
               copiedElement.linkedTextData.isSelected = false;
               console.log('📋 COPY: Linked text data stored with rectangle');
           }
       }

       console.log('📋 Element copied:', copiedElement.type, copiedElement.text || copiedElement.imageUrl);

       // Enable paste button
       const pasteBtn = document.getElementById('pasteElementBtn');
       if (pasteBtn) {
           pasteBtn.disabled = false;
           let elementType = 'Element';
           if (copiedElement.type === 'text') elementType = 'Text';
           else if (copiedElement.type === 'image') elementType = 'Image';
           else if (copiedElement.type === 'rectangle') elementType = 'Rectangle';
           pasteBtn.title = `Paste ${elementType}`;
       }

       if (window.showToast) {
           let elementType = 'Element';
           if (copiedElement.type === 'text') elementType = 'Text';
           else if (copiedElement.type === 'image') elementType = 'Image';
           else if (copiedElement.type === 'rectangle') elementType = 'Rectangle';
           window.showToast(`${elementType} copied to clipboard`, 'success');
       }
   }

   // Paste Element Function
   function pasteElement() {
       if (!copiedElement) {
           console.log('No element in clipboard to paste');
           if (window.showToast) window.showToast('No element in clipboard to paste', 'warning');
           return;
       }

       // Create a new copy for pasting (so we can paste multiple times)
       const newElement = JSON.parse(JSON.stringify(copiedElement));

       // Generate a new unique ID
       newElement.id = Date.now() + Math.random();

       // 🔴 CHECK FOR RED RECTANGLE (TEXT/SHAPE BOUNDING BOX) SELECTION FIRST
       const selectedObject = selectedObjectIndex !== -1 ? canvasObjects[selectedObjectIndex] : null;
       const isRedRectSelected = selectedObject &&
                                selectedObject.type === 'rectangle' &&
                                (selectedObject.isTextBoundingBox === true || selectedObject.isShapeBoundingBox === true);

       console.log('📋 PASTE RED RECT CHECK: selectedObject =', selectedObject);
       console.log('📋 PASTE RED RECT CHECK: isRedRectSelected =', isRedRectSelected);

       // Check if a layout rectangle is selected for positioning
       console.log('📋 PASTE LAYOUT CHECK: selectedLayoutRectIndex =', selectedLayoutRectIndex);
       console.log('📋 PASTE LAYOUT CHECK: layoutRectangles =', layoutRectangles);
       console.log('📋 PASTE LAYOUT CHECK: layoutRectangles length =', layoutRectangles ? layoutRectangles.length : 'undefined');

       const isLayoutRectSelected = selectedLayoutRectIndex !== -1 &&
                                   layoutRectangles &&
                                   layoutRectangles[selectedLayoutRectIndex];

       console.log('📋 PASTE LAYOUT CHECK: isLayoutRectSelected =', isLayoutRectSelected);

       // 🔴 HANDLE PASTING INTO RED RECTANGLE (TEXT/SHAPE BOUNDING BOX)
       if (isRedRectSelected && (newElement.type === 'text' || newElement.type === 'image')) {
           console.log('🔴 PASTE INTO RED RECT: Pasting element into red rectangle (text/shape bounding box)');

           const redRect = selectedObject;
           console.log('🔴 PASTE INTO RED RECT: Red rectangle dimensions:', {
               x: redRect.x, y: redRect.y,
               width: redRect.width, height: redRect.height
           });

           // Position element at the center of the red rectangle
           newElement.x = redRect.x;
           newElement.y = redRect.y;

           let elementWidth, elementHeight;

           if (newElement.type === 'text') {
               // Get the actual visible bounds of the text to be pasted
               const actualBounds = getActualVisibleBounds(newElement);
               elementWidth = actualBounds.width;
               elementHeight = actualBounds.height;
           } else if (newElement.type === 'image') {
               // For images, use original dimensions
               elementWidth = (newElement.originalWidth || newElement.width || 100) * (newElement.scale || 1);
               elementHeight = (newElement.originalHeight || newElement.height || 100) * (newElement.scale || 1);
           }

           console.log('🔴 PASTE INTO RED RECT: Element actual dimensions:', {
               width: elementWidth, height: elementHeight, type: newElement.type
           });

           // Calculate scale to fit element exactly inside the red rectangle
           const scaleX = redRect.width / elementWidth;
           const scaleY = redRect.height / elementHeight;
           const scale = Math.min(scaleX, scaleY); // Use smaller scale to fit both dimensions

           console.log('🔴 PASTE INTO RED RECT: Scale calculation:', {
               scaleX: scaleX, scaleY: scaleY, finalScale: scale
           });

           // Apply the scale to fit the element exactly in the red rectangle
           newElement.scale = scale;

           console.log('🔴 PASTE INTO RED RECT: Element fitted exactly into red rectangle');
           console.log('🔴 PASTE INTO RED RECT: Final element properties:', {
               x: newElement.x, y: newElement.y, scale: newElement.scale, type: newElement.type
           });

       } else if (isLayoutRectSelected) {
           const layoutRect = layoutRectangles[selectedLayoutRectIndex];
           console.log('📋 PASTE LAYOUT RECT FOUND: Pasting element into selected layout rectangle:', layoutRect);
           console.log('📋 PASTE LAYOUT RECT: dimensions =', layoutRect.width, 'x', layoutRect.height);
           console.log('📋 PASTE LAYOUT RECT: position =', layoutRect.x, ',', layoutRect.y);

           // Position in the center of the layout rectangle
           newElement.x = layoutRect.x + layoutRect.width / 2;
           newElement.y = layoutRect.y + layoutRect.height / 2;
           console.log('📋 PASTE TARGET POS: x =', newElement.x, 'y =', newElement.y);
       } else {
           console.log('📋 PASTE: No layout rectangle selected, using default offset');
           // Offset the position slightly so it doesn't overlap exactly
           newElement.x += 50;
           newElement.y += 50;
       }

       // Ensure the element is not selected initially
       newElement.isSelected = false;

       // Handle special cases for different element types
       if (newElement.type === 'text') {
           console.log('📋 Pasting text element:', newElement.text);

           // Reset any mesh warp or grid distort states that might cause issues
           if (newElement.effectMode === 'mesh' && newElement.meshWarp) {
               // Reset mesh warp to avoid control point conflicts
               newElement.meshWarp = null;
               newElement.effectMode = 'normal';
           }

           if (newElement.effectMode === 'grid-distort' && newElement.gridDistort) {
               // Reset grid distort to avoid control point conflicts
               newElement.gridDistort = null;
               newElement.effectMode = 'normal';
           }

           // Scale text to fit layout rectangle if one is selected
           if (isLayoutRectSelected) {
               const layoutRect = layoutRectangles[selectedLayoutRectIndex];

               console.log('🔍 PASTE DEBUG: ===== STARTING LAYOUT RECTANGLE FITTING =====');
               console.log('🔍 PASTE DEBUG: Layout rectangle:', layoutRect);
               console.log('🔍 PASTE DEBUG: Text element before fitting:', {
                   text: newElement.text,
                   fontSize: newElement.fontSize,
                   fontFamily: newElement.fontFamily,
                   type: newElement.type
               });

               // IMPROVED: Get actual visible text dimensions instead of bounding box
               console.log('🔍 PASTE DEBUG: About to call getActualVisibleBounds...');
               const actualBounds = getActualVisibleBounds(newElement);
               console.log('🔍 PASTE DEBUG: getActualVisibleBounds returned:', actualBounds);

               const textWidth = actualBounds.width;
               const textHeight = actualBounds.height;

               console.log('🔍 PASTE DEBUG: Extracted dimensions - textWidth:', textWidth, 'textHeight:', textHeight);
               console.log('📋 IMPROVED FITTING: Using pixel-perfect bounds for shape fitting');
               console.log('📋 Pixel-perfect dimensions:', textWidth, 'x', textHeight);

               // Calculate scale to fit within layout rectangle while maintaining aspect ratio
               const scaleX = layoutRect.width / textWidth;
               const scaleY = layoutRect.height / textHeight;
               console.log('🔍 PASTE DEBUG: Scale calculations - scaleX:', scaleX, 'scaleY:', scaleY);

               const maxScale = Math.min(scaleX, scaleY);
               console.log('🔍 PASTE DEBUG: maxScale (min of scaleX, scaleY):', maxScale);

               // Use 95% of the maximum scale to fit within the rectangle with padding
               const scale = maxScale * 1;
               console.log('🔍 PASTE DEBUG: Final scale (95% of maxScale):', scale);

               // Calculate target dimensions
               const width = textWidth * scale;
               const height = textHeight * scale;
               console.log('🔍 PASTE DEBUG: Target dimensions - width:', width, 'height:', height);

               // 🎯 NEW APPROACH: Use normal text scaling instead of pixel-perfect clipping
               // This preserves all text effects (shadows, decorations, gradients, etc.)

               // Apply the scale directly to the text object using normal scaling
               newElement.scale = scale;

               console.log('🎯 NEW APPROACH: Using normal text scaling instead of pixel-perfect clipping');
               console.log('🎯 NEW APPROACH: Applied scale:', scale);
               console.log('🎯 NEW APPROACH: This preserves all text effects (shadows, decorations, gradients)');

               console.log('🔧 PASTE DEBUG: Text pasted into layout rectangle with normal scaling:', {
                   text: newElement.text,
                   scale: newElement.scale,
                   letterSpacing: newElement.letterSpacing,
                   _effectiveLetterSpacing: newElement._effectiveLetterSpacing
               });

               console.log('📋 Applied pixel-perfect fitting with scale:', scale);
               console.log('📋 Layout rect dimensions:', layoutRect.width, 'x', layoutRect.height);
               console.log('📋 Pixel-perfect dimensions:', textWidth, 'x', textHeight);
               console.log('📋 Target dimensions:', width, 'x', height);
               console.log('🔍 PASTE DEBUG: ===== LAYOUT RECTANGLE FITTING COMPLETE =====');
           }

           // Handle text with linked rectangle data
           if (newElement.linkedRectangleData) {
               console.log('📋 TEXT PASTE: Text has linked rectangle data, creating linked rectangle');

               // Create the linked rectangle
               const newLinkedRectangle = newElement.linkedRectangleData;
               newLinkedRectangle.id = Date.now() + Math.random() + 1; // Ensure unique ID

               // Update the text's linked rectangle reference
               newElement.linkedRectangleId = newLinkedRectangle.id;

               // Update the rectangle's linked text reference
               newLinkedRectangle.linkedTextId = newElement.id;

               // Position rectangle at same location as text
               newLinkedRectangle.x = newElement.x;
               newLinkedRectangle.y = newElement.y;

               // If text was scaled for layout rectangle, scale rectangle proportionally
               if (isLayoutRectSelected && newElement.scale) {
                   newLinkedRectangle.width *= newElement.scale;
                   newLinkedRectangle.height *= newElement.scale;
                   console.log('📋 TEXT PASTE: Scaled linked rectangle by text scale factor:', newElement.scale);
               }

               // Add the linked rectangle to canvas
               canvasObjects.push(newLinkedRectangle);
               console.log('📋 TEXT PASTE: Added linked rectangle to canvas');

               // Clean up the temporary data
               delete newElement.linkedRectangleData;
           }

       } else if (newElement.type === 'rectangle') {
           console.log('📋 Pasting rectangle element:', newElement.id);

           // Handle rectangle with linked text data (from copy operation)
           if (newElement.linkedTextData) {
               console.log('📋 RECTANGLE PASTE: Rectangle has linked text data, creating linked text');

               // Create the linked text
               const newLinkedText = newElement.linkedTextData;
               newLinkedText.id = Date.now() + Math.random() + 1; // Ensure unique ID

               // Update the rectangle's linked text reference
               newElement.linkedTextId = newLinkedText.id;

               // Update the text's linked rectangle reference
               newLinkedText.linkedRectangleId = newElement.id;

               // Position both rectangle and text in layout rectangle if selected
               if (isLayoutRectSelected) {
                   const layoutRect = layoutRectangles[selectedLayoutRectIndex];
                   console.log('📋 RECTANGLE PASTE: Positioning rectangle and text in layout rectangle');

                   // Position rectangle in center of layout rectangle
                   newElement.x = layoutRect.x + layoutRect.width / 2;
                   newElement.y = layoutRect.y + layoutRect.height / 2;

                   // Position text at same location as rectangle
                   newLinkedText.x = newElement.x;
                   newLinkedText.y = newElement.y;

                   // Scale rectangle to fit layout rectangle
                   const scaleX = (layoutRect.width * 0.9) / newElement.width;
                   const scaleY = (layoutRect.height * 0.9) / newElement.height;
                   const scale = Math.min(scaleX, scaleY);

                   // Apply scaling to rectangle
                   newElement.width *= scale;
                   newElement.height *= scale;

                   // Apply proportional scaling to text
                   if (newLinkedText.originalFontSize) {
                       newLinkedText.fontSize = newLinkedText.originalFontSize * scale;
                   } else {
                       newLinkedText.fontSize *= scale;
                   }

                   console.log('📋 RECTANGLE PASTE: Scaled rectangle and text by factor:', scale);
               } else {
                   // Offset both rectangle and text
                   newLinkedText.x = newElement.x;
                   newLinkedText.y = newElement.y;
               }

               // Add the linked text to canvas first
               canvasObjects.push(newLinkedText);
               console.log('📋 RECTANGLE PASTE: Added linked text to canvas');

               // Clean up the temporary data
               delete newElement.linkedTextData;
           }

           // Scale rectangle to fit layout rectangle if one is selected
           if (isLayoutRectSelected && !newElement.isTextController) {
               const layoutRect = layoutRectangles[selectedLayoutRectIndex];

               // Scale rectangle to fit within layout rectangle
               const scaleX = (layoutRect.width * 0.9) / newElement.width;
               const scaleY = (layoutRect.height * 0.9) / newElement.height;
               const scale = Math.min(scaleX, scaleY);

               newElement.width *= scale;
               newElement.height *= scale;

               console.log('📋 RECTANGLE PASTE: Scaled standalone rectangle by factor:', scale);
           }

       } else if (newElement.type === 'image') {
           console.log('📋 Pasting image element:', newElement.imageUrl);

           // For images, we need to reload the image object
           if (newElement.imageUrl) {
               const img = new Image();
               img.onload = () => {
                   newElement.image = img;
                   newElement.originalWidth = img.width;
                   newElement.originalHeight = img.height;

                   // Scale image to fit layout rectangle if one is selected
                   if (isLayoutRectSelected) {
                       const layoutRect = layoutRectangles[selectedLayoutRectIndex];

                       // IMPROVED: Use original image dimensions (actual visible content, no bounding box issues)
                       // Images don't have invisible padding like text bounding boxes
                       const originalWidth = img.naturalWidth || img.width;
                       const originalHeight = img.naturalHeight || img.height;

                       console.log('📋 IMPROVED FITTING: Using actual image dimensions (no bounding box issues)');
                       // Calculate scale to fit within layout rectangle while maintaining aspect ratio
                       const scaleX = layoutRect.width / originalWidth;
                       const scaleY = layoutRect.height / originalHeight;
                       const maxScale = Math.min(scaleX, scaleY);

                       // Use 95% of the maximum scale to fit within the rectangle with padding
                       // This ensures the object actually fits inside the rectangle
                       const scale = maxScale * 1;

                       // Calculate target dimensions (like shapes-loader.js does)
                       const width = originalWidth * scale;
                       const height = originalHeight * scale;

                       // Set the scale property like shapes-loader.js does
                       newElement.scale = Math.min(width / originalWidth, height / originalHeight);

                       console.log('📋 Scaled image to fit layout rectangle:', newElement.scale);
                       console.log('📋 Layout rect dimensions:', layoutRect.width, 'x', layoutRect.height);
                       console.log('📋 Original image dimensions:', originalWidth, 'x', originalHeight);
                       console.log('📋 Target dimensions:', width, 'x', height);
                   }

                   // Add to canvas and update
                   canvasObjects.push(newElement);

                   // Select the newly pasted element
                   if (selectedObjectIndex !== -1) {
                       canvasObjects[selectedObjectIndex].isSelected = false;
                   }
                   selectedObjectIndex = canvasObjects.length - 1;
                   newElement.isSelected = true;

                   updateUIFromSelectedObject();
                   update();

                   console.log('📋 Image element pasted successfully');
               };

               img.onerror = () => {
                   console.error('Failed to load pasted image:', newElement.imageUrl);
                   if (window.showToast) window.showToast('Failed to load pasted image', 'error');
               };

               img.src = newElement.imageUrl;
               return; // Exit early for async image loading
           }
       }

       // Add the new element to the canvas
       canvasObjects.push(newElement);

       // Select the newly pasted element
       if (selectedObjectIndex !== -1) {
           canvasObjects[selectedObjectIndex].isSelected = false;
       }
       selectedObjectIndex = canvasObjects.length - 1;
       newElement.isSelected = true;

       updateUIFromSelectedObject();
       update();

       console.log('📋 Element pasted successfully');
       if (window.showToast) {
           window.showToast(`${newElement.type === 'text' ? 'Text' : 'Image'} pasted successfully`, 'success');
       }

       // Save state for undo/redo
       saveState(`Paste ${newElement.type === 'text' ? 'Text' : 'Image'}`);
   }

   // Copy/Paste Button Event Listeners
   const copyBtn = document.getElementById('copyElementBtn');
   const pasteBtn = document.getElementById('pasteElementBtn');

   if (copyBtn) {
       copyBtn.addEventListener('click', copySelectedElement);
   }

   if (pasteBtn) {
       pasteBtn.addEventListener('click', pasteElement);
       // Initially disabled until something is copied
       pasteBtn.disabled = true;
   }

   // --- ALIGNMENT BUTTON EVENT LISTENERS ---
   const alignLeftBtn = document.getElementById('alignLeftBtn');
   const alignCenterBtn = document.getElementById('alignCenterBtn');
   const alignRightBtn = document.getElementById('alignRightBtn');

   if (alignLeftBtn) {
       alignLeftBtn.addEventListener('click', alignLeft);
   }

   if (alignCenterBtn) {
       alignCenterBtn.addEventListener('click', alignCenter);
   }

   if (alignRightBtn) {
       alignRightBtn.addEventListener('click', alignRight);
   }

   // Keyboard shortcuts for copy/paste
   document.addEventListener('keydown', (e) => {
       // Only handle shortcuts when not typing in input fields
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
           return;
       }

       // ESC key to cancel mask selection mode
       if (e.key === 'Escape' && isMaskSelectionMode) {
           e.preventDefault();
           exitMaskSelectionMode();
           if (window.showToast) {
               window.showToast('Mask selection cancelled', 'info');
           }
           return;
       }

       // Ctrl+C or Cmd+C for copy
       if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
           e.preventDefault();
           copySelectedElement();
       }

       // Ctrl+V or Cmd+V for paste
       if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
           e.preventDefault();
           pasteElement();
       }

       // Delete key for layout rectangles (works in any mode)
       if (e.key === 'Delete' || e.key === 'Backspace') {
           if (selectedLayoutRectIndex !== -1) {
               e.preventDefault();
               layoutRectangles.splice(selectedLayoutRectIndex, 1);
               window.layoutRectangles = layoutRectangles; // Update global reference
               selectedLayoutRectIndex = -1;
               window.selectedLayoutRectIndex = -1;
               console.log('[LayoutTool] Deleted layout rectangle');

               // Update UI since layout selection changed
               updateLayoutSelectionUI();

               update();
           }
       }

       // ⌨️ ARROW KEY MOVEMENT: Move selected objects with arrow keys
       if (selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length) {
           const selectedObject = canvasObjects[selectedObjectIndex];
           if (selectedObject && !selectedObject.isLocked) {
               let moved = false;
               const moveDistance = e.shiftKey ? 10 : 1; // Hold Shift for larger movements

               switch (e.key) {
                   case 'ArrowUp':
                       e.preventDefault();
                       selectedObject.y -= moveDistance;
                       moved = true;
                       console.log(`[ArrowMove] Moved object ${selectedObject.id} UP by ${moveDistance}px to (${selectedObject.x}, ${selectedObject.y})`);
                       break;
                   case 'ArrowDown':
                       e.preventDefault();
                       selectedObject.y += moveDistance;
                       moved = true;
                       console.log(`[ArrowMove] Moved object ${selectedObject.id} DOWN by ${moveDistance}px to (${selectedObject.x}, ${selectedObject.y})`);
                       break;
                   case 'ArrowLeft':
                       e.preventDefault();
                       selectedObject.x -= moveDistance;
                       moved = true;
                       console.log(`[ArrowMove] Moved object ${selectedObject.id} LEFT by ${moveDistance}px to (${selectedObject.x}, ${selectedObject.y})`);
                       break;
                   case 'ArrowRight':
                       e.preventDefault();
                       selectedObject.x += moveDistance;
                       moved = true;
                       console.log(`[ArrowMove] Moved object ${selectedObject.id} RIGHT by ${moveDistance}px to (${selectedObject.x}, ${selectedObject.y})`);
                       break;
               }

               if (moved) {
                   // Update global references if they exist
                   if (window.canvasObjects) {
                       window.canvasObjects = canvasObjects;
                   }

                   // Trigger canvas redraw
                   update();

                   // Save state for undo/redo
                   if (typeof saveState === 'function') {
                       saveState(`Move ${selectedObject.type} with arrow keys`);
                   }
               }
           }
       }
   });

   // Update copy button state when selection changes
   function updateCopyPasteButtons() {
       const copyBtn = document.getElementById('copyElementBtn');

       if (copyBtn) {
           copyBtn.disabled = selectedObjectIndex === -1;

           if (selectedObjectIndex !== -1 && selectedObjectIndex < canvasObjects.length) {
               const selectedObject = canvasObjects[selectedObjectIndex];
               if (selectedObject) {
                   let elementType = 'Element';
                   if (selectedObject.type === 'text') elementType = 'Text';
                   else if (selectedObject.type === 'image') elementType = 'Image';
                   else if (selectedObject.type === 'rectangle') elementType = 'Rectangle';
                   copyBtn.title = `Copy ${elementType}`;
               } else {
                   copyBtn.title = 'Copy Selected Element';
               }
           } else {
               copyBtn.title = 'Copy Selected Element';
           }
       }
   }

   // Call this function whenever selection changes
   // Add this to the existing updateUIFromSelectedObject function or call it separately

   // --- Undo/Redo Functionality ---
   let historyStack = [];
   let historyIndex = -1;
   const MAX_HISTORY_SIZE = 50;

   // Save current state to history
   function saveStateToHistory(actionName = 'Action') {
       // Create a deep copy of the current canvas state, excluding circular references
       const cleanCanvasObjects = canvasObjects.map(obj => {
           const cleanObj = { ...obj };
           // Remove circular reference properties that can't be serialized
           delete cleanObj._meshWarpHandler;
           return cleanObj;
       });

       const currentState = {
           canvasObjects: JSON.parse(JSON.stringify(cleanCanvasObjects)),
           selectedObjectIndex: selectedObjectIndex,
           canvasBackgroundColor: canvasBackgroundColor,
           artboard: JSON.parse(JSON.stringify(artboard)),
           actionName: actionName,
           timestamp: Date.now()
       };

       // Remove any history after current index (when we're not at the end)
       if (historyIndex < historyStack.length - 1) {
           historyStack = historyStack.slice(0, historyIndex + 1);
       }

       // Add new state to history
       historyStack.push(currentState);

       // Limit history size
       if (historyStack.length > MAX_HISTORY_SIZE) {
           historyStack.shift();
       } else {
           historyIndex++;
       }

       console.log('📚 State saved to history:', actionName, 'Index:', historyIndex, 'Stack size:', historyStack.length);
       updateUndoRedoButtons();
   }

   // Restore state from history
   function restoreStateFromHistory(state) {
       console.log('📚 Restoring state:', state.actionName);
       console.log('📚 State data:', state);

       // 🔧 FIX: Store current objects as backup before clearing
       const backupObjects = [...canvasObjects];
       const backupSelectedIndex = selectedObjectIndex;

       // Clear current objects
       canvasObjects.length = 0;
       selectedObjectIndex = -1;

       // Restore canvas objects
       if (state.canvasObjects && Array.isArray(state.canvasObjects) && state.canvasObjects.length > 0) {
           console.log('📚 Restoring', state.canvasObjects.length, 'objects');

           const objectPromises = state.canvasObjects.map((objData, index) => {
               return new Promise((resolve) => {
                   console.log('📚 Restoring object', index, ':', objData.type, objData.text || objData.imageUrl);

                   if (objData.type === 'text') {
                       try {
                           const textObj = createTextObject(objData);
                           // Copy all properties from saved state
                           Object.assign(textObj, objData);
                           canvasObjects.push(textObj);
                           console.log('📚 ✅ Text object restored:', textObj.text);
                           resolve(true);
                       } catch (error) {
                           console.error('📚 ❌ Failed to restore text object:', error);
                           resolve(false);
                       }
                   } else if (objData.type === 'image') {
                       const img = new Image();
                       img.onload = () => {
                           try {
                               const imageObj = createImageObject(img, objData);
                               // Copy all properties from saved state
                               Object.assign(imageObj, objData);
                               imageObj.image = img;
                               canvasObjects.push(imageObj);
                               console.log('📚 ✅ Image object restored:', objData.imageUrl);
                               resolve(true);
                           } catch (error) {
                               console.error('📚 ❌ Failed to create image object:', error);
                               resolve(false);
                           }
                       };
                       img.onerror = () => {
                           console.error('📚 ❌ Failed to load image:', objData.imageUrl);
                           resolve(false);
                       };
                       img.src = objData.imageUrl;
                   } else {
                       console.log('📚 ⚠️ Unknown object type:', objData.type);
                       resolve(false);
                   }
               });
           });

           Promise.all(objectPromises).then((results) => {
               const successCount = results.filter(r => r === true).length;
               const failCount = results.filter(r => r === false).length;
               console.log('📚 Restoration complete:', successCount, 'success,', failCount, 'failed');

               // 🔧 FIX: If no objects were restored successfully, restore backup
               if (canvasObjects.length === 0 && backupObjects.length > 0) {
                   console.log('📚 ⚠️ No objects restored, using backup');
                   canvasObjects.push(...backupObjects);
                   selectedObjectIndex = backupSelectedIndex;
               }
               // Recreate mesh warp handlers for text objects with mesh effect
               canvasObjects.forEach(obj => {
                   if (obj.type === 'text' && obj.effectMode === 'mesh' && obj.meshWarp) {
                       console.log('[UndoRedo] Recreating mesh warp handler for text object:', obj.text);
                       try {
                           // Prepare saved data
                           let savedControlPoints = null;
                           let savedInitialControlPoints = null;
                           let savedRelativeControlPoints = null;
                           let savedHasCustomDistortion = false;
                           let savedShowGrid = true;
                           let savedGridRect = null;

                           if (obj.meshWarp.controlPoints && obj.meshWarp.controlPoints.length > 0) {
                               savedControlPoints = obj.meshWarp.controlPoints.map(p => ({ ...p }));
                               savedInitialControlPoints = obj.meshWarp.initialControlPoints.map(p => ({ ...p }));
                               savedRelativeControlPoints = obj.meshWarp.relativeControlPoints.map(p => ({ ...p }));
                               savedHasCustomDistortion = obj.meshWarp.hasCustomDistortion;
                               savedShowGrid = obj.meshWarp.showGrid;
                               savedGridRect = obj.meshWarp.gridRect ? { ...obj.meshWarp.gridRect } : null;
                           }

                           // Create mesh warp handler
                           const meshHandler = new MeshWarpHandler(
                               document.getElementById('demo'),
                               obj
                           );

                           // Restore saved data
                           if (savedControlPoints) {
                               meshHandler.controlPoints = savedControlPoints;
                               meshHandler.initialControlPoints = savedInitialControlPoints;
                               meshHandler.relativeControlPoints = savedRelativeControlPoints;
                               meshHandler.hasCustomDistortion = savedHasCustomDistortion;
                               meshHandler.showGrid = savedShowGrid;
                               meshHandler.initialGridRect = savedGridRect;
                           }

                           // Store handler reference
                           obj._meshWarpHandler = meshHandler;
                       } catch (error) {
                           console.error('[UndoRedo] Error recreating mesh warp handler for:', obj.text, error);
                       }
                   }
               });

               // Restore selection
               selectedObjectIndex = state.selectedObjectIndex;
               if (selectedObjectIndex !== -1 && canvasObjects[selectedObjectIndex]) {
                   canvasObjects[selectedObjectIndex].isSelected = true;

                   // Activate mesh warp handler if the selected object has mesh effect
                   const selectedObject = canvasObjects[selectedObjectIndex];
                   if (selectedObject.type === 'text' && selectedObject.effectMode === 'mesh' && selectedObject._meshWarpHandler) {
                       console.log('[UndoRedo] Activating mesh warp handler for selected object:', selectedObject.text);
                       activeMeshWarpHandler = selectedObject._meshWarpHandler;
                       activeMeshWarpHandler.selectedTextObject = selectedObject;
                   }
               }

               // Restore background color
               canvasBackgroundColor = state.canvasBackgroundColor || '#ffffff';

               // Restore artboard
               if (state.artboard) {
                   Object.assign(artboard, state.artboard);
               }

               // Update UI and redraw
               updateUIFromSelectedObject();
               update();
               console.log('📚 State restored successfully');
           });
       } else {
           // No objects to restore - this might be intentional (like after "Delete All")
           console.log('📚 No objects in saved state - canvas will be empty');
           selectedObjectIndex = -1;
           canvasBackgroundColor = state.canvasBackgroundColor || '#ffffff';
           if (state.artboard) {
               Object.assign(artboard, state.artboard);
           }
           updateUIFromSelectedObject();
           update();
           console.log('📚 Empty state restored successfully');
       }
   }

   // Undo function
   function performUndo() {
       if (historyIndex > 0) {
           historyIndex--;
           const previousState = historyStack[historyIndex];
           console.log('⏪ Undoing to:', previousState.actionName);
           restoreStateFromHistory(previousState);
           updateUndoRedoButtons();

           if (window.showToast) {
               window.showToast(`Undone: ${previousState.actionName}`, 'info');
           }
       } else {
           console.log('⏪ Nothing to undo');
           if (window.showToast) {
               window.showToast('Nothing to undo', 'warning');
           }
       }
   }

   // Redo function
   function performRedo() {
       if (historyIndex < historyStack.length - 1) {
           historyIndex++;
           const nextState = historyStack[historyIndex];
           console.log('⏩ Redoing to:', nextState.actionName);
           restoreStateFromHistory(nextState);
           updateUndoRedoButtons();

           if (window.showToast) {
               window.showToast(`Redone: ${nextState.actionName}`, 'info');
           }
       } else {
           console.log('⏩ Nothing to redo');
           if (window.showToast) {
               window.showToast('Nothing to redo', 'warning');
           }
       }
   }

   // Update undo/redo button states
   function updateUndoRedoButtons() {
       const undoBtn = document.getElementById('undoBtn');
       const redoBtn = document.getElementById('redoBtn');

       if (undoBtn) {
           undoBtn.disabled = historyIndex <= 0;
           if (historyIndex > 0) {
               undoBtn.title = `Undo: ${historyStack[historyIndex].actionName}`;
           } else {
               undoBtn.title = 'Undo';
           }
       }

       if (redoBtn) {
           redoBtn.disabled = historyIndex >= historyStack.length - 1;
           if (historyIndex < historyStack.length - 1) {
               redoBtn.title = `Redo: ${historyStack[historyIndex + 1].actionName}`;
           } else {
               redoBtn.title = 'Redo';
           }
       }
   }

   // Undo/Redo Button Event Listeners
   const undoBtn = document.getElementById('undoBtn');
   const redoBtn = document.getElementById('redoBtn');

   if (undoBtn) {
       undoBtn.addEventListener('click', performUndo);
   }

   if (redoBtn) {
       redoBtn.addEventListener('click', performRedo);
   }

   // Keyboard shortcuts for undo/redo
   document.addEventListener('keydown', (e) => {
       // Only handle shortcuts when not typing in input fields
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
           return;
       }

       // Ctrl+Z or Cmd+Z for undo
       if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
           e.preventDefault();
           performUndo();
       }

       // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z for redo
       if (((e.ctrlKey || e.metaKey) && e.key === 'y') ||
           ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
           e.preventDefault();
           performRedo();
       }
   });

   // Save initial state - but wait for content to load first
   function saveInitialStateWhenReady() {
       // Wait for either objects to be loaded or a reasonable timeout
       if (canvasObjects.length > 0) {
           console.log('📚 Saving initial state with', canvasObjects.length, 'objects');
           saveStateToHistory('Initial State');
       } else {
           // Check again after a short delay, up to 5 seconds total
           const checkCount = saveInitialStateWhenReady.checkCount || 0;
           if (checkCount < 50) { // 50 * 100ms = 5 seconds max
               saveInitialStateWhenReady.checkCount = checkCount + 1;
               setTimeout(saveInitialStateWhenReady, 100);
           } else {
               // Timeout reached, save empty state as fallback
               console.log('📚 Timeout reached, saving empty initial state');
               saveStateToHistory('Initial State');
           }
       }
   }

   setTimeout(saveInitialStateWhenReady, 500); // Start checking after 500ms

   // Helper function to save state with action name
   function saveState(actionName) {
       saveStateToHistory(actionName);
   }



   // --- Save Text Style Logic ---
   async function handleSaveTextStyle() {
       console.log('[SaveTextStyle] Button clicked - starting save process');

       if (!artboard) {
           const msg = 'Cannot save text style without an Artboard defined.';
           console.error('[SaveTextStyle] Error:', msg);
           alert(msg);
           return;
       }

       console.log('[SaveTextStyle] Artboard found:', artboard);
       console.log('[SaveTextStyle] Canvas objects count:', canvasObjects ? canvasObjects.length : 0);

       const saveBtn = document.getElementById('saveTextStyleBtn');
       if (saveBtn) saveBtn.disabled = true; // Disable button to prevent double-clicks

       // 1. Generate Preview Image (using the same method as Save Template)
       const exportCanvas = document.createElement('canvas');
       exportCanvas.width = artboard.width;
       exportCanvas.height = artboard.height;
       const exportCtx = exportCanvas.getContext('2d');

       // Set white background for preview
       exportCtx.fillStyle = '#ffffff';
       exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

       exportCtx.save();
       // Translate context so drawing happens relative to artboard's top-left
       exportCtx.translate(-artboard.x, -artboard.y);

       // Draw objects within artboard bounds using the same method as Save Template
       canvasObjects.forEach((obj) => {
           const bounds = calculateObjectBounds(obj);
           if (bounds.x + bounds.width > artboard.x && bounds.x < artboard.x + artboard.width &&
               bounds.y + bounds.height > artboard.y && bounds.y < artboard.y + artboard.height) {

               // Skip drawing mask shapes that are being used as masks (they should be invisible)
               if (obj.type === 'image' && obj.isMaskShape && obj.isVisible === false) {
                   console.log('[Preview] 🎭 Skipping drawing of mask shape in text style preview:', obj.id);
                   return; // Skip this object
               }

               if (obj.type === 'text') {
                   drawTextObject(obj, exportCtx);
               } else if (obj.type === 'image') {
                   drawImageObject(obj, exportCtx);
               }
           }
       });
       exportCtx.restore();

       const previewDataUrl = exportCanvas.toDataURL('image/png');
       let previewImageUrl = '';

       // 2. Upload Preview Image
       try {
           console.log('[SaveTextStyle] Uploading preview image...');
           console.log('[SaveTextStyle] Preview data URL length:', previewDataUrl.length);

           const blob = await (await fetch(previewDataUrl)).blob();
           console.log('[SaveTextStyle] Blob created, size:', blob.size);

           const formData = new FormData();
           formData.append('image', blob, `text_style_preview_${Date.now()}.png`);

           console.log('[SaveTextStyle] Sending request to /api/images/upload');
           const response = await fetch('/api/images/upload', {
               method: 'POST',
               body: formData
           });

           console.log('[SaveTextStyle] Upload response status:', response.status);

           if (!response.ok) {
               const errorText = await response.text();
               console.error('[SaveTextStyle] Upload failed with response:', errorText);
               throw new Error(`Preview upload failed: ${response.statusText} - ${errorText}`);
           }

           const result = await response.json();
           console.log('[SaveTextStyle] Upload response data:', result);

           previewImageUrl = result.imageUrl || result.url || result.fileUrl;

           if (!previewImageUrl || typeof previewImageUrl !== 'string') {
               console.error('[SaveTextStyle] Invalid upload response:', result);
               throw new Error('Invalid or missing imageUrl in preview upload response.');
           }

           console.log('[SaveTextStyle] Preview uploaded successfully:', previewImageUrl);

       } catch (e) {
           console.error('[SaveTextStyle] Error uploading preview:', e);
           const msg = `Error uploading preview: ${e.message}`;
           alert(msg);
           if (saveBtn) saveBtn.disabled = false;
           return;
       }

       // 3. Prepare Canvas Objects (filter to artboard bounds)
       const serializableObjects = canvasObjects.filter(obj => {
           return obj.x >= artboard.x && obj.y >= artboard.y &&
                  obj.x <= artboard.x + artboard.width && obj.y <= artboard.y + artboard.height;
       }).map(obj => {
           const cleanObj = cleanObjectForSerialization(obj);

           // Convert to relative coordinates
           cleanObj.x = obj.x - artboard.x;
           cleanObj.y = obj.y - artboard.y;

           console.log('[SaveTextStyle] Cleaned object:', obj.type, obj.text || obj.imageUrl, 'has meshWarp:', !!cleanObj.meshWarp);
           return cleanObj;
       });

       // 4. Get name from user
       const styleName = prompt('Enter a name for this text style:');
       if (!styleName) {
           console.log('[SaveTextStyle] User cancelled name input');
           if (saveBtn) saveBtn.disabled = false;
           return;
       }

       // 5. Prepare Text Style Data Payload (simplified compared to template)
       const textStyleData = {
           name: styleName.trim() || `Text Style ${Date.now()}`,
           previewImageUrl: previewImageUrl,
           artboard: {
               x: 0, // Always start at 0,0 for text styles
               y: 0,
               width: artboard.width,
               height: artboard.height
           },
           canvasObjects: serializableObjects
       };

       console.log('[SaveTextStyle] Data being sent:');
       console.log('[SaveTextStyle] - name:', textStyleData.name);
       console.log('[SaveTextStyle] - previewImageUrl:', textStyleData.previewImageUrl);
       console.log('[SaveTextStyle] - artboard:', textStyleData.artboard);
       console.log('[SaveTextStyle] - canvasObjects count:', textStyleData.canvasObjects.length);
       console.log('[SaveTextStyle] - Full data:', JSON.stringify(textStyleData, null, 2));

       // Validate required data before sending
       if (!textStyleData.previewImageUrl) {
           console.error('[SaveTextStyle] Missing previewImageUrl');
           alert('Error: Missing preview image URL');
           if (saveBtn) saveBtn.disabled = false;
           return;
       }

       if (!textStyleData.artboard || typeof textStyleData.artboard.width !== 'number' || typeof textStyleData.artboard.height !== 'number') {
           console.error('[SaveTextStyle] Invalid artboard data');
           alert('Error: Invalid artboard data');
           if (saveBtn) saveBtn.disabled = false;
           return;
       }

       if (!textStyleData.canvasObjects || !Array.isArray(textStyleData.canvasObjects)) {
           console.error('[SaveTextStyle] Invalid canvasObjects data');
           alert('Error: Invalid canvas objects data');
           if (saveBtn) saveBtn.disabled = false;
           return;
       }

       // 6. Send Data to Backend
       try {
           console.log('[SaveTextStyle] Saving text style data to /api/text-styles');
           const saveResponse = await fetch('/api/text-styles', {
               method: 'POST',
               headers: { 'Content-Type': 'application/json' },
               body: JSON.stringify(textStyleData)
           });

           if (!saveResponse.ok) {
                const errorText = await saveResponse.text();
                throw new Error(`Save text style failed: ${saveResponse.statusText} - ${errorText}`);
           }

           const savedTextStyle = await saveResponse.json();
           console.log('[SaveTextStyle] Text style saved successfully:', savedTextStyle);
           const msg = `Text style "${styleName}" saved successfully!`;
           alert(msg);

       } catch (e) {
            console.error('[SaveTextStyle] Error saving text style data:', e);
            const msg = `Error saving text style: ${e.message}`;
            alert(msg);
       } finally {
            if (saveBtn) saveBtn.disabled = false; // Re-enable button regardless of success/failure
       }
   }

   // Add event listeners for Save Template and Save Text Style buttons
   document.addEventListener('DOMContentLoaded', function() {
       // Initialize global project variables
       window.currentProjectId = null;
       window.currentProjectTitle = null;
       window.currentProjectFolderId = null;
       console.log('[Init] Global project variables initialized');

       // Project loading is handled by DOMContentLoaded event above
       // No need to duplicate project loading here
       console.log('[Init] Project loading handled by DOMContentLoaded event');

       const saveTemplateBtn = document.getElementById('saveTemplateBtn');
       if (saveTemplateBtn) {
           console.log('[Init] Save Template button found, adding event listener');
           saveTemplateBtn.addEventListener('click', handleSaveTemplate);
       } else {
           console.error('Save Template button not found!');
       }

       const updateTemplateBtn = document.getElementById('updateTemplateBtn');
       if (updateTemplateBtn) {
           console.log('[Init] Update Template button found, adding event listener');
           updateTemplateBtn.addEventListener('click', handleUpdateTemplate);
       }

       const saveAsTemplateBtn = document.getElementById('saveAsTemplateBtn');
       if (saveAsTemplateBtn) {
           console.log('[Init] Save As Template button found, adding event listener');
           saveAsTemplateBtn.addEventListener('click', handleSaveAsTemplate);
       }

       // Initialize save buttons for new template (default state)
       updateSaveButtonsForExistingTemplate(null, null);

       const saveTextStyleBtn = document.getElementById('saveTextStyleBtn');
       if (saveTextStyleBtn) {
           console.log('[Init] Save Text Style button found, adding event listener');
           saveTextStyleBtn.addEventListener('click', handleSaveTextStyle);
       } else {
           console.error('Save Text Style button not found!');
       }

       const validateMasksBtn = document.getElementById('validateMasksBtn');
       if (validateMasksBtn) {
           console.log('[Init] Validate Masks button found, adding event listener');
           validateMasksBtn.addEventListener('click', () => {
               const results = validateMaskRelationships();

               let message = `🎭 Mask Validation Results:\n\n`;
               message += `Total masked images: ${results.totalMaskedImages}\n`;
               message += `Valid relationships: ${results.validRelationships}\n`;
               message += `Broken relationships: ${results.brokenRelationships}\n`;
               message += `Orphaned masks: ${results.orphanedMasks}\n\n`;

               if (results.issues.length > 0) {
                   message += `Issues found:\n`;
                   results.issues.forEach((issue, index) => {
                       message += `${index + 1}. Image ${issue.imageId} (${issue.templateId || 'no template ID'}):\n`;
                       if (issue.issues.length > 0) {
                           issue.issues.forEach(problemDesc => {
                               message += `   - ${problemDesc}\n`;
                           });
                       } else {
                           message += `   ✅ Valid\n`;
                       }
                   });
               }

               message += `\nCheck console for detailed logs.`;
               alert(message);
           });
       } else {
           console.error('Validate Masks button not found!');
       }

       // Performance controls
       const performanceToggleBtn = document.getElementById('performanceToggleBtn');
       if (performanceToggleBtn) {
           console.log('[Init] Performance Toggle button found, adding event listener');
           performanceToggleBtn.addEventListener('click', () => {
               togglePerformanceMode();
               updatePerformanceIndicator();
           });
       }

       const performanceIndicator = document.getElementById('performanceIndicator');
       if (performanceIndicator) {
           console.log('[Init] Performance Indicator found, adding event listener');
           performanceIndicator.addEventListener('click', () => {
               const report = getPerformanceReport();
               const message = `🚀 Performance Report:\n\n` +
                   `Total Renders: ${report.totalRenders}\n` +
                   `Movement Renders: ${report.movementRenders}\n` +
                   `Average Render Time: ${report.averageRenderTime.toFixed(2)}ms\n` +
                   `Max Render Time: ${report.maxRenderTime.toFixed(2)}ms\n` +
                   `Renders/Second: ${report.rendersPerSecond}\n` +
                   `Font Cache Size: ${report.fontCacheSize}\n` +
                   `Font Cache Hit Rate: ${report.fontCacheHitRate}\n` +
                   `Uptime: ${(report.uptimeMs / 1000).toFixed(1)}s\n\n` +
                   `Performance Mode: ${PERFORMANCE_MODE ? 'ON' : 'OFF'}\n` +
                   `Debug Mode: ${DEBUG_MODE ? 'ON' : 'OFF'}\n\n` +
                   `Console commands:\n` +
                   `- togglePerformanceMode()\n` +
                   `- toggleDebugMode()\n` +
                   `- resetPerformanceStats()`;
               alert(message);
           });
       }

       // Initialize performance indicator
       updatePerformanceIndicator();
   });

   // Make cleanObjectForSerialization globally available
   window.cleanObjectForSerialization = cleanObjectForSerialization;

   // Font/Decor styles management moved to before DOMContentLoaded for proper initialization order



   // All font/decor styles management moved to before DOMContentLoaded for proper initialization order
   // This ensures project loading can properly restore font/decor styles

   // --- Canvas Quality Control Functions ---

   // Function to change canvas quality
   function setCanvasQuality(scaleFactor) {
       console.log(`🎯 [QUALITY] === CHANGING CANVAS QUALITY TO ${scaleFactor}x ===`);
       console.log(`🎯 [QUALITY] Previous scaleFactor: ${currentScaleFactor}`);

       currentScaleFactor = scaleFactor;

       // Log canvas state before re-setup
       console.log(`🎯 [QUALITY] BEFORE re-setup - Canvas: ${canvas.width}x${canvas.height}, Style: ${canvas.style.width}x${canvas.style.height}`);
       console.log(`🎯 [QUALITY] BEFORE re-setup - Transform:`, ctx.getTransform());

       // Re-setup canvas with new scale
       canvasScale = setupHighDPICanvas(canvas, ctx, scaleFactor);

       // Log canvas state after re-setup
       console.log(`🎯 [QUALITY] AFTER re-setup - Canvas: ${canvas.width}x${canvas.height}, Style: ${canvas.style.width}x${canvas.style.height}`);
       console.log(`🎯 [QUALITY] AFTER re-setup - Transform:`, ctx.getTransform());
       console.log(`🎯 [QUALITY] AFTER re-setup - canvasScale: ${canvasScale}`);

       // Update button states
       updateQualityButtonStates(scaleFactor);

       // Show a temporary quality indicator
       showQualityIndicator(scaleFactor);

       // Redraw everything using the correct function
       if (window.update && typeof window.update === 'function') {
           console.log(`🎯 [QUALITY] Calling window.update() to redraw canvas`);
           window.update();
       } else {
           console.warn('window.update function not available');
       }

       console.log(`✅ [QUALITY] Canvas quality changed to ${scaleFactor}x`);
       console.log(`✅ [QUALITY] Canvas actual dimensions: ${canvas.width}x${canvas.height}`);
       console.log(`✅ [QUALITY] Canvas display dimensions: ${canvas.style.width} x ${canvas.style.height}`);
   }

   // Function to show a temporary quality indicator
   function showQualityIndicator(scaleFactor) {
       // Remove any existing indicator
       const existingIndicator = document.getElementById('qualityIndicator');
       if (existingIndicator) {
           existingIndicator.remove();
       }

       // Create new indicator
       const indicator = document.createElement('div');
       indicator.id = 'qualityIndicator';
       indicator.style.cssText = `
           position: fixed;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           background: rgba(0, 0, 0, 0.8);
           color: white;
           padding: 20px 30px;
           border-radius: 10px;
           font-size: 18px;
           font-weight: bold;
           z-index: 10000;
           pointer-events: none;
       `;
       indicator.textContent = `Canvas Quality: ${scaleFactor}x`;
       document.body.appendChild(indicator);

       // Remove after 2 seconds
       setTimeout(() => {
           if (indicator.parentNode) {
               indicator.parentNode.removeChild(indicator);
           }
       }, 2000);
   }

   // Function to update quality button states
   function updateQualityButtonStates(activeScale) {
       const buttons = ['quality1xBtn', 'quality2xBtn', 'quality4xBtn'];
       const scales = [1, 2, 4];

       buttons.forEach((buttonId, index) => {
           const button = document.getElementById(buttonId);
           if (button) {
               if (scales[index] === activeScale) {
                   button.classList.add('active');
               } else {
                   button.classList.remove('active');
               }
           }
       });
   }

   // Make quality control function globally available
   window.setCanvasQuality = setCanvasQuality;

   // Initialize quality button states on page load
   document.addEventListener('DOMContentLoaded', () => {
       updateQualityButtonStates(currentScaleFactor);
   });

   // 🔒 UI INTERACTION LOCK: Add comprehensive UI interaction detection
   document.addEventListener('DOMContentLoaded', () => {
       console.log('🔒 UI LOCK: Setting up comprehensive UI interaction detection');

       // Get all UI control areas
       const uiControlAreas = [
           '.controls-panel',
           '.text-controls',
           '.image-controls',
           '.shape-controls',
           '.right-panel',
           '.property-controls',
           '.left-sidebar',
           '.left-menu'
       ];

       // Add event listeners for common UI interactions
       uiControlAreas.forEach(selector => {
           const elements = document.querySelectorAll(selector);
           elements.forEach(element => {
               // Mouse events
               element.addEventListener('mousedown', startUIInteraction);
               element.addEventListener('mouseenter', startUIInteraction);

               // Input events
               element.addEventListener('input', startUIInteraction);
               element.addEventListener('change', startUIInteraction);
               element.addEventListener('click', startUIInteraction);

               // Focus events
               element.addEventListener('focus', startUIInteraction, true); // Use capture
               element.addEventListener('focusin', startUIInteraction);
           });
       });

       // Add specific listeners for input elements
       const inputElements = document.querySelectorAll('input, select, button, textarea');
       inputElements.forEach(element => {
           element.addEventListener('mousedown', startUIInteraction);
           element.addEventListener('input', startUIInteraction);
           element.addEventListener('change', startUIInteraction);
           element.addEventListener('focus', startUIInteraction);
       });

       // Add listeners for sliders specifically
       const sliders = document.querySelectorAll('input[type="range"]');
       sliders.forEach(slider => {
           slider.addEventListener('mousedown', startUIInteraction);
           slider.addEventListener('input', startUIInteraction);
           slider.addEventListener('change', startUIInteraction);
       });

       console.log('🔒 UI LOCK: UI interaction detection setup complete');
   });





