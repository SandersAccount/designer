<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Canvas Studio - Image & Text</title>
    <link rel="stylesheet" href="/styles.css"> <!-- Main styles with proper topbar -->
    <link rel="stylesheet" href="/style-design-editor.css">
    <link href="https://cdn.jsdelivr.net/npm/@simonwep/pickr@1.9.1/dist/themes/nano.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"> <!-- Added Font Awesome -->
    <link rel="stylesheet" href="/css/artboard-edit.css"> <!-- Artboard Edit Mode Styles -->
    <link rel="stylesheet" href="/css/left-menu.css"> <!-- Left Menu Styles -->
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;0,500;0,600;1,400&family=Arial&family=Verdana&family=Georgia&family=Times+New+Roman&family=Courier+New&family=Impact&family=Comic+Sans+MS:wght@400;700&display=swap" rel="stylesheet">

    <!-- Professional Button Styles -->
    <style>
        /* Professional buttons matching collection page style */
        .professional-btn {
            width: calc(70% - 20px);
            margin-left: 110px;
            padding: 0.6rem 1rem;
            font-size: 0.9em;
            font-family: 'Arial', sans-serif;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            margin-bottom: 8px;
            text-decoration: none;
            text-align: left;
            font-style: normal;
        }

        .professional-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .professional-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .professional-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .professional-btn:disabled:hover {
            background: white;
            border-color: #d1d5db;
            transform: none;
            box-shadow: none;
        }

        .professional-btn i {
            font-size: 0.85em;
            color: #6b7280;
        }

        /* Image actions container */
        .image-actions-container {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        /* Header styling for sections */
        .image-actions-header {
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
            color: #374151;
            margin-top: 20px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
        }

        /* AI Object Enhancement Container Styling */
        .ai-object-enhancement-container {
            display: flex;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
        }

        .ai-tone-dropdown {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 12px;
            cursor: pointer;
            color: #374151;
            min-width: 0; /* Allow shrinking */
        }

        .ai-tone-dropdown:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 1px rgba(0, 123, 255, 0.25);
        }

        .ai-enhance-object-btn {
            background: #ffffff;
            color: #393939;
            border: 1px solid #ddd;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 32px;
            height: 32px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .ai-enhance-object-btn:hover {
            background: #f8f9fa;
            border-color: #007bff;
            color: #007bff;
        }

        .ai-enhance-object-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ai-enhance-object-btn.regenerate-mode {
            background: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        .ai-enhance-object-btn.regenerate-mode:hover {
            background: #5a6268;
            border-color: #545b62;
        }

        /* Export Format Dropdown Styles */
        .export-group {
            position: relative;
            display: inline-block;
        }

        .export-format-dropdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 220px;
            max-height: 300px;
            overflow-y: auto;
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        .export-format-dropdown.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .export-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .export-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .export-dropdown-header {
            padding: 15px 20px 10px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .format-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            border: none;
            background: white;
            color: #333;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
            white-space: nowrap;
            border-radius: 0;
        }

        .format-btn:hover {
            background: #f5f5f5;
        }

        .format-btn:first-child {
            border-radius: 4px 4px 0 0;
        }

        .format-btn:last-child {
            border-radius: 0 0 4px 4px;
        }

        .format-btn.selected {
            background: #007bff;
            color: white;
        }

        /* AI Enhancement Section Styling */
        .ai-enhancement-section {
            margin-left: 115px; /* Align with text input field */
            max-width: calc(100% - 80px);
            overflow: visible;
            position: relative;
            z-index: 100;
        }

        .ai-enhancement-layout {
            display: flex;
            gap: 6px;
            align-items: center;
            max-width: 100%;
            overflow: visible;
            position: relative;
        }

        .ai-checkbox-row {
            margin-top: 10px;
        }
        .ai-checkbox-row-side {
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .text-tone-dropdown-full {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            font-size: 12px;
            cursor: pointer;
            color: #374151;
            box-sizing: border-box;
            position: relative;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
        }

        .text-tone-dropdown:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 1px rgba(0, 123, 255, 0.25);
        }

        .text-tone-dropdown:disabled {
            background-color: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .enhance-text-btn {
            background: #ffffff;
            color: #393939;
            border: 1px solid #d1d5db;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            white-space: nowrap;
            transition: all 0.2s ease;
            font-family: inherit;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .enhance-text-btn:hover:not(:disabled) {
            background: #f8f9fa;
            border-color: #007bff;
            color: #007bff;
        }

        .enhance-text-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #f3f4f6;
            color: #9ca3af;
        }

        .enhance-text-btn.regenerate-mode {
            background: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        .enhance-text-btn.regenerate-mode:hover {
            background: #5a6268;
            border-color: #545b62;
        }

        /* Square button for AI enhancement */
        .enhance-text-btn-square {
            background: #ffffff;
            color: #393939;
            border: 1px solid #d1d5db;
            padding: 6px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-family: inherit;
            width: 32px;
            height: 32px;
            min-width: 32px;
            box-sizing: border-box;
        }

        .enhance-text-btn-square:hover:not(:disabled) {
            background: #f8f9fa;
            border-color: #007bff;
            color: #007bff;
        }

        .enhance-text-btn-square:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: #f3f4f6;
            color: #9ca3af;
        }

        .enhance-text-btn-square.regenerate-mode {
            background: #6c757d;
            color: white;
            border-color: #6c757d;
        }

        .enhance-text-btn-square.regenerate-mode:hover {
            background: #5a6268;
            border-color: #545b62;
        }

        /* Checkbox styling for text enhancement */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 11px;
            line-height: 1.2;
        }

        .checkbox-label input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-label input[type="checkbox"]:disabled {
            cursor: not-allowed;
        }

        /* Ensure control groups allow dropdown overflow */
        .control-group {
            position: relative;
            overflow: visible;
            z-index: 1;
        }

        /* Text alignment button styles */
        .alignment-btn {
            transition: all 0.2s ease;
            color: #666;
        }

        .alignment-btn:hover {
            background: #e9ecef !important;
            border-color: #adb5bd !important;
            color: #333;
        }

        .alignment-btn.active {
            background: #007bff !important;
            border-color: #007bff !important;
            color: white;
        }

        .alignment-btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        /* Special handling for AI text enhancement control group */
        .control-group:has(.text-enhancement-container) {
            overflow: visible;
            z-index: 100;
        }

        /* Button container and action button styling */
        .button-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .action-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .action-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .action-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Font selector with navigation arrows */
        .font-selector-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .font-selector-container select {
            flex: 1;
            min-width: 0;
            max-width: calc(100% - 60px);
        }

        .font-nav-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .font-nav-btn {
            width: 24px;
            height: 20px;
            padding: 0;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            background: white;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 0;
        }

        .font-nav-btn:hover:not(:disabled) {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .font-nav-btn:active:not(:disabled) {
            background: #e5e7eb;
            transform: scale(0.95);
        }

        .font-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f9fafb;
        }

        .font-nav-btn svg {
            pointer-events: none;
        }

        /* All Caps control styling */
        .all-caps-control {
            margin-top: 6px;
        }

        .all-caps-control .checkbox-label {
            font-size: 12px;
        }

        .checkbox-text {
            color: #374151;
        }

        /* Canvas Quality Controls */
        .quality-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .quality-label {
            font-size: 12px;
            color: #6b7280;
            margin-right: 4px;
        }

        .quality-btn {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #d1d5db;
            background: white;
            color: #374151;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 28px;
        }

        .quality-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .quality-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .quality-btn.active:hover {
            background: #2563eb;
            border-color: #2563eb;
        }

        /* 🔥 HIDE SPECIFIC CANVAS CONTROLS - User Request */
        #unlockAllBtn,
        #unhideAllBtn,
        #testObjectBtn,
        #performanceToggleBtn,
        #performanceIndicator,
        .quality-controls,
        .quality-label {
            display: none !important;
        }

        /* 🔥 HIDE TOOLBAR ELEMENTS - User Request */
        #copyElementBtn,
        #pasteElementBtn {
            display: none !important;
        }

        /* Rulers and Guidelines System */
        .ruler-corner {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            z-index: 1000;
        }

        .horizontal-ruler {
            position: absolute;
            top: 0;
            left: 20px;
            height: 20px;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            z-index: 1000;
            cursor: crosshair;
            display: none; /* Hidden by default */
        }

        .vertical-ruler {
            position: absolute;
            top: 20px;
            left: 0;
            width: 20px;
            background: #f5f5f5;
            border-right: 1px solid #ddd;
            z-index: 1000;
            cursor: crosshair;
            display: none; /* Hidden by default */
        }

        .ruler-corner {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
            border-right: 1px solid #ddd;
            z-index: 1000;
            display: none; /* Hidden by default */
        }

        .guidelines-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 500;
        }

        .guideline {
            position: absolute;
            background: #007bff;
            pointer-events: auto;
            z-index: 500;
        }

        .guideline.horizontal {
            height: 1px;
            cursor: ns-resize;
        }

        .guideline.vertical {
            width: 1px;
            cursor: ew-resize;
        }

        .guideline:hover {
            background: #dc3545;
        }

        .guideline.dragging {
            background: #dc3545;
        }

        /* Admin test buttons */
        .admin-test-btn {
            margin-top: 5px;
            padding: 4px 8px;
            font-size: 12px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .admin-test-btn.primary {
            background-color: #6366f1;
        }

        .admin-test-btn.success {
            background-color: #10b981;
        }

        .admin-test-btn.danger {
            background-color: #ef4444;
        }

        /* Shape replacement dropdown styling */
        .shape-replacement-select {
            flex: 1;
            border: 2px solid #3498db;
            background-color: #f8fcff;
            padding: 6px;
            border-radius: 4px;
        }

        /* Perspective control styling */
        .perspective-control {
            display: none;
            margin-top: 10px;
            padding: 8px;
            background-color: #f0f9ff;
            border-left: 3px solid #3b82f6;
            border-radius: 4px;
        }

        /* Hidden control groups */
        .control-group.hidden {
            display: none;
        }

        /* Helper text styling */
        .helper-text {
            color: #666;
            font-size: 11px;
            display: block;
            margin-top: 3px;
        }

        /* Full width select styling */
        .full-width-select {
            width: 100%;
            padding: 6px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background-color: #fff;
        }

        /* Debug display styling */
        .debug-display {
            margin-top: 8px;
            padding: 8px;
            background-color: #f0f9ff;
            border: 2px solid #3b82f6;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }

        .debug-text {
            font-size: 12px;
            color: #1e40af;
            font-weight: bold;
        }

        /* Common utility classes */
        .hidden {
            display: none;
        }

        .flex-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .flex-column {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .icon-style {
            font-size: 20px;
            color: #6b7280;
        }

        .button-icon {
            width: 16px;
            height: 16px;
            vertical-align: middle;
        }

        .button-icon-flipped {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            transform: scaleX(-1);
        }

        .button-icon-rotated {
            width: 16px;
            height: 16px;
            vertical-align: middle;
            transform: rotate(180deg);
        }

        .export-button {
            padding: 8px 6px;
            margin-left: 2px;
        }

        .test-button {
            background: #22c55e;
            color: white;
        }

        .readonly-input {
            background-color: #e9ecef;
            flex-grow: 1;
        }

        .readonly-textarea {
            background-color: #e9ecef;
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9em;
            resize: vertical;
        }

        .monospace-textarea {
            font-family: monospace;
        }

        .small-text {
            color: #666;
            font-size: 10px;
            margin-top: 2px;
        }

        .section-border {
            border-top: 2px solid;
            margin-top: 15px;
            padding-top: 15px;
        }

        .section-border-green {
            border-color: #10b981;
        }

        .section-border-purple {
            border-color: #8b5cf6;
        }

        .section-border-orange {
            border-color: #f59e0b;
        }

        .section-border-red {
            border-color: #ef4444;
        }

        .section-border-blue {
            border-color: #3498db;
        }

        .section-border-crimson {
            border-color: #e74c3c;
        }

        .status-display {
            font-size: 11px;
            color: #666;
            padding: 4px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .blue-status {
            background-color: #f8fcff;
            border: 1px solid #bde4ff;
            margin-top: 8px;
        }

        .admin-header {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1e293b;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 8px;
        }

        .admin-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .label-left {
            flex-basis: 80px;
            text-align: left;
        }

        .label-auto {
            flex-basis: auto;
            text-align: left;
            margin-bottom: 5px;
        }

        .save-button {
            margin-top: 15px;
        }

        .save-button-green {
            background-color: #10b981;
        }

        .save-button-secondary {
            margin-top: 10px;
        }

        .save-button-blue {
            background-color: #6366f1;
        }

        .svg-hidden {
            position: absolute;
            width: 0;
            height: 0;
            visibility: hidden;
        }

        .divider-line {
            border-top: 1px solid #eee;
            margin: 8px 0;
        }

        /* Form control styling */
        .form-label-bold {
            font-weight: 500;
            color: #374151;
        }

        .form-label-flex {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #374151;
        }

        .form-input-color {
            width: 40px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .form-input-text {
            flex: 1;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: monospace;
        }

        .form-input-file {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
        }

        .form-select-small {
            width: 100%;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
        }

        .form-select-flex {
            flex: 1;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background: white;
        }

        .button-full-width {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .button-small {
            width: 100%;
            padding: 6px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-top: 8px;
        }

        .button-green {
            background-color: #10b981;
            color: white;
        }

        .button-blue {
            background-color: #3b82f6;
            color: white;
        }

        .button-purple {
            background-color: #8b5cf6;
            color: white;
        }

        .button-purple-dark {
            background-color: #7c3aed;
            color: white;
        }

        .button-orange {
            background-color: #f59e0b;
            color: white;
        }

        .button-red {
            background-color: #ef4444;
            color: white;
        }

        .button-gray {
            background-color: #6b7280;
            color: white;
        }

        .button-success {
            background-color: #28a745;
            color: white;
        }

        .button-primary {
            background-color: #007bff;
            color: white;
        }

        .button-delete {
            padding: 6px 10px;
            font-size: 12px;
            border: 1px solid #dc3545;
            border-radius: 3px;
            background: #dc3545;
            color: white;
            cursor: pointer;
        }

        .controls-hidden {
            display: none;
            margin-left: 20px;
        }

        .image-header {
            margin-top: 20px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e5e7eb;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
            color: #374151;
        }

        .flex-gap-5 {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .flex-gap-8 {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 5px;
        }

        .margin-no {
            margin: 0;
        }

        .tip-box {
            background: #f3f4f6;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #6b7280;
            border-left: 3px solid #3b82f6;
        }

        .preview-hidden {
            margin-top: 8px;
            text-align: center;
            display: none;
        }

        .preview-image {
            max-width: 100px;
            max-height: 60px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .clear-button {
            display: block;
            margin: 5px auto;
            padding: 4px 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
        }

        .small-gray-text {
            font-size: 11px;
            color: #6b7280;
            margin-top: 4px;
        }

        .preset-input {
            width: 100%;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
            margin-bottom: 8px;
            font-family: 'Inter', sans-serif;
        }

        .preset-save-button {
            width: 100%;
            padding: 8px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .margin-top-5 {
            margin-top: 5px;
        }

        .margin-top-10 {
            margin-top: 10px;
        }

        .margin-top-15 {
            margin-top: 15px;
        }

        .padding-top-15 {
            padding-top: 15px;
        }

        .border-top-gray {
            border-top: 1px solid #e5e7eb;
        }

        .crimson-label {
            color: #e74c3c;
            font-weight: bold;
        }

        .crimson-border {
            border: 2px solid #e74c3c;
            background-color: #fff5f5;
        }

        .blue-label {
            color: #3498db;
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
        }

        .blue-button {
            background: #3498db;
            border-color: #3498db;
            padding: 6px 12px;
            font-size: 12px;
        }

        .gray-button {
            background: #95a5a6;
            border-color: #95a5a6;
            padding: 6px 10px;
            font-size: 11px;
        }

        .small-gray-label {
            color: #7f8c8d;
            font-size: 11px;
            display: block;
            margin-top: 5px;
        }

        .debug-red {
            margin-top: 5px;
            padding: 5px;
            background-color: #fef2f2;
            border: 1px solid #e74c3c;
            border-radius: 4px;
        }

        .debug-red-text {
            font-size: 10px;
            color: #dc2626;
            font-weight: bold;
        }

        .debug-red-large {
            margin-top: 8px;
            padding: 8px;
            background-color: #fef2f2;
            border: 2px solid #e74c3c;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.1);
        }

        .debug-red-text-large {
            font-size: 12px;
            color: #dc2626;
            font-weight: bold;
        }

        /* Text box and slider controls */
        .text-box-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .text-box-slider {
            flex: 1;
            height: 6px;
            background: #ddd;
            outline: none;
            border-radius: 3px;
        }

        .text-box-value {
            min-width: 80px;
            font-size: 12px;
            color: #666;
        }

        .line-height-value {
            min-width: 40px;
            font-size: 12px;
            color: #666;
        }

        /* Alignment buttons */
        .alignment-container {
            display: flex;
            gap: 4px;
            margin-top: 5px;
        }

        .alignment-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Image effects form controls */
        .form-label-flex-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            color: #374151;
        }

        .form-checkbox-no-margin {
            margin: 0;
        }

        .form-color-input {
            width: 40px;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .form-text-input-mono {
            flex: 1;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: monospace;
        }

        .form-file-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
        }

        .form-color-input-full {
            width: 100%;
            height: 32px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 5px;
        }

        .form-select-margin {
            width: 100%;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
        }

        .controls-hidden-indent {
            display: none;
            margin-left: 20px;
        }

        .preview-container {
            margin-top: 8px;
            text-align: center;
            display: none;
        }

        .small-gray-text-margin {
            font-size: 11px;
            color: #6b7280;
            margin-top: 4px;
        }

        .tip-box-blue {
            background: #f3f4f6;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #6b7280;
            border-left: 3px solid #3b82f6;
        }

        .control-group-hidden {
            display: none;
        }

        .flex-column-start {
            flex-direction: column;
            align-items: flex-start;
        }

        .label-margin-bottom {
            flex-basis: auto;
            text-align: left;
            margin-bottom: 5px;
        }

        .readonly-textarea-mono {
            background-color: #e9ecef;
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9em;
            resize: vertical;
            font-family: monospace;
        }

        .small-text-margin {
            color: #666;
            font-size: 10px;
            margin-top: 2px;
        }

        .save-button-margin {
            margin-top: 15px;
        }

        .save-button-margin-small {
            margin-top: 10px;
        }

        .save-button-hidden {
            margin-top: 15px;
            display: none;
        }

        .save-button-hidden-small {
            margin-top: 10px;
            display: none;
        }

        .save-button-blue-hidden {
            margin-top: 15px;
            display: none;
            background-color: #10b981;
        }

        .save-button-purple-margin {
            margin-top: 10px;
            background-color: #6366f1;
        }

        .border-top-gray-margin {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e5e7eb;
        }

        .form-label-bold-color {
            font-weight: 600;
            color: #374151;
        }

        .preset-input-margin {
            width: 100%;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-top: 5px;
            margin-bottom: 8px;
            font-family: 'Inter', sans-serif;
        }

        .preset-save-button-transition {
            width: 100%;
            padding: 8px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .test-button-margin {
            width: 100%;
            padding: 8px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
        }

        .debug-button-margin {
            width: 100%;
            padding: 8px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 5px;
        }

        .reset-button-red {
            width: 100%;
            padding: 8px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .reset-button-gray-small {
            width: 100%;
            padding: 6px;
            background-color: #6b7280;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-top: 8px;
        }

        .admin-controls-flex {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .blue-status-border {
            font-size: 11px;
            color: #666;
            padding: 4px;
            background-color: #f8fcff;
            border-radius: 4px;
            margin-top: 8px;
            border: 1px solid #bde4ff;
        }

        .debug-red-small {
            margin-top: 5px;
            padding: 5px;
            background-color: #fef2f2;
            border: 1px solid #e74c3c;
            border-radius: 4px;
        }

        .debug-red-text-small {
            font-size: 10px;
            color: #dc2626;
            font-weight: bold;
        }

        .debug-red-text-small-normal {
            font-size: 10px;
            color: #dc2626;
        }

        /* Additional utility classes for remaining inline styles */
        .admin-label-80 {
            flex-basis: 80px;
            text-align: left;
        }

        .admin-input-readonly {
            background-color: #e9ecef;
            flex-grow: 1;
        }

        .admin-textarea-readonly {
            background-color: #e9ecef;
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9em;
            resize: vertical;
        }

        .admin-textarea-readonly-mono {
            background-color: #e9ecef;
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9em;
            resize: vertical;
            font-family: monospace;
        }

        .blue-button-custom {
            background: #3498db;
            border-color: #3498db;
            padding: 6px 12px;
            font-size: 12px;
        }

        .gray-button-custom {
            background: #95a5a6;
            border-color: #95a5a6;
            padding: 6px 10px;
            font-size: 11px;
        }

        .preview-img-small {
            max-width: 100px;
            max-height: 60px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .clear-button-small {
            display: block;
            margin: 5px auto;
            padding: 4px 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
        }

        .svg-hidden {
            position: absolute;
            width: 0;
            height: 0;
            visibility: hidden;
        }

        /* Accessibility utility class */
        .visually-hidden {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        /* Two-Column Layout for Text Properties */
        .text-properties-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 12px;
            padding: 0;
            align-items: start;
        }

        .property-label {
            text-align: right;
            font-family: 'Inter', sans-serif !important;
            font-weight: 400 !important;
            font-size: 13px !important;
            color: #374151;
            align-self: center;
            margin: 0;
            padding-right: 8px;
        }

        .property-control {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        /* Standardized control sizing */
        .property-control select,
        .property-control input[type="text"] {
            width: 100%;
            max-width: 200px;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: 'Inter', sans-serif !important;
            font-size: 13px !important;
            font-weight: 400 !important;
            background: white;
            box-sizing: border-box;
        }

        /* Font dropdown (wider for arrows) */
        .font-control-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .font-control-container select {
            flex: 1;
            max-width: 160px;
        }

        .font-nav-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .font-nav-btn {
            width: 20px;
            height: 18px;
            padding: 0;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        /* Slider containers */
        .slider-control-container {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .slider-control-container input[type="range"] {
            flex: 1;
            max-width: 140px;
            margin: 0;
        }

        .slider-value-display {
            min-width: 60px;
            text-align: right;
            font-family: 'Inter', sans-serif !important;
            font-size: 12px !important;
            font-weight: 400 !important;
            color: #6b7280;
        }

        /* Color picker container */
        .color-control-container {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .color-control-container input[type="color"] {
            width: 40px;
            height: 32px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        /* Simplified color picker with gradient support */
        .simplified-color-picker {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 200px;
        }

        .simplified-color-picker input[type="color"] {
            width: 100%;
            height: 32px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            background: none;
            padding: 0;
            box-sizing: border-box;
        }

        .simplified-color-picker input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 3px;
        }

        .simplified-color-picker input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }

        /* Alignment buttons container */
        .alignment-control-container {
            display: flex;
            gap: 4px;
            width: 100%;
        }

        .alignment-control-container button {
            flex: 1;
            max-width: 40px;
            height: 32px;
            padding: 6px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .alignment-control-container button:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .alignment-control-container button.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        /* Style controls (Bold, Italic, All Caps) */
        .style-control-container {
            display: flex;
            align-items: center;
            gap: 16px;
            width: 100%;
        }

        .style-checkbox-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .style-checkbox-group label {
            font-family: 'Inter', sans-serif !important;
            font-size: 13px !important;
            font-weight: 400 !important;
            margin: 0;
        }

        .style-checkbox-group input[type="checkbox"] {
            margin: 0;
        }

        /* AI Section at bottom */
        .ai-section-bottom {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
        }

        /* Remove debug displays */
        .debug-display {
            display: none !important;
        }

        /* Ensure consistent typography */
        .text-properties-grid * {
            font-family: 'Inter', sans-serif !important;
            font-weight: 400 !important;
        }

        .text-properties-grid label {
            font-size: 13px !important;
        }

        .text-properties-grid input,
        .text-properties-grid select,
        .text-properties-grid button {
            font-size: 13px !important;
        }

        /* Hide helper text for cleaner look */
        .helper-text {
            display: none;
        }

        /* AI Section specific styling */
        .ai-section-bottom .control-group {
            margin-bottom: 12px;
        }

        .ai-section-bottom .button-full-width {
            width: 100%;
            margin-bottom: 4px;
        }

        /* Ensure AI buttons maintain their original colors and styling */
        .ai-section-bottom .section-border {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        /* Text box action buttons - keep outside grid for now */
        .text-box-actions {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #e5e7eb;
        }

        .text-box-actions .button-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .text-box-actions .action-button {
            flex: 1;
            min-width: 120px;
            padding: 8px 12px;
            font-size: 12px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }

        .text-box-actions .action-button:hover {
            background: #f3f4f6;
        }

        .text-box-actions .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* AI Enhancement Control Styling */
        .ai-enhancement-control {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .ai-enhancement-control select {
            flex: 1;
        }

        .ai-enhancement-control .enhance-text-btn-square {
            width: 32px;
            height: 32px;
            padding: 6px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-enhancement-control .enhance-text-btn-square:hover {
            background: #f3f4f6;
        }

        .ai-enhancement-control .enhance-text-btn-square:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* AI Tab Styling */
        .ai-header {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3b82f6;
        }

        .ai-section {
            margin-bottom: 24px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .ai-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 500;
            color: #475569;
        }

        .ai-actions-section {
            margin-top: 16px;
        }

        .ai-actions-section h4 {
            margin: 0 0 16px 0;
            font-size: 14px;
            font-weight: 500;
            color: #475569;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        /* Show helper text in AI tab */
        #ai-tab-content .helper-text {
            display: block;
            font-size: 11px;
            color: #6b7280;
            margin-top: 4px;
            line-height: 1.3;
        }

        /* Status displays in AI tab */
        .status-display {
            font-size: 11px;
            color: #6b7280;
            margin-top: 8px;
            padding: 6px 8px;
            background: #f1f5f9;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }

        /* Gradient Color Picker Container */
        .gradient-color-picker-container {
            width: 100%;
            max-width: 200px;
        }

        /* Override gradient picker styles to fit in our layout */
        .gradient-picker-container {
            width: 100% !important;
        }

        .gradient-picker-preview {
            width: 100% !important;
            height: 32px !important;
            border: 1px solid #d1d5db !important;
            border-radius: 4px !important;
            cursor: pointer !important;
        }

        .gradient-picker-dropdown {
            position: absolute !important;
            top: 100% !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 1000 !important;
            background: white !important;
            border: 1px solid #d1d5db !important;
            border-radius: 6px !important;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
            margin-top: 4px !important;
            min-width: 300px !important;
        }

        .gradient-picker-header {
            padding: 12px !important;
            border-bottom: 1px solid #e5e7eb !important;
        }

        .gradient-type-tabs {
            display: flex !important;
            gap: 4px !important;
            margin-bottom: 8px !important;
        }

        .gradient-tab {
            flex: 1 !important;
            padding: 6px 12px !important;
            border: 1px solid #d1d5db !important;
            background: white !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            font-size: 12px !important;
            transition: all 0.2s ease !important;
        }

        .gradient-tab.active {
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
        }

        .gradient-picker-actions {
            display: flex !important;
            gap: 8px !important;
            justify-content: flex-end !important;
        }

        .gradient-apply-btn,
        .gradient-cancel-btn {
            padding: 6px 16px !important;
            border: 1px solid #d1d5db !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            font-size: 12px !important;
        }

        .gradient-apply-btn {
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
        }

        .gradient-cancel-btn {
            background: white !important;
            color: #374151 !important;
        }

        .gradient-picker-content {
            padding: 12px !important;
        }

        .gradient-panel {
            display: none !important;
        }

        .gradient-panel.active {
            display: block !important;
        }

        .color-picker-container {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
        }

        .gradient-solid-color-input {
            width: 40px !important;
            height: 32px !important;
            border: 1px solid #d1d5db !important;
            border-radius: 4px !important;
            cursor: pointer !important;
        }

        .color-input-wrapper {
            display: flex !important;
            align-items: center !important;
            gap: 8px !important;
        }

        .gradient-solid-color-text {
            width: 80px !important;
            padding: 6px 8px !important;
            border: 1px solid #d1d5db !important;
            border-radius: 4px !important;
            font-size: 12px !important;
        }

        /* Stroke parameter controls */
        .parameter-control.stroke-param {
            margin-top: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .parameter-control.stroke-param.hidden {
            display: none;
        }

        .parameter-control.stroke-param h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            font-weight: 500;
            color: #475569;
        }

        /* Font dropdown styling to show fonts in their actual style */
        #iFontFamily {
            font-size: 14px;
        }

        #iFontFamily option {
            font-size: 14px !important;
            padding: 4px 8px !important;
        }

        /* Force each font option to display in its own font */
        #iFontFamily option[style*="Poppins"] { font-family: "Poppins", sans-serif !important; }
        #iFontFamily option[style*="Arial"] { font-family: "Arial", sans-serif !important; }
        #iFontFamily option[style*="Verdana"] { font-family: "Verdana", sans-serif !important; }
        #iFontFamily option[style*="Georgia"] { font-family: "Georgia", serif !important; }
        #iFontFamily option[style*="Times"] { font-family: "Times New Roman", serif !important; }
        #iFontFamily option[style*="Courier"] { font-family: "Courier New", monospace !important; }
        #iFontFamily option[style*="Impact"] { font-family: "Impact", sans-serif !important; }
        #iFontFamily option[style*="Comic"] { font-family: "Comic Sans MS", cursive !important; }

        /* Additional font styling for better visibility */
        .font-control-container select {
            font-size: 14px;
        }

        .font-control-container select option {
            font-size: 14px !important;
            padding: 6px 8px !important;
        }

        /* Try to force font inheritance */
        select option {
            font-family: inherit !important;
        }

        /* AI Enhancement Section Styling */
        .ai-enhancement-section {
            margin-left: 115px; /* Align with text input field */
            max-width: calc(100% - 80px);
            overflow: visible;
            position: relative;
            z-index: 100;
        }

        .ai-enhancement-layout {
            display: flex;
            gap: 6px;
            align-items: center;
            max-width: 100%;
            overflow: visible;
            position: relative;
        }

        .ai-enhancement-control {
            margin-top: 10px;
        }

        .ai-enhancement-control input[type="checkbox"] {
            margin-right: 8px;
        }

        .ai-enhancement-control label {
            font-size: 12px;
            color: #666;
        }

        /* AI note styling */
        .ai-note {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 16px;
            font-size: 12px;
            color: #0369a1;
        }

        /* Color picker modal z-index fix */
        .pcr-app {
            z-index: 99999 !important;
        }

        /* Gradient color picker modal z-index fix */
        .gradient-color-picker-modal {
            z-index: 99999 !important;
        }

        /* General modal overlay z-index */
        .modal-overlay {
            z-index: 99998 !important;
        }
    </style>
</head>
<body class="normal">
    <div class="studio-container">
        <main class="main-content">
            <!-- Left Menu -->
            <div class="left-menu">
                <div class="left-menu-item" data-sidebar="menu-sidebar">
                    <img src="/images/ion-menu-outline-icon.svg" alt="Menu">
                </div>
                <div class="left-menu-item" data-sidebar="text-sidebar">
                    <img src="/images/ph-text-t-light-icon.svg" alt="Text">
                </div>
                <div class="left-menu-item" data-sidebar="elements-sidebar">
                    <img src="/images/ph-shapes-light-icon.svg" alt="Elements">
                </div>
                <div class="left-menu-item" data-sidebar="images-sidebar">
                    <img src="/images/ph-images-square-light-icon.svg" alt="Images">
                </div>
                <div class="left-menu-item" data-sidebar="ai-generator-sidebar">
                    <i class="fas fa-magic icon-style"></i>
                </div>
            </div>

            <!-- Left Sidebars -->
            <div class="left-sidebar" id="menu-sidebar">
                <div class="left-sidebar-header">
                    <h3>Menu</h3>
                    <button class="left-sidebar-close">&times;</button>
                </div>
                <div class="left-sidebar-content">
                    <div class="section-title">Project Options</div>
                    <ul class="menu-items">
                        <li class="menu-item">New Project</li>
                        <li class="menu-item">My Projects</li>
                        <li class="menu-item" id="saveProjectBtn">Save Project</li>
                        <li class="menu-item hidden" id="updateProjectBtn">Save Project</li>
                        <li class="menu-item hidden" id="saveAsProjectBtn">📋 Save As New Project</li>
                        <li class="menu-item">Duplicate Project</li>
                    </ul>
                </div>
            </div>

            <div class="left-sidebar" id="text-sidebar">
                <div class="left-sidebar-header">
                    <h3>Text Library</h3>
                    <button class="left-sidebar-close">&times;</button>
                </div>
                <div class="left-sidebar-content">
                    <div class="section-title">Saved Text Styles</div>
                    <div class="text-styles-grid" id="text-styles-grid">
                        <!-- Text styles will be loaded dynamically here -->
                        <div class="loading-message">Loading text styles...</div>
                    </div>
                </div>
            </div>

            <div class="left-sidebar" id="elements-sidebar">
                <div class="left-sidebar-header">
                    <h3>Elements</h3>
                    <button class="left-sidebar-close">&times;</button>
                </div>
                <div class="left-sidebar-content">
                    <div class="section-title">Stock Shapes</div>
                    <!-- Dynamic shapes content will be loaded here by shapes-loader.js -->
                    <div class="elements-accordion">
                        <!-- Shapes and folders will be loaded dynamically here -->
                    </div>
                </div>
            </div>

            <div class="left-sidebar" id="images-sidebar">
                <div class="left-sidebar-header">
                    <h3>Images</h3>
                    <button class="left-sidebar-close">&times;</button>
                </div>
                <div class="left-sidebar-content">
                    <div class="section-title">Stock Images</div>
                    <div class="image-grid">
                        <!-- Stock images will be loaded dynamically here -->
                    </div>
                </div>
            </div>

            <!-- AI Generator Sidebar -->
            <div class="left-sidebar" id="ai-generator-sidebar">
                <div class="left-sidebar-header">
                    <h3>AI Generator</h3>
                    <button class="left-sidebar-close">&times;</button>
                </div>
                <div class="left-sidebar-content">
                    <!-- Object Input -->
                    <div class="section-title">What would you like to create?</div>
                    <div class="form-group">
                        <input type="text" id="aiObjectInput" placeholder="Enter what you want to create (e.g., dog, car, flower)" class="ai-input">
                        <div class="ai-object-enhancement-container">
                            <select id="aiToneSelect" class="ai-tone-dropdown" title="Select tone/style for AI object creation">
                                <option value="Generic">Generic</option>
                                <option value="Funny">Funny</option>
                                <option value="Sarcastic">Sarcastic</option>
                                <option value="Cute">Cute</option>
                                <option value="For Kids">For Kids</option>
                                <option value="Horror">Horror</option>
                                <option value="Apocalyptic">Apocalyptic</option>
                                <option value="Romantic - Love">Romantic - Love</option>
                                <option value="Nostalgic">Nostalgic</option>
                                <option value="Cool - Edgy">Cool - Edgy</option>
                                <option value="Dark Humor">Dark Humor</option>
                                <option value="Inspirational">Inspirational</option>
                                <option value="Minimalist">Minimalist</option>
                                <option value="Psychedelic">Psychedelic</option>
                                <option value="Aesthetic - Artsy">Aesthetic - Artsy</option>
                                <option value="Gothic">Gothic</option>
                                <option value="Fantasy">Fantasy</option>
                                <option value="Sci-Fi - Futuristic">Sci-Fi - Futuristic</option>
                                <option value="Patriotic">Patriotic</option>
                                <option value="Sporty - Active">Sporty - Active</option>
                                <option value="Pop Culture">Pop Culture</option>
                            </select>
                            <button type="button" class="ai-enhance-object-btn" onclick="enhanceAIObject(event)"
                                    title="Enhance object description with AI">
                                <i class="fas fa-magic"></i>
                            </button>
                        </div>
                    </div>

                    <!-- Image Style Section -->
                    <div class="section-title">Image Style</div>
                    <div class="form-group">
                        <label>Prompt Templates</label>
                        <div class="ai-template-grid-container">
                            <div class="ai-template-grid" id="aiTemplateGrid">
                                <!-- Templates will be loaded here -->
                            </div>
                            <div class="ai-custom-scrollbar" id="aiCustomScrollbar">
                                <div class="ai-custom-scrollbar-thumb" id="aiCustomScrollbarThumb"></div>
                            </div>
                        </div>
                    </div>
                    <!-- Color Texts Section -->
                    <div class="section-title">Texts</div>
                    <div class="form-group" id="textToneContainer">
                        <label for="aiTextToneSelect">Text Tone</label>
                        <select id="aiTextToneSelect" class="ai-tone-dropdown" title="Select tone for AI text generation">
                            <option value="Generic">Generic</option>
                            <option value="Funny">Funny</option>
                            <option value="Sarcastic">Sarcastic</option>
                            <option value="Cute">Cute</option>
                            <option value="For Kids">For Kids</option>
                            <option value="Horror">Horror</option>
                            <option value="Apocalyptic">Apocalyptic</option>
                            <option value="Romantic - Love">Romantic - Love</option>
                            <option value="Nostalgic">Nostalgic</option>
                            <option value="Cool - Edgy">Cool - Edgy</option>
                            <option value="Dark Humor">Dark Humor</option>
                            <option value="Inspirational - Motivational">Inspirational - Motivational</option>
                            <option value="Minimalist">Minimalist</option>
                            <option value="Psychedelic">Psychedelic</option>
                            <option value="Aesthetic - Artsy">Aesthetic - Artsy</option>
                            <option value="Gothic">Gothic</option>
                            <option value="Fantasy">Fantasy</option>
                            <option value="Sci-Fi - Futuristic">Sci-Fi - Futuristic</option>
                            <option value="Patriotic">Patriotic</option>
                            <option value="Sporty - Active">Sporty - Active</option>
                            <option value="Pop Culture - Meme">Pop Culture - Meme</option>
                        </select>
                    </div>
                    <div class="ai-checkbox-row-side">
                        <label class="checkbox-label">
                            <input type="checkbox" id="replaceAllTextsCheckboxform">
                            <span class="checkbox-text">Replace All Texts</span>
                        </label>
                    </div>

                    <!-- Color Palette Section -->
                    <div class="section-title">Color Palette</div>
                    <div class="form-group">
                        <color-palette-selector id="aiColorPaletteSelector"></color-palette-selector>
                    </div>

                    <!-- Include Texts and Shapes Checkbox -->
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="includeTextsCheckbox">
                            <span class="checkbox-text">Include Texts and Shapes Colors</span>
                        </label>
                        <small class="helper-text">
                            Only texts and shapes with assigned color intensity will be updated
                        </small>
                    </div>

                    <!-- Generate Button -->
                    <div class="form-group">
                        <button id="aiGenerateBtn" class="ai-generate-btn">
                            <i class="fas fa-magic"></i> Generate Image
                        </button>
                    </div>

                    <!-- Loading State -->
                    <div id="aiLoadingContainer" class="ai-loading-container hidden">
                        <div class="ai-loading-spinner"></div>
                        <p>Generating your image...</p>
                    </div>
                </div>
            </div>
            <div class="canvas-area" id="canvas-area">
                <!-- Rulers -->
                <div id="ruler-corner" class="ruler-corner"></div>
                <canvas id="horizontal-ruler" class="horizontal-ruler"></canvas>
                <canvas id="vertical-ruler" class="vertical-ruler"></canvas>

                <!-- Main Canvas -->
                <canvas id="demo" width="2048" height="2048"></canvas>

                <!-- Guidelines Container -->
                <div id="guidelines-container" class="guidelines-container"></div>
                 <div class="canvas-controls">
                      <button id="zoomOutBtn" title="Zoom Out">-</button>
                      <span class="zoom-level" id="zoomLevel">100%</span>
                      <button id="zoomInBtn" title="Zoom In">+</button>
                      <div class="separator"></div> <!-- Separator -->
                      <!-- Div for Pickr initialization -->
                      <div id="canvasBgColorPicker" title="Change Background Color"></div>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="toggleArtboardBtn" title="Toggle Artboard">Artboard</button>
                      <div class="export-group">
                          <button id="addToCollectionBtn" title="Add Artboard to Collection (PNG)">Add to Collection</button>
                          <button id="exportOptionsBtn" title="More Export Options" class="export-button">▼</button>
                      </div>

                      <!-- Export Options Modal -->
                      <div class="export-overlay hidden"></div>
                      <div class="export-format-dropdown hidden">
                          <div class="export-dropdown-header">Export Options</div>
                          <button class="format-btn" data-format="png">📁 PNG to Collection</button>
                          <button class="format-btn" data-format="svg">📁 SVG to Collection</button>
                          <div class="divider-line"></div>
                          <button class="format-btn" data-format="download-png">⬇️ Download PNG</button>
                          <button class="format-btn" data-format="download-svg">⬇️ Download SVG</button>
                      </div>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="toggleRulersBtn" title="Toggle Rulers">📏</button>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="lockObjectBtn" title="Lock Selected Object" disabled>🔒</button>
                      <button id="hideObjectBtn" title="Hide Selected Object" disabled>👁️</button>
                      <button id="unlockAllBtn" title="Unlock All Objects">🔓</button>
                      <button id="unhideAllBtn" title="Unhide All Objects">👀</button>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="hideLayoutBtn" title="Hide Selected Layout / Hide All Layouts">📐</button>
                      <button id="ungroupSvgBtn" title="Ungroup SVG into Individual Shapes" disabled class="hidden">🔗</button>
                      <button id="testObjectBtn" title="Add Test Object" class="test-button">TEST</button>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="performanceToggleBtn" title="Toggle Performance Mode (reduces quality during movement for better performance)">⚡ Performance</button>
                      <span id="performanceIndicator" class="performance-indicator" title="Click to view performance report">🟢</span>

                      <!-- CANVAS QUALITY CONTROLS -->
                      <div class="quality-controls">
                          <span class="quality-label">Quality:</span>
                          <button id="quality1xBtn" class="quality-btn" title="Standard Quality (1x)" onclick="setCanvasQuality(1)">1x</button>
                          <button id="quality2xBtn" class="quality-btn active" title="High Quality (2x)" onclick="setCanvasQuality(2)">2x</button>
                          <button id="quality4xBtn" class="quality-btn" title="Ultra Quality (4x)" onclick="setCanvasQuality(4)">4x</button>
                      </div>
                      <!-- ALIGNMENT CONTROLS (shown only when multiple objects are selected) -->
                      <div class="alignment-controls hidden" id="alignment-controls">
                          <span class="alignment-label" id="alignment-label">Align Objects:</span>
                          <button id="alignLeftBtn" class="align-btn" title="Align Left">
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                  <line x1="3" y1="6" x2="21" y2="6"></line>
                                  <line x1="3" y1="12" x2="15" y2="12"></line>
                                  <line x1="3" y1="18" x2="18" y2="18"></line>
                              </svg>
                          </button>
                          <button id="alignCenterBtn" class="align-btn" title="Align Center">
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                  <line x1="18" y1="6" x2="6" y2="6"></line>
                                  <line x1="21" y1="12" x2="3" y2="12"></line>
                                  <line x1="16" y1="18" x2="8" y2="18"></line>
                              </svg>
                          </button>
                          <button id="alignRightBtn" class="align-btn" title="Align Right">
                              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                  <line x1="21" y1="6" x2="3" y2="6"></line>
                                  <line x1="21" y1="12" x2="9" y2="12"></line>
                                  <line x1="21" y1="18" x2="6" y2="18"></line>
                              </svg>
                          </button>
                          <span class="selected-count" id="selected-count">2 objects selected</span>
                      </div>
                      <div class="separator hidden" id="alignment-separator"></div> <!-- Separator for alignment -->
                      <button id="moveForwardBtn" title="Move Forward" disabled>
                          <img src="/images/radix-icons-stack-icon.svg" alt="Forward" class="button-icon">
                      </button>
                      <button id="moveBackwardBtn" title="Move Backward" disabled>
                          <img src="/images/radix-icons-stack-icon.svg" alt="Backward" class="button-icon-rotated">
                      </button>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="copyElementBtn" title="Copy Selected Element" disabled>
                          <img src="/images/icons/ph-copy-light-icon.svg" alt="Copy" class="button-icon">
                      </button>
                      <button id="pasteElementBtn" title="Paste Element" disabled>
                          <img src="/images/icons/ph-clipboard-light-icon.svg" alt="Paste" class="button-icon">
                      </button>
                      <button id="undoBtn" title="Undo" disabled>
                          <img src="/images/icons/redo.svg" alt="Undo" class="button-icon-flipped">
                      </button>
                      <button id="redoBtn" title="Redo" disabled>
                          <img src="/images/icons/redo.svg" alt="Redo" class="button-icon">
                      </button>
                      <div class="separator"></div> <!-- Separator -->
                      <button id="layoutToolBtn" title="Layout Tool - Draw layout rectangles for precise object placement">
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <rect x="3" y="3" width="7" height="7"></rect>
                              <rect x="14" y="3" width="7" height="7"></rect>
                              <rect x="3" y="14" width="7" height="7"></rect>
                              <rect x="14" y="14" width="7" height="7"></rect>
                          </svg>
                      </button>
                      <button id="clearLayoutBtn" title="Clear All Layout Rectangles">
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                              <line x1="9" y1="9" x2="15" y2="15"></line>
                              <line x1="15" y1="9" x2="9" y2="15"></line>
                          </svg>
                      </button>
                      <button id="lockGuidelinesBtn" title="Lock/Unlock Guidelines - Prevent guideline movement">
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                              <path d="m7 11V7a5 5 0 0 1 10 0v4"></path>
                          </svg>
                      </button>
                      <button id="toggleGuidelinesBtn" title="Hide/Show All Guidelines">
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                              <circle cx="12" cy="12" r="3"></circle>
                          </svg>
                      </button>
                      <button id="clearGuidelinesBtn" title="Clear All Guidelines">
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <polyline points="3,6 5,6 21,6"></polyline>
                              <path d="m19,6v14a2,2 0 0,1-2,2H7a2,2 0 0,1-2-2V6m3,0V4a2,2 0 0,1,2-2h4a2,2 0 0,1,2,2v2"></path>
                              <line x1="10" y1="11" x2="10" y2="17"></line>
                              <line x1="14" y1="11" x2="14" y2="17"></line>
                          </svg>
                      </button>
                 </div>
            </div>

            <aside class="sidebar">
                <div class="sidebar-tabs">
                    <button class="sidebar-tab active" data-tab="text-tab-content">Text</button>
                    <button class="sidebar-tab" data-tab="image-tab-content">Image</button>
                    <button class="sidebar-tab" data-tab="ai-tab-content">AI</button>
                    <button class="sidebar-tab" data-tab="admin-tab-content">Admin</button> <!-- Added Admin Tab -->
                </div>

                <!-- TEXT TAB CONTENT -->
                <div class="sidebar-content active" id="text-tab-content">
                    <div class="action-buttons">
                        <button id="addEditTextBtn" class="add-btn">Add</button>
                        <button id="deleteTextBtn" class="delete-btn" title="Delete Selected Text" disabled>Delete</button>
                    </div>
                    <div class="text-properties-header">Text Properties</div>
                    <div class="text-property-tabs">
                        <button class="property-tab active" data-panel="basic-panel">Basic</button>
                        <button class="property-tab" data-panel="distort-panel">Distort</button>
                        <button class="property-tab" data-panel="shadow-panel">Shadow</button>
                        <button class="property-tab" data-panel="decor-panel">Decor</button>
                    </div>
                     <!-- TEXT Panels Wrapper -->
                     <div id="text-controls">
                        <!-- BASIC -->
                        <div class="property-panel active basic-panel">
                            <div class="text-properties-grid">
                                <!-- Text Input -->
                                <label for="iText" class="property-label">Text:</label>
                                <div class="property-control">
                                    <input id="iText" type="text" value="" placeholder="Type text here...">
                                </div>
                            </div>

                            <!-- AI Text Enhancement Section -->
                            <div class="ai-enhancement-section">
                                <div class="ai-enhancement-layout">
                                    <select id="textToneSelect" class="text-tone-dropdown-full" title="Select tone for AI text enhancement" disabled>
                                        <option value="Generic">Generic</option>
                                        <option value="Funny">Funny</option>
                                        <option value="Sarcastic">Sarcastic</option>
                                        <option value="Cute">Cute</option>
                                        <option value="For Kids">For Kids</option>
                                        <option value="Horror">Horror</option>
                                        <option value="Apocalyptic">Apocalyptic</option>
                                        <option value="Romantic - Love">Romantic - Love</option>
                                        <option value="Nostalgic">Nostalgic</option>
                                        <option value="Cool - Edgy">Cool - Edgy</option>
                                        <option value="Dark Humor">Dark Humor</option>
                                        <option value="Inspirational">Inspirational</option>
                                        <option value="Minimalist">Minimalist</option>
                                        <option value="Psychedelic">Psychedelic</option>
                                        <option value="Aesthetic - Artsy">Aesthetic - Artsy</option>
                                        <option value="Gothic">Gothic</option>
                                        <option value="Fantasy">Fantasy</option>
                                        <option value="Sci-Fi - Futuristic">Sci-Fi - Futuristic</option>
                                        <option value="Patriotic">Patriotic</option>
                                        <option value="Sporty - Active">Sporty - Active</option>
                                        <option value="Pop Culture">Pop Culture</option>
                                    </select>
                                    <button type="button" id="enhanceTextBtn" class="enhance-text-btn-square" onclick="enhanceSelectedText()" disabled title="Enhance selected text with AI">
                                        <i class="fas fa-magic"></i>
                                    </button>
                                </div>
                                <div class="ai-enhancement-control">
                                    <input type="checkbox" id="replaceAllTextsCheckbox" disabled>
                                    <label for="replaceAllTextsCheckbox">Replace All Texts</label>
                                </div>
                            </div>

                            <div class="text-properties-grid">
                                <!-- Font -->
                                <label for="iFontFamily" class="property-label">Font:</label>
                                <div class="property-control">
                                    <div class="font-selector-container">
                                        <select id="iFontFamily" disabled>
                                            <option value="Poppins">Poppins</option>
                                            <option value="Arial">Arial</option>
                                            <option value="Verdana">Verdana</option>
                                            <option value="Georgia">Georgia</option>
                                            <option value="Times New Roman">Times New Roman</option>
                                            <option value="Courier New">Courier New</option>
                                            <option value="Impact">Impact</option>
                                            <option value="Comic Sans MS">Comic Sans MS</option>
                                        </select>
                                        <div class="font-nav-buttons">
                                            <button type="button" id="fontNavUp" class="font-nav-btn" title="Previous font" disabled>
                                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polyline points="18,15 12,9 6,15"></polyline>
                                                </svg>
                                            </button>
                                            <button type="button" id="fontNavDown" class="font-nav-btn" title="Next font" disabled>
                                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polyline points="6,9 12,15 18,9"></polyline>
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Filter Tags -->
                                <label for="iFontFilter" class="property-label">Filter Tags:</label>
                                <div class="property-control">
                                    <select id="iFontFilter">
                                        <option value="All">All</option>
                                        <option value="Condensed">Condensed</option>
                                        <option value="Condensed Regular">Condensed Regular</option>
                                        <option value="Sans Serif">Sans Serif</option>
                                        <option value="Serif">Serif</option>
                                        <option value="Elegant">Elegant</option>
                                        <option value="Modern">Modern</option>
                                        <option value="Playful">Playful</option>
                                        <option value="Bold">Bold</option>
                                        <option value="Light">Light</option>
                                        <option value="Script">Script</option>
                                        <option value="Black">Black</option>
                                        <option value="Rounded">Rounded</option>
                                        <option value="Extended Regular">Extended Regular</option>
                                        <option value="Extended">Extended</option>
                                    </select>
                                </div>

                                <!-- Style -->
                                <label class="property-label">Style:</label>
                                <div class="property-control">
                                    <div class="style-control-container">
                                        <div class="style-checkbox-group">
                                            <label for="iBold">B</label>
                                            <input id="iBold" type="checkbox" disabled>
                                        </div>
                                        <div class="style-checkbox-group">
                                            <label for="iItalic">I</label>
                                            <input id="iItalic" type="checkbox" disabled>
                                        </div>
                                        <div class="style-checkbox-group">
                                            <input type="checkbox" id="iAllCaps" disabled>
                                            <label for="iAllCaps">All Caps</label>
                                        </div>
                                    </div>
                                </div>

                                <!-- Font Size -->
                                <label for="iFontSize" class="property-label">Font Size:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iFontSize" type="range" min="10" max="500" value="100" step="1" disabled>
                                        <span class="slider-value-display" id="vFontSize">100px</span>
                                    </div>
                                </div>

                                <!-- Letter Spacing -->
                                <label for="iLetterSpacing" class="property-label">Letter Spacing:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iLetterSpacing" type="range" min="-20" max="100" value="0" step="1" disabled>
                                        <span class="slider-value-display" id="vLetterSpacing">0px</span>
                                    </div>
                                </div>

                                <!-- Text Color -->
                                <label for="iTextColor" class="property-label">Text Color:</label>
                                <div class="property-control">
                                    <div id="textColorPickerContainer" class="simplified-color-picker">
                                        <input id="iTextColor" type="color" value="#FF0000">
                                    </div>
                                </div>

                                <!-- Stroke -->
                                <label for="strokeToggle" class="property-label">Stroke:</label>
                                <div class="property-control">
                                    <select id="strokeToggle" disabled>
                                        <option value="noStroke" selected>No Stroke</option>
                                        <option value="stroke">Standard</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Stroke Parameters (hidden by default) -->
                            <div class="parameter-control stroke-param hidden">
                                <div class="text-properties-grid">
                                    <!-- Stroke Width -->
                                    <label for="strokeWidth" class="property-label">Width:</label>
                                    <div class="property-control">
                                        <div class="slider-control-container">
                                            <input type="range" id="strokeWidth" min="0" max="8" value="1" disabled>
                                            <span class="slider-value-display" id="vStrokeWidth">1px</span>
                                        </div>
                                    </div>

                                    <!-- Stroke Color -->
                                    <label for="strokeColor" class="property-label">Color:</label>
                                    <div class="property-control">
                                        <div class="simplified-color-picker">
                                            <input type="color" id="strokeColor" value="#000000" disabled>
                                        </div>
                                    </div>

                                    <!-- Stroke Opacity -->
                                    <label for="strokeOpacity" class="property-label">Opacity:</label>
                                    <div class="property-control">
                                        <div class="slider-control-container">
                                            <input type="range" id="strokeOpacity" min="0" max="100" value="100" step="1" disabled>
                                            <span class="slider-value-display" id="vStrokeOpacity">100%</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="text-properties-grid">

                                <!-- Opacity -->
                                <label for="iOpacity" class="property-label">Opacity:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iOpacity" type="range" min="1" max="100" value="100" step="1" disabled>
                                        <span class="slider-value-display" id="vOpacity">100%</span>
                                    </div>
                                </div>

                                <!-- Rotation -->
                                <label for="iTextRotation" class="property-label">Rotation:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iTextRotation" type="range" min="-180" max="180" value="0" step="1">
                                        <span class="slider-value-display" id="vTextRotation">0°</span>
                                    </div>
                                </div>

                                <!-- Text Box -->
                                <label for="iTextBoxWidth" class="property-label">Text Box:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iTextBoxWidth" type="range" min="0" max="200" value="0" class="text-box-slider">
                                        <span class="slider-value-display" id="textBoxWidthValue">0 (unlimited)</span>
                                    </div>
                                </div>

                                <!-- Alignment -->
                                <label class="property-label">Alignment:</label>
                                <div class="property-control">
                                    <div class="alignment-control-container">
                                        <button type="button" id="alignLeft" class="alignment-btn" data-align="left" title="Align Left">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M3 3h18v2H3V3zm0 4h12v2H3V7zm0 4h18v2H3v-2zm0 4h12v2H3v-2zm0 4h18v2H3v-2z"/>
                                            </svg>
                                        </button>
                                        <button type="button" id="alignCenter" class="alignment-btn" data-align="center" title="Align Center">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M3 3h18v2H3V3zm3 4h12v2H6V7zm-3 4h18v2H3v-2zm3 4h12v2H6v-2zm-3 4h18v2H3v-2z"/>
                                            </svg>
                                        </button>
                                        <button type="button" id="alignRight" class="alignment-btn" data-align="right" title="Align Right">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M3 3h18v2H3V3zm6 4h12v2H9V7zm-6 4h18v2H3v-2zm6 4h12v2H9v-2zm-6 4h18v2H3v-2z"/>
                                            </svg>
                                        </button>
                                        <button type="button" id="alignJustify" class="alignment-btn" data-align="justify" title="Justify">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M3 3h18v2H3V3zm0 4h18v2H3V7zm0 4h18v2H3v-2zm0 4h18v2H3v-2zm0 4h18v2H3v-2z"/>
                                            </svg>
                                        </button>
                                    </div>
                                </div>

                                <!-- Line Height -->
                                <label for="iLineHeight" class="property-label">Line Height:</label>
                                <div class="property-control">
                                    <div class="slider-control-container">
                                        <input id="iLineHeight" type="range" min="0.8" max="3.0" step="0.1" value="1.2" class="text-box-slider">
                                        <span class="slider-value-display" id="lineHeightValue">1.2x</span>
                                    </div>
                                </div>

                                <!-- Color Intensity -->
                                <label for="iTextColorIntensity" class="property-label">Color Intensity:</label>
                                <div class="property-control">
                                    <select id="iTextColorIntensity">
                                        <option value="no-change">No Change</option>
                                        <option value="lightest">Lightest</option>
                                        <option value="light">Light-Medium</option>
                                        <option value="medium">Medium</option>
                                        <option value="dark">Dark-Medium</option>
                                        <option value="darkest">Darkest</option>
                                    </select>
                                </div>

                                <!-- Template ID -->
                                <label for="textTemplateId" class="property-label">Template ID:</label>
                                <div class="property-control">
                                    <select id="textTemplateId" disabled>
                                        <option value="">Not Replaceable</option>
                                        <option value="t01">t01 - Text 1</option>
                                        <option value="t02">t02 - Text 2</option>
                                        <option value="t03">t03 - Text 3</option>
                                        <option value="t04">t04 - Text 4</option>
                                        <option value="t05">t05 - Text 5</option>
                                        <option value="t06">t06 - Text 6</option>
                                        <option value="t07">t07 - Text 7</option>
                                        <option value="t08">t08 - Text 8</option>
                                        <option value="t09">t09 - Text 9</option>
                                        <option value="t10">t10 - Text 10</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Text Box Action Buttons -->
                            <div class="text-box-actions">
                                <div class="button-container">
                                    <button type="button" id="btnShrinkTextBox" class="action-button" disabled>
                                        📦 Shrink to Fit Text
                                    </button>
                                    <button type="button" id="btnDrawFittingRectangle" class="action-button" disabled>
                                        📐 Draw Fitting Rectangle
                                    </button>
                                    <button type="button" id="btnCleanRectangles" class="action-button">
                                        🧹 Clean All Rectangles
                                    </button>
                                </div>
                                <div class="control-group hidden" id="rectangleScaleGroup">
                                    <label for="rectangleScale">Rectangle Scale:</label>
                                    <input id="rectangleScale" type="range" min="0.5" max="3.0" value="1.0" step="0.1" disabled>
                                    <span id="rectangleScaleValue">1.0x</span>
                                </div>
                                <div class="control-group hidden" id="layoutFitGroup">
                                    <label>Layout Fitting:</label>
                                    <button type="button" id="btnFitGreenRectangle" class="action-button" disabled>
                                        🎯 Fit Green Rectangle Inside
                                    </button>
                                </div>
                            </div>


                        </div>

                        <!-- DISTORT -->
                        <div class="property-panel distort-panel">
                            <div class="control-group">
                                <label for="effectMode">Effect:</label>
                                <select id="effectMode" title="Select distortion effect type" disabled>
                                    <option value="normal">Normal</option>
                                    <option value="skew">Skew</option>
                                    <option value="warp">Warp</option>
                                    <option value="curve">Curved</option>
                                    <option value="circle">Circular</option>
                                    <option value="mesh">Mesh Warp</option>
                                    <option value="grid-distort">Grid Distort</option>
                                </select>
                            </div>

                            <div class="parameter-control horizontal-skew control-group" id="horizontalSkewControl">
                                <label for="skewSlider">Skew X:</label>
                                <div class="slider-container">
                                    <input type="range" id="skewSlider" min="-50" max="50" value="0" step="1" title="Horizontal skew amount" disabled>
                                    <span class="slider-value" id="vSkew">0</span>
                                </div>
                            </div>

                            <div class="parameter-control vertical-skew control-group" id="verticalSkewControl">
                                <label for="skewYSlider">Skew Y:</label>
                                <div class="slider-container">
                                    <input type="range" id="skewYSlider" min="-50" max="50" value="0" step="1" title="Vertical skew amount" disabled>
                                    <span class="slider-value" id="vSkewY">0</span>
                                </div>
                            </div>

                            <div class="parameter-control mesh-param">
                                <h4>Mesh Settings</h4>
                                <div class="control-group">
                                    <label for="iMeshCols">Columns:</label>
                                    <div class="slider-container">
                                        <input id="iMeshCols" type="range" min="3" max="9" value="5" step="1" title="Number of mesh columns" disabled>
                                        <span class="slider-value" id="vMeshCols">5</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iMeshRows">Rows:</label>
                                    <div class="slider-container">
                                        <input id="iMeshRows" type="range" min="2" max="8" value="4" step="1" title="Number of mesh rows" disabled>
                                        <span class="slider-value" id="vMeshRows">4</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <button id="resetMeshBtn" title="Reset mesh points to default positions" disabled>Reset Points</button>
                                </div>
                                <div class="control-group">
                                    <button id="toggleMeshBtn" title="Toggle mesh grid visibility" disabled>Show Grid</button>
                                </div>
                            </div>

                            <div class="parameter-control warp-param">
                                <h4>Warp Settings</h4>
                                <div class="control-group">
                                    <label for="iCurve">Curve:</label>
                                    <div class="slider-container">
                                        <input id="iCurve" type="range" min="-500" max="500" value="100" title="Warp curve intensity" disabled>
                                        <span class="slider-value" id="vCurve">100</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iOffset">Offset Y:</label>
                                    <div class="slider-container">
                                        <input id="iOffset" type="range" min="-500" max="500" value="10" title="Vertical offset amount" disabled>
                                        <span class="slider-value" id="vOffset">10</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iHeight">Height:</label>
                                    <div class="slider-container">
                                        <input id="iHeight" type="range" min="-500" max="500" value="100" title="Warp height adjustment" disabled>
                                        <span class="slider-value" id="vHeight">100</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iBottom">Bottom:</label>
                                    <div class="slider-container">
                                        <input id="iBottom" type="range" min="-500" max="500" value="150" title="Bottom warp adjustment" disabled>
                                        <span class="slider-value" id="vBottom">150</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iTriangle">Triangle:</label>
                                    <input id="iTriangle" type="checkbox" title="Enable triangle warp mode" disabled>
                                </div>
                                <div class="control-group shift-center-control">
                                    <label for="iShiftCenter">Shift Center:</label>
                                    <div class="slider-container">
                                        <input id="iShiftCenter" type="range" min="0" max="200" value="100" title="Center shift amount" disabled>
                                        <span class="slider-value" id="vShiftCenter">100</span>
                                    </div>
                                </div>
                            </div>

                            <div class="parameter-control circle-param">
                                <h4>Circular Settings</h4>
                                <div class="control-group">
                                    <label for="iDiameter">Diameter:</label>
                                    <div class="slider-container">
                                        <input id="iDiameter" type="range" min="100" max="1500" value="600" step="1" title="Circle diameter in pixels" disabled>
                                        <span class="slider-value" id="vDiameter">600px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iKerning">Kerning:</label>
                                    <div class="slider-container">
                                        <input id="iKerning" type="range" min="-20" max="50" value="0" step="1" title="Character spacing adjustment" disabled>
                                        <span class="slider-value" id="vKerning">0px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iCircleRotation">Rotation:</label>
                                    <div class="slider-container">
                                        <input id="iCircleRotation" type="range" min="-180" max="180" value="0" step="1" title="Circle rotation in degrees" disabled>
                                        <span class="slider-value" id="vCircleRotation">0°</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iFlip">Flip:</label>
                                    <input id="iFlip" type="checkbox" title="Flip circular text direction" disabled>
                                </div>
                            </div>

                            <div class="parameter-control curve-param">
                                <h4>Curved Settings</h4>
                                <div class="control-group">
                                    <label for="iCurveAmount">Curve:</label>
                                    <div class="slider-container">
                                        <input id="iCurveAmount" type="range" min="-100" max="100" value="40" step="1" title="Curve amount" disabled>
                                        <span class="slider-value" id="vCurveAmount">40</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iCurveKerning">Spacing:</label>
                                    <div class="slider-container">
                                        <input id="iCurveKerning" type="range" min="-20" max="50" value="0" step="1" title="Character spacing for curved text" disabled>
                                        <span class="slider-value" id="vCurveKerning">0px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iCurveFlip">Flip:</label>
                                    <input id="iCurveFlip" type="checkbox" title="Flip curved text direction" disabled>
                                </div>
                            </div>
                            <div class="parameter-control grid-distort-param">
                                <h4>Grid Distort Settings</h4>
                                <div class="control-group">
                                    <label for="iGridDistortCols">Columns:</label>
                                    <div class="slider-container">
                                        <input id="iGridDistortCols" type="range" min="1" max="5" value="2" step="1" title="Number of grid distort columns" disabled>
                                        <span class="slider-value" id="vGridDistortCols">2</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iGridDistortRows">Rows:</label>
                                    <div class="slider-container">
                                        <input id="iGridDistortRows" type="range" min="1" max="5" value="1" step="1" title="Number of grid distort rows" disabled>
                                        <span class="slider-value" id="vGridDistortRows">1</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iGridDistortPadding">Padding:</label>
                                    <div class="slider-container">
                                        <input id="iGridDistortPadding" type="range" min="20" max="200" value="80" step="1" title="Grid distort padding in pixels" disabled>
                                        <span class="slider-value" id="vGridDistortPadding">80px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="iGridDistortIntensity">Intensity:</label>
                                    <div class="slider-container">
                                        <input id="iGridDistortIntensity" type="range" min="0" max="100" value="100" step="1" title="Grid distort intensity percentage" disabled>
                                        <span class="slider-value" id="vGridDistortIntensity">100%</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label>Direction:</label>
                                    <div class="direction-options">
                                        <label for="gridDistortDirectionBoth">
                                            <input type="radio" name="gridDistortDirection" id="gridDistortDirectionBoth" value="both" title="Apply distortion in both directions" disabled> Both
                                        </label>
                                        <label for="gridDistortDirectionVertical">
                                            <input type="radio" name="gridDistortDirection" id="gridDistortDirectionVertical" value="vertical" title="Apply distortion vertically only" checked disabled> Vertical Only
                                        </label>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <button id="resetGridDistortBtn" title="Reset grid distort to default" disabled>Reset Grid</button>
                                </div>
                                <div class="control-group">
                                    <button id="toggleGridDistortBtn" title="Toggle grid distort visibility" disabled>Show Grid</button>
                                </div>
                            </div>
                        </div>
                        <!-- SHADOW -->
                        <div class="property-panel shadow-panel">
                            <div class="control-group">
                                <label for="shadow">Shadow:</label>
                                <select id="shadow" title="Select shadow type" disabled>
                                    <option value="noShadow" selected>No Shadow</option>
                                    <option value="shadow">Standard</option>
                                    <option value="blockShadow">Block</option>
                                    <option value="perspectiveShadow">Perspective Shadow</option>
                                    <option value="lineShadow">Line</option>
                                    <option value="detailed3D">Detailed 3D</option>
                                </select>
                            </div>

                            <div class="parameter-control shadow-param">
                                <h4>Standard Shadow</h4>
                                <div class="control-group">
                                    <label for="shadowColor">Color:</label>
                                    <div class="simplified-color-picker">
                                        <input type="color" id="shadowColor" value="#000000" title="Shadow color" disabled>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="shadowOffsetX">Offset X:</label>
                                    <div class="slider-container">
                                        <input type="range" id="shadowOffsetX" class="slider" min="-50" max="50" value="5" step="1" title="Horizontal shadow offset" disabled>
                                        <span class="slider-value" id="vShadowOffsetX">5px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="shadowOffsetY">Offset Y:</label>
                                    <div class="slider-container">
                                        <input type="range" id="shadowOffsetY" class="slider" min="-50" max="50" value="5" step="1" title="Vertical shadow offset" disabled>
                                        <span class="slider-value" id="vShadowOffsetY">5px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="shadowBlur">Blur:</label>
                                    <div class="slider-container">
                                        <input type="range" id="shadowBlur" class="slider" min="0" max="50" value="10" step="1" title="Shadow blur amount" disabled>
                                        <span class="slider-value" id="vShadowBlur">10px</span>
                                    </div>
                                </div>
                            </div>

                            <div class="parameter-control block-shadow-param">
                                <h4>Block Shadow</h4>
                                <div class="control-group">
                                    <label for="blockShadowColor">Color:</label>
                                    <div class="simplified-color-picker">
                                        <input type="color" id="blockShadowColor" value="#000000" title="Block shadow color" disabled>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="blockShadowOpacity">Opacity:</label>
                                    <div class="slider-container">
                                        <input type="range" id="blockShadowOpacity" class="slider" min="0" max="100" value="100" step="1" title="Block shadow opacity percentage" disabled>
                                        <span class="slider-value" id="vBlockShadowOpacity">100%</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="blockShadowOffset">Distance:</label>
                                    <div class="slider-container">
                                        <input type="range" id="blockShadowOffset" class="slider" min="0" max="200" value="40" step="1" title="Block shadow distance" disabled>
                                        <span class="slider-value" id="vBlockShadowOffset">40px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="blockShadowAngle">Angle:</label>
                                    <div class="slider-container">
                                        <input type="range" id="blockShadowAngle" class="slider" min="-180" max="180" value="-58" step="1" title="Block shadow angle in degrees" disabled>
                                        <span class="slider-value" id="vBlockShadowAngle">-58°</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="blockShadowBlur">Blur:</label>
                                    <div class="slider-container">
                                        <input type="range" id="blockShadowBlur" class="slider" min="0" max="50" value="5" step="1" title="Block shadow blur amount" disabled>
                                        <span class="slider-value" id="vBlockShadowBlur">5px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="blockShadowPerspective">Perspective:</label>
                                    <div class="switch-container">
                                        <label class="switch-label" for="blockShadowPerspective">
                                            <input type="checkbox" id="blockShadowPerspective" title="Enable perspective for block shadow" disabled>
                                            <span class="switch-custom"></span>Enable Perspective
                                        </label>
                                    </div>
                                </div>
                                <div class="control-group perspective-control">
                                    <label for="blockShadowPerspectiveIntensity">Perspective Intensity:</label>
                                    <div class="slider-container">
                                        <input type="range" id="blockShadowPerspectiveIntensity" class="slider" min="1" max="100" value="50" step="1" title="Block shadow perspective intensity" disabled>
                                        <span class="slider-value" id="vBlockShadowPerspectiveIntensity">50%</span>
                                    </div>
                                    <div class="control-hint">Higher values make distant shadows smaller, 1% = almost no perspective</div>
                                </div>
                            </div>

                            <div class="parameter-control perspective-shadow-param">
                                <h4>Perspective Shadow</h4>
                                <div class="control-group">
                                    <label for="perspectiveShadowColor">Color:</label>
                                    <div class="simplified-color-picker">
                                        <input type="color" id="perspectiveShadowColor" value="#333333" title="Perspective shadow color" disabled>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="perspectiveShadowOpacity">Opacity:</label>
                                    <div class="slider-container">
                                        <input type="range" id="perspectiveShadowOpacity" class="slider" min="0" max="100" value="100" step="1" title="Perspective shadow opacity" disabled>
                                        <span class="slider-value" id="vPerspectiveShadowOpacity">100%</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="perspectiveShadowOffset">Distance:</label>
                                    <div class="slider-container">
                                        <input type="range" id="perspectiveShadowOffset" class="slider" min="0" max="20" value="6" step="1" title="Perspective shadow distance" disabled>
                                        <span class="slider-value" id="vPerspectiveShadowOffset">6px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="perspectiveShadowAngle">Angle:</label>
                                    <div class="slider-container">
                                        <input type="range" id="perspectiveShadowAngle" class="slider" min="-180" max="180" value="105" step="1" title="Perspective shadow angle" disabled>
                                        <span class="slider-value" id="vPerspectiveShadowAngle">105°</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="perspectiveShadowBlur">Blur:</label>
                                    <div class="slider-container">
                                        <input type="range" id="perspectiveShadowBlur" class="slider" min="0" max="50" value="2" step="1" title="Perspective shadow blur" disabled>
                                        <span class="slider-value" id="vPerspectiveShadowBlur">2px</span>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label for="perspectiveShadowIntensity">Perspective Intensity:</label>
                                    <div class="slider-container">
                                        <input type="range" id="perspectiveShadowIntensity" class="slider" min="1" max="100" value="16" step="1" title="Perspective shadow intensity" disabled>
                                        <span class="slider-value" id="vPerspectiveShadowIntensity">16%</span>
                                    </div>
                                    <div class="control-hint">Higher values make distant shadows smaller, 1% = almost no perspective</div>
                                </div>
<h5>Front Outline</h5>
<div class="control-group"><label for="perspectiveShadowOutlineColor">Color:</label><div class="simplified-color-picker"><input type="color" id="perspectiveShadowOutlineColor" value="#d1d5db" disabled></div></div>
<div class="control-group"><label for="perspectiveShadowOutlineOpacity">Opacity:</label><div class="slider-container"><input type="range" id="perspectiveShadowOutlineOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vPerspectiveShadowOutlineOpacity">100%</span></div></div>
<div class="control-group"><label for="perspectiveShadowOutlineWidth">Width:</label><div class="slider-container"><input type="range" id="perspectiveShadowOutlineWidth" class="slider" min="0" max="30" value="3" step="1" disabled><span class="slider-value" id="vPerspectiveShadowOutlineWidth">3px</span></div></div>
<div class="control-group"><label for="perspectiveShadowOutlineOffsetX">Offset X:</label><div class="slider-container"><input type="range" id="perspectiveShadowOutlineOffsetX" class="slider" min="-50" max="50" value="2" step="1" disabled><span class="slider-value" id="vPerspectiveShadowOutlineOffsetX">2px</span></div></div>
<div class="control-group"><label for="perspectiveShadowOutlineOffsetY">Offset Y:</label><div class="slider-container"><input type="range" id="perspectiveShadowOutlineOffsetY" class="slider" min="-50" max="50" value="-3" step="1" disabled><span class="slider-value" id="vPerspectiveShadowOutlineOffsetY">-3px</span></div></div>
</div> <div class="parameter-control line-shadow-param"> <h4>Line Shadow</h4> <div class="control-group"><label for="lineShadowColor">Color:</label><div class="simplified-color-picker"><input type="color" id="lineShadowColor" value="#AAAAAA" disabled></div></div> <div class="control-group"><label for="lineShadowDistance">Distance:</label><div class="slider-container"><input type="range" id="lineShadowDistance" class="slider" min="0" max="100" value="15" step="1" disabled><span class="slider-value" id="vLineShadowDistance">15px</span></div></div> <div class="control-group"><label for="lineShadowAngle">Angle:</label><div class="slider-container"><input type="range" id="lineShadowAngle" class="slider" min="-180" max="180" value="-45" step="1" disabled><span class="slider-value" id="vLineShadowAngle">-45°</span></div></div> <div class="control-group"><label for="lineShadowThickness">Thickness:</label><div class="slider-container"><input type="range" id="lineShadowThickness" class="slider" min="1" max="30" value="5" step="1" disabled><span class="slider-value" id="vLineShadowThickness">5px</span></div></div> </div> <div class="parameter-control detailed-3d-param"> <h4>Detailed 3D</h4> <h5>Extrusion</h5> <div class="control-group"><label for="detailed3DPrimaryColor">Color:</label><div class="simplified-color-picker"><input type="color" id="detailed3DPrimaryColor" value="#000000" disabled></div></div> <div class="control-group"><label for="detailed3DPrimaryOpacity">Opacity:</label><div class="slider-container"><input type="range" id="detailed3DPrimaryOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vDetailed3DPrimaryOpacity">100%</span></div></div> <div class="control-group"><label for="detailed3DOffset">Distance:</label><div class="slider-container"><input type="range" id="detailed3DOffset" class="slider" min="0" max="200" value="36" step="1" disabled><span class="slider-value" id="vDetailed3DOffset">36px</span></div></div> <div class="control-group"><label for="detailed3DAngle">Angle:</label><div class="slider-container"><input type="range" id="detailed3DAngle" class="slider" min="-180" max="180" value="-63" step="1" disabled><span class="slider-value" id="vDetailed3DAngle">-63°</span></div></div> <div class="control-group"><label for="detailed3DBlur">Blur:</label><div class="slider-container"><input type="range" id="detailed3DBlur" class="slider" min="0" max="50" value="5" step="1" disabled><span class="slider-value" id="vDetailed3DBlur">5px</span></div></div> <h5>Front Outline</h5> <div class="control-group"><label for="detailed3DSecondaryColor">Color:</label><div class="simplified-color-picker"><input type="color" id="detailed3DSecondaryColor" value="#00FF00" disabled></div></div> <div class="control-group"><label for="detailed3DSecondaryOpacity">Opacity:</label><div class="slider-container"><input type="range" id="detailed3DSecondaryOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vDetailed3DSecondaryOpacity">100%</span></div></div> <div class="control-group"><label for="detailed3DSecondaryWidth">Width:</label><div class="slider-container"><input type="range" id="detailed3DSecondaryWidth" class="slider" min="0" max="30" value="4" step="1" disabled><span class="slider-value" id="vDetailed3DSecondaryWidth">4px</span></div></div> <div class="control-group"><label for="detailed3DSecondaryOffsetX">Offset X:</label><div class="slider-container"><input type="range" id="detailed3DSecondaryOffsetX" class="slider" min="-50" max="50" value="-5" step="1" disabled><span class="slider-value" id="vDetailed3DSecondaryOffsetX">-5px</span></div></div> <div class="control-group"><label for="detailed3DSecondaryOffsetY">Offset Y:</label><div class="slider-container"><input type="range" id="detailed3DSecondaryOffsetY" class="slider" min="-50" max="50" value="-5" step="1" disabled><span class="slider-value" id="vDetailed3DSecondaryOffsetY">-5px</span></div></div> </div> </div>
                        <!-- DECOR --> <div class="property-panel decor-panel"> <div class="control-group"> <label for="linesDecoration">Fill Decor:</label> <select id="linesDecoration" disabled> <option value="noDecoration">None</option> <option value="horizontalLines">Horizontal Lines</option> <option value="colorCut">Color Cut</option> <option value="obliqueLines">Oblique Lines</option> <option value="fadingLinesCut">Fading Lines</option> <option value="diagonalLines">Diagonal Lines</option> </select> </div> <div class="parameter-control horizontal-lines-param"> <h4>Horizontal Lines</h4> <div class="control-group"><label for="hWeight">Weight:</label><div class="slider-container"><input type="range" id="hWeight" min="1" max="30" value="3" disabled><span class="slider-value" id="vHWeight">3px</span></div></div> <div class="control-group"><label for="hDistance">Distance:</label><div class="slider-container"><input type="range" id="hDistance" min="1" max="50" value="7" disabled><span class="slider-value" id="vHDistance">7px</span></div></div> <div class="control-group"><label for="hColor">Line Color:</label><div class="simplified-color-picker"><input type="color" id="hColor" value="#0000FF" disabled></div></div> <div class="control-group"><label for="hOpacity">Opacity:</label><div class="slider-container"><input type="range" id="hOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vHOpacity">100%</span></div></div> </div> <div class="parameter-control color-cut-param"> <h4>Color Cut</h4> <div class="control-group"><label for="ccDistance">Cut (%):</label><div class="slider-container"><input type="range" id="ccDistance" min="1" max="100" value="50" disabled><span class="slider-value" id="vCcDistance">50%</span></div></div> <div class="control-group fill-direction"><label>Direction:</label><div class="radio-group"><label class="radio-container"><input type="radio" name="ccFillDirection" id="ccFillTop" value="top" checked disabled><span>Top</span></label><label class="radio-container"><input type="radio" name="ccFillDirection" id="ccFillBottom" value="bottom" disabled><span>Bottom</span></label></div></div> <div class="control-group"><label for="ccColor">Cut Color:</label><div class="simplified-color-picker"><input type="color" id="ccColor" value="#00FF00" disabled></div></div> <div class="control-group"><label for="ccOpacity">Opacity:</label><div class="slider-container"><input type="range" id="ccOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vCcOpacity">100%</span></div></div> </div> <div class="parameter-control oblique-lines-param"> <h4>Oblique Lines</h4> <div class="control-group"><label for="oWeight">Weight:</label><div class="slider-container"><input type="range" id="oWeight" min="1" max="30" value="4" disabled><span class="slider-value" id="vOWeight">4px</span></div></div> <div class="control-group"><label for="oDistance">Distance:</label><div class="slider-container"><input type="range" id="oDistance" min="1" max="50" value="3" disabled><span class="slider-value" id="vODistance">3px</span></div></div> <div class="control-group"><label for="oColor">Line Color:</label><div class="simplified-color-picker"><input type="color" id="oColor" value="#0000FF" disabled></div></div> <div class="control-group"><label for="oOpacity">Opacity:</label><div class="slider-container"><input type="range" id="oOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vOOpacity">100%</span></div></div> </div> <div class="parameter-control fading-lines-cut-param"> <h4>Fading Lines</h4> <div class="control-group"><label for="flcDistance">Cut (%):</label><div class="slider-container"><input type="range" id="flcDistance" min="1" max="100" value="62" disabled><span class="slider-value" id="vFlcDistance">62%</span></div></div> <div class="control-group fill-direction"><label>Direction:</label><div class="radio-group"><label class="radio-container"><input type="radio" name="flcFillDirection" id="flcFillTop" value="top" checked disabled><span>Solid Top</span></label><label class="radio-container"><input type="radio" name="flcFillDirection" id="flcFillBottom" value="bottom" disabled><span>Solid Bottom</span></label></div></div> <div class="control-group"><label for="flcColor">Line/Fill:</label><div class="simplified-color-picker"><input type="color" id="flcColor" value="#cccccc" disabled></div></div> <div class="control-group"><label for="flcOpacity">Opacity:</label><div class="slider-container"><input type="range" id="flcOpacity" class="slider" min="0" max="100" value="100" step="1" disabled><span class="slider-value" id="vFlcOpacity">100%</span></div></div> <div class="control-group"><label for="flcMaxWeight">Weight:</label><div class="slider-container"><input type="range" id="flcMaxWeight" min="1" max="30" value="3" disabled><span class="slider-value" id="vFlcMaxWeight">3px</span></div></div> <div class="control-group"><label for="flcSpacing">Spacing:</label><div class="slider-container"><input type="range" id="flcSpacing" min="1" max="40" value="10" disabled><span class="slider-value" id="vFlcSpacing">10px</span></div></div> </div> </div>
                     </div> <!-- End Text Controls Wrapper -->
                </div><!-- End Text Tab -->

                <!-- IMAGE TAB CONTENT -->
                <div class="sidebar-content" id="image-tab-content">
                     <div class="action-buttons">
                        <label for="image-file-input" class="visually-hidden">Select image file to upload</label>
                        <input type="file" id="image-file-input" accept="image/*">
                        <button id="addImageBtn" class="add-btn">Add Image</button>
                        <button id="deleteImageBtn" class="delete-btn" title="Delete Selected Image" disabled>Delete</button>
                    </div>
                    <div class="image-properties-header">Image Properties</div>
                    <div id="image-controls">
                        <div class="control-group">
                            <label for="iImageSize">Size:</label>
                            <div class="slider-container"> <input id="iImageSize" type="range" min="0.1" max="20" value="1" step="0.05"> <span class="slider-value" id="vImageSize">100%</span> </div>
                        </div>
                        <div class="control-group">
                            <label for="iImageRotation">Rotation:</label>
                            <div class="slider-container"> <input id="iImageRotation" type="range" min="-180" max="180" value="0" step="1"> <span class="slider-value" id="vImageRotation">0°</span> </div>
                        </div>
                        <div class="control-group">
                            <label for="iImageOpacity">Opacity:</label>
                            <div class="slider-container">
                                <input type="range" id="iImageOpacity" min="0" max="100" value="100" step="1">
                                <span class="slider-value" id="vImageOpacity">100%</span>
                            </div>
                        </div>
                        <div class="control-group hidden" id="imageColorGroup">
                            <label for="iImageColor">Color:</label>
                            <div class="simplified-color-picker">
                                <input type="color" id="iImageColor" value="#000000" title="Select image color">
                            </div>
                        </div>
                        <div class="control-group hidden" id="imageColorIntensityGroup">
                            <label for="iImageColorIntensity">Color Intensity:</label>
                            <select id="iImageColorIntensity" class="full-width-select" title="Select color intensity level">
                                <option value="no-change">No Change (keep current color)</option>
                                <option value="lightest">Lightest (Lightest color from palette)</option>
                                <option value="light">Light-Medium (Light-medium colors from palette)</option>
                                <option value="medium">Medium (Medium colors from palette)</option>
                                <option value="dark">Dark-Medium (Dark-medium colors from palette)</option>
                                <option value="darkest">Darkest (Darkest colors from palette)</option>
                            </select>
                            <small class="helper-text">
                                Choose how this shape should use colors from the selected palette
                            </small>
                            <!-- Debug display for persistent Color Intensity (Images) -->
                            <div class="debug-display">
                                <span class="debug-text">💾 Debug newColorIntensity: </span>
                                <span id="debugImageNewColorIntensity" class="debug-text">N/A</span>
                            </div>
                        </div>

                        <!-- Image Stroke Controls -->
                        <div class="control-group">
                            <label for="iImageStroke">Stroke:</label>
                            <select id="iImageStroke">
                                <option value="none" selected>No Stroke</option>
                                <option value="standard">Standard</option>
                            </select>
                        </div>

                        <!-- Standard Stroke Controls -->
                        <div class="parameter-control image-stroke-param hidden">
                            <h4>Standard Stroke</h4>
                            <div class="control-group">
                                <label for="iImageStrokeWidth">Width:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageStrokeWidth" min="1" max="50" value="3" step="1">
                                    <span class="slider-value" id="vImageStrokeWidth">3px</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageStrokeColor">Color:</label>
                                <div class="simplified-color-picker">
                                    <input type="color" id="iImageStrokeColor" value="#000000">
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageStrokeOpacity">Opacity:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageStrokeOpacity" min="0" max="100" value="100" step="1">
                                    <span class="slider-value" id="vImageStrokeOpacity">100%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Image Shadow Controls -->
                        <div class="control-group">
                            <label for="iImageShadow">Shadow:</label>
                            <select id="iImageShadow">
                                <option value="none" selected>No Shadow</option>
                                <option value="standard">Standard</option>
                            </select>
                        </div>

                        <!-- Standard Shadow Controls -->
                        <div class="parameter-control image-shadow-param hidden">
                            <h4>Standard Shadow</h4>
                            <div class="control-group">
                                <label for="iImageShadowColor">Color:</label>
                                <div class="simplified-color-picker">
                                    <input type="color" id="iImageShadowColor" value="#000000">
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageShadowOpacity">Opacity:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageShadowOpacity" min="0" max="100" value="100" step="1">
                                    <span class="slider-value" id="vImageShadowOpacity">100%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageShadowOffsetX">Offset X:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageShadowOffsetX" min="-50" max="50" value="5" step="1">
                                    <span class="slider-value" id="vImageShadowOffsetX">5px</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageShadowOffsetY">Offset Y:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageShadowOffsetY" min="-50" max="50" value="5" step="1">
                                    <span class="slider-value" id="vImageShadowOffsetY">5px</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageShadowBlur">Blur:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageShadowBlur" min="0" max="50" value="10" step="1">
                                    <span class="slider-value" id="vImageShadowBlur">10px</span>
                                </div>
                            </div>
                        </div>

                        <!-- Image Masking Controls -->
                        <div class="control-group hidden" id="imageMaskingGroup">
                            <button id="maskImageBtn" class="professional-btn margin-top-10">
                                <i class="fas fa-shapes"></i> Mask with Shape
                            </button>
                            <button id="unmaskImageBtn" class="professional-btn hidden">
                                <i class="fas fa-times"></i> Remove Mask
                            </button>
                        </div>

                        <!-- Shape/Image Fitting Rectangle Controls -->
                        <div class="control-group">
                            <label>Shape Box:</label>
                            <div class="button-container">
                                <button id="btnDrawFittingRectangleShape" class="action-button" disabled>
                                    📐 Draw Fitting Rectangle
                                </button>
                            </div>
                        </div>

                        <!-- CSS Filters Section -->
                        <div class="image-header">
                            CSS Filters
                        </div>
                        <div id="image-filters-controls">
                            <!-- Filter Presets Dropdown -->
                            <div class="control-group">
                                <label for="filterPresetSelect">Filter Presets:</label>
                                <div class="flex-gap-5">
                                    <select id="filterPresetSelect" class="form-select-flex">
                                        <option value="">Select a preset...</option>
                                    </select>
                                    <button id="deletePresetBtn" title="Delete selected preset" class="button-delete hidden">
                                        🗑️
                                    </button>
                                </div>
                            </div>

                            <!-- Individual Filter Controls -->
                            <div class="control-group">
                                <label for="iImageBlur">Blur:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageBlur" min="0" max="10" value="0" step="0.1">
                                    <span class="slider-value" id="vImageBlur">0px</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageBrightness">Brightness:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageBrightness" min="0" max="3" value="1" step="0.1">
                                    <span class="slider-value" id="vImageBrightness">100%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageContrast">Contrast:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageContrast" min="0" max="3" value="1" step="0.1">
                                    <span class="slider-value" id="vImageContrast">100%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageSaturation">Saturation:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageSaturation" min="0" max="3" value="1" step="0.1">
                                    <span class="slider-value" id="vImageSaturation">100%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageHue">Hue Rotate:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageHue" min="0" max="360" value="0" step="1">
                                    <span class="slider-value" id="vImageHue">0°</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageGrayscale">Grayscale:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageGrayscale" min="0" max="1" value="0" step="0.1">
                                    <span class="slider-value" id="vImageGrayscale">0%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageSepia">Sepia:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageSepia" min="0" max="1" value="0" step="0.1">
                                    <span class="slider-value" id="vImageSepia">0%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <label for="iImageInvert">Invert:</label>
                                <div class="slider-container">
                                    <input type="range" id="iImageInvert" min="0" max="1" value="0" step="0.1">
                                    <span class="slider-value" id="vImageInvert">0%</span>
                                </div>
                            </div>
                            <div class="control-group">
                                <button id="resetImageFiltersBtn" class="reset-filters-btn reset-button-red" title="Reset all image effects: CSS filters, duotone, glitch, and halftone">
                                    Reset All Effects
                                </button>
                            </div>

                            <!-- DuoTone Section -->
                            <div class="image-header">
                                DuoTone
                            </div>
                            <div id="duotone-controls">
                                <!-- DuoTone Toggle -->
                                <div class="control-group">
                                    <label for="duotoneEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="duotoneEnabled" class="form-checkbox-no-margin">
                                        Enable DuoTone Effect
                                    </label>
                                </div>

                                <!-- DuoTone Color Controls -->
                                <div id="duotone-color-controls" class="hidden">
                                    <div class="control-group">
                                        <label for="duotoneColor1" class="form-label-bold">Color 1 (Highlights):</label>
                                        <div class="flex-gap-8">
                                            <input type="color" id="duotoneColor1" value="#3B82F6" class="form-color-input">
                                            <input type="text" id="duotoneColor1Text" value="#3B82F6" class="form-text-input-mono">
                                        </div>
                                    </div>

                                    <div class="control-group">
                                        <label for="duotoneColor2" class="form-label-bold">Color 2 (Shadows):</label>
                                        <div class="flex-gap-8">
                                            <input type="color" id="duotoneColor2" value="#EAB308" class="form-color-input">
                                            <input type="text" id="duotoneColor2Text" value="#EAB308" class="form-text-input-mono">
                                        </div>
                                    </div>

                                    <!-- DuoTone Reset Button -->
                                    <div class="control-group">
                                        <button id="resetDuotoneBtn" class="reset-button-gray-small">
                                            Reset DuoTone
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Glinch Effects Section -->
                            <div class="image-header">
                                Glinch Effects
                            </div>
                            <div id="glinch-controls">
                                <!-- Color Shift Effect -->
                                <div class="control-group">
                                    <label for="colorShiftEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="colorShiftEnabled" class="form-checkbox-no-margin">
                                        Color Shift
                                    </label>
                                </div>
                                <div id="color-shift-controls" class="controls-hidden-indent">
                                    <div class="control-group">
                                        <label for="colorShiftIntensity" class="form-label-bold">Intensity:</label>
                                        <div class="slider-container">
                                            <input type="range" id="colorShiftIntensity" min="0" max="2" value="1" step="0.1">
                                            <span class="slider-value" id="vColorShiftIntensity">100%</span>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label for="colorShiftAmount" class="form-label-bold">Shift Amount:</label>
                                        <div class="slider-container">
                                            <input type="range" id="colorShiftAmount" min="0" max="50" value="20" step="1">
                                            <span class="slider-value" id="vColorShiftAmount">20px</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Wave Deform Effect -->
                                <div class="control-group">
                                    <label for="waveDeformEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="waveDeformEnabled" class="form-checkbox-no-margin">
                                        Wave Deform
                                    </label>
                                </div>
                                <div id="wave-deform-controls" class="controls-hidden-indent">
                                    <div class="control-group">
                                        <label for="waveDirection" class="form-label-bold">Direction:</label>
                                        <select id="waveDirection" class="form-select-margin">
                                            <option value="horizontal">Horizontal</option>
                                            <option value="vertical">Vertical</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label for="waveAmplitude" class="form-label-bold">Amplitude:</label>
                                        <div class="slider-container">
                                            <input type="range" id="waveAmplitude" min="0" max="50" value="10" step="1">
                                            <span class="slider-value" id="vWaveAmplitude">10px</span>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label for="waveFrequency" class="form-label-bold">Frequency:</label>
                                        <div class="slider-container">
                                            <input type="range" id="waveFrequency" min="0" max="0.2" value="0.05" step="0.01">
                                            <span class="slider-value" id="vWaveFrequency">0.05</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Displacement Effect -->
                                <div class="control-group">
                                    <label for="displacementEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="displacementEnabled" class="form-checkbox-no-margin">
                                        Displacement
                                    </label>
                                </div>
                                <div id="displacement-controls" class="controls-hidden-indent">
                                    <div class="control-group">
                                        <label for="displacementMode" class="form-label-bold">Mode:</label>
                                        <select id="displacementMode" class="form-select-margin">
                                            <option value="horizontal">Horizontal</option>
                                            <option value="vertical">Vertical</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label for="displacementIntensity" class="form-label-bold">Intensity:</label>
                                        <div class="slider-container">
                                            <input type="range" id="displacementIntensity" min="0" max="20" value="8" step="1">
                                            <span class="slider-value" id="vDisplacementIntensity">8</span>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label for="displacementSize" class="form-label-bold">Size:</label>
                                        <div class="slider-container">
                                            <input type="range" id="displacementSize" min="1" max="50" value="18" step="1">
                                            <span class="slider-value" id="vDisplacementSize">18</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Pixel Sort Effect -->
                                <div class="control-group">
                                    <label for="pixelSortEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="pixelSortEnabled" class="form-checkbox-no-margin">
                                        Pixel Sort
                                    </label>
                                </div>
                                <div id="pixel-sort-controls" class="controls-hidden-indent">
                                    <div class="control-group">
                                        <label for="pixelSortDirection" class="form-label-bold">Direction:</label>
                                        <select id="pixelSortDirection" class="form-select-margin">
                                            <option value="horizontal">Horizontal</option>
                                            <option value="vertical">Vertical</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label for="pixelSortBlockSize" class="form-label-bold">Block Size:</label>
                                        <div class="slider-container">
                                            <input type="range" id="pixelSortBlockSize" min="1" max="20" value="5" step="1">
                                            <span class="slider-value" id="vPixelSortBlockSize">5</span>
                                        </div>
                                    </div>
                                    <div class="control-group">
                                        <label for="pixelSortFrequency" class="form-label-bold">Frequency:</label>
                                        <div class="slider-container">
                                            <input type="range" id="pixelSortFrequency" min="0" max="1" value="0.5" step="0.01">
                                            <span class="slider-value" id="vPixelSortFrequency">50%</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Palette Reduction Effect -->
                                <div class="control-group">
                                    <label for="paletteReductionEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="paletteReductionEnabled" class="form-checkbox-no-margin">
                                        Palette Reduction
                                    </label>
                                </div>
                                <div id="palette-reduction-controls" class="controls-hidden-indent">
                                    <div class="control-group">
                                        <label for="paletteName" class="form-label-bold">Palette:</label>
                                        <select id="paletteName" class="form-select-margin">
                                            <option value="gameboy">Game Boy</option>
                                            <option value="firewatch">Firewatch</option>
                                            <option value="desert" selected>Desert</option>
                                            <option value="lavender">Lavender</option>
                                            <option value="strangerThings">Stranger Things</option>
                                            <option value="dawnbringer">Dawnbringer</option>
                                            <option value="blackwhite">Black & White</option>
                                            <option value="grayscale4">Grayscale 4</option>
                                            <option value="bladeRunner">Blade Runner</option>
                                            <option value="madMax">Mad Max</option>
                                            <option value="matrix">Matrix</option>
                                            <option value="tronLegacy">Tron Legacy</option>
                                            <option value="drive">Drive</option>
                                            <option value="akira">Akira</option>
                                            <option value="vaporwave">Vaporwave</option>
                                            <option value="miamiVice">Miami Vice</option>
                                            <option value="lofi">Lofi</option>
                                            <option value="nes">NES</option>
                                            <option value="glitchCore">Glitch Core</option>
                                            <option value="acid">Acid</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label for="distanceMode" class="form-label-bold">Distance:</label>
                                        <select id="distanceMode" class="form-select-margin">
                                            <option value="fast">Fast</option>
                                            <option value="accurate" selected>Accurate</option>
                                            <option value="perceptual">Perceptual</option>
                                        </select>
                                    </div>
                                    <div class="control-group">
                                        <label for="useDithering" class="form-label-flex-checkbox">
                                            <input type="checkbox" id="useDithering" checked class="form-checkbox-no-margin">
                                            Enable Dithering
                                        </label>
                                    </div>
                                </div>

                                <!-- Reset Glinch Button -->
                                <div class="control-group">
                                    <button id="resetGlinchBtn" class="reset-button-gray-small">
                                        Reset All Glinch Effects
                                    </button>
                                </div>
                            </div>

                            <!-- Halftone Effects Section -->
                            <div class="image-header">
                                Halftone Effects
                            </div>
                            <div id="halftone-controls">
                                <!-- Halftone Enable Toggle -->
                                <div class="control-group">
                                    <label for="halftoneEnabled" class="form-label-flex-checkbox">
                                        <input type="checkbox" id="halftoneEnabled" class="form-checkbox-no-margin">
                                        Enable Halftone
                                    </label>
                                </div>

                                <!-- Halftone Controls (hidden by default) -->
                                <div id="halftone-effect-controls" class="controls-hidden-indent">
                                    <!-- Dot Size Control -->
                                    <div class="control-group">
                                        <label for="halftoneDotSize" class="form-label-bold">Dot Size:</label>
                                        <div class="slider-container">
                                            <input type="range" id="halftoneDotSize" min="0.05" max="1" value="0.4" step="0.01">
                                            <span class="slider-value" id="vHalftoneDotSize">0.4em</span>
                                        </div>
                                    </div>

                                    <!-- Halftone Image Upload -->
                                    <div class="control-group">
                                        <label for="halftoneImageUpload" class="form-label-bold">Replace Dots with Image:</label>
                                        <input type="file" id="halftoneImageUpload" accept="image/*" class="form-file-input">
                                        <div id="halftoneImagePreview" class="preview-container">
                                            <img id="halftoneImagePreviewImg" class="preview-img-small">
                                            <button id="clearHalftoneImage" class="clear-button-small">Clear Image</button>
                                        </div>
                                    </div>

                                    <!-- Grayscale Toggle Control -->
                                    <div class="control-group">
                                        <label class="form-label-flex-checkbox">
                                            <input type="checkbox" id="halftoneGrayscale" checked class="form-checkbox-no-margin">
                                            Convert to Grayscale
                                        </label>
                                        <div class="small-gray-text-margin">
                                            Disable for colored custom images
                                        </div>
                                    </div>

                                    <!-- Color Control Note -->
                                    <div class="control-group">
                                        <div class="tip-box-blue">
                                            <strong>💡 Tip:</strong> Upload an image to replace dots, or use <strong>Duotone</strong> effect below to color halftone!
                                        </div>
                                    </div>

                                    <!-- Dot Color Control - HIDDEN (use duotone for colors) -->
                                    <div class="control-group hidden">
                                        <label for="halftoneDotColor" class="form-label-bold">Dot Color:</label>
                                        <input type="color" id="halftoneDotColor" value="#333333" class="form-color-input-full">
                                    </div>

                                    <!-- Line Contrast Control -->
                                    <div class="control-group">
                                        <label for="halftoneLineContrast" class="form-label-bold">Line Contrast:</label>
                                        <div class="slider-container">
                                            <input type="range" id="halftoneLineContrast" min="100" max="5000" value="1050" step="10">
                                            <span class="slider-value" id="vHalftoneLineContrast">1050%</span>
                                        </div>
                                    </div>

                                    <!-- Photo Brightness Control -->
                                    <div class="control-group">
                                        <label for="halftonePhotoBrightness" class="form-label-bold">Photo Brightness:</label>
                                        <div class="slider-container">
                                            <input type="range" id="halftonePhotoBrightness" min="0" max="200" value="70" step="1">
                                            <span class="slider-value" id="vHalftonePhotoBrightness">70%</span>
                                        </div>
                                    </div>

                                    <!-- Photo Contrast Control -->
                                    <div class="control-group">
                                        <label for="halftonePhotoContrast" class="form-label-bold">Photo Contrast:</label>
                                        <div class="slider-container">
                                            <input type="range" id="halftonePhotoContrast" min="0" max="300" value="100" step="1">
                                            <span class="slider-value" id="vHalftonePhotoContrast">100%</span>
                                        </div>
                                    </div>

                                    <!-- Photo Blur Control -->
                                    <div class="control-group">
                                        <label for="halftonePhotoBlur" class="form-label-bold">Photo Blur:</label>
                                        <div class="slider-container">
                                            <input type="range" id="halftonePhotoBlur" min="0" max="10" value="0" step="0.1">
                                            <span class="slider-value" id="vHalftonePhotoBlur">0px</span>
                                        </div>
                                    </div>

                                    <!-- Blend Mode Control -->
                                    <div class="control-group">
                                        <label for="halftoneBlendMode" class="form-label-bold">Blend Mode:</label>
                                        <select id="halftoneBlendMode" class="form-select-margin">
                                            <option value="normal">Normal</option>
                                            <option value="multiply">Multiply</option>
                                            <option value="screen">Screen</option>
                                            <option value="overlay">Overlay</option>
                                            <option value="darken">Darken</option>
                                            <option value="lighten">Lighten</option>
                                            <option value="color-dodge">Color Dodge</option>
                                            <option value="color-burn">Color Burn</option>
                                            <option value="hard-light" selected>Hard Light</option>
                                            <option value="soft-light">Soft Light</option>
                                            <option value="difference">Difference</option>
                                            <option value="exclusion">Exclusion</option>
                                            <option value="hue">Hue</option>
                                            <option value="saturation">Saturation</option>
                                            <option value="color">Color</option>
                                            <option value="luminosity">Luminosity</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- Reset Halftone Button -->
                                <div class="control-group">
                                    <button id="resetHalftoneBtn" class="reset-button-gray-small">
                                        Reset Halftone Effect
                                    </button>
                                </div>
                            </div>

                            <!-- Save Filter Preset -->
                            <div class="control-group border-top-gray-margin">
                                <label for="newPresetName" class="form-label-bold-color">Save New Preset:</label>
                                <input type="text" id="newPresetName" placeholder="Enter preset name (e.g., Nuclear)" class="preset-input-margin">
                                <button id="saveFilterPresetBtn" class="save-preset-btn preset-save-button-transition">
                                    💾 Save All Effects Preset
                                </button>
                            </div>
                            <div class="control-group">
                                <button id="testImageFiltersBtn" class="test-filters-btn test-button-margin">
                                    Test Filters (Grayscale)
                                </button>
                            </div>
                            <div class="control-group">
                                <button id="debugImageFiltersBtn" class="debug-filters-btn debug-button-margin">
                                    Debug: Check Selection
                                </button>
                            </div>
                        </div>

                        <!-- Image Actions Section -->
                        <div class="image-header">
                            Image Actions
                        </div>

                        <div class="image-actions-container">
                            <!-- Remove Background Button -->
                            <button id="removeBgBtn" class="professional-btn hidden">
                                <i class="fas fa-cut"></i> Remove Background
                            </button>

                            <!-- Regenerate Button -->
                            <button id="regenerateBtn" class="professional-btn hidden">
                                <i class="fas fa-redo"></i> Regenerate
                            </button>

                            <!-- Restyle Button -->
                            <button id="restyleBtn" class="professional-btn hidden">
                                <i class="fas fa-magic"></i> Restyle
                            </button>

                            <!-- Replace Button -->
                            <button id="replaceBtn" class="professional-btn hidden">
                                <i class="fas fa-exchange-alt"></i> Replace
                            </button>
                        </div>

                        <!-- Template ID for image replacement -->
                        <div class="control-group section-border section-border-crimson">
                            <label for="imageTemplateId" class="crimson-label">Template ID:</label>
                            <select id="imageTemplateId" class="crimson-border" disabled>
                                <option value="">Not Replaceable</option>
                                <option value="i01">i01 - Main Image</option>
                                <option value="i02">i02 - Image 2</option>
                                <option value="i03">i03 - Image 3</option>
                                <option value="i04">i04 - Image 4</option>
                                <option value="i05">i05 - Image 5</option>
                                <optgroup label="🎭 Mask Shapes">
                                    <option value="mask01">mask01 - Mask Shape 1</option>
                                    <option value="mask02">mask02 - Mask Shape 2</option>
                                    <option value="mask03">mask03 - Mask Shape 3</option>
                                </optgroup>
                            </select>
                            <small class="small-gray-label">
                                Select an ID to make this image replaceable in templates. i01 is the main image that gets replaced with generated content.
                            </small>
                        </div>
                        <!-- Debug display for persistent Template ID (Images) -->
                            <div class="debug-red-small">
                                <span class="debug-red-text-small">Debug newTemplateId: </span>
                                <span id="debugImageNewTemplateId" class="debug-red-text-small-normal">N/A</span>
                            </div>

                        <!-- Shape Replacement Controls -->
                        <div class="control-group section-border section-border-blue">
                            <label for="shapeReplacementFolder" class="blue-label">
                                <i class="fas fa-shapes"></i> Shape Replacement
                            </label>
                            <div class="flex-gap-8">
                                <select id="shapeReplacementFolder" class="shape-replacement-select" title="Select shape size category" disabled>
                                    <option value="">Select size...</option>
                                </select>
                                <button id="changeShapeBtn" class="professional-btn blue-button-custom" disabled>
                                    <i class="fas fa-random"></i> Change Shape
                                </button>
                                <button id="resetSizeBtn" class="professional-btn gray-button-custom" disabled>
                                    <i class="fas fa-undo"></i> Reset Size
                                </button>
                            </div>
                            <small class="small-gray-label">
                                Select a shape to replace it with a random shape from the chosen size category. Position and scale will be preserved.
                            </small>
                            <div id="shapeReplacementStatus" class="blue-status-border">
                                Select a shape object to enable replacement
                            </div>
                        </div>
                    </div>
                     <p id="no-image-selected-msg">No image selected.</p>
                </div><!-- End Image Tab -->

                <!-- AI TAB CONTENT -->
                <div class="sidebar-content" id="ai-tab-content">
                    <div class="ai-header">AI Features</div>

                    <!-- Note about Text Enhancement -->
                    <div class="ai-note">
                        💡 <strong>Text Enhancement</strong> is located in the <strong>Text</strong> tab for easier access when editing text.
                    </div>

                    <!-- AI Action Buttons -->
                    <div class="ai-actions-section">
                        <h4>Style Management</h4>

                        <!-- Font Styles Management -->
                        <div class="control-group section-border section-border-green">
                            <button type="button" id="changeFontsBtn" class="button-full-width button-green">
                                🔄 Change Fonts
                            </button>
                            <small class="helper-text">
                                Cycle through saved font style configurations
                            </small>
                            <button type="button" id="saveFontStyleBtn" class="button-full-width button-blue">
                                💾 Save Font Style (Admin)
                            </button>
                            <small class="helper-text">
                                Save current font configuration of all texts for cycling
                            </small>
                            <div id="fontStylesStatus" class="status-display">
                                No saved font styles
                            </div>
                        </div>

                        <!-- Decor Styles Management -->
                        <div class="control-group section-border section-border-purple">
                            <button type="button" id="changeDecorBtn" class="button-full-width button-purple">
                                🎨 Change Decor Styles
                            </button>
                            <small class="helper-text">
                                Cycle through saved decoration and shadow configurations
                            </small>
                            <button type="button" id="saveDecorStyleBtn" class="button-full-width button-purple-dark">
                                💾 Save Decor Style (Admin)
                            </button>
                            <small class="helper-text">
                                Save current decoration/shadow configuration of all objects for cycling
                            </small>
                            <div id="decorStylesStatus" class="status-display">
                                No saved decor styles
                            </div>
                        </div>

                        <!-- Color Palette Management -->
                        <div class="control-group section-border section-border-orange">
                            <button type="button" id="changeColorsBtn" class="button-full-width button-orange">
                                🌈 Change Colors
                            </button>
                            <small class="helper-text">
                                Randomly select a new palette and apply colors based on assigned intensities
                            </small>
                            <div id="colorChangeStatus" class="status-display">
                                Ready to apply random palette colors
                            </div>
                        </div>

                        <!-- Image Effects Management -->
                        <div class="control-group section-border section-border-red">
                            <button type="button" id="changeImageEffectBtn" class="button-full-width button-red">
                                🎭 Change Image Effect
                            </button>
                            <small class="helper-text">
                                Randomly apply a comprehensive image effect preset to selected image
                            </small>
                            <button type="button" id="changeImageColorsBtn" onclick="console.log('🎨 Inline click detected!'); if(window.changeImageColors) window.changeImageColors(); else console.error('🎨 changeImageColors function not found');" class="button-full-width button-purple">
                                🎨 Change Image Colors
                            </button>
                            <small class="helper-text">
                                Randomly adjust hue rotation while keeping all other effects unchanged
                            </small>
                            <button type="button" id="resetImageEffectBtn" class="button-full-width button-gray">
                                🔄 Reset Image Effect
                            </button>
                            <small class="helper-text">
                                Clear all image effects and return to original image
                            </small>
                            <div id="imageEffectStatus" class="status-display">
                                Ready to apply random image effects
                            </div>
                        </div>
                    </div>
                </div><!-- End AI Tab -->



                <!-- ADMIN TAB CONTENT -->
                <div class="sidebar-content" id="admin-tab-content">
                    <div class="admin-header">Inspiration Details</div>
                    <div id="admin-controls" class="admin-controls-flex">
                        <div class="control-group">
                            <label for="adminImageUrl" class="admin-label-80">Image URL:</label>
                            <input id="adminImageUrl" type="text" readonly class="admin-input-readonly">
                        </div>
                        <div class="control-group">
                            <label for="adminModel" class="admin-label-80">Model:</label>
                            <input id="adminModel" type="text" readonly class="admin-input-readonly">
                        </div>
                         <div class="control-group">
                            <label for="adminPalette" class="admin-label-80">Palette:</label>
                            <input id="adminPalette" type="text" readonly class="admin-input-readonly">
                        </div>

                        <div class="control-group">
                            <label for="adminOriginalPalette" class="admin-label-80">Original Palette:</label>
                            <input id="adminOriginalPalette" type="text" readonly class="admin-input-readonly">
                        </div>

                        <div class="control-group flex-column-start">
                            <label for="adminOriginalObject" class="label-margin-bottom">Original Object:</label>
                            <textarea id="adminOriginalObject" rows="3" readonly class="admin-textarea-readonly"></textarea>
                        </div>

                        <div class="control-group flex-column-start">
                            <label for="adminFontStyles" class="label-margin-bottom">Text Font Styles:</label>
                            <textarea id="adminFontStyles" rows="4" readonly class="admin-textarea-readonly-mono" placeholder="No saved font styles"></textarea>
                            <small class="small-text-margin">JSON array of saved font configurations for cycling</small>
                        </div>

                        <div class="control-group flex-column-start">
                            <label for="adminDecorStyles" class="label-margin-bottom">Decor Styles:</label>
                            <textarea id="adminDecorStyles" rows="4" readonly class="admin-textarea-readonly-mono" placeholder="No saved decor styles"></textarea>
                            <small class="small-text-margin">JSON array of saved decoration and shadow configurations for cycling</small>
                            <button type="button" onclick="
                                const field = document.getElementById('adminFontStyles');
                                console.log('🎯 🔧 MANUAL TEST - Checking ALL data sources:');
                                console.log('🎯 🔧 window.fontStylesList:', window.fontStylesList);
                                console.log('🎯 🔧 window._fontStylesListBackup:', window._fontStylesListBackup);
                                console.log('🎯 🔧 window.__fontStylesData__:', window.__fontStylesData__);

                                let dataToUse = null;
                                let source = '';

                                // Try main location
                                if (window.fontStylesList && window.fontStylesList.length > 0) {
                                    dataToUse = window.fontStylesList;
                                    source = 'window.fontStylesList';
                                }
                                // Try backup 1
                                else if (window._fontStylesListBackup && window._fontStylesListBackup.length > 0) {
                                    dataToUse = window._fontStylesListBackup;
                                    source = 'window._fontStylesListBackup';
                                }
                                // Try backup 2
                                else if (window.__fontStylesData__ && window.__fontStylesData__.length > 0) {
                                    dataToUse = window.__fontStylesData__;
                                    source = 'window.__fontStylesData__';
                                }
                                // Try sessionStorage backup
                                else {
                                    try {
                                        const sessionData = sessionStorage.getItem('_fontStylesBackup');
                                        if (sessionData) {
                                            dataToUse = JSON.parse(sessionData);
                                            source = 'sessionStorage';
                                        }
                                    } catch (e) {
                                        console.log('🎯 🔧 SessionStorage backup failed:', e);
                                    }
                                }
                                // Try DOM element backup
                                if (!dataToUse) {
                                    try {
                                        const domStorage = document.getElementById('_fontStylesStorage');
                                        if (domStorage) {
                                            const domData = domStorage.getAttribute('data-fontstyles');
                                            if (domData) {
                                                dataToUse = JSON.parse(domData);
                                                source = 'DOM element';
                                            }
                                        }
                                    } catch (e) {
                                        console.log('🎯 🔧 DOM backup failed:', e);
                                    }
                                }

                                if (dataToUse && dataToUse.length > 0) {
                                    field.value = JSON.stringify(dataToUse, null, 2);
                                    console.log('🎯 🔧 MANUAL TEST: Found data in ' + source + ', set field value');
                                    // Restore to main location
                                    window.fontStylesList = dataToUse;
                                } else {
                                    field.value = 'TEST DATA: No fontStylesList found in ANY backup location';
                                    console.log('🎯 🔧 MANUAL TEST: No fontStylesList found in ANY location');
                                }
                            " class="admin-test-btn primary">
                                🔧 Test Fill Field
                            </button>
                            <button type="button" onclick="
                                if (window.updateAdminFontStylesDisplay) {
                                    window.updateAdminFontStylesDisplay();
                                    console.log('🎯 ✅ Called updateAdminFontStylesDisplay function');
                                } else {
                                    console.log('🎯 ❌ updateAdminFontStylesDisplay function not available');
                                }
                            " class="admin-test-btn success">
                                🔄 Call Update Function
                            </button>
                            <button type="button" onclick="
                                console.log('🛡️ PROTECTION TEST - Checking protection system...');
                                if (window._fontStylesProtection) {
                                    const data = window._fontStylesProtection.retrieve();
                                    if (data && data.length > 0) {
                                        const field = document.getElementById('adminFontStyles');
                                        field.value = JSON.stringify(data, null, 2);
                                        console.log('🛡️ PROTECTION TEST: Restored', data.length, 'font styles from protection system');
                                        window.fontStylesList = data;
                                    } else {
                                        console.log('🛡️ PROTECTION TEST: No protected data found');
                                    }
                                } else {
                                    console.log('🛡️ PROTECTION TEST: Protection system not available');
                                }
                            " class="admin-test-btn danger">
                                🛡️ Test Protection
                            </button>
                        </div>

                        <div class="control-group flex-column-start">
                            <label for="adminPrompt" class="label-margin-bottom">Prompt:</label>
                            <textarea id="adminPrompt" rows="8" readonly class="admin-textarea-readonly"></textarea>
                        </div>
                        <input type="hidden" id="adminInspirationId"> <!-- Hidden field for ID -->

                        <!-- Template Save Buttons - Show different buttons based on whether editing existing template -->
                        <div id="templateSaveButtons">
                            <button id="saveTemplateBtn" class="add-btn save-button-margin">Save as Inspiration</button> <!-- Default for new templates -->
                            <button id="updateTemplateBtn" class="add-btn save-button-blue-hidden">💾 Save</button> <!-- For existing templates -->
                            <button id="saveAsTemplateBtn" class="add-btn save-button-hidden-small">📋 Save As New</button> <!-- For existing templates -->
                        </div>

                        <button id="saveTextStyleBtn" class="add-btn save-button-margin-small">Save Text Style</button> <!-- New Text Style button -->
                         <button id="validateMasksBtn" class="add-btn save-button-purple-margin">🎭 Validate Masks</button> <!-- Debug button for mask validation -->
                    </div>
                </div><!-- End Admin Tab -->

            </aside>
        </main>
    </div>

    <!-- Color input replaced with text input for Coloris -->
    <!-- OpenType.js for Grid Distort effect -->
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>

    <script src="/js/font-variant-detector.js"></script>
    <script src="/js/gradient-color-picker.js"></script>
    <script src="/js/decoration-module.js"></script>
    <script type="module">
        // Load color palette functions and make them globally available
        import { getPaletteById, getTextColorForPalette } from '/js/data/colorPalettes.js';
        import { setupProjectModal } from '/js/components/ProjectModal.js?v=1749502000';

        window.getPaletteById = getPaletteById;
        window.getTextColorForPalette = getTextColorForPalette;

        // Setup project modal functionality
        setupProjectModal();
    </script>
    <script src="/js/design-editor-fixed-new.js?v=20250805124500&nocache=true&force=true&random=1740020500008"></script>
    <script src="/js/mesh-warp-implementation.js?v=1750012021"></script>
    <script src="/js/left-menu.js?v=1750012000"></script>
    <script src="/js/shapes-api.js"></script>
    <script src="/js/elements-accordion.js"></script>
    <script src="/js/images-loader.js"></script>
    <script src="/js/shapes-loader.js"></script>
    <script src="/js/svg-ungroup.js"></script>
    <script type="module" src="/js/components/Topbar.js"></script>
    <script type="module" src="/js/components/CollectionModal.js"></script>
    <script type="module" src="/js/components/ColorPaletteSelector.js"></script>
    <script type="module">
       import { createTopbar } from '/js/components/Topbar.js';

       // Global error handler for uncaught errors
       window.addEventListener('error', function(event) {
           console.error('🚨 Global error caught:', {
               message: event.message,
               filename: event.filename,
               lineno: event.lineno,
               colno: event.colno,
               error: event.error
           });

           // Don't prevent default error handling
           return false;
       });

       // Global error handler for unhandled promise rejections
       window.addEventListener('unhandledrejection', function(event) {
           console.error('🚨 Unhandled promise rejection:', event.reason);
       });

       document.addEventListener('DOMContentLoaded', async () => {
           // Initialize topbar (same as other pages)
           await createTopbar();

           // Initialize font variant detection system with retry
           function initializeFontSystem() {
               if (window.fontVariantDetector && window.fontMap) {
                   console.log('🔤 Initializing font variant detection system...');
                   try {
                       window.fontVariantDetector.initialize(window.fontMap);
                       console.log('🔤 Font variant detection system initialized successfully');
                       console.log('🔤 FontMap available with', Object.keys(window.fontMap).length, 'fonts');
                       return true;
                   } catch (error) {
                       console.error('🔤 Failed to initialize font variant detection system:', error);
                       return false;
                   }
               } else {
                   console.warn('🔤 FontVariantDetector or fontMap not available yet');
                   return false;
               }
           }

           // Try to initialize immediately
           if (!initializeFontSystem()) {
               // If not available, wait for the main script to load
               console.log('🔤 Waiting for fontMap to be available...');
               let retryCount = 0;
               const maxRetries = 10;
               const retryInterval = setInterval(() => {
                   retryCount++;
                   if (initializeFontSystem()) {
                       clearInterval(retryInterval);
                   } else if (retryCount >= maxRetries) {
                       console.error('🔤 Failed to initialize font system after', maxRetries, 'retries');
                       clearInterval(retryInterval);
                   }
               }, 500);
           }

           // Wait for design-editor.js to load before loading template data
           const waitForDesignEditor = () => {
               return new Promise((resolve) => {
                   if (window.updateAdminFontStylesDisplay) {
                       console.log('🎯 ✅ design-editor.js already loaded');
                       resolve();
                   } else {
                       console.log('🎯 ⏳ Waiting for design-editor.js to load...');
                       const checkInterval = setInterval(() => {
                           if (window.updateAdminFontStylesDisplay) {
                               console.log('🎯 ✅ design-editor.js loaded');
                               clearInterval(checkInterval);
                               resolve();
                           }
                       }, 100);
                   }
               });
           };

           await waitForDesignEditor();

           // Initialize template-specific flags
           window._templateSpecificFontStylesLoaded = false;
           window._templateSpecificDecorStylesLoaded = false;

           // Load template data from sessionStorage (from inspiration.html)
           loadTemplateFromSessionStorage();

           // AI Generator functionality is handled by left-menu.js

           // ULTRA ROBUST FONT STYLES PROTECTION SYSTEM
           // Create multiple protected storage locations for font styles data
           window._fontStylesProtection = {
               data: null,
               isProtected: false,

               // Store font styles data in multiple protected locations
               protect: function(fontStylesData) {
                   if (!fontStylesData || !Array.isArray(fontStylesData) || fontStylesData.length === 0) {
                       console.log('🛡️ No font styles data to protect');
                       return;
                   }

                   console.log('🛡️ PROTECTING font styles data:', fontStylesData.length, 'styles');
                   this.data = JSON.parse(JSON.stringify(fontStylesData)); // Deep clone
                   this.isProtected = true;

                   // Store in multiple locations
                   window._PROTECTED_FONT_STYLES_ = JSON.parse(JSON.stringify(fontStylesData));
                   sessionStorage.setItem('_PROTECTED_FONT_STYLES_', JSON.stringify(fontStylesData));
                   localStorage.setItem('_PROTECTED_FONT_STYLES_BACKUP_', JSON.stringify(fontStylesData));

                   // Create hidden DOM element as backup
                   let hiddenStorage = document.getElementById('_hiddenFontStylesStorage');
                   if (!hiddenStorage) {
                       hiddenStorage = document.createElement('div');
                       hiddenStorage.id = '_hiddenFontStylesStorage';
                       hiddenStorage.style.display = 'none';
                       document.body.appendChild(hiddenStorage);
                   }
                   hiddenStorage.setAttribute('data-font-styles', JSON.stringify(fontStylesData));

                   console.log('🛡️ Font styles data protected in 4 locations');
                   this.startMonitoring();
               },

               // Retrieve font styles data from any available location
               retrieve: function() {
                   let data = null;
                   let source = '';

                   // Try main storage
                   if (this.data && this.data.length > 0) {
                       data = this.data;
                       source = 'main protection';
                   }
                   // Try window backup
                   else if (window._PROTECTED_FONT_STYLES_ && window._PROTECTED_FONT_STYLES_.length > 0) {
                       data = window._PROTECTED_FONT_STYLES_;
                       source = 'window backup';
                   }
                   // Try sessionStorage
                   else {
                       try {
                           const sessionData = sessionStorage.getItem('_PROTECTED_FONT_STYLES_');
                           if (sessionData) {
                               data = JSON.parse(sessionData);
                               source = 'sessionStorage';
                           }
                       } catch (e) {
                           console.log('🛡️ SessionStorage retrieval failed:', e);
                       }
                   }
                   // Try localStorage
                   if (!data) {
                       try {
                           const localData = localStorage.getItem('_PROTECTED_FONT_STYLES_BACKUP_');
                           if (localData) {
                               data = JSON.parse(localData);
                               source = 'localStorage';
                           }
                       } catch (e) {
                           console.log('🛡️ LocalStorage retrieval failed:', e);
                       }
                   }
                   // Try DOM element
                   if (!data) {
                       try {
                           const hiddenStorage = document.getElementById('_hiddenFontStylesStorage');
                           if (hiddenStorage) {
                               const domData = hiddenStorage.getAttribute('data-font-styles');
                               if (domData) {
                                   data = JSON.parse(domData);
                                   source = 'DOM element';
                               }
                           }
                       } catch (e) {
                           console.log('🛡️ DOM retrieval failed:', e);
                       }
                   }

                   if (data && data.length > 0) {
                       console.log('🛡️ Retrieved font styles from:', source, '- Count:', data.length);
                       return data;
                   }

                   console.log('🛡️ No font styles data found in any protected location');
                   return null;
               },

               // Start monitoring the adminFontStyles field
               startMonitoring: function() {
                   // 🔧 PERFORMANCE FIX: Use state flags to prevent redundant monitoring
                   if (window._isTemplateLoaded || window._fontStylesMonitoringComplete) {
                       console.log('🛡️ PERFORMANCE: Skipping font styles monitoring - system already loaded');
                       return;
                   }

                   if (this.monitorInterval) {
                       clearInterval(this.monitorInterval);
                   }

                   console.log('🛡️ Starting font styles field monitoring...');

                   // Add delay if template loading is in progress
                   if (window._templateAlreadyLoaded === undefined) {
                       console.log('🛡️ Template loading may be in progress, delaying monitoring...');
                       setTimeout(() => {
                           this.startMonitoring();
                       }, 2000);
                       return;
                   }

                   let checkCount = 0;

                   this.monitorInterval = setInterval(() => {
                       checkCount++;
                       const adminFontStylesField = document.getElementById('adminFontStyles');

                       if (adminFontStylesField) {
                           const currentValue = adminFontStylesField.value;
                           const hasData = currentValue && currentValue.trim() !== '' && currentValue !== 'No saved font styles';

                           console.log(`🛡️ FONT PROTECTION CHECK ${checkCount}:`, {
                               hasData,
                               isProtected: this.isProtected,
                               templateSpecificLoaded: window._templateSpecificFontStylesLoaded,
                               templateAlreadyLoaded: window._templateAlreadyLoaded,
                               currentValue: currentValue?.substring(0, 50) + '...'
                           });

                           // Check if template data is already loaded (either flag is set or field has non-empty array data)
                           const templateDataLoaded = window._templateSpecificFontStylesLoaded ||
                                                    window._templateAlreadyLoaded ||
                                                    (hasData && currentValue !== '[]' && !currentValue.includes('No saved font styles'));

                           if (!hasData && this.isProtected && !templateDataLoaded) {
                               const protectedData = this.retrieve();
                               if (protectedData && protectedData.length > 0) {
                                   const jsonValue = JSON.stringify(protectedData, null, 2);
                                   adminFontStylesField.value = jsonValue;
                                   console.log(`🛡️ RESTORED font styles to field (check ${checkCount}) - no template data loaded`);

                                   // Also restore to window.fontStylesList if needed
                                   if (!window.fontStylesList || window.fontStylesList.length === 0) {
                                       window.fontStylesList = JSON.parse(JSON.stringify(protectedData));
                                       console.log('🛡️ Restored window.fontStylesList');
                                   }
                               }
                           } else if (templateDataLoaded) {
                               console.log(`🛡️ SKIPPING font styles restoration (check ${checkCount}) - template data already loaded`);

                               // 🔧 PERFORMANCE FIX: Stop monitoring immediately when template is loaded
                               console.log('🛡️ PERFORMANCE: Stopping font styles monitoring - template data confirmed loaded');
                               window._fontStylesMonitoringComplete = true;
                               clearInterval(this.monitorInterval);
                               this.monitorInterval = null;
                               return;
                           }
                       }

                       // Stop monitoring after 2 minutes
                       if (checkCount >= 240) { // 240 * 500ms = 2 minutes
                           console.log('🛡️ Stopping font styles monitoring after 2 minutes');
                           clearInterval(this.monitorInterval);
                       }
                   }, 500); // Check every 500ms
               }
           };

           // DECOR STYLES PROTECTION SYSTEM
           // Create multiple protected storage locations for decor styles data
           window._decorStylesProtection = {
               data: null,
               isProtected: false,

               // Store decor styles data in multiple protected locations
               protect: function(decorStylesData) {
                   if (!decorStylesData || !Array.isArray(decorStylesData) || decorStylesData.length === 0) {
                       console.log('🛡️ No decor styles data to protect');
                       return;
                   }

                   console.log('🛡️ PROTECTING decor styles data:', decorStylesData.length, 'styles');
                   this.data = JSON.parse(JSON.stringify(decorStylesData)); // Deep clone
                   this.isProtected = true;

                   // Store in multiple locations
                   window._PROTECTED_DECOR_STYLES_ = JSON.parse(JSON.stringify(decorStylesData));

                   // Store in localStorage
                   try {
                       localStorage.setItem('_PROTECTED_DECOR_STYLES_BACKUP_', JSON.stringify(decorStylesData));
                   } catch (e) {
                       console.log('🛡️ localStorage storage failed:', e);
                   }

                   // Store in hidden DOM element
                   let hiddenStorage = document.getElementById('_hiddenDecorStylesStorage');
                   if (!hiddenStorage) {
                       hiddenStorage = document.createElement('div');
                       hiddenStorage.id = '_hiddenDecorStylesStorage';
                       hiddenStorage.style.display = 'none';
                       document.body.appendChild(hiddenStorage);
                   }
                   hiddenStorage.setAttribute('data-decor-styles', JSON.stringify(decorStylesData));

                   console.log('🛡️ Decor styles data protected in 4 locations');
                   this.startMonitoring();
               },

               // Retrieve decor styles data from any available location
               retrieve: function() {
                   let data = null;
                   let source = '';

                   // Try main storage
                   if (this.data && this.data.length > 0) {
                       data = this.data;
                       source = 'main storage';
                   }

                   // Try window backup
                   if (!data && window._PROTECTED_DECOR_STYLES_) {
                       try {
                           data = JSON.parse(JSON.stringify(window._PROTECTED_DECOR_STYLES_));
                           source = 'window backup';
                       } catch (e) {
                           console.log('🛡️ Window backup retrieval failed:', e);
                       }
                   }

                   // Try localStorage
                   if (!data) {
                       try {
                           const stored = localStorage.getItem('_PROTECTED_DECOR_STYLES_BACKUP_');
                           if (stored) {
                               data = JSON.parse(stored);
                               source = 'localStorage';
                           }
                       } catch (e) {
                           console.log('🛡️ localStorage retrieval failed:', e);
                       }
                   }

                   // Try DOM storage
                   if (!data) {
                       try {
                           const hiddenStorage = document.getElementById('_hiddenDecorStylesStorage');
                           if (hiddenStorage) {
                               const stored = hiddenStorage.getAttribute('data-decor-styles');
                               if (stored) {
                                   data = JSON.parse(stored);
                                   source = 'DOM storage';
                               }
                           }
                       } catch (e) {
                           console.log('🛡️ DOM retrieval failed:', e);
                       }
                   }

                   if (data && data.length > 0) {
                       console.log('🛡️ Retrieved decor styles from:', source, '- Count:', data.length);
                       return data;
                   }

                   console.log('🛡️ No decor styles data found in any protected location');
                   return null;
               },

               // Start monitoring the adminDecorStyles field
               startMonitoring: function() {
                   // 🔧 PERFORMANCE FIX: Use state flags to prevent redundant monitoring
                   if (window._isTemplateLoaded || window._decorStylesMonitoringComplete || window.isFullyLoaded) {
                       console.log('🛡️ PERFORMANCE: Skipping decor styles monitoring - system already loaded');
                       return;
                   }

                   if (this.monitorInterval) {
                       clearInterval(this.monitorInterval);
                   }

                   console.log('🛡️ Starting decor styles field monitoring...');

                   // Add delay if template loading is in progress (but limit recursion)
                   if (window._templateAlreadyLoaded === undefined && !this.recursionCount) {
                       this.recursionCount = (this.recursionCount || 0) + 1;
                       if (this.recursionCount < 5) { // Limit to 5 attempts
                           console.log('🛡️ Template loading may be in progress, delaying monitoring... (attempt', this.recursionCount, ')');
                           setTimeout(() => {
                               this.startMonitoring();
                           }, 2000);
                           return;
                       } else {
                           console.log('🛡️ Max recursion attempts reached, proceeding with monitoring');
                           this.recursionCount = 0;
                       }
                   }

                   let checkCount = 0;

                   this.monitorInterval = setInterval(() => {
                       checkCount++;
                       const adminDecorStylesField = document.getElementById('adminDecorStyles');

                       if (adminDecorStylesField) {
                           const currentValue = adminDecorStylesField.value;
                           const hasData = currentValue && currentValue.trim() !== '' && currentValue !== 'No saved decor styles';

                           // Check if template data is already loaded (either flag is set or field has non-empty array data)
                           const templateDataLoaded = window._templateSpecificDecorStylesLoaded ||
                                                    window._templateAlreadyLoaded ||
                                                    (hasData && currentValue !== '[]' && !currentValue.includes('No saved decor styles'));

                           if (!hasData && this.isProtected && !templateDataLoaded) {
                               const protectedData = this.retrieve();
                               if (protectedData && protectedData.length > 0) {
                                   const jsonValue = JSON.stringify(protectedData, null, 2);
                                   adminDecorStylesField.value = jsonValue;
                                   console.log(`🛡️ RESTORED decor styles to field (check ${checkCount}) - no template data loaded`);

                                   // Also restore to window.decorStylesList if needed
                                   if (!window.decorStylesList || window.decorStylesList.length === 0) {
                                       window.decorStylesList = JSON.parse(JSON.stringify(protectedData));
                                       console.log('🛡️ Restored window.decorStylesList');
                                   }
                               }
                           } else if (templateDataLoaded) {
                               console.log(`🛡️ SKIPPING decor styles restoration (check ${checkCount}) - template data already loaded`);

                               // 🔧 PERFORMANCE FIX: Stop monitoring immediately when template is loaded
                               console.log('🛡️ PERFORMANCE: Stopping decor styles monitoring - template data confirmed loaded');
                               window._decorStylesMonitoringComplete = true;
                               clearInterval(this.monitorInterval);
                               this.monitorInterval = null;
                               return;
                           }
                       }

                       // Stop monitoring after 2 minutes
                       if (checkCount >= 240) { // 240 * 500ms = 2 minutes
                           console.log('🛡️ Stopping decor styles monitoring after 2 minutes');
                           clearInterval(this.monitorInterval);
                       }
                   }, 500); // Check every 500ms
               }
           };

           // Additional check to ensure font styles are displayed after all scripts load
           setTimeout(() => {
               console.log('🎯 🔄 FINAL CHECK: Looking for font styles data...');

               // Check if we have font styles data in any location
               let fontStylesData = null;

               if (window.fontStylesList && window.fontStylesList.length > 0) {
                   fontStylesData = window.fontStylesList;
                   console.log('🎯 Found font styles in window.fontStylesList');
               } else if (window._fontStylesProtection && !window._templateSpecificFontStylesLoaded) {
                   // Only use protection system if no template-specific data was loaded
                   fontStylesData = window._fontStylesProtection.retrieve();
                   if (fontStylesData) {
                       console.log('🎯 Found font styles in protected storage (no template data)');
                   }
               }

               if (fontStylesData && fontStylesData.length > 0) {
                   // Protect the data
                   window._fontStylesProtection.protect(fontStylesData);

                   const adminFontStylesField = document.getElementById('adminFontStyles');
                   if (adminFontStylesField && (!adminFontStylesField.value || adminFontStylesField.value.trim() === '')) {
                       console.log('🎯 🔄 FINAL CHECK: adminFontStyles field is empty but we have font styles data');
                       if (window.updateAdminFontStylesDisplay) {
                           window.updateAdminFontStylesDisplay();
                           console.log('🎯 ✅ FINAL CHECK: Called updateAdminFontStylesDisplay');
                       } else {
                           // Direct population as fallback
                           const jsonValue = JSON.stringify(fontStylesData, null, 2);
                           adminFontStylesField.value = jsonValue;
                           console.log('🎯 ✅ FINAL CHECK: Directly populated adminFontStyles field');
                       }
                   }
               } else {
                   console.log('🎯 ❌ FINAL CHECK: No font styles data found anywhere');
               }

               // Similar check for decor styles
               console.log('🎯 🔄 FINAL CHECK: Looking for decor styles data...');

               let decorStylesData = null;

               if (window.decorStylesList && window.decorStylesList.length > 0) {
                   decorStylesData = window.decorStylesList;
                   console.log('🎯 Found decor styles in window.decorStylesList');
               } else if (window._decorStylesProtection && !window._templateSpecificDecorStylesLoaded) {
                   // Only use protection system if no template-specific data was loaded
                   decorStylesData = window._decorStylesProtection.retrieve();
                   if (decorStylesData) {
                       console.log('🎯 Found decor styles in protected storage (no template data)');
                   }
               }

               if (decorStylesData && decorStylesData.length > 0) {
                   // Protect the data
                   window._decorStylesProtection.protect(decorStylesData);

                   const adminDecorStylesField = document.getElementById('adminDecorStyles');
                   if (adminDecorStylesField && (!adminDecorStylesField.value || adminDecorStylesField.value.trim() === '')) {
                       console.log('🎯 🔄 FINAL CHECK: adminDecorStyles field is empty but we have decor styles data');
                       if (window.updateAdminDecorStylesDisplay) {
                           window.updateAdminDecorStylesDisplay();
                           console.log('🎯 ✅ FINAL CHECK: Called updateAdminDecorStylesDisplay');
                       } else {
                           // Direct population as fallback
                           const jsonValue = JSON.stringify(decorStylesData, null, 2);
                           adminDecorStylesField.value = jsonValue;
                           console.log('🎯 ✅ FINAL CHECK: Directly populated adminDecorStyles field');
                       }
                   }
               } else {
                   console.log('🎯 ❌ FINAL CHECK: No decor styles data found anywhere');
               }
           }, 3000); // Wait 3 seconds for all scripts to load

           // Text color picker is now a simple color input - no initialization needed
           console.log('🎨 Using simple color picker for text color');

           // Initialize stroke controls
           setTimeout(() => {
               try {
                   initializeStrokeControls();
               } catch (error) {
                   console.error('🎨 Error during stroke controls initialization:', error);
               }
           }, 600);

           // Validate all required elements exist
           setTimeout(() => {
               validateRequiredElements();
           }, 1000);
       });

       // Text color picker initialization removed - using simple color input

       // Initialize stroke controls
       function initializeStrokeControls() {
           try {
               const strokeToggle = document.getElementById('strokeToggle');
               const strokeParams = document.querySelector('.parameter-control.stroke-param');
               const strokeWidth = document.getElementById('strokeWidth');
               const strokeWidthValue = document.getElementById('vStrokeWidth');
               const strokeColor = document.getElementById('strokeColor');
               const strokeOpacity = document.getElementById('strokeOpacity');
               const strokeOpacityValue = document.getElementById('vStrokeOpacity');

               console.log('🎨 Initializing stroke controls...');

               // Stroke toggle functionality
               if (strokeToggle && strokeParams) {
                   strokeToggle.addEventListener('change', function() {
                       if (this.value === 'stroke') {
                           strokeParams.classList.remove('hidden');
                           console.log('🎨 Stroke controls enabled');
                       } else {
                           strokeParams.classList.add('hidden');
                           console.log('🎨 Stroke controls disabled');
                       }
                   });
               }

               // Stroke width slider
               if (strokeWidth && strokeWidthValue) {
                   strokeWidth.addEventListener('input', function() {
                       const value = this.value;
                       strokeWidthValue.textContent = value + 'px';
                       console.log('🎨 Stroke width changed:', value);
                   });
               }

               // Stroke opacity slider
               if (strokeOpacity && strokeOpacityValue) {
                   strokeOpacity.addEventListener('input', function() {
                       const value = this.value;
                       strokeOpacityValue.textContent = value + '%';
                       console.log('🎨 Stroke opacity changed:', value);
                   });
               }

               // Stroke color picker
               if (strokeColor) {
                   strokeColor.addEventListener('input', function() {
                       console.log('🎨 Stroke color changed:', this.value);
                   });
               }

               console.log('🎨 Stroke controls initialized successfully');
           } catch (error) {
               console.error('🎨 Error initializing stroke controls:', error);
           }
       }

       // Validate that all required elements exist
       function validateRequiredElements() {
           const requiredElements = [
               'iText',
               'iFontFamily',
               'iFontFilter',
               'iBold',
               'iItalic',
               'iAllCaps',
               'iFontSize',
               'vFontSize',
               'iLetterSpacing',
               'vLetterSpacing',
               'iOpacity',
               'vOpacity',
               'iTextRotation',
               'vTextRotation',
               'iTextBoxWidth',
               'textBoxWidthValue',
               'iLineHeight',
               'lineHeightValue',
               'iTextColorIntensity',
               'textTemplateId',
               'strokeToggle',
               'strokeWidth',
               'vStrokeWidth',
               'strokeColor',
               'strokeOpacity',
               'vStrokeOpacity',
               'textColorPickerContainer'
           ];

           const missingElements = [];

           requiredElements.forEach(id => {
               const element = document.getElementById(id);
               if (!element) {
                   missingElements.push(id);
               }
           });

           if (missingElements.length > 0) {
               console.warn('🚨 Missing required elements:', missingElements);
           } else {
               console.log('✅ All required elements found');
           }

           // Check for duplicate IDs
           const allElements = document.querySelectorAll('[id]');
           const idCounts = {};

           allElements.forEach(element => {
               const id = element.id;
               if (id) {
                   idCounts[id] = (idCounts[id] || 0) + 1;
               }
           });

           const duplicateIds = Object.keys(idCounts).filter(id => idCounts[id] > 1);
           if (duplicateIds.length > 0) {
               console.warn('🚨 Duplicate IDs found:', duplicateIds);
           } else {
               console.log('✅ No duplicate IDs found');
           }
       }

       // Function to load template data from sessionStorage and populate admin fields
       function loadTemplateFromSessionStorage() {
           try {
               // Check if a template was already loaded via URL parameter
               if (window._templateAlreadyLoaded) {
                   console.log('🎯 📋 TEMPLATE LOADING - Template already loaded via URL, skipping sessionStorage load');
                   return;
               }

               // Initialize template-specific flags at the start of each load
               window._templateSpecificFontStylesLoaded = false;
               window._templateSpecificDecorStylesLoaded = false;
               console.log('🎯 📋 TEMPLATE LOADING - Reset template-specific flags');

               const modifiedTemplateData = sessionStorage.getItem('modifiedTemplate');
               if (modifiedTemplateData) {
                   const template = JSON.parse(modifiedTemplateData);

                   // Reset template-specific flags for new template load
                   window._templateSpecificFontStylesLoaded = false;
                   window._templateSpecificDecorStylesLoaded = false;
                   console.log('🎯 📋 TEMPLATE LOADING - Template found, reset flags to false');

                   // Debug: Log the raw sessionStorage data
                   console.log('🎯 Raw sessionStorage modifiedTemplate:', modifiedTemplateData.substring(0, 500) + '...');
                   console.log('🎯 Parsed template keys:', Object.keys(template));
                   console.log('🎯 Template adminData keys:', template.adminData ? Object.keys(template.adminData) : 'no adminData');
                   console.log('🎯 📥 LOADING template data from sessionStorage:', {
                       templateId: template._id,
                       templateName: template.name,
                       'template keys': Object.keys(template),
                       'adminData exists': !!template.adminData,
                       'adminData keys': template.adminData ? Object.keys(template.adminData) : 'no adminData',
                       'adminData.object': template.adminData?.object,
                       'adminData.palette': template.adminData?.palette,
                       'top-level fontStylesList exists': !!template.fontStylesList,
                       'adminData.fontStylesList exists': !!template.adminData?.fontStylesList,
                       'top-level fontStylesList': template.fontStylesList,
                       'adminData.fontStylesList': template.adminData?.fontStylesList,
                       'top-level fontStylesList length': template.fontStylesList?.length || 0,
                       'adminData.fontStylesList length': template.adminData?.fontStylesList?.length || 0,
                       'originalPalette': template.originalPalette
                   });

                   // Populate admin fields with the template's ORIGINAL data (CORRECTED field IDs)
                   const editOriginalObjectField = document.getElementById('editOriginalObject');
                   const editOriginalPaletteField = document.getElementById('editOriginalPalette');

                   if (editOriginalObjectField && template.originalObject) {
                       editOriginalObjectField.value = template.originalObject;
                       console.log('🎯 Set Original Object field from template.originalObject:', template.originalObject);
                   }

                   if (editOriginalPaletteField && template.originalPalette) {
                       editOriginalPaletteField.value = template.originalPalette;
                       console.log('🎯 Set Original Palette field from template.originalPalette:', template.originalPalette);
                   }

                   // Load font styles list if available (check both top-level and adminData) - CRITICAL: Check for content, not just existence
                   console.log('🎯 🔍 FONT STYLES LOADING - Checking for font styles...');
                   console.log('🎯 🔍 template.fontStylesList:', template.fontStylesList);
                   console.log('🎯 🔍 template.adminData?.fontStylesList:', template.adminData?.fontStylesList);

                   // Use the one that has content, not just exists (following documentation pattern)
                   const fontStylesList = (template.fontStylesList && template.fontStylesList.length > 0)
                       ? template.fontStylesList
                       : template.adminData?.fontStylesList;
                   console.log('🎯 🔍 Combined fontStylesList:', fontStylesList);
                   console.log('🎯 🔍 fontStylesList is array:', Array.isArray(fontStylesList));
                   console.log('🎯 🔍 fontStylesList length:', fontStylesList?.length);

                   if (fontStylesList && Array.isArray(fontStylesList) && fontStylesList.length > 0) {
                       console.log('🎯 ✅ FONT STYLES FOUND - Loading into window.fontStylesList...', fontStylesList.length, 'styles');
                       window.fontStylesList = fontStylesList;
                       window._templateSpecificFontStylesLoaded = true; // Flag to prevent protection system override
                       console.log('🎯 ✅ window.fontStylesList assigned:', window.fontStylesList);
                       console.log('🎯 ✅ Set _templateSpecificFontStylesLoaded = true');

                       // ULTRA PROTECTION: Store in multiple hidden locations
                       window._fontStylesListBackup = JSON.parse(JSON.stringify(fontStylesList));
                       window.__fontStylesData__ = JSON.parse(JSON.stringify(fontStylesList));

                       // Store in sessionStorage as additional backup
                       sessionStorage.setItem('_fontStylesBackup', JSON.stringify(fontStylesList));

                       // NEW: Use the protection system
                       if (window._fontStylesProtection) {
                           window._fontStylesProtection.protect(fontStylesList);
                           console.log('🎯 🛡️ Font styles data protected using new protection system');
                       }

                       // Store in a hidden DOM element as final backup
                       let hiddenStorage = document.getElementById('_fontStylesStorage');
                       if (!hiddenStorage) {
                           hiddenStorage = document.createElement('div');
                           hiddenStorage.id = '_fontStylesStorage';
                           hiddenStorage.style.display = 'none';
                           hiddenStorage.setAttribute('data-fontstyles', JSON.stringify(fontStylesList));
                           document.body.appendChild(hiddenStorage);
                       }

                       console.log('🎯 🛡️ Created MULTIPLE backup copies of fontStylesList');
                       console.log('🎯 🛡️ Backups stored in: window._fontStylesListBackup, window.__fontStylesData__, sessionStorage, DOM element');

                       // PROTECTION: Make window.fontStylesList non-configurable to prevent overwrites
                       try {
                           Object.defineProperty(window, 'fontStylesList', {
                               value: fontStylesList,
                               writable: true,
                               enumerable: true,
                               configurable: false
                           });
                           console.log('🎯 🛡️ Protected window.fontStylesList from being overwritten');
                       } catch (e) {
                           console.log('🎯 ⚠️ Could not protect window.fontStylesList:', e.message);
                       }

                       // Add a persistent field updater
                       let checkCount = 0;
                       const fieldUpdater = setInterval(() => {
                           checkCount++;
                           const adminFontStylesField = document.getElementById('adminFontStyles');

                           if (!window.fontStylesList || window.fontStylesList.length === 0) {
                               console.log(`🎯 ❌ ALERT: window.fontStylesList was CLEARED at check ${checkCount}!`);
                               console.log('🎯 ❌ Current value:', window.fontStylesList);
                               clearInterval(fieldUpdater);
                           } else if (adminFontStylesField && (!adminFontStylesField.value || adminFontStylesField.value.trim() === '')) {
                               // Field is empty but we have data - populate it
                               let dataToUse = window.fontStylesList;
                               if (!dataToUse || dataToUse.length === 0) {
                                   // Try backup if main is cleared
                                   if (window._fontStylesListBackup && window._fontStylesListBackup.length > 0) {
                                       dataToUse = window._fontStylesListBackup;
                                       window.fontStylesList = window._fontStylesListBackup; // Restore
                                       console.log(`🎯 🔄 PERSISTENT UPDATE ${checkCount}: Restored from backup`);
                                   }
                               }
                               if (dataToUse && dataToUse.length > 0) {
                                   const jsonValue = JSON.stringify(dataToUse, null, 2);
                                   adminFontStylesField.value = jsonValue;
                                   console.log(`🎯 🔄 PERSISTENT UPDATE ${checkCount}: Populated empty field with font styles`);
                               }
                           } else if (adminFontStylesField && adminFontStylesField.value.trim() !== '') {
                               console.log(`🎯 ✅ Field successfully populated at check ${checkCount}`);
                               clearInterval(fieldUpdater);
                           } else if (checkCount >= 20) {
                               console.log(`🎯 ⏰ Stopped checking after ${checkCount} attempts`);
                               clearInterval(fieldUpdater);
                           }
                       }, 500); // Check every 500ms
                       console.log('🎯 ✅ Loaded font styles list:', {
                           'source': template.fontStylesList ? 'top-level' : 'adminData',
                           'styles count': window.fontStylesList.length,
                           'first style preview': window.fontStylesList[0] ? `${window.fontStylesList[0].length} text configs` : 'none',
                           'full data': window.fontStylesList
                       });

                       console.log('🎯 ✅ Calling updateFontStylesStatus...');
                       if (window.updateFontStylesStatus) {
                           window.updateFontStylesStatus();
                           console.log('🎯 ✅ updateFontStylesStatus called');
                       } else {
                           console.log('🎯 ❌ updateFontStylesStatus not available');
                       }

                       console.log('🎯 ✅ Calling updateAdminFontStylesDisplay...');

                       // AGGRESSIVE APPROACH: Try multiple methods to populate the field
                       const populateField = () => {
                           const adminFontStylesField = document.getElementById('adminFontStyles');
                           if (adminFontStylesField && window.fontStylesList && window.fontStylesList.length > 0) {
                               const jsonValue = JSON.stringify(window.fontStylesList, null, 2);
                               adminFontStylesField.value = jsonValue;
                               console.log('🎯 🔧 DIRECT POPULATION - Set adminFontStyles field:', jsonValue);
                               return true;
                           }
                           return false;
                       };

                       // Try immediately
                       if (!populateField()) {
                           console.log('🎯 🔧 Immediate population failed, trying with delays...');

                           // Try after 100ms
                           setTimeout(() => {
                               if (!populateField()) {
                                   // Try after 500ms
                                   setTimeout(() => {
                                       if (!populateField()) {
                                           // Try after 1000ms
                                           setTimeout(() => {
                                               if (!populateField()) {
                                                   console.log('🎯 ❌ All attempts to populate field failed');
                                               }
                                           }, 1000);
                                       }
                                   }, 500);
                               }
                           }, 100);
                       }

                       // Also try the original function approach
                       if (window.updateAdminFontStylesDisplay) {
                           window.updateAdminFontStylesDisplay();
                           console.log('🎯 ✅ updateAdminFontStylesDisplay called');
                       } else {
                           console.log('🎯 ❌ updateAdminFontStylesDisplay not available - will call after script loads');
                           // Try multiple times with increasing delays to ensure the function is available
                           const tryUpdateDisplay = (attempt = 1) => {
                               setTimeout(() => {
                                   if (window.updateAdminFontStylesDisplay) {
                                       window.updateAdminFontStylesDisplay();
                                       console.log(`🎯 ✅ updateAdminFontStylesDisplay called after delay (attempt ${attempt})`);
                                   } else if (attempt < 5) {
                                       console.log(`🎯 🔄 updateAdminFontStylesDisplay still not available, trying again (attempt ${attempt + 1})`);
                                       tryUpdateDisplay(attempt + 1);
                                   } else {
                                       console.log('🎯 ❌ updateAdminFontStylesDisplay never became available after 5 attempts');
                                   }
                               }, attempt * 500); // 500ms, 1000ms, 1500ms, 2000ms, 2500ms
                           };
                           tryUpdateDisplay();
                       }
                   } else {
                       console.log('🎯 ❌ NO FONT STYLES FOUND in template:', {
                           'top-level fontStylesList exists': !!template.fontStylesList,
                           'adminData.fontStylesList exists': !!template.adminData?.fontStylesList,
                           'top-level fontStylesList type': typeof template.fontStylesList,
                           'adminData.fontStylesList type': typeof template.adminData?.fontStylesList,
                           'top-level fontStylesList value': template.fontStylesList,
                           'adminData.fontStylesList value': template.adminData?.fontStylesList,
                           'fontStylesList variable': fontStylesList,
                           'is array check': Array.isArray(fontStylesList)
                       });
                       window.fontStylesList = [];
                       // Still set the flag to indicate we checked for template-specific data
                       window._templateSpecificFontStylesLoaded = true;
                       console.log('🎯 ❌ Set _templateSpecificFontStylesLoaded = true (no data found)');
                   }

                   // Load decor styles list if available (check both top-level and adminData)
                   console.log('🎯 🔍 DECOR STYLES LOADING - Checking for decor styles...');
                   console.log('🎯 🔍 template.decorStylesList:', template.decorStylesList);
                   console.log('🎯 🔍 template.adminData?.decorStylesList:', template.adminData?.decorStylesList);

                   // Use the one that has content, not just exists (following documentation pattern)
                   const decorStylesList = (template.decorStylesList && template.decorStylesList.length > 0)
                       ? template.decorStylesList
                       : template.adminData?.decorStylesList;
                   console.log('🎯 🔍 Combined decorStylesList:', decorStylesList);
                   console.log('🎯 🔍 decorStylesList is array:', Array.isArray(decorStylesList));
                   console.log('🎯 🔍 decorStylesList length:', decorStylesList?.length);

                   if (decorStylesList && Array.isArray(decorStylesList) && decorStylesList.length > 0) {
                       console.log('🎯 ✅ DECOR STYLES FOUND - Loading into window.decorStylesList...', decorStylesList.length, 'styles');
                       window.decorStylesList = decorStylesList;
                       window._templateSpecificDecorStylesLoaded = true; // Flag to prevent protection system override
                       console.log('🎯 ✅ window.decorStylesList assigned:', window.decorStylesList);

                       // Protect the decor styles data
                       if (window._decorStylesProtection) {
                           window._decorStylesProtection.protect(decorStylesList);
                           console.log('🎯 🛡️ Decor styles protected');
                       }

                       // Update admin field if available
                       if (window.updateAdminDecorStylesDisplay) {
                           window.updateAdminDecorStylesDisplay();
                           console.log('🎯 ✅ Called updateAdminDecorStylesDisplay');
                       }
                   } else {
                       console.log('🎯 ❌ NO DECOR STYLES FOUND in template:', {
                           'top-level decorStylesList exists': !!template.decorStylesList,
                           'adminData.decorStylesList exists': !!template.adminData?.decorStylesList,
                           'top-level decorStylesList type': typeof template.decorStylesList,
                           'adminData.decorStylesList type': typeof template.adminData?.decorStylesList,
                           'top-level decorStylesList value': template.decorStylesList,
                           'adminData.decorStylesList value': template.adminData?.decorStylesList,
                           'decorStylesList variable': decorStylesList,
                           'is array check': Array.isArray(decorStylesList)
                       });
                       window.decorStylesList = [];
                       // Still set the flag to indicate we checked for template-specific data
                       window._templateSpecificDecorStylesLoaded = true;
                       console.log('🎯 ❌ Set _templateSpecificDecorStylesLoaded = true (no data found)');
                   }

                   // Restore CSS filter state if available
                   if (template.cssFilterState) {
                       console.log('[SessionStorage] 🎨 Found CSS filter state in template:', template.cssFilterState);
                       // Call the CSS filter restoration function from design-editor.js
                       if (typeof window.restoreCSSFilterState === 'function') {
                           window.restoreCSSFilterState(template.cssFilterState);
                       } else {
                           console.log('[SessionStorage] 🎨 restoreCSSFilterState function not available yet, will retry...');
                           // Retry after a short delay to ensure design-editor.js is loaded
                           setTimeout(() => {
                               if (typeof window.restoreCSSFilterState === 'function') {
                                   window.restoreCSSFilterState(template.cssFilterState);
                               } else {
                                   console.log('[SessionStorage] 🎨 restoreCSSFilterState function still not available');
                               }
                           }, 1000);
                       }
                   } else {
                       console.log('[SessionStorage] 🎨 No CSS filter state found in template, using defaults');
                   }

                   // Restore duotone effect state if available
                   if (template.duotoneState) {
                       console.log('[SessionStorage] 🎨 Found duotone state in template:', template.duotoneState);
                       // Call the duotone restoration function from design-editor.js
                       if (typeof window.restoreDuotoneState === 'function') {
                           window.restoreDuotoneState(template.duotoneState);
                       } else {
                           console.log('[SessionStorage] 🎨 restoreDuotoneState function not available yet, will retry...');
                           // Retry after a short delay to ensure design-editor.js is loaded
                           setTimeout(() => {
                               if (typeof window.restoreDuotoneState === 'function') {
                                   window.restoreDuotoneState(template.duotoneState);
                               } else {
                                   console.log('[SessionStorage] 🎨 restoreDuotoneState function still not available');
                               }
                           }, 1000);
                       }
                   } else {
                       console.log('[SessionStorage] 🎨 No duotone state found in template, using defaults');
                   }

                   // Restore glitch effect state if available
                   if (template.glitchState) {
                       console.log('[SessionStorage] 🎨 Found glitch state in template:', template.glitchState);
                       // Call the glitch restoration function from design-editor.js
                       if (typeof window.restoreGlitchState === 'function') {
                           window.restoreGlitchState(template.glitchState);
                       } else {
                           console.log('[SessionStorage] 🎨 restoreGlitchState function not available yet, will retry...');
                           // Retry after a short delay to ensure design-editor.js is loaded
                           setTimeout(() => {
                               if (typeof window.restoreGlitchState === 'function') {
                                   window.restoreGlitchState(template.glitchState);
                               } else {
                                   console.log('[SessionStorage] 🎨 restoreGlitchState function still not available');
                               }
                           }, 1000);
                       }
                   } else {
                       console.log('[SessionStorage] 🎨 No glitch state found in template, using defaults');
                   }

                   // Restore halftone effect state if available
                   if (template.halftoneState) {
                       console.log('[SessionStorage] 🎨 Found halftone state in template:', template.halftoneState);
                       // Call the halftone restoration function from design-editor.js
                       if (typeof window.restoreHalftoneState === 'function') {
                           window.restoreHalftoneState(template.halftoneState);
                       } else {
                           console.log('[SessionStorage] 🎨 restoreHalftoneState function not available yet, will retry...');
                           // Retry after a short delay to ensure design-editor.js is loaded
                           setTimeout(() => {
                               if (typeof window.restoreHalftoneState === 'function') {
                                   window.restoreHalftoneState(template.halftoneState);
                               } else {
                                   console.log('[SessionStorage] 🎨 restoreHalftoneState function still not available');
                               }
                           }, 1000);
                       }
                   } else {
                       console.log('[SessionStorage] 🎨 No halftone state found in template, using defaults');
                   }

                   // Also populate other admin fields if available
                   const adminPromptField = document.getElementById('adminPrompt');
                   if (adminPromptField && template.adminData?.prompt) {
                       adminPromptField.value = template.adminData.prompt;
                   }
               } else {
                   console.log('🎯 No template data found in sessionStorage');
                   // Set flags to true when no template is loaded to prevent protection system from overriding
                   window._templateSpecificFontStylesLoaded = true;
                   window._templateSpecificDecorStylesLoaded = true;
                   console.log('🎯 📋 NO TEMPLATE - Set flags to true to prevent protection override');
               }

               // 🔧 PERFORMANCE FIX: Mark system as fully loaded after template processing
               setTimeout(() => {
                   if (window.markAsFullyLoaded) {
                       window.markAsFullyLoaded();
                   }
               }, 1000); // Small delay to ensure all template processing is complete

           } catch (error) {
               console.error('🎯 Error loading template from sessionStorage:', error);
           }
       }









       // Store previous object enhancement answers to avoid repetition
       window.previousAIObjectAnswers = window.previousAIObjectAnswers || {};

       // Enhance AI Object Function
       async function enhanceAIObject(event) {
           // Prevent the click from bubbling up and closing the sidebar
           if (event) {
               event.stopPropagation();
               event.preventDefault();
           }

           console.log('🎯 Enhance AI object called');

           // Get the object input and tone selection
           const objectInput = document.getElementById('aiObjectInput')?.value?.trim();
           const toneSelect = document.getElementById('aiToneSelect');
           const selectedTone = toneSelect?.value || 'Generic';

           if (!objectInput) {
               // Use the same toast system as the design editor
               if (window.showToast) {
                   window.showToast('Please enter an object/subject first', 'error');
               } else {
                   alert('Please enter an object/subject first');
               }
               return;
           }

           // Get the enhance button and update its state
           const enhanceBtn = document.querySelector('.ai-enhance-object-btn');
           if (enhanceBtn) {
               enhanceBtn.disabled = true;
               enhanceBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
           }

           try {
               // Store the original user input for regeneration
               if (!enhanceBtn.dataset.originalInput) {
                   enhanceBtn.dataset.originalInput = objectInput;
               }
               const originalInput = enhanceBtn.dataset.originalInput;

               // Get previous answers for this original input + tone combination
               const cacheKey = `${originalInput.toLowerCase().trim()}_${selectedTone.toLowerCase()}`;
               const previousAnswers = window.previousAIObjectAnswers[cacheKey] || [];

               // Build the prompt using the same template as other pages
               let prompt = `Give a simple, expressive idea for a t-shirt image: ${originalInput} with a ${selectedTone} tone. Just describe the subject, no text. Max 20 characters but can be less, or a lot less.`;

               // Add exclusions if we have previous answers
               if (previousAnswers.length > 0) {
                   prompt += '\n\nIMPORTANT: Do NOT use any of these previous suggestions:\n';
                   previousAnswers.forEach((answer, index) => {
                       prompt += `- "${answer}"\n`;
                   });
                   prompt += '\nCreate a completely different and original description.';
               }

               console.log('🤖 Sending AI object enhancement prompt:', prompt);

               // Call the text generation API (reusing the same endpoint)
               const response = await fetch('/api/generate-texts', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   credentials: 'include',
                   body: JSON.stringify({
                       prompt: prompt,
                       objectInput: originalInput,
                       textCount: 1 // We only want one enhanced description
                   })
               });

               if (!response.ok) {
                   const errorData = await response.json();
                   throw new Error(errorData.error || 'Failed to enhance object description');
               }

               const result = await response.json();
               console.log('🤖 AI object enhancement result:', result);

               // Parse the generated description and update the input
               if (result.texts && Array.isArray(result.texts) && result.texts[0]) {
                   const enhancedDescription = result.texts[0].trim();
                   console.log('🎯 Enhanced description:', enhancedDescription);

                   // Update the input field
                   const objectInputField = document.getElementById('aiObjectInput');
                   if (objectInputField) {
                       objectInputField.value = enhancedDescription;
                       // Trigger input event to update any listeners
                       objectInputField.dispatchEvent(new Event('input', { bubbles: true }));
                   }

                   if (window.showToast) {
                       window.showToast('Object description enhanced successfully!', 'success');
                   }

                   // Save the generated description to prevent repetition
                   if (!window.previousAIObjectAnswers[cacheKey]) {
                       window.previousAIObjectAnswers[cacheKey] = [];
                   }
                   window.previousAIObjectAnswers[cacheKey].push(enhancedDescription);

                   // Keep only the last 5 attempts to avoid overly long prompts
                   if (window.previousAIObjectAnswers[cacheKey].length > 5) {
                       window.previousAIObjectAnswers[cacheKey] = window.previousAIObjectAnswers[cacheKey].slice(-5);
                   }

                   console.log('💾 Saved AI object answers for', cacheKey, ':', window.previousAIObjectAnswers[cacheKey]);

                   // Change button to regenerate mode
                   if (enhanceBtn) {
                       enhanceBtn.classList.add('regenerate-mode');
                       enhanceBtn.title = 'Generate different variation';
                   }

               } else {
                   throw new Error('Invalid response format from object enhancement');
               }

           } catch (error) {
               console.error('Error enhancing AI object:', error);
               if (window.showToast) {
                   window.showToast('Failed to enhance object: ' + error.message, 'error');
               } else {
                   alert('Failed to enhance object: ' + error.message);
               }
           } finally {
               // Re-enable the button
               if (enhanceBtn) {
                   enhanceBtn.disabled = false;
                   enhanceBtn.innerHTML = '<i class="fas fa-redo"></i>';
               }
           }
       }

       // Make the function globally available
       window.enhanceAIObject = enhanceAIObject;

       // Store previous text enhancement answers to avoid repetition
       window.previousTextAnswers = window.previousTextAnswers || {};

       // Enhance Selected Text Function
       async function enhanceSelectedText() {
           console.log('🎯 Enhance selected text called');

           // Validate that a text element is selected
           const textInput = document.getElementById('iText');
           if (!textInput || textInput.disabled || !textInput.value.trim()) {
               if (window.showToast) {
                   window.showToast('Please select a text element first', 'error');
               } else {
                   alert('Please select a text element first');
               }
               return;
           }

           // Check if "Replace All Texts" is enabled
           const replaceAllCheckbox = document.getElementById('replaceAllTextsCheckbox');
           const replaceAllTexts = replaceAllCheckbox?.checked || false;

           // Get the current text and tone selection
           const currentText = textInput.value.trim();
           const toneSelect = document.getElementById('textToneSelect');
           const selectedTone = toneSelect?.value || 'Generic';

           // Get object context from Admin tab
           const adminOriginalObjectField = document.getElementById('adminOriginalObject');
           const objectContext = adminOriginalObjectField?.value?.trim() || 'general design';

           // Get the enhance button and update its state
           const enhanceBtn = document.getElementById('enhanceTextBtn');
           if (enhanceBtn) {
               enhanceBtn.disabled = true;
               // Keep icon-only format for square button
               enhanceBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
               if (replaceAllTexts) {
                   enhanceBtn.title = 'Replacing all texts...';
               } else {
                   enhanceBtn.title = 'Generating enhanced text...';
               }
           }

           try {
               if (replaceAllTexts) {
                   // Replace All Texts Mode
                   await replaceAllCanvasTexts(selectedTone, objectContext);
               } else {
                   // Single Text Mode (existing functionality)
                   await replaceSingleText(currentText, selectedTone, objectContext, enhanceBtn);
               }

           } catch (error) {
               console.error('Error enhancing text:', error);
               if (window.showToast) {
                   window.showToast('Failed to enhance text: ' + error.message, 'error');
               } else {
                   alert('Failed to enhance text: ' + error.message);
               }
           } finally {
               // Re-enable the button
               if (enhanceBtn) {
                   enhanceBtn.disabled = false;
                   // Keep icon-only format for square button
                   enhanceBtn.innerHTML = '<i class="fas fa-magic"></i>';
                   enhanceBtn.title = 'Enhance selected text with AI';
               }
           }
       }

       // Function to replace a single text element
       async function replaceSingleText(currentText, selectedTone, objectContext, enhanceBtn) {
           // Measure current text length for target matching
           const targetLength = currentText.length;
           console.log('🎯 Current text:', currentText, 'Length:', targetLength);

           // Store the original text for regeneration
           if (!enhanceBtn.dataset.originalText) {
               enhanceBtn.dataset.originalText = currentText;
           }
           const originalText = enhanceBtn.dataset.originalText;

           // Get previous answers for this original text + tone combination
           const cacheKey = `${originalText.toLowerCase().trim()}_${selectedTone.toLowerCase()}_${objectContext.toLowerCase()}`;
           const previousAnswers = window.previousTextAnswers[cacheKey] || [];

           // Build the prompt using the same template as inspiration.html
           let prompt = `Generate a ${selectedTone.toLowerCase()} text for a t-shirt design about: ${objectContext}.

The text should be:
- ${selectedTone} in tone
- Related to: ${objectContext}
- Approximately ${targetLength} characters long (target: ${targetLength-2} to ${targetLength+2} characters)
- Suitable for t-shirt design
- Creative and engaging

Current text to replace: "${originalText}"

Generate only the text content, no quotes or explanations.`;

           // Add exclusions if we have previous answers
           if (previousAnswers.length > 0) {
               prompt += '\n\nIMPORTANT: Do NOT use any of these previous suggestions:\n';
               previousAnswers.forEach((answer, index) => {
                   prompt += `- "${answer}"\n`;
               });
               prompt += '\nCreate a completely different and original text.';
           }

           console.log('🤖 Sending text enhancement prompt:', prompt);

           // Call the text generation API
           const response = await fetch('/api/generate-texts', {
               method: 'POST',
               headers: {
                   'Content-Type': 'application/json'
               },
               credentials: 'include',
               body: JSON.stringify({
                   prompt: prompt,
                   objectInput: objectContext,
                   textCount: 1,
                   targetLength: targetLength
               })
           });

           if (!response.ok) {
               const errorData = await response.json();
               throw new Error(errorData.error || 'Failed to enhance text');
           }

           const result = await response.json();
           console.log('🤖 Text enhancement result:', result);

           // Parse the generated text and update the input
           if (result.texts && Array.isArray(result.texts) && result.texts[0]) {
               let enhancedText = result.texts[0].trim();

               // Check if All Caps should be applied to this text
               const allCapsCheckbox = document.getElementById('iAllCaps');
               const shouldApplyAllCaps = allCapsCheckbox && allCapsCheckbox.checked;

               // Apply All Caps transformation if enabled
               if (shouldApplyAllCaps) {
                   enhancedText = enhancedText.toUpperCase();
                   console.log(`🎯 Applied All Caps to enhanced text: "${enhancedText}"`);
               }

               console.log('🎯 Enhanced text:', enhancedText, 'Length:', enhancedText.length);

               // Update the text input field
               const textInput = document.getElementById('iText');
               textInput.value = enhancedText;

               // Trigger change event to update the canvas text
               textInput.dispatchEvent(new Event('input', { bubbles: true }));
               textInput.dispatchEvent(new Event('change', { bubbles: true }));

               if (window.showToast) {
                   window.showToast(`Text enhanced successfully! (${enhancedText.length} chars)`, 'success');
               }

               // Save the generated text to prevent repetition
               if (!window.previousTextAnswers[cacheKey]) {
                   window.previousTextAnswers[cacheKey] = [];
               }
               window.previousTextAnswers[cacheKey].push(enhancedText);

               // Keep only the last 5 attempts to avoid overly long prompts
               if (window.previousTextAnswers[cacheKey].length > 5) {
                   window.previousTextAnswers[cacheKey] = window.previousTextAnswers[cacheKey].slice(-5);
               }

               console.log('💾 Saved text answers for', cacheKey, ':', window.previousTextAnswers[cacheKey]);

               // Change button to regenerate mode
               if (enhanceBtn) {
                   enhanceBtn.classList.add('regenerate-mode');
                   enhanceBtn.title = 'Generate different variation';
               }

           } else {
               throw new Error('Invalid response format from text enhancement');
           }
       }

       // Function to replace all text elements on the canvas
       async function replaceAllCanvasTexts(selectedTone, objectContext) {
           console.log('🎯 Replace all canvas texts called');

           // Detect which workflow is calling this function
           const isRestyleMode = window.isRestyleMode === true;
           const isReplaceMode = window.isReplaceMode === true;
           const workflowType = isRestyleMode ? 'Restyle' : (isReplaceMode ? 'Replace' : 'Unknown');

           console.log(`🎯 Workflow detected: ${workflowType} mode`);
           console.log(`🎯 Object context: "${objectContext}" (from ${isRestyleMode ? 'Admin tab' : isReplaceMode ? 'Sidebar input' : 'Unknown source'})`);

           // Access canvas objects from the design-editor system
           let allCanvasObjects = [];

           // Check for canvas objects in the design-editor system
           if (window.canvasObjects && Array.isArray(window.canvasObjects)) {
               allCanvasObjects = window.canvasObjects;
               console.log('🎯 Found canvas objects via window.canvasObjects:', allCanvasObjects.length);
           } else {
               console.error('🎯 Cannot access window.canvasObjects');
               throw new Error('Cannot access canvas text elements. Please ensure a text is selected first.');
           }

           // Filter for text objects only
           const allTexts = allCanvasObjects.filter(obj => obj.type === 'text');
           console.log('🎯 Found text objects:', allTexts.length);

           if (allTexts.length === 0) {
               if (window.showToast) {
                   window.showToast('No text elements found on canvas', 'warning');
               }
               return;
           }

           // Get the currently selected text to exclude it from replacement
           const textInput = document.getElementById('iText');
           const currentSelectedText = textInput?.value?.trim();

           // Get the currently selected object index to exclude it
           const selectedIndex = window.selectedObjectIndex || -1;

           // Include ALL texts (including selected one) for replacement
           const textsToReplace = allTexts.filter(textObj => {
               return textObj.text && textObj.text.trim();
           });

           console.log('🎯 Total texts found:', allTexts.length);
           console.log('🎯 Texts to replace (including selected):', textsToReplace.length);

           if (textsToReplace.length === 0) {
               if (window.showToast) {
                   window.showToast('No text elements found to replace', 'warning');
               }
               return;
           }

           try {
               // Build a single prompt for all texts
               let prompt = `Create ${textsToReplace.length} catchy texts in a ${selectedTone.toLowerCase()} tone for a T-shirt design about ${objectContext}.\n\n`;

               // Add each text with its requirements
               textsToReplace.forEach((textObj, index) => {
                   const originalText = textObj.text.trim();
                   const targetLength = originalText.length;
                   prompt += `${index + 1}. Text to replace: "${originalText}" (${targetLength} characters max, Title Case)\n`;
               });

               prompt += `\nRespond with only the ${textsToReplace.length} text contents, no quotes or explanations, one per line.`;

               console.log('🤖 Sending batch text enhancement prompt:', prompt);

               // Call the text generation API with single request
               const response = await fetch('/api/generate-texts', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   credentials: 'include',
                   body: JSON.stringify({
                       prompt: prompt,
                       objectInput: objectContext,
                       textCount: textsToReplace.length
                   })
               });

               if (!response.ok) {
                   const errorData = await response.json();
                   throw new Error(errorData.error || 'Failed to enhance texts');
               }

               const result = await response.json();
               console.log('🤖 Batch text enhancement result:', result);

               // Parse the generated texts and update all text objects
               if (result.texts && Array.isArray(result.texts) && result.texts.length >= textsToReplace.length) {
                   let successCount = 0;

                   textsToReplace.forEach((textObj, index) => {
                       if (result.texts[index]) {
                           const originalText = textObj.text.trim();
                           let enhancedText = result.texts[index].trim();

                           // Check if All Caps should be applied to this specific text object
                           console.log(`🎯 Checking All Caps for text "${originalText}": isAllCaps property = ${textObj.isAllCaps}`);

                           // If isAllCaps is not set, detect from current text content
                           if (textObj.isAllCaps === undefined) {
                               const isCurrentlyAllCaps = originalText === originalText.toUpperCase() && originalText !== originalText.toLowerCase();
                               textObj.isAllCaps = isCurrentlyAllCaps;
                               console.log(`🎯 Auto-detected All Caps state for "${originalText}": ${isCurrentlyAllCaps}`);
                           }

                           const shouldApplyAllCaps = textObj.isAllCaps === true;

                           // Apply All Caps transformation if enabled for this text
                           if (shouldApplyAllCaps) {
                               enhancedText = enhancedText.toUpperCase();
                               console.log(`🎯 Applied All Caps to enhanced text (stored state): "${enhancedText}"`);
                           } else {
                               console.log(`🎯 No All Caps applied to text "${originalText}" (isAllCaps: ${textObj.isAllCaps})`);
                           }

                           console.log(`🎯 Enhanced text ${index + 1}: "${originalText}" → "${enhancedText}" (${enhancedText.length} chars)`);

                           // Update the text object directly in the design-editor system
                           textObj.text = enhancedText;
                           successCount++;
                       }
                   });

                   // Update the selected text input if it was one of the replaced texts
                   if (currentSelectedText && selectedIndex >= 0) {
                       const selectedObject = window.canvasObjects[selectedIndex];
                       if (selectedObject && selectedObject.type === 'text') {
                           const textInput = document.getElementById('iText');
                           if (textInput) {
                               textInput.value = selectedObject.text;

                               // Update All Caps checkbox state based on the new text
                               const allCapsCheckbox = document.getElementById('iAllCaps');
                               if (allCapsCheckbox) {
                                   const newText = selectedObject.text;
                                   const isAllCaps = newText === newText.toUpperCase() && newText !== newText.toLowerCase();
                                   allCapsCheckbox.checked = isAllCaps;
                                   console.log(`🎯 Updated All Caps checkbox state: ${isAllCaps} for text: "${newText}"`);
                               }
                           }
                       }
                   }

                   console.log(`🎯 Batch replace completed: ${successCount} texts enhanced`);

                   if (window.showToast) {
                       window.showToast(`All ${successCount} texts enhanced successfully!`, 'success');
                   }
               } else {
                   throw new Error(`Expected ${textsToReplace.length} texts, got ${result.texts?.length || 0}`);
               }

           } catch (error) {
               console.error('Error in batch text enhancement:', error);
               if (window.showToast) {
                   window.showToast('Failed to enhance texts: ' + error.message, 'error');
               }
               throw error;
           }

           // Update All Caps control state for all text enhancement controls
           if (window.updateAllCapsControlState) {
               window.updateAllCapsControlState();
               console.log('🎯 Updated All Caps control state after text replacements');
           }

           // Trigger canvas redraw using the design-editor's update function
           if (window.update && typeof window.update === 'function') {
               window.update();
               console.log('🎯 Canvas updated after text replacements');
           } else {
               console.warn('🎯 Could not find update function to redraw canvas');
           }

           // Note: Success message is already shown in the try block above
           console.log('🎯 Replace all texts completed successfully');
       }

       // Setup All Caps Control
       function setupAllCapsControl() {
           const allCapsCheckbox = document.getElementById('iAllCaps');
           const textInput = document.getElementById('iText');

           if (!allCapsCheckbox || !textInput) return;

           allCapsCheckbox.addEventListener('change', function() {
               if (!textInput.value) return;

               const isChecked = allCapsCheckbox.checked;

               if (isChecked) {
                   // Convert to uppercase
                   textInput.value = textInput.value.toUpperCase();
               } else {
                   // Convert to title case (capitalize first letter of each word)
                   textInput.value = textInput.value.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
               }

               // Store All Caps state in the current text object
               const selectedIndex = window.selectedObjectIndex;
               if (selectedIndex >= 0 && window.canvasObjects && window.canvasObjects[selectedIndex]) {
                   const selectedObject = window.canvasObjects[selectedIndex];
                   if (selectedObject.type === 'text') {
                       selectedObject.isAllCaps = isChecked;
                       console.log(`🎯 Stored All Caps state (${isChecked}) for text object:`, selectedObject.text);
                   }
               }

               // Trigger change event to update the canvas text
               textInput.dispatchEvent(new Event('input', { bubbles: true }));
               textInput.dispatchEvent(new Event('change', { bubbles: true }));

               console.log('All Caps toggled:', isChecked, 'New text:', textInput.value);
           });

           // Debounce timer for All Caps state updates
           let allCapsDebounceTimer = null;
           const ALL_CAPS_DEBOUNCE_DELAY = 150; // 150ms delay for UI updates

           // Update checkbox state when text is selected
           function updateAllCapsState() {
               const currentText = textInput.value;
               console.log(`🎯 updateAllCapsState called with text: "${currentText}" (will be debounced)`);

               // Clear existing timer
               if (allCapsDebounceTimer) {
                   clearTimeout(allCapsDebounceTimer);
               }

               // Debounce the All Caps state update
               allCapsDebounceTimer = setTimeout(() => {
                   console.log(`🎯 DEBOUNCED: Processing All Caps state for text: "${currentText}"`);

                   if (currentText) {
                       // First check if the selected text object has a stored All Caps state
                       const selectedIndex = window.selectedObjectIndex;
                       let isAllCaps = false;

                       if (selectedIndex >= 0 && window.canvasObjects && window.canvasObjects[selectedIndex]) {
                           const selectedObject = window.canvasObjects[selectedIndex];

                           // Always detect from current text content (this is more reliable)
                           isAllCaps = currentText === currentText.toUpperCase() && currentText !== currentText.toLowerCase();

                           // Update the stored state to match the current text
                           if (selectedObject && selectedObject.type === 'text') {
                               const oldStoredState = selectedObject.isAllCaps;
                               selectedObject.isAllCaps = isAllCaps;

                               if (oldStoredState !== isAllCaps) {
                                   console.log(`🎯 Updated stored All Caps state from ${oldStoredState} to ${isAllCaps} for text:`, selectedObject.text);
                               } else {
                                   console.log(`🎯 All Caps state remains ${isAllCaps} for text:`, selectedObject.text);
                               }
                           }
                       } else {
                           // Fallback: detect from text content
                           isAllCaps = currentText === currentText.toUpperCase() && currentText !== currentText.toLowerCase();
                       }

                       console.log(`🎯 Setting All Caps checkbox to: ${isAllCaps} for text: "${currentText}"`);
                       allCapsCheckbox.checked = isAllCaps;
                   } else {
                       console.log(`🎯 No text content, unchecking All Caps checkbox`);
                       allCapsCheckbox.checked = false;
                   }

                   allCapsDebounceTimer = null;
               }, ALL_CAPS_DEBOUNCE_DELAY);
           }

           // Listen for text selection changes
           textInput.addEventListener('input', updateAllCapsState);
           textInput.addEventListener('change', updateAllCapsState);

           // Update All Caps checkbox state based on text selection
           function updateAllCapsControlState() {
               const isTextSelected = textInput && !textInput.disabled && textInput.value.trim();
               allCapsCheckbox.disabled = !isTextSelected;

               if (isTextSelected) {
                   updateAllCapsState();
               } else {
                   allCapsCheckbox.checked = false;
               }
           }

           // Make this function available globally so it can be called when text selection changes
           window.updateAllCapsControlState = updateAllCapsControlState;
       }

       // Make the functions globally available
       window.enhanceSelectedText = enhanceSelectedText;
       window.replaceAllCanvasTexts = replaceAllCanvasTexts;

       // Debounce timer for text enhancement controls
       let textEnhancementDebounceTimer = null;
       const TEXT_ENHANCEMENT_DEBOUNCE_DELAY = 100; // 100ms delay for UI updates

       // Function to update text enhancement controls state
       function updateTextEnhancementControls() {
           console.log(`🎯 updateTextEnhancementControls called (will be debounced)`);

           // Clear existing timer
           if (textEnhancementDebounceTimer) {
               clearTimeout(textEnhancementDebounceTimer);
           }

           // Debounce the text enhancement controls update
           textEnhancementDebounceTimer = setTimeout(() => {
               console.log(`🎯 DEBOUNCED: Processing text enhancement controls update`);

               const textInput = document.getElementById('iText');
               const toneSelect = document.getElementById('textToneSelect');
               const enhanceBtn = document.getElementById('enhanceTextBtn');
               const replaceAllCheckbox = document.getElementById('replaceAllTextsCheckbox');

               const isTextSelected = textInput && !textInput.disabled && textInput.value.trim();

               // Enable/disable controls based on text selection
               if (toneSelect) toneSelect.disabled = !isTextSelected;
               if (enhanceBtn) enhanceBtn.disabled = !isTextSelected;
               if (replaceAllCheckbox) replaceAllCheckbox.disabled = !isTextSelected;

               // Update All Caps control state if available (this will also be debounced)
               if (window.updateAllCapsControlState) {
                   window.updateAllCapsControlState();
               }

               // Reset button state when text changes
               if (enhanceBtn && isTextSelected) {
                   enhanceBtn.classList.remove('regenerate-mode');
                   // Keep just the icon for the square button
                   enhanceBtn.innerHTML = '<i class="fas fa-magic"></i>';
                   enhanceBtn.title = 'Enhance selected text with AI';
                   delete enhanceBtn.dataset.originalText;
               }

               textEnhancementDebounceTimer = null;
           }, TEXT_ENHANCEMENT_DEBOUNCE_DELAY);
       }

       // Monitor text input state changes
       function setupTextEnhancementMonitoring() {
           const textInput = document.getElementById('iText');
           if (!textInput) return;

           // Create a MutationObserver to watch for disabled attribute changes
           const observer = new MutationObserver(function(mutations) {
               mutations.forEach(function(mutation) {
                   if (mutation.type === 'attributes' && mutation.attributeName === 'disabled') {
                       updateTextEnhancementControls();
                   }
               });
           });

           // Start observing
           observer.observe(textInput, {
               attributes: true,
               attributeFilter: ['disabled']
           });

           // Also listen for value changes
           textInput.addEventListener('input', updateTextEnhancementControls);
           textInput.addEventListener('change', updateTextEnhancementControls);

           // Initial state update
           updateTextEnhancementControls();

           // Setup All Caps functionality
           setupAllCapsControl();
       }

       // Initialize text enhancement monitoring when DOM is ready
       document.addEventListener('DOMContentLoaded', function() {
           setupTextEnhancementMonitoring();
       });

       // If DOM is already loaded, setup immediately
       if (document.readyState === 'loading') {
           document.addEventListener('DOMContentLoaded', setupTextEnhancementMonitoring);
       } else {
           setupTextEnhancementMonitoring();
       }

       // ===== CSS FILTERS FOR IMAGES =====

       // Filter presets from adjust.html
       const filterPresets = {
           "watercolor": {
               "brightness": 1.3,
               "invert": 0.17,
               "saturate": 2.6,
               "sepia": 0.25
           },
           "faded-photo": {
               "blur": 0.2,
               "brightness": 1.1,
               "hueRotate": 5,
               "opacity": 0.9,
               "saturate": 1.3,
               "sepia": 0.4
           },
           "old-horror": {
               "grayscale": 1,
               "sepia": 0.5,
               "brightness": 1.3,
               "invert": 0.8
           },
           "old-grainy": {
               "grayscale": 0.6,
               "sepia": 0.5,
               "brightness": 1.5
           },
           "fade-out": {
               "brightness": 0.8,
               "hueRotate": 350,
               "saturate": 3,
               "blur": 8,
               "contrast": 0.6
           },
           "mist": {
               "brightness": 0.8,
               "saturate": 0.8
           }
       };

       // Function to apply CSS filters to selected image
       async function applyImageFilters() {
           console.log('🎨 [CSS Filters] ========== applyImageFilters() called ==========');

           // Find the selected object by checking isSelected property
           let selectedObject = null;
           let selectedIndex = -1;

           if (window.canvasObjects) {
               console.log('🎨 [CSS Filters] Checking', window.canvasObjects.length, 'canvas objects for selection');
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected) {
                       selectedObject = window.canvasObjects[i];
                       selectedIndex = i;
                       console.log('🎨 [CSS Filters] Found selected object at index', i, 'type:', selectedObject.type);
                       break;
                   }
               }
           } else {
               console.log('🎨 [CSS Filters] ❌ window.canvasObjects is not available');
           }

           console.log('🎨 [CSS Filters] Selected object:', selectedObject ? selectedObject.type : 'none');
           console.log('🎨 [CSS Filters] Selected index:', selectedIndex);

           if (selectedObject && selectedObject.type === 'image') {
                   // Get filter values from controls
                   const filters = {
                       blur: parseFloat(document.getElementById('iImageBlur')?.value || 0),
                       brightness: parseFloat(document.getElementById('iImageBrightness')?.value || 1),
                       contrast: parseFloat(document.getElementById('iImageContrast')?.value || 1),
                       saturate: parseFloat(document.getElementById('iImageSaturation')?.value || 1),
                       hueRotate: parseFloat(document.getElementById('iImageHue')?.value || 0),
                       grayscale: parseFloat(document.getElementById('iImageGrayscale')?.value || 0),
                       sepia: parseFloat(document.getElementById('iImageSepia')?.value || 0),
                       invert: parseFloat(document.getElementById('iImageInvert')?.value || 0)
                   };

                   console.log('🎨 [CSS Filters] Filter values:', filters);

                   // Store filters in the image object
                   selectedObject.cssFilters = filters;

                   // Build CSS filter string
                   const filterParts = [];
                   if (filters.blur > 0) filterParts.push(`blur(${filters.blur}px)`);
                   if (filters.brightness !== 1) filterParts.push(`brightness(${filters.brightness})`);
                   if (filters.contrast !== 1) filterParts.push(`contrast(${filters.contrast})`);
                   if (filters.saturate !== 1) filterParts.push(`saturate(${filters.saturate})`);
                   if (filters.hueRotate > 0) filterParts.push(`hue-rotate(${filters.hueRotate}deg)`);
                   if (filters.grayscale > 0) filterParts.push(`grayscale(${filters.grayscale})`);
                   if (filters.sepia > 0) filterParts.push(`sepia(${filters.sepia})`);
                   if (filters.invert > 0) filterParts.push(`invert(${filters.invert})`);

                   selectedObject.cssFilterString = filterParts.length > 0 ? filterParts.join(' ') : 'none';
                   console.log('🎨 [CSS Filters] Generated filter string:', selectedObject.cssFilterString);

                   // 🎯 INVALIDATE GLITCH, DUOTONE, AND HALFTONE CACHES WHEN CSS FILTERS CHANGE
                   console.log('🎨 [CSS Filters] Invalidating glitch, duotone, and halftone caches due to CSS filter change');
                   if (selectedObject.glinchImageCache) {
                       selectedObject.glinchImageCache = {};
                       console.log('🎨 [CSS Filters] Cleared glitch image cache');
                   }
                   if (selectedObject.duotoneImageCache) {
                       selectedObject.duotoneImageCache = {};
                       console.log('🎨 [CSS Filters] Cleared duotone image cache');
                   }
                   if (selectedObject.halftoneImageCache) {
                       selectedObject.halftoneImageCache = {};
                       console.log('🎨 [CSS Filters] Cleared halftone image cache');
                   }

                   // Apply filters using client-side processing (simpler and more reliable)
                   console.log('🎨 [CSS Filters] Applying client-side filters');
                   applyClientSideFilters(selectedObject, filters);

                   // 🎯 PRESERVE EXISTING DUOTONE SETTINGS - Only update if duotone controls are enabled
                   const duotoneEnabled = document.getElementById('duotoneEnabled')?.checked || false;
                   const existingDuotoneEnabled = selectedObject.duotoneEnabled || false;

                   // Only apply duotone if the UI control is enabled
                   if (duotoneEnabled) {
                       const color1 = document.getElementById('duotoneColor1')?.value || '#3B82F6';
                       const color2 = document.getElementById('duotoneColor2')?.value || '#EAB308';

                       console.log('🎨 [DuoTone] Applying duotone with colors:', color1, color2);

                       const matrixValues = generateDuotoneMatrix(color1, color2);
                       if (matrixValues) {
                           selectedObject.duotoneEnabled = true;
                           selectedObject.duotoneColor1 = color1;
                           selectedObject.duotoneColor2 = color2;
                           selectedObject.duotoneMatrix = matrixValues;

                           console.log('🎨 [DuoTone] Duotone settings stored in image object');
                       }
                   } else if (existingDuotoneEnabled) {
                       // Preserve existing duotone settings when CSS filters change
                       console.log('🎨 [DuoTone] Preserving existing duotone settings during CSS filter change');
                   }

                   // 🎯 PRESERVE EXISTING GLITCH SETTINGS - Only update if UI controls are actually being used
                   const anyGlinchUIEnabled = document.getElementById('paletteReductionEnabled')?.checked ||
                                             document.getElementById('colorShiftEnabled')?.checked ||
                                             document.getElementById('waveDeformEnabled')?.checked ||
                                             document.getElementById('displacementEnabled')?.checked ||
                                             document.getElementById('pixelSortEnabled')?.checked;

                   const existingGlinchEnabled = selectedObject.glinchEnabled || false;

                   // Only apply glitch effects if any UI controls are enabled
                   if (anyGlinchUIEnabled) {
                       const glinchEffects = {};
                       let hasGlinchEffects = false;

                       // Palette Reduction
                       const paletteReductionEnabled = document.getElementById('paletteReductionEnabled')?.checked || false;
                       if (paletteReductionEnabled) {
                           glinchEffects.paletteReduction = {
                               enabled: true,
                               paletteName: document.getElementById('paletteName')?.value || 'desert',
                               distanceMode: document.getElementById('distanceMode')?.value || 'accurate',
                               useDithering: document.getElementById('useDithering')?.checked || true
                           };
                           hasGlinchEffects = true;
                       }

                       // Color Shift
                       const colorShiftEnabled = document.getElementById('colorShiftEnabled')?.checked || false;
                       if (colorShiftEnabled) {
                           glinchEffects.colorShift = {
                               enabled: true,
                               intensity: parseFloat(document.getElementById('colorShiftIntensity')?.value || 1),
                               shiftAmount: parseFloat(document.getElementById('colorShiftAmount')?.value || 20)
                           };
                           hasGlinchEffects = true;
                       }

                       // Wave Deform
                       const waveDeformEnabled = document.getElementById('waveDeformEnabled')?.checked || false;
                       if (waveDeformEnabled) {
                           glinchEffects.waveDeform = {
                               enabled: true,
                               direction: document.getElementById('waveDirection')?.value || 'horizontal',
                               amplitude: parseFloat(document.getElementById('waveAmplitude')?.value || 10),
                               frequency: parseFloat(document.getElementById('waveFrequency')?.value || 0.05)
                           };
                           hasGlinchEffects = true;
                       }

                       // Displacement
                       const displacementEnabled = document.getElementById('displacementEnabled')?.checked || false;
                       if (displacementEnabled) {
                           glinchEffects.displacement = {
                               enabled: true,
                               mode: document.getElementById('displacementMode')?.value || 'horizontal',
                               displacementIntensity: parseFloat(document.getElementById('displacementIntensity')?.value || 8),
                               displacementSize: parseFloat(document.getElementById('displacementSize')?.value || 18),
                               displacementFrequency: 0.5
                           };
                           hasGlinchEffects = true;
                       }

                       // Pixel Sort
                       const pixelSortEnabled = document.getElementById('pixelSortEnabled')?.checked || false;
                       if (pixelSortEnabled) {
                           glinchEffects.pixelSort = {
                               enabled: true,
                               direction: document.getElementById('pixelSortDirection')?.value || 'horizontal',
                               blockSize: parseFloat(document.getElementById('pixelSortBlockSize')?.value || 5),
                               frequency: parseFloat(document.getElementById('pixelSortFrequency')?.value || 0.5)
                           };
                           hasGlinchEffects = true;
                       }

                       if (hasGlinchEffects) {
                           console.log('🎨 [Glinch] Applying glitch effects:', glinchEffects);
                           selectedObject.glinchEnabled = true;
                           selectedObject.glinchEffects = glinchEffects;
                       }
                   } else if (existingGlinchEnabled) {
                       // Preserve existing glitch settings when CSS filters change
                       console.log('🎨 [Glinch] Preserving existing glitch settings during CSS filter change');
                   }

                   // 🎯 CAPTURE CSS FILTER STATE FOR SAVE/LOAD FUNCTIONALITY
                   captureCSSFilterState();

                   // Trigger unified pipeline update to show the CSS filter changes
                   if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
                       console.log('🎨 [CSS Filters] Triggering unified pipeline update');
                       window.imageEffectsPipeline.triggerPipelineUpdate('css-filters-change');
                   } else {
                       // Fallback to immediate update if pipeline not available
                       if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                           console.log('🎨 [CSS Filters] Fallback: Using immediate update');
                           window.immediateUpdate('css-filters-fallback');
                       } else if (window.update && typeof window.update === 'function') {
                           console.log('🎨 [CSS Filters] Fallback: Calling window.update()');
                           window.update();

                           // Force a second update to ensure image is visible (like Reset does)
                           setTimeout(() => {
                               console.log('🎨 [CSS Filters] Forcing second update to ensure visibility');
                               window.update();
                           }, 50);
                       } else {
                           console.log('🎨 [CSS Filters] No update function available');
                       }
                   }
               } else {
                   console.log('🎨 [CSS Filters] No valid image selected');
               }
       }

       // Make applyImageFilters globally accessible for template loading
       window.applyImageFilters = applyImageFilters;

       // Function to capture current CSS filter state into global variable
       function captureCSSFilterState() {
           const filterControls = [
               { id: 'iImageBlur', key: 'blur' },
               { id: 'iImageBrightness', key: 'brightness' },
               { id: 'iImageContrast', key: 'contrast' },
               { id: 'iImageSaturation', key: 'saturate' },
               { id: 'iImageHue', key: 'hueRotate' },
               { id: 'iImageGrayscale', key: 'grayscale' },
               { id: 'iImageSepia', key: 'sepia' },
               { id: 'iImageInvert', key: 'invert' }
           ];

           const cssFilterState = {};

           filterControls.forEach(control => {
               const element = document.getElementById(control.id);
               if (element) {
                   cssFilterState[control.key] = parseFloat(element.value);
               }
           });

           // Update global state
           window.cssFilterState = cssFilterState;

           console.log('🎨 [CSS Filters] Captured filter state to window.cssFilterState:', cssFilterState);
           console.log('🎨 [CSS Filters] 🔍 DETAILED VALUES:', JSON.stringify(cssFilterState, null, 2));
           return cssFilterState;
       }

       // Make captureCSSFilterState globally accessible
       window.captureCSSFilterState = captureCSSFilterState;

       // Function to capture current duotone state into global variable
       function captureDuotoneState() {
           const duotoneState = {
               enabled: document.getElementById('duotoneEnabled')?.checked || false,
               color1: document.getElementById('duotoneColor1')?.value || '#3B82F6',
               color2: document.getElementById('duotoneColor2')?.value || '#EAB308'
           };

           // Generate matrix if duotone is enabled
           if (duotoneState.enabled) {
               const matrixValues = generateDuotoneMatrix(duotoneState.color1, duotoneState.color2);
               if (matrixValues) {
                   duotoneState.matrix = matrixValues;
               }
           }

           console.log('🎨 [DuoTone] Captured duotone state:', duotoneState);
           return duotoneState;
       }

       // Function to capture current glitch state into global variable
       function captureGlitchState() {
           const glitchState = {};

           // Capture Color Shift settings
           const colorShiftEnabled = document.getElementById('colorShiftEnabled')?.checked || false;
           if (colorShiftEnabled) {
               glitchState.colorShift = {
                   enabled: true,
                   intensity: parseFloat(document.getElementById('colorShiftIntensity')?.value || 1),
                   shiftAmount: parseFloat(document.getElementById('colorShiftAmount')?.value || 20)
               };
           }

           // Capture Palette Reduction settings
           const paletteReductionEnabled = document.getElementById('paletteReductionEnabled')?.checked || false;
           if (paletteReductionEnabled) {
               glitchState.paletteReduction = {
                   enabled: true,
                   paletteName: document.getElementById('paletteName')?.value || 'desert',
                   distanceMode: document.getElementById('distanceMode')?.value || 'accurate',
                   useDithering: document.getElementById('useDithering')?.checked || true
               };
           }

           // Capture Wave Deform settings
           const waveDeformEnabled = document.getElementById('waveDeformEnabled')?.checked || false;
           if (waveDeformEnabled) {
               glitchState.waveDeform = {
                   enabled: true,
                   direction: document.getElementById('waveDirection')?.value || 'horizontal',
                   amplitude: parseFloat(document.getElementById('waveAmplitude')?.value || 10),
                   frequency: parseFloat(document.getElementById('waveFrequency')?.value || 0.05)
               };
           }

           // Capture Displacement settings
           const displacementEnabled = document.getElementById('displacementEnabled')?.checked || false;
           if (displacementEnabled) {
               glitchState.displacement = {
                   enabled: true,
                   mode: document.getElementById('displacementMode')?.value || 'horizontal',
                   intensity: parseFloat(document.getElementById('displacementIntensity')?.value || 10),
                   size: parseFloat(document.getElementById('displacementSize')?.value || 5)
               };
           }

           // Capture Pixel Sort settings
           const pixelSortEnabled = document.getElementById('pixelSortEnabled')?.checked || false;
           if (pixelSortEnabled) {
               glitchState.pixelSort = {
                   enabled: true,
                   direction: document.getElementById('pixelSortDirection')?.value || 'horizontal',
                   blockSize: parseFloat(document.getElementById('pixelSortBlockSize')?.value || 10),
                   frequency: parseFloat(document.getElementById('pixelSortFrequency')?.value || 0.5)
               };
           }

           console.log('🎨 [Glinch] Captured glitch state:', glitchState);
           return glitchState;
       }

       // Make capture functions globally accessible
       window.captureDuotoneState = captureDuotoneState;
       window.captureGlitchState = captureGlitchState;

       // Function to restore duotone state from saved data
       function restoreDuotoneState(duotoneState) {
           console.log('🎨 [DuoTone] Restoring duotone state:', duotoneState);

           if (!duotoneState || typeof duotoneState !== 'object') {
               console.log('🎨 [DuoTone] No valid duotone state to restore');
               return;
           }

           // Restore duotone enabled state
           const duotoneEnabled = document.getElementById('duotoneEnabled');
           if (duotoneEnabled) {
               duotoneEnabled.checked = duotoneState.enabled || false;

               // Show/hide color controls based on enabled state
               const duotoneColorControls = document.getElementById('duotone-color-controls');
               if (duotoneColorControls) {
                   duotoneColorControls.style.display = duotoneState.enabled ? 'block' : 'none';
               }
           }

           // Restore color values
           if (duotoneState.color1) {
               const duotoneColor1 = document.getElementById('duotoneColor1');
               const duotoneColor1Text = document.getElementById('duotoneColor1Text');
               if (duotoneColor1) duotoneColor1.value = duotoneState.color1;
               if (duotoneColor1Text) duotoneColor1Text.value = duotoneState.color1;
           }

           if (duotoneState.color2) {
               const duotoneColor2 = document.getElementById('duotoneColor2');
               const duotoneColor2Text = document.getElementById('duotoneColor2Text');
               if (duotoneColor2) duotoneColor2.value = duotoneState.color2;
               if (duotoneColor2Text) duotoneColor2Text.value = duotoneState.color2;
           }

           // Apply the restored duotone effect
           if (duotoneState.enabled) {
               setTimeout(() => {
                   applyDuotoneEffect();
               }, 100);
           }

           console.log('🎨 [DuoTone] Duotone state restored successfully');
       }

       // Function to restore glitch state from saved data
       function restoreGlitchState(glitchState) {
           console.log('🎨 [Glinch] Restoring glitch state:', glitchState);

           if (!glitchState || typeof glitchState !== 'object') {
               console.log('🎨 [Glinch] No valid glitch state to restore');
               return;
           }

           // Restore Color Shift settings
           if (glitchState.colorShift) {
               const colorShiftEnabled = document.getElementById('colorShiftEnabled');
               const colorShiftControls = document.getElementById('colorShift-controls');
               const colorShiftIntensity = document.getElementById('colorShiftIntensity');
               const colorShiftAmount = document.getElementById('colorShiftAmount');

               if (colorShiftEnabled) {
                   colorShiftEnabled.checked = glitchState.colorShift.enabled || false;
                   if (colorShiftControls) {
                       colorShiftControls.style.display = glitchState.colorShift.enabled ? 'block' : 'none';
                   }
               }
               if (colorShiftIntensity) colorShiftIntensity.value = glitchState.colorShift.intensity || 1;
               if (colorShiftAmount) colorShiftAmount.value = glitchState.colorShift.shiftAmount || 20;
           }

           // Restore Palette Reduction settings
           if (glitchState.paletteReduction) {
               const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
               const paletteReductionControls = document.getElementById('paletteReduction-controls');
               const paletteName = document.getElementById('paletteName');
               const distanceMode = document.getElementById('distanceMode');
               const useDithering = document.getElementById('useDithering');

               if (paletteReductionEnabled) {
                   paletteReductionEnabled.checked = glitchState.paletteReduction.enabled || false;
                   if (paletteReductionControls) {
                       paletteReductionControls.style.display = glitchState.paletteReduction.enabled ? 'block' : 'none';
                   }
               }
               if (paletteName) paletteName.value = glitchState.paletteReduction.paletteName || 'desert';
               if (distanceMode) distanceMode.value = glitchState.paletteReduction.distanceMode || 'accurate';
               if (useDithering) useDithering.checked = glitchState.paletteReduction.useDithering !== false;
           }

           // Restore Wave Deform settings
           if (glitchState.waveDeform) {
               const waveDeformEnabled = document.getElementById('waveDeformEnabled');
               const waveDeformControls = document.getElementById('waveDeform-controls');
               const waveDirection = document.getElementById('waveDirection');
               const waveAmplitude = document.getElementById('waveAmplitude');
               const waveFrequency = document.getElementById('waveFrequency');

               if (waveDeformEnabled) {
                   waveDeformEnabled.checked = glitchState.waveDeform.enabled || false;
                   if (waveDeformControls) {
                       waveDeformControls.style.display = glitchState.waveDeform.enabled ? 'block' : 'none';
                   }
               }
               if (waveDirection) waveDirection.value = glitchState.waveDeform.direction || 'horizontal';
               if (waveAmplitude) waveAmplitude.value = glitchState.waveDeform.amplitude || 10;
               if (waveFrequency) waveFrequency.value = glitchState.waveDeform.frequency || 0.05;
           }

           // Restore Displacement settings
           if (glitchState.displacement) {
               const displacementEnabled = document.getElementById('displacementEnabled');
               const displacementControls = document.getElementById('displacement-controls');
               const displacementMode = document.getElementById('displacementMode');
               const displacementIntensity = document.getElementById('displacementIntensity');
               const displacementSize = document.getElementById('displacementSize');

               if (displacementEnabled) {
                   displacementEnabled.checked = glitchState.displacement.enabled || false;
                   if (displacementControls) {
                       displacementControls.style.display = glitchState.displacement.enabled ? 'block' : 'none';
                   }
               }
               if (displacementMode) displacementMode.value = glitchState.displacement.mode || 'horizontal';
               if (displacementIntensity) displacementIntensity.value = glitchState.displacement.intensity || 10;
               if (displacementSize) displacementSize.value = glitchState.displacement.size || 5;
           }

           // Restore Pixel Sort settings
           if (glitchState.pixelSort) {
               const pixelSortEnabled = document.getElementById('pixelSortEnabled');
               const pixelSortControls = document.getElementById('pixelSort-controls');
               const pixelSortDirection = document.getElementById('pixelSortDirection');
               const pixelSortBlockSize = document.getElementById('pixelSortBlockSize');
               const pixelSortFrequency = document.getElementById('pixelSortFrequency');

               if (pixelSortEnabled) {
                   pixelSortEnabled.checked = glitchState.pixelSort.enabled || false;
                   if (pixelSortControls) {
                       pixelSortControls.style.display = glitchState.pixelSort.enabled ? 'block' : 'none';
                   }
               }
               if (pixelSortDirection) pixelSortDirection.value = glitchState.pixelSort.direction || 'horizontal';
               if (pixelSortBlockSize) pixelSortBlockSize.value = glitchState.pixelSort.blockSize || 10;
               if (pixelSortFrequency) pixelSortFrequency.value = glitchState.pixelSort.frequency || 0.5;
           }

           // Apply the restored glitch effects
           setTimeout(() => {
               applyGlinchEffects();
           }, 100);

           console.log('🎨 [Glinch] Glitch state restored successfully');
       }

       // Function to restore CSS filter state from saved data
       function restoreCSSFilterState(cssFilterState) {
           console.log('🎨 [CSS Filters] Restoring CSS filter state:', cssFilterState);

           if (!cssFilterState || typeof cssFilterState !== 'object') {
               console.log('🎨 [CSS Filters] No valid CSS filter state to restore');
               return;
           }

           const filterControls = [
               { id: 'iImageBlur', key: 'blur', defaultValue: 0 },
               { id: 'iImageBrightness', key: 'brightness', defaultValue: 1 },
               { id: 'iImageContrast', key: 'contrast', defaultValue: 1 },
               { id: 'iImageSaturation', key: 'saturate', defaultValue: 1 },
               { id: 'iImageHue', key: 'hueRotate', defaultValue: 0 },
               { id: 'iImageGrayscale', key: 'grayscale', defaultValue: 0 },
               { id: 'iImageSepia', key: 'sepia', defaultValue: 0 },
               { id: 'iImageInvert', key: 'invert', defaultValue: 0 }
           ];

           filterControls.forEach(control => {
               const element = document.getElementById(control.id);
               if (element) {
                   const value = cssFilterState[control.key] !== undefined
                       ? cssFilterState[control.key]
                       : control.defaultValue;
                   element.value = value;

                   // Update display values
                   const displayElement = document.getElementById('v' + control.id.substring(1));
                   if (displayElement) {
                       if (control.key === 'blur') {
                           displayElement.textContent = value + 'px';
                       } else if (control.key === 'hueRotate') {
                           displayElement.textContent = value + '°';
                       } else if (['brightness', 'contrast', 'saturate'].includes(control.key)) {
                           displayElement.textContent = Math.round(value * 100) + '%';
                       } else {
                           displayElement.textContent = Math.round(value * 100) + '%';
                       }
                   }
               }
           });

           // Update global state
           window.cssFilterState = cssFilterState;

           // Apply the restored filters
           setTimeout(() => {
               applyImageFilters();
           }, 100);

           console.log('🎨 [CSS Filters] CSS filter state restored successfully');
       }

       // Make restore functions globally accessible
       window.restoreDuotoneState = restoreDuotoneState;
       window.restoreGlitchState = restoreGlitchState;
       window.restoreCSSFilterState = restoreCSSFilterState;

       // Function to apply filters server-side for images
       async function applyServerSideFilters(imageObject, filters, imageSource) {
           try {
               console.log('🎨 [CSS Filters] Requesting server-side filter processing...');

               const response = await fetch('/api/apply-image-filters', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json',
                   },
                   body: JSON.stringify({
                       imageUrl: imageSource,
                       filters: filters
                   })
               });

               if (!response.ok) {
                   throw new Error(`Server responded with ${response.status}: ${response.statusText}`);
               }

               const result = await response.json();
               console.log('🎨 [CSS Filters] Server-side filter result:', result);

               if (result.success && result.filteredImageUrl) {
                   // Create new image with filtered version
                   const filteredImg = new Image();
                   filteredImg.crossOrigin = 'anonymous';

                   filteredImg.onload = () => {
                       // Replace the image object's image with the filtered version
                       imageObject.image = filteredImg;
                       imageObject.filteredImageUrl = result.filteredImageUrl;
                       console.log('🎨 [CSS Filters] Filtered image loaded and applied');

                       // Update canvas
                       if (window.update && typeof window.update === 'function') {
                           window.update();
                       }
                   };

                   filteredImg.onerror = () => {
                       console.error('🎨 [CSS Filters] Failed to load filtered image');
                   };

                   filteredImg.src = result.filteredImageUrl;
               }
           } catch (error) {
               console.error('🎨 [CSS Filters] Server-side filter error:', error);
               throw error;
           }
       }

       // Function to apply filters client-side
       function applyClientSideFilters(imageObject, filters) {
           console.log('🎨 [CSS Filters] Applying client-side filters');

           try {
               // Ensure we have the original image stored for non-cumulative filtering
               if (!imageObject.originalImage && imageObject.image) {
                   imageObject.originalImage = imageObject.image;
                   console.log('🎨 [CSS Filters] Stored original image reference for non-cumulative filtering');
               }

               // Store the filter string for canvas rendering (this is used by drawImageObject)
               imageObject.cssFilterString = buildFilterString(filters);
               imageObject.cssFilters = filters;

               console.log('🎨 [CSS Filters] Client-side filters applied:', imageObject.cssFilterString);
               console.log('🎨 [CSS Filters] Filter object stored in image:', imageObject.cssFilters);
               console.log('🎨 [CSS Filters] Original image preserved:', !!imageObject.originalImage);

               // Clear any cached filtered images to force regeneration
               if (imageObject.filteredImageCache) {
                   imageObject.filteredImageCache = {};
                   console.log('🎨 [CSS Filters] Cleared filter cache');
               }

               // Also clear any cached images in the canvas system
               if (imageObject.cachedFilteredImages) {
                   imageObject.cachedFilteredImages = {};
                   console.log('🎨 [CSS Filters] Cleared canvas filter cache');
               }

               // 🎯 CRITICAL: Clear duotone and glitch caches when CSS filters change
               // This ensures effects are applied to the new CSS-filtered image
               if (imageObject.duotoneImageCache) {
                   imageObject.duotoneImageCache = {};
                   console.log('🎨 [CSS Filters] Cleared duotone cache');
               }

               if (imageObject.glinchImageCache) {
                   imageObject.glinchImageCache = {};
                   console.log('🎨 [CSS Filters] Cleared glitch cache');
               }

               // Mark the object as needing a visual update
               imageObject.needsUpdate = true;

               // Force immediate canvas redraw to ensure image is visible
               console.log('🎨 [CSS Filters] Forcing immediate canvas redraw');

           } catch (error) {
               console.error('🎨 [CSS Filters] Client-side filter error:', error);
           }
       }

       // Function to build CSS filter string from filter values
       function buildFilterString(filters) {
           const filterParts = [];
           if (filters.blur > 0) filterParts.push(`blur(${filters.blur}px)`);
           if (filters.brightness !== 1) filterParts.push(`brightness(${filters.brightness})`);
           if (filters.contrast !== 1) filterParts.push(`contrast(${filters.contrast})`);
           if (filters.saturate !== 1) filterParts.push(`saturate(${filters.saturate})`);
           if (filters.hueRotate > 0) filterParts.push(`hue-rotate(${filters.hueRotate}deg)`);
           if (filters.grayscale > 0) filterParts.push(`grayscale(${filters.grayscale})`);
           if (filters.sepia > 0) filterParts.push(`sepia(${filters.sepia})`);
           if (filters.invert > 0) filterParts.push(`invert(${filters.invert})`);

           return filterParts.length > 0 ? filterParts.join(' ') : 'none';
       }

       // Function to update filter value displays
       function updateFilterValueDisplay(filterName, value) {
           // Convert control ID to display ID (e.g., 'iImageBrightness' -> 'vImageBrightness')
           const displayId = filterName.replace('iImage', 'vImage');
           const display = document.getElementById(displayId);

           console.log('🎨 [CSS Filters] Updating display for:', filterName, '-> ID:', displayId, 'value:', value);

           if (display) {
               let displayValue = value;
               switch (filterName) {
                   case 'iImageBlur':
                       displayValue = value + 'px';
                       break;
                   case 'iImageHue':
                       displayValue = value + '°';
                       break;
                   case 'iImageBrightness':
                   case 'iImageContrast':
                   case 'iImageSaturation':
                       displayValue = Math.round(value * 100) + '%';
                       break;
                   case 'iImageGrayscale':
                   case 'iImageSepia':
                   case 'iImageInvert':
                       displayValue = Math.round(value * 100) + '%';
                       break;
               }
               display.textContent = displayValue;
               console.log('🎨 [CSS Filters] Display updated to:', displayValue);
           } else {
               console.log('🎨 [CSS Filters] ❌ Display element not found:', displayId);
           }
       }

       // Make updateFilterValueDisplay globally accessible for template loading
       window.updateFilterValueDisplay = updateFilterValueDisplay;

       // Function to apply filter preset
       function applyFilterPreset(presetName) {
           const preset = filterPresets[presetName];
           if (!preset) return;

           console.log('🎨 [CSS Filters] Applying preset:', presetName, preset);

           // Log settings before applying preset
           logAllEffectSettings('BEFORE LOADING PRESET');

           // Reset all filters first
           resetImageFilters(false);

           // Apply preset values
           Object.keys(preset).forEach(key => {
               const controlId = `iImage${key.charAt(0).toUpperCase() + key.slice(1)}`;
               const control = document.getElementById(controlId);
               if (control) {
                   control.value = preset[key];
                   updateFilterValueDisplay(controlId, preset[key]);
               }
           });

           applyImageFilters().then(() => {
               // Capture filter state after preset application
               captureCSSFilterState();

               // Log settings after applying preset
               setTimeout(() => {
                   logAllEffectSettings('AFTER LOADING PRESET');
               }, 200);
           });
       }

       // Function to reset image filters
       function resetImageFilters(updateUI = true) {
           console.log('🎨 [CSS Filters] Resetting image filters, updateUI:', updateUI);

           // Map filter names to actual control IDs
           const filterControlMap = {
               blur: 'iImageBlur',
               brightness: 'iImageBrightness',
               contrast: 'iImageContrast',
               saturate: 'iImageSaturation',  // Note: saturate -> Saturation
               hueRotate: 'iImageHue',        // Note: hueRotate -> Hue
               grayscale: 'iImageGrayscale',
               sepia: 'iImageSepia',
               invert: 'iImageInvert'
           };

           const defaultValues = {
               iImageBlur: 0,
               iImageBrightness: 1,
               iImageContrast: 1,
               iImageSaturation: 1,
               iImageHue: 0,
               iImageGrayscale: 0,
               iImageSepia: 0,
               iImageInvert: 0
           };

           if (updateUI) {
               Object.keys(defaultValues).forEach(controlId => {
                   const control = document.getElementById(controlId);
                   if (control) {
                       control.value = defaultValues[controlId];
                       updateFilterValueDisplay(controlId, defaultValues[controlId]);
                       console.log('🎨 [CSS Filters] Reset control:', controlId, 'to:', defaultValues[controlId]);
                   } else {
                       console.log('🎨 [CSS Filters] ❌ Control not found:', controlId);
                   }
               });

               // Clear preset dropdown selection
               const presetSelect = document.getElementById('filterPresetSelect');
               if (presetSelect) {
                   presetSelect.value = '';
               }
           }

           applyImageFilters().then(() => {
               // Capture filter state after reset
               captureCSSFilterState();
           });
       }

       // Function to save current ALL effects settings as a new preset
       async function saveCurrentFilterPreset(presetName) {
           console.log('🎨 [All Effects] Saving comprehensive preset:', presetName);

           // Log all current settings before saving
           const allSettings = logAllEffectSettings('SAVING PRESET');

           // Find the selected object
           let selectedObject = null;
           if (window.canvasObjects) {
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected && window.canvasObjects[i].type === 'image') {
                       selectedObject = window.canvasObjects[i];
                       break;
                   }
               }
           }

           if (!selectedObject) {
               alert('Please select an image to save preset from');
               return;
           }

           // 1. Get CSS Filter values
           const cssFilters = {};
           const filterControls = [
               { id: 'iImageBlur', key: 'blur', defaultValue: 0 },
               { id: 'iImageBrightness', key: 'brightness', defaultValue: 1 },
               { id: 'iImageContrast', key: 'contrast', defaultValue: 1 },
               { id: 'iImageSaturation', key: 'saturate', defaultValue: 1 },
               { id: 'iImageHue', key: 'hueRotate', defaultValue: 0 },
               { id: 'iImageGrayscale', key: 'grayscale', defaultValue: 0 },
               { id: 'iImageSepia', key: 'sepia', defaultValue: 0 },
               { id: 'iImageInvert', key: 'invert', defaultValue: 0 }
           ];

           filterControls.forEach(filter => {
               const control = document.getElementById(filter.id);
               if (control) {
                   const value = parseFloat(control.value);
                   if (value !== filter.defaultValue) {
                       cssFilters[filter.key] = value;
                   }
               }
           });

           // 2. Get Duotone settings
           const duotoneSettings = {
               enabled: selectedObject.duotoneEnabled || false,
               matrix: selectedObject.duotoneMatrix || null,
               color1: selectedObject.duotoneColor1 || document.getElementById('duotoneColor1')?.value || '#3B82F6',
               color2: selectedObject.duotoneColor2 || document.getElementById('duotoneColor2')?.value || '#EAB308'
           };

           // 3. Get Glitch settings
           const glitchSettings = {
               enabled: selectedObject.glinchEnabled || false,
               effects: selectedObject.glinchEffects || null
           };

           // 4. Get Halftone settings
           const halftoneSettings = {
               enabled: selectedObject.halftoneEnabled || false,
               settings: selectedObject.halftoneSettings || null
           };

           // 5. Handle custom halftone image upload
           let customImageData = null;
           if (window.halftoneCustomImage) {
               try {
                   // Convert image to base64 for storage
                   const canvas = document.createElement('canvas');
                   const ctx = canvas.getContext('2d');
                   canvas.width = window.halftoneCustomImage.width;
                   canvas.height = window.halftoneCustomImage.height;
                   ctx.drawImage(window.halftoneCustomImage, 0, 0);
                   customImageData = canvas.toDataURL('image/png');
                   console.log('🎨 [All Effects] Custom image captured for preset');
               } catch (error) {
                   console.error('🎨 [All Effects] Error capturing custom image:', error);
               }
           }

           // Create comprehensive preset object
           const comprehensivePreset = {
               cssFilters,
               duotone: duotoneSettings,
               glitch: glitchSettings,
               halftone: halftoneSettings,
               customImage: customImageData,
               version: '1.0' // For future compatibility
           };

           console.log('🎨 [All Effects] Comprehensive preset to save:', comprehensivePreset);

           // Add to filterPresets object (for backward compatibility)
           const presetKey = presetName.toLowerCase().replace(/\s+/g, '-');
           filterPresets[presetKey] = comprehensivePreset;

           // Save to localStorage for persistence
           saveComprehensivePresetToStorage(presetKey, presetName, comprehensivePreset);

           // Add to dropdown
           const presetSelect = document.getElementById('filterPresetSelect');
           const deletePresetBtn = document.getElementById('deletePresetBtn');

           if (presetSelect) {
               const option = document.createElement('option');
               option.value = presetName.toLowerCase().replace(/\s+/g, '-');
               option.textContent = presetName;
               presetSelect.appendChild(option);

               // Select the new preset
               presetSelect.value = option.value;

               // Show delete button for all presets
               if (deletePresetBtn) {
                   deletePresetBtn.style.display = 'block';
               }
           }

           // Clear the input field
           const presetNameInput = document.getElementById('newPresetName');
           if (presetNameInput) {
               presetNameInput.value = '';
           }

           console.log('🎨 [All Effects] Comprehensive preset saved:', presetName);
           alert(`Comprehensive preset "${presetName}" saved successfully!`);
       }

       // Function to apply comprehensive preset
       async function applyComprehensivePreset(presetData) {
           console.log('🎨 [All Effects] Applying comprehensive preset:', presetData);

           // Log settings before applying comprehensive preset
           logAllEffectSettings('BEFORE LOADING COMPREHENSIVE PRESET');

           // Find the selected object
           let selectedObject = null;
           if (window.canvasObjects) {
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected && window.canvasObjects[i].type === 'image') {
                       selectedObject = window.canvasObjects[i];
                       break;
                   }
               }
           }

           if (!selectedObject) {
               alert('Please select an image to apply preset to');
               return;
           }

           // STEP 0: Reset all effect settings to defaults first
           resetAllEffectSettings(selectedObject);
           console.log('🎨 [All Effects] All settings reset to defaults before applying preset');

           // 1. Apply CSS Filters
           if (presetData.cssFilters) {
               const filterControls = [
                   { id: 'iImageBlur', key: 'blur', defaultValue: 0 },
                   { id: 'iImageBrightness', key: 'brightness', defaultValue: 1 },
                   { id: 'iImageContrast', key: 'contrast', defaultValue: 1 },
                   { id: 'iImageSaturation', key: 'saturate', defaultValue: 1 },
                   { id: 'iImageHue', key: 'hueRotate', defaultValue: 0 },
                   { id: 'iImageGrayscale', key: 'grayscale', defaultValue: 0 },
                   { id: 'iImageSepia', key: 'sepia', defaultValue: 0 },
                   { id: 'iImageInvert', key: 'invert', defaultValue: 0 }
               ];

               filterControls.forEach(control => {
                   const element = document.getElementById(control.id);
                   if (element) {
                       const value = presetData.cssFilters[control.key] || control.defaultValue;
                       element.value = value;

                       // Update display
                       const displayElement = document.getElementById('v' + control.id.substring(1));
                       if (displayElement) {
                           if (control.key === 'blur') {
                               displayElement.textContent = value + 'px';
                           } else if (control.key === 'hueRotate') {
                               displayElement.textContent = value + '°';
                           } else {
                               displayElement.textContent = Math.round(value * 100) + '%';
                           }
                       }
                   }
               });

               // Apply CSS filters
               if (window.applyCSSFilters) {
                   window.applyCSSFilters();
               }
           }

           // 2. Apply Duotone
           if (presetData.duotone && presetData.duotone.enabled) {
               console.log('🎨 [All Effects] Applying duotone preset data:', presetData.duotone);

               selectedObject.duotoneEnabled = true;
               selectedObject.duotoneMatrix = presetData.duotone.matrix;

               // Store colors if available
               if (presetData.duotone.color1) {
                   selectedObject.duotoneColor1 = presetData.duotone.color1;
                   console.log('🎨 [All Effects] Stored duotone color1 in object:', presetData.duotone.color1);
               }
               if (presetData.duotone.color2) {
                   selectedObject.duotoneColor2 = presetData.duotone.color2;
                   console.log('🎨 [All Effects] Stored duotone color2 in object:', presetData.duotone.color2);
               }

               const duotoneToggle = document.getElementById('duotoneEnabled');
               if (duotoneToggle) {
                   duotoneToggle.checked = true;
                   console.log('🎨 [All Effects] Enabled duotone toggle');
               }

               // Update duotone UI controls with preset values
               console.log('🎨 [All Effects] About to update duotone UI with data:', presetData.duotone);
               updateDuotoneUIFromPreset(presetData.duotone);

               // Show duotone controls
               const duotoneControls = document.getElementById('duotone-color-controls');
               if (duotoneControls) {
                   duotoneControls.style.display = 'block';
                   console.log('🎨 [All Effects] Showed duotone controls');
               }

               // Don't apply immediately - let the final update handle it
               console.log('🎨 [All Effects] Duotone preset applied to object');
           } else {
               console.log('🎨 [All Effects] No duotone data to apply or duotone not enabled');
           }

           // 3. Apply Glitch
           if (presetData.glitch && presetData.glitch.enabled) {
               selectedObject.glinchEnabled = true;
               selectedObject.glinchEffects = presetData.glitch.effects;

               // Update UI controls with preset values (this will enable individual effects)
               updateGlitchUIFromSettings(presetData.glitch.effects);

               // Don't apply immediately - let the final update handle it
               console.log('🎨 [All Effects] Glitch preset applied to object');
           }

           // 4. Apply Halftone
           if (presetData.halftone && presetData.halftone.enabled) {
               selectedObject.halftoneEnabled = true;
               selectedObject.halftoneSettings = presetData.halftone.settings;

               const halftoneToggle = document.getElementById('halftoneEnabled');
               if (halftoneToggle) halftoneToggle.checked = true;

               // Update UI controls with preset values
               updateHalftoneUIFromSettings(presetData.halftone.settings);

               // Show halftone controls
               const halftoneControls = document.getElementById('halftone-effect-controls');
               if (halftoneControls) {
                   halftoneControls.style.display = 'block';
               }

               // Don't apply immediately - let the final update handle it
               console.log('🎨 [All Effects] Halftone preset applied to object');
           }

           // 5. Load custom image if present
           if (presetData.customImage) {
               try {
                   const img = new Image();
                   img.onload = () => {
                       window.halftoneCustomImage = img;
                       const imagePreviewImg = document.getElementById('halftoneImagePreviewImg');
                       const imagePreview = document.getElementById('halftoneImagePreview');
                       if (imagePreviewImg) imagePreviewImg.src = presetData.customImage;
                       if (imagePreview) imagePreview.style.display = 'block';
                       console.log('🎨 [All Effects] Custom image loaded from preset');

                       // Reapply halftone with custom image
                       if (window.applyHalftoneEffects) {
                           window.applyHalftoneEffects();
                       }
                   };
                   img.src = presetData.customImage;
               } catch (error) {
                   console.error('🎨 [All Effects] Error loading custom image from preset:', error);
               }
           }

           // Update canvas with a small delay to ensure image is loaded
           setTimeout(() => {
               if (window.update && typeof window.update === 'function') {
                   window.update();
               }
               console.log('🎨 [All Effects] Comprehensive preset applied successfully');

               // Log settings after applying comprehensive preset
               setTimeout(() => {
                   logAllEffectSettings('AFTER LOADING COMPREHENSIVE PRESET');
               }, 200);
           }, 100);
       }

       // Debounce mechanism to prevent duplicate saves
       let saveInProgress = false;
       const saveTimeouts = new Map();

       // Function to save comprehensive preset to localStorage
       function saveComprehensivePresetToStorage(presetKey, presetName, comprehensivePreset) {
           try {
               console.log('🎨 [All Effects] Saving comprehensive preset to localStorage:', presetKey);

               // Get existing custom presets
               const customPresets = JSON.parse(localStorage.getItem('customFilterPresets') || '[]');

               // Check if preset already exists and update it, or add new one
               const existingIndex = customPresets.findIndex(preset => preset.key === presetKey);
               const presetData = {
                   key: presetKey,
                   name: presetName,
                   preset: comprehensivePreset,
                   type: 'comprehensive',
                   created: new Date().toISOString()
               };

               if (existingIndex >= 0) {
                   customPresets[existingIndex] = presetData;
               } else {
                   customPresets.push(presetData);
               }

               // Save to localStorage
               localStorage.setItem('customFilterPresets', JSON.stringify(customPresets));

               console.log('🎨 [All Effects] Comprehensive preset saved to localStorage successfully');
           } catch (error) {
               console.error('🎨 [All Effects] Error saving comprehensive preset to localStorage:', error);
           }
       }

       // Function to save preset to database (legacy CSS filters only)
       async function savePresetToDatabase(presetKey, presetName, filters) {
           try {
               console.log('🎨 [CSS Filters] Saving preset to database:', presetKey);

               const response = await fetch('/api/filter-presets', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify({
                       key: presetKey,
                       name: presetName,
                       filters: filters
                   })
               });

               if (response.ok) {
                   console.log('🎨 [CSS Filters] Preset saved to database successfully');
               } else {
                   console.error('🎨 [CSS Filters] Failed to save preset to database:', response.statusText);
               }
           } catch (error) {
               console.error('🎨 [CSS Filters] Error saving preset to database:', error);
           }
       }

       // Function to delete preset from localStorage (no database needed)
       function deletePresetFromStorage(presetKey) {
           try {
               console.log('🎨 [CSS Filters] Deleting preset from localStorage:', presetKey);

               // Get current custom presets from localStorage
               const customPresets = JSON.parse(localStorage.getItem('customFilterPresets') || '[]');

               // Filter out the preset to delete
               const updatedPresets = customPresets.filter(preset => preset.key !== presetKey);

               // Save back to localStorage
               localStorage.setItem('customFilterPresets', JSON.stringify(updatedPresets));

               console.log('🎨 [CSS Filters] Preset deleted from localStorage:', presetKey);
           } catch (error) {
               console.error('🎨 [CSS Filters] Failed to delete preset from localStorage:', error.message);
           }
       }

       // Function to show delete preset confirmation
       function showDeletePresetConfirmation(presetKey, presetDisplayName) {
           console.log('🎨 [CSS Filters] Delete confirmation for:', presetKey, presetDisplayName);

           // Show confirmation dialog
           const confirmed = confirm(`Are you sure you want to delete the preset "${presetDisplayName}"?\n\nThis action cannot be undone.`);

           if (confirmed) {
               deleteFilterPreset(presetKey, presetDisplayName);
           }
       }

       // Function to delete a filter preset
       function deleteFilterPreset(presetKey, presetDisplayName) {
           console.log('🎨 [CSS Filters] Deleting preset:', presetKey);

           // List of built-in presets that cannot be deleted
           const builtInPresets = ['watercolor', 'faded-photo', 'old-horror', 'old-grainy', 'fade-out', 'mist'];

           if (builtInPresets.includes(presetKey)) {
               console.warn('🎨 [CSS Filters] Cannot delete built-in preset:', presetKey);
               if (window.showToast) window.showToast('Cannot delete built-in presets', 'warning');
               return;
           }

           // Remove from filterPresets object
           if (filterPresets[presetKey]) {
               delete filterPresets[presetKey];
           }

           // Delete from localStorage
           deletePresetFromStorage(presetKey);

           // Remove from dropdown
           const presetSelect = document.getElementById('filterPresetSelect');
           const deletePresetBtn = document.getElementById('deletePresetBtn');

           if (presetSelect) {
               const optionToRemove = presetSelect.querySelector(`option[value="${presetKey}"]`);
               if (optionToRemove) {
                   optionToRemove.remove();
               }

               // Reset dropdown selection
               presetSelect.value = '';
           }

           // Hide delete button
           if (deletePresetBtn) {
               deletePresetBtn.style.display = 'none';
           }

           console.log('🎨 [CSS Filters] Preset deleted:', presetKey);
           alert(`Filter preset "${presetDisplayName}" deleted successfully!`);
       }

       // Debounce timer for filter application
       let filterDebounceTimer = null;

       // Track if controls have been set up to prevent duplicate event listeners
       let imageFilterControlsSetup = false;

       // Setup CSS filter controls
       function setupImageFilterControls() {
           console.log('🎨 [CSS Filters] Setting up image filter controls...');

           // Prevent duplicate setup
           if (imageFilterControlsSetup) {
               console.log('🎨 [CSS Filters] Controls already set up, skipping...');
               return;
           }

           // Setup filter sliders
           const filterControls = [
               'iImageBlur', 'iImageBrightness', 'iImageContrast', 'iImageSaturation',
               'iImageHue', 'iImageGrayscale', 'iImageSepia', 'iImageInvert'
           ];

           filterControls.forEach(controlId => {
               const control = document.getElementById(controlId);
               if (control) {
                   console.log('🎨 [CSS Filters] Found control:', controlId);

                   // Add input event listener with debouncing
                   control.addEventListener('input', (e) => {
                       console.log('🎨 [CSS Filters] ⚡ INPUT EVENT TRIGGERED on:', controlId, 'value:', e.target.value);

                       // 🎯 INVALIDATE GLITCH, DUOTONE, AND HALFTONE CACHES IMMEDIATELY WHEN CSS FILTERS CHANGE
                       if (window.canvasObjects) {
                           for (let i = 0; i < window.canvasObjects.length; i++) {
                               const obj = window.canvasObjects[i];
                               if (obj.isSelected && obj.type === 'image') {
                                   if (obj.glinchImageCache) {
                                       obj.glinchImageCache = {};
                                       console.log('🎨 [CSS Filters] Cleared glitch cache for immediate feedback');
                                   }
                                   if (obj.duotoneImageCache) {
                                       obj.duotoneImageCache = {};
                                       console.log('🎨 [CSS Filters] Cleared duotone cache for immediate feedback');
                                   }
                                   if (obj.halftoneImageCache) {
                                       obj.halftoneImageCache = {};
                                       console.log('🎨 [CSS Filters] Cleared halftone cache for immediate feedback');
                                   }
                                   break;
                               }
                           }
                       }

                       // Update display immediately for responsive UI
                       updateFilterValueDisplay(controlId, parseFloat(e.target.value));

                       // 🔥 CRITICAL FIX: Provide immediate visual feedback
                       if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                           console.log('🎨 [CSS Filters] Providing immediate visual feedback');
                           window.immediateUpdate('css-filter-input');
                       }

                       // Clear existing timer
                       if (filterDebounceTimer) {
                           clearTimeout(filterDebounceTimer);
                       }

                       // Set new timer to apply filters after 500ms of no input
                       filterDebounceTimer = setTimeout(() => {
                           console.log('🎨 [CSS Filters] 🕐 Debounced filter application triggered for:', controlId);

                           // Show processing indicator
                           showFilterProcessingIndicator(true);

                           applyImageFilters().finally(() => {
                               // Hide processing indicator
                               showFilterProcessingIndicator(false);
                               // Capture filter state after application
                               captureCSSFilterState();
                           });
                       }, 500);

                       // Clear preset dropdown selection when manually adjusting
                       const presetSelect = document.getElementById('filterPresetSelect');
                       if (presetSelect) {
                           presetSelect.value = '';
                       }
                   });

                   // Add change event for immediate application when user releases slider
                   control.addEventListener('change', (e) => {
                       console.log('🎨 [CSS Filters] ⚡ CHANGE EVENT on:', controlId, 'value:', e.target.value);

                       // Clear debounce timer and apply immediately
                       if (filterDebounceTimer) {
                           clearTimeout(filterDebounceTimer);
                           filterDebounceTimer = null;
                       }

                       updateFilterValueDisplay(controlId, parseFloat(e.target.value));
                       applyImageFilters().then(() => {
                           // Capture filter state after application
                           captureCSSFilterState();
                       });
                   });
               } else {
                   console.log('🎨 [CSS Filters] Control not found:', controlId);
               }
           });

           // Setup preset dropdown
           const presetSelect = document.getElementById('filterPresetSelect');
           const deletePresetBtn = document.getElementById('deletePresetBtn');

           if (presetSelect) {
               presetSelect.addEventListener('change', (e) => {
                   const presetName = e.target.value;

                   console.log('🎨 [CSS Filters] ⚡ PRESET DROPDOWN CHANGED! Selected:', presetName);
                   console.log('🎨 [CSS Filters] Available presets in filterPresets:', Object.keys(filterPresets));

                   // Show/hide delete button based on selection
                   if (deletePresetBtn) {
                       // Allow deletion of any preset (you can now delete built-in presets too)
                       const canDelete = presetName && presetName !== '';

                       console.log('🎨 [CSS Filters] Can delete preset?', canDelete, 'Selected:', presetName);
                       console.log('🎨 [CSS Filters] Setting delete button display to:', canDelete ? 'block' : 'none');

                       deletePresetBtn.style.display = canDelete ? 'block' : 'none';
                   }

                   if (presetName) {
                       // Check if it's a comprehensive preset or legacy CSS filter preset
                       const presetData = filterPresets[presetName];

                       console.log('🎨 [PRESET LOADING] Selected preset:', presetName);
                       console.log('🎨 [PRESET LOADING] Preset data found:', !!presetData);
                       console.log('🎨 [PRESET LOADING] Preset data:', presetData);
                       console.log('🎨 [PRESET LOADING] Preset data type:', typeof presetData);
                       console.log('🎨 [PRESET LOADING] Has version?', !!presetData?.version);
                       console.log('🎨 [PRESET LOADING] Has duotone?', !!presetData?.duotone);
                       if (presetData?.duotone) {
                           console.log('🎨 [PRESET LOADING] Duotone data:', presetData.duotone);
                       }

                       // 🎯 AUTOMATICALLY RESET ALL EFFECTS BEFORE APPLYING PRESET
                       console.log('🎨 [PRESET LOADING] Auto-resetting all effects before applying preset...');
                       resetAllImageEffects(false); // Don't clear dropdown - keep preset name visible

                       // Small delay to ensure reset completes before applying new preset
                       setTimeout(() => {
                           if (presetData && presetData.version) {
                               // It's a comprehensive preset
                               console.log('🎨 [PRESET LOADING] Loading as comprehensive preset');
                               applyComprehensivePreset(presetData);
                           } else {
                               // It's a legacy CSS filter preset
                               console.log('🎨 [PRESET LOADING] Loading as legacy CSS filter preset');
                               applyFilterPreset(presetName);
                           }
                       }, 100); // 100ms delay to ensure reset completes
                   }
               });
           }

           // Setup delete preset button
           if (deletePresetBtn) {
               deletePresetBtn.addEventListener('click', () => {
                   const selectedPreset = presetSelect.value;
                   const selectedOption = presetSelect.options[presetSelect.selectedIndex];

                   if (selectedPreset && selectedOption) {
                       showDeletePresetConfirmation(selectedPreset, selectedOption.textContent);
                   }
               });
           }

           // Setup save preset functionality - ONLY ONCE
           const savePresetBtn = document.getElementById('saveFilterPresetBtn');
           const presetNameInput = document.getElementById('newPresetName');

           if (savePresetBtn && presetNameInput) {
               savePresetBtn.addEventListener('click', () => {
                   const presetName = presetNameInput.value.trim();
                   if (!presetName) {
                       alert('Please enter a preset name');
                       return;
                   }

                   saveCurrentFilterPreset(presetName);
               });
           }

           // Mark as set up to prevent duplicate event listeners
           imageFilterControlsSetup = true;
           console.log('🎨 [CSS Filters] Controls setup completed - marked as initialized');

           // Setup reset button - Enhanced to reset ALL effects
           const resetBtn = document.getElementById('resetImageFiltersBtn');
           if (resetBtn) {
               resetBtn.addEventListener('click', () => {
                   console.log('🎨 [Reset All] Reset All Filters button clicked');
                   resetAllImageEffects();
               });
           }

           // Setup test button
           const testBtn = document.getElementById('testImageFiltersBtn');
           if (testBtn) {
               testBtn.addEventListener('click', () => {
                   console.log('🎨 [CSS Filters] Test button clicked');

                   // Find the selected object by checking isSelected property
                   let selectedObject = null;
                   if (window.canvasObjects) {
                       for (let i = 0; i < window.canvasObjects.length; i++) {
                           if (window.canvasObjects[i].isSelected) {
                               selectedObject = window.canvasObjects[i];
                               break;
                           }
                       }
                   }

                   if (selectedObject && selectedObject.type === 'image') {
                           // Apply grayscale filter directly
                           selectedObject.cssFilterString = 'grayscale(1)';
                           selectedObject.cssFilters = { grayscale: 1 };
                           console.log('🎨 [CSS Filters] Applied test grayscale filter');

                           // Update UI
                           const grayscaleSlider = document.getElementById('iImageGrayscale');
                           if (grayscaleSlider) {
                               grayscaleSlider.value = 1;
                               const valueDisplay = document.getElementById('vImageGrayscale');
                               if (valueDisplay) valueDisplay.textContent = '100%';
                           }

                           // Force update
                           if (window.update && typeof window.update === 'function') {
                               window.update();
                           }
                       }
               });
           }

           // Setup debug button
           const debugBtn = document.getElementById('debugImageFiltersBtn');
           if (debugBtn) {
               debugBtn.addEventListener('click', () => {
                   console.log('🔍 [DEBUG] Debug button clicked');
                   console.log('🔍 [DEBUG] window.selectedObjectIndex:', window.selectedObjectIndex);
                   console.log('🔍 [DEBUG] window.canvasObjects:', window.canvasObjects);

                   if (window.canvasObjects && window.canvasObjects.length > 0) {
                       console.log('🔍 [DEBUG] All canvas objects:');
                       window.canvasObjects.forEach((obj, index) => {
                           console.log(`🔍 [DEBUG] Object ${index}:`, {
                               type: obj.type,
                               id: obj.id,
                               isSelected: obj.isSelected,
                               cssFilters: obj.cssFilters,
                               cssFilterString: obj.cssFilterString
                           });
                       });
                   }

                   // Find the selected object by checking isSelected property
                   let selectedObject = null;
                   if (window.canvasObjects) {
                       for (let i = 0; i < window.canvasObjects.length; i++) {
                           if (window.canvasObjects[i].isSelected) {
                               selectedObject = window.canvasObjects[i];
                               break;
                           }
                       }
                   }

                   if (selectedObject) {
                       console.log('🔍 [DEBUG] Selected object details:', {
                           type: selectedObject.type,
                           id: selectedObject.id,
                           imageUrl: selectedObject.imageUrl,
                           cssFilters: selectedObject.cssFilters,
                           cssFilterString: selectedObject.cssFilterString
                       });
                   } else {
                       console.log('🔍 [DEBUG] No object selected');
                   }
               });
           }
       }

       // Function to show/hide filter processing indicator
       function showFilterProcessingIndicator(show) {
           const indicator = document.getElementById('filter-processing-indicator');
           if (indicator) {
               indicator.style.display = show ? 'block' : 'none';
           } else if (show) {
               // Create indicator if it doesn't exist
               const newIndicator = document.createElement('div');
               newIndicator.id = 'filter-processing-indicator';
               newIndicator.innerHTML = '🎨 Processing filters...';
               newIndicator.style.cssText = `
                   position: fixed;
                   top: 10px;
                   right: 10px;
                   background: rgba(0,0,0,0.8);
                   color: white;
                   padding: 8px 12px;
                   border-radius: 4px;
                   font-size: 12px;
                   z-index: 10000;
                   pointer-events: none;
               `;
               document.body.appendChild(newIndicator);
           }
       }

       // Add hover effects for save button
       document.addEventListener('DOMContentLoaded', function() {
           const saveBtn = document.getElementById('saveFilterPresetBtn');
           if (saveBtn) {
               saveBtn.addEventListener('mouseenter', function() {
                   this.style.backgroundColor = '#218838';
               });
               saveBtn.addEventListener('mouseleave', function() {
                   this.style.backgroundColor = '#28a745';
               });
           }
       });

       // Function to load presets from database
       async function loadPresetsFromDatabase() {
           try {
               console.log('🎨 [CSS Filters] Loading presets from database...');

               const response = await fetch('/api/filter-presets');
               if (response.ok) {
                   const presets = await response.json();

                   // Add custom presets to filterPresets object
                   presets.forEach(preset => {
                       filterPresets[preset.key] = preset.filters;

                       // Add to dropdown if not already there
                       const presetSelect = document.getElementById('filterPresetSelect');
                       if (presetSelect && !presetSelect.querySelector(`option[value="${preset.key}"]`)) {
                           const option = document.createElement('option');
                           option.value = preset.key;
                           option.textContent = preset.name;
                           presetSelect.appendChild(option);
                       }
                   });

                   console.log('🎨 [CSS Filters] Loaded', presets.length, 'custom presets from database');
               } else {
                   console.log('🎨 [CSS Filters] No custom presets found in database');
               }

               // Load comprehensive presets
               console.log('🎨 [PRESET LOADING] Fetching comprehensive presets from /api/comprehensive-presets...');
               const comprehensiveResponse = await fetch('/api/comprehensive-presets');
               console.log('🎨 [PRESET LOADING] Comprehensive presets response status:', comprehensiveResponse.status);
               if (comprehensiveResponse.ok) {
                   const comprehensivePresets = await comprehensiveResponse.json();
                   console.log('🎨 [PRESET LOADING] Received comprehensive presets:', comprehensivePresets.length, 'presets');

                   // Add comprehensive presets to filterPresets object
                   comprehensivePresets.forEach(preset => {
                       console.log('🎨 [PRESET LOADING] Loading comprehensive preset from DB:', preset.key);
                       console.log('🎨 [PRESET LOADING] Raw preset data:', preset);
                       console.log('🎨 [PRESET LOADING] Preset.preset data:', preset.preset);

                       filterPresets[preset.key] = preset.preset;

                       // Add to dropdown if not already there
                       const presetSelect = document.getElementById('filterPresetSelect');
                       if (presetSelect && !presetSelect.querySelector(`option[value="${preset.key}"]`)) {
                           const option = document.createElement('option');
                           option.value = preset.key;
                           option.textContent = preset.name + ' (All Effects)';
                           presetSelect.appendChild(option);
                       }
                   });

                   console.log('🎨 [All Effects] Loaded', comprehensivePresets.length, 'comprehensive presets from database');
               } else {
                   console.log('🎨 [All Effects] No comprehensive presets found in database');
               }

           } catch (error) {
               console.error('🎨 [All Effects] Error loading presets from database:', error);
           }
       }

       // Initialize CSS filter controls when DOM is ready
       document.addEventListener('DOMContentLoaded', () => {
           console.log('🎨 [CSS Filters] DOMContentLoaded event fired, setting up filters...');
           setTimeout(() => {
               setupImageFilterControls();
               loadPresetsFromDatabase();
           }, 1000); // Delay to ensure all elements are ready
       });

       if (document.readyState !== 'loading') {
           console.log('🎨 [CSS Filters] DOM already loaded, setting up filters with delay...');
           setTimeout(setupImageFilterControls, 1000);
       }

       // ===== DUOTONE EFFECT FUNCTIONALITY =====

       // Function to convert hex color to RGB values
       function hexToRgb(hex) {
           const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
           return result ? {
               r: parseInt(result[1], 16),
               g: parseInt(result[2], 16),
               b: parseInt(result[3], 16)
           } : null;
       }

       // Function to generate duotone matrix values
       function generateDuotoneMatrix(color1, color2) {
           console.log('🎨 [DuoTone] Generating matrix for colors:', color1, color2);

           const rgb1 = hexToRgb(color1);
           const rgb2 = hexToRgb(color2);

           if (!rgb1 || !rgb2) {
               console.error('🎨 [DuoTone] Invalid color format');
               return null;
           }

           // Normalize RGB values to 0-1 range
           const r1 = rgb1.r / 255;
           const g1 = rgb1.g / 255;
           const b1 = rgb1.b / 255;
           const r2 = rgb2.r / 255;
           const g2 = rgb2.g / 255;
           const b2 = rgb2.b / 255;

           // Create duotone matrix
           // This matrix maps grayscale values to the two colors
           const matrix = [
               r2 - r1, 0, 0, 0, r1,
               g2 - g1, 0, 0, 0, g1,
               b2 - b1, 0, 0, 0, b1,
               0, 0, 0, 1, 0
           ];

           console.log('🎨 [DuoTone] Generated matrix:', matrix);
           return matrix.join(' ');
       }

       // Make generateDuotoneMatrix globally accessible for template save/load functionality
       window.generateDuotoneMatrix = generateDuotoneMatrix;

       // Function to apply duotone effect to selected image
       function applyDuotoneEffect() {
           console.log('🎨 [DuoTone] ===== APPLY DUOTONE EFFECT CALLED =====');

           // Find the selected object
           let selectedObject = null;
           let selectedIndex = -1;

           if (window.canvasObjects) {
               console.log('🎨 [DuoTone] Checking', window.canvasObjects.length, 'canvas objects for selection');
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected) {
                       selectedObject = window.canvasObjects[i];
                       selectedIndex = i;
                       console.log('🎨 [DuoTone] Found selected object at index', i, 'type:', selectedObject.type);
                       break;
                   }
               }
           }

           if (!selectedObject || selectedObject.type !== 'image') {
               console.log('🎨 [DuoTone] No image selected');
               return;
           }

           const duotoneEnabled = document.getElementById('duotoneEnabled')?.checked || false;

           if (duotoneEnabled) {
               const color1 = document.getElementById('duotoneColor1')?.value || '#3B82F6';
               const color2 = document.getElementById('duotoneColor2')?.value || '#EAB308';

               console.log('🎨 [DuoTone] Applying duotone with colors:', color1, color2);

               // 🎯 INVALIDATE GLITCH CACHE WHEN DUOTONE CHANGES
               if (selectedObject.glinchImageCache) {
                   selectedObject.glinchImageCache = {};
                   console.log('🎨 [DuoTone] Cleared glitch cache due to duotone change');
               }

               const matrixValues = generateDuotoneMatrix(color1, color2);
               if (matrixValues) {
                   // Update the SVG filter matrix
                   const duotoneMatrix = document.getElementById('duotone-matrix');
                   if (duotoneMatrix) {
                       duotoneMatrix.setAttribute('values', matrixValues);
                   }

                   // Store duotone settings in the image object
                   selectedObject.duotoneEnabled = true;
                   selectedObject.duotoneColor1 = color1;
                   selectedObject.duotoneColor2 = color2;
                   selectedObject.duotoneMatrix = matrixValues;

                   console.log('🎨 [DuoTone] Duotone effect applied');
               }
           } else {
               // Remove duotone effect
               selectedObject.duotoneEnabled = false;
               delete selectedObject.duotoneColor1;
               delete selectedObject.duotoneColor2;
               delete selectedObject.duotoneMatrix;

               // 🎯 INVALIDATE GLITCH CACHE WHEN DUOTONE IS DISABLED
               if (selectedObject.glinchImageCache) {
                   selectedObject.glinchImageCache = {};
                   console.log('🎨 [DuoTone] Cleared glitch cache due to duotone removal');
               }

               console.log('🎨 [DuoTone] Duotone effect removed');
           }

           // Clear all effect caches to ensure proper pipeline integration
           if (selectedObject.duotoneImageCache) {
               selectedObject.duotoneImageCache = {};
           }
           if (selectedObject.glinchImageCache) {
               selectedObject.glinchImageCache = {};
           }
           if (selectedObject.halftoneImageCache) {
               selectedObject.halftoneImageCache = {};
           }

           // Trigger unified pipeline update to show the duotone effect
           if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
               console.log('🎨 [DuoTone] Triggering unified pipeline update');
               window.imageEffectsPipeline.triggerPipelineUpdate('duotone-change');
           } else {
               // Fallback to immediate update if pipeline not available
               if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                   console.log('🎨 [DuoTone] Fallback: Using immediate update');
                   window.immediateUpdate('duotone-fallback');
               } else if (window.update && typeof window.update === 'function') {
                   console.log('🎨 [DuoTone] Fallback: Calling window.update()');
                   window.update();
               }
           }
       }

       // Make applyDuotoneEffect globally accessible for template save/load functionality
       window.applyDuotoneEffect = applyDuotoneEffect;

       // Function to setup duotone controls
       function setupDuotoneControls() {
           console.log('🎨 [DuoTone] Setting up duotone controls...');

           const duotoneEnabled = document.getElementById('duotoneEnabled');
           const duotoneColorControls = document.getElementById('duotone-color-controls');
           const duotoneColor1 = document.getElementById('duotoneColor1');
           const duotoneColor1Text = document.getElementById('duotoneColor1Text');
           const duotoneColor2 = document.getElementById('duotoneColor2');
           const duotoneColor2Text = document.getElementById('duotoneColor2Text');
           const resetDuotoneBtn = document.getElementById('resetDuotoneBtn');

           if (duotoneEnabled) {
               duotoneEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [DuoTone] Toggle changed:', e.target.checked);

                   if (duotoneColorControls) {
                       duotoneColorControls.style.display = e.target.checked ? 'block' : 'none';
                   }

                   applyDuotoneEffect();
               });
           }

           // Debounce timer for duotone color changes
           let duotoneColorDebounceTimer = null;
           const DUOTONE_COLOR_DEBOUNCE_DELAY = 300; // 300ms delay for color changes

           // Function to apply duotone with debouncing for better pipeline integration
           function applyDuotoneWithDebounce() {
               // Clear existing timer
               if (duotoneColorDebounceTimer) {
                   clearTimeout(duotoneColorDebounceTimer);
               }

               // Apply immediate visual feedback (just duotone)
               applyDuotoneEffect();

               // Debounce the full pipeline update
               duotoneColorDebounceTimer = setTimeout(() => {
                   console.log('🎨 [DuoTone] DEBOUNCED: Applying full effects pipeline after color change');
                   // Trigger unified pipeline update to show complete pipeline
                   if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
                       window.imageEffectsPipeline.triggerPipelineUpdate('duotone-color-debounced');
                   } else {
                       // Fallback to immediate update
                       if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                           console.log('🎨 [DuoTone] Debounced fallback: Using immediate update');
                           window.immediateUpdate('duotone-debounced-fallback');
                       } else if (window.update && typeof window.update === 'function') {
                           window.update();
                       }
                   }
                   duotoneColorDebounceTimer = null;
               }, DUOTONE_COLOR_DEBOUNCE_DELAY);
           }

           // Color picker 1 events
           if (duotoneColor1 && duotoneColor1Text) {
               duotoneColor1.addEventListener('input', (e) => {
                   duotoneColor1Text.value = e.target.value;
                   applyDuotoneWithDebounce();
               });

               duotoneColor1Text.addEventListener('input', (e) => {
                   if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                       duotoneColor1.value = e.target.value;
                       applyDuotoneWithDebounce();
                   }
               });
           }

           // Color picker 2 events
           if (duotoneColor2 && duotoneColor2Text) {
               duotoneColor2.addEventListener('input', (e) => {
                   duotoneColor2Text.value = e.target.value;
                   applyDuotoneWithDebounce();
               });

               duotoneColor2Text.addEventListener('input', (e) => {
                   if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                       duotoneColor2.value = e.target.value;
                       applyDuotoneWithDebounce();
                   }
               });
           }

           // Reset button
           if (resetDuotoneBtn) {
               resetDuotoneBtn.addEventListener('click', () => {
                   console.log('🎨 [DuoTone] Reset button clicked');

                   if (duotoneEnabled) duotoneEnabled.checked = false;
                   if (duotoneColor1) duotoneColor1.value = '#3B82F6';
                   if (duotoneColor1Text) duotoneColor1Text.value = '#3B82F6';
                   if (duotoneColor2) duotoneColor2.value = '#EAB308';
                   if (duotoneColor2Text) duotoneColor2Text.value = '#EAB308';
                   if (duotoneColorControls) duotoneColorControls.style.display = 'none';

                   applyDuotoneEffect();
               });
           }

           console.log('🎨 [DuoTone] Duotone controls setup complete');
       }

       // Initialize duotone controls when DOM is ready
       document.addEventListener('DOMContentLoaded', () => {
           console.log('🎨 [DuoTone] DOMContentLoaded event fired, setting up duotone...');
           setTimeout(() => {
               setupDuotoneControls();
           }, 1000); // Delay to ensure all elements are ready
       });

       if (document.readyState !== 'loading') {
           console.log('🎨 [DuoTone] DOM already loaded, setting up duotone with delay...');
           setTimeout(setupDuotoneControls, 1000);
       }

       // ===== GLINCH EFFECTS FUNCTIONALITY =====

       // Function to update glitch UI controls from settings
       function updateGlitchUIFromSettings(effects) {
           console.log('🎨 [Glinch] Updating UI controls from settings:', effects);

           if (!effects) return;

           // Update Color Shift
           if (effects.colorShift) {
               const colorShiftEnabled = document.getElementById('colorShiftEnabled');
               if (colorShiftEnabled) colorShiftEnabled.checked = effects.colorShift.enabled || false;

               if (effects.colorShift.enabled) {
                   const intensitySlider = document.getElementById('colorShiftIntensity');
                   const intensityDisplay = document.getElementById('vColorShiftIntensity');
                   if (intensitySlider && effects.colorShift.intensity !== undefined) {
                       intensitySlider.value = effects.colorShift.intensity;
                       if (intensityDisplay) intensityDisplay.textContent = Math.round(effects.colorShift.intensity * 100) + '%';
                   }

                   const amountSlider = document.getElementById('colorShiftAmount');
                   const amountDisplay = document.getElementById('vColorShiftAmount');
                   if (amountSlider && effects.colorShift.shiftAmount !== undefined) {
                       amountSlider.value = effects.colorShift.shiftAmount;
                       if (amountDisplay) amountDisplay.textContent = effects.colorShift.shiftAmount + 'px';
                   }

                   // Show color shift controls
                   const colorShiftControls = document.getElementById('color-shift-controls');
                   if (colorShiftControls) colorShiftControls.style.display = 'block';
               }
           }

           // Update Wave Deform
           if (effects.waveDeform) {
               const waveDeformEnabled = document.getElementById('waveDeformEnabled');
               if (waveDeformEnabled) waveDeformEnabled.checked = effects.waveDeform.enabled || false;

               if (effects.waveDeform.enabled) {
                   const directionSelect = document.getElementById('waveDirection');
                   if (directionSelect && effects.waveDeform.direction) {
                       directionSelect.value = effects.waveDeform.direction;
                   }

                   const amplitudeSlider = document.getElementById('waveAmplitude');
                   const amplitudeDisplay = document.getElementById('vWaveAmplitude');
                   if (amplitudeSlider && effects.waveDeform.amplitude !== undefined) {
                       amplitudeSlider.value = effects.waveDeform.amplitude;
                       if (amplitudeDisplay) amplitudeDisplay.textContent = effects.waveDeform.amplitude + 'px';
                   }

                   const frequencySlider = document.getElementById('waveFrequency');
                   const frequencyDisplay = document.getElementById('vWaveFrequency');
                   if (frequencySlider && effects.waveDeform.frequency !== undefined) {
                       frequencySlider.value = effects.waveDeform.frequency;
                       if (frequencyDisplay) frequencyDisplay.textContent = effects.waveDeform.frequency;
                   }

                   // Show wave deform controls
                   const waveDeformControls = document.getElementById('wave-deform-controls');
                   if (waveDeformControls) waveDeformControls.style.display = 'block';
               }
           }

           // Update Displacement
           if (effects.displacement) {
               const displacementEnabled = document.getElementById('displacementEnabled');
               if (displacementEnabled) displacementEnabled.checked = effects.displacement.enabled || false;

               if (effects.displacement.enabled) {
                   const modeSelect = document.getElementById('displacementMode');
                   if (modeSelect && effects.displacement.mode) {
                       modeSelect.value = effects.displacement.mode;
                   }

                   const intensitySlider = document.getElementById('displacementIntensity');
                   const intensityDisplay = document.getElementById('vDisplacementIntensity');
                   if (intensitySlider && effects.displacement.displacementIntensity !== undefined) {
                       intensitySlider.value = effects.displacement.displacementIntensity;
                       if (intensityDisplay) intensityDisplay.textContent = effects.displacement.displacementIntensity;
                   }

                   const sizeSlider = document.getElementById('displacementSize');
                   const sizeDisplay = document.getElementById('vDisplacementSize');
                   if (sizeSlider && effects.displacement.displacementSize !== undefined) {
                       sizeSlider.value = effects.displacement.displacementSize;
                       if (sizeDisplay) sizeDisplay.textContent = effects.displacement.displacementSize;
                   }

                   // Show displacement controls
                   const displacementControls = document.getElementById('displacement-controls');
                   if (displacementControls) displacementControls.style.display = 'block';
               }
           }

           // Update Pixel Sort
           if (effects.pixelSort) {
               const pixelSortEnabled = document.getElementById('pixelSortEnabled');
               if (pixelSortEnabled) pixelSortEnabled.checked = effects.pixelSort.enabled || false;

               if (effects.pixelSort.enabled) {
                   const directionSelect = document.getElementById('pixelSortDirection');
                   if (directionSelect && effects.pixelSort.direction) {
                       directionSelect.value = effects.pixelSort.direction;
                   }

                   const blockSizeSlider = document.getElementById('pixelSortBlockSize');
                   const blockSizeDisplay = document.getElementById('vPixelSortBlockSize');
                   if (blockSizeSlider && effects.pixelSort.blockSize !== undefined) {
                       blockSizeSlider.value = effects.pixelSort.blockSize;
                       if (blockSizeDisplay) blockSizeDisplay.textContent = effects.pixelSort.blockSize;
                   }

                   const frequencySlider = document.getElementById('pixelSortFrequency');
                   const frequencyDisplay = document.getElementById('vPixelSortFrequency');
                   if (frequencySlider && effects.pixelSort.frequency !== undefined) {
                       frequencySlider.value = effects.pixelSort.frequency;
                       if (frequencyDisplay) frequencyDisplay.textContent = Math.round(effects.pixelSort.frequency * 100) + '%';
                   }

                   // Show pixel sort controls
                   const pixelSortControls = document.getElementById('pixel-sort-controls');
                   if (pixelSortControls) pixelSortControls.style.display = 'block';
               }
           }

           // Update Palette Reduction
           if (effects.paletteReduction) {
               const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
               if (paletteReductionEnabled) paletteReductionEnabled.checked = effects.paletteReduction.enabled || false;

               if (effects.paletteReduction.enabled) {
                   const paletteSelect = document.getElementById('paletteName');
                   if (paletteSelect && effects.paletteReduction.paletteName) {
                       paletteSelect.value = effects.paletteReduction.paletteName;
                   }

                   const distanceSelect = document.getElementById('distanceMode');
                   if (distanceSelect && effects.paletteReduction.distanceMode) {
                       distanceSelect.value = effects.paletteReduction.distanceMode;
                   }

                   const ditheringCheckbox = document.getElementById('useDithering');
                   if (ditheringCheckbox && effects.paletteReduction.useDithering !== undefined) {
                       ditheringCheckbox.checked = effects.paletteReduction.useDithering;
                   }

                   // Show palette reduction controls
                   const paletteReductionControls = document.getElementById('palette-reduction-controls');
                   if (paletteReductionControls) paletteReductionControls.style.display = 'block';
               }
           }

           console.log('🎨 [Glinch] UI controls updated successfully');
       }

       // Utility function for random number generation with seed
       function mulberry32(a) {
           return function() {
               a |= 0;
               a = a + 0x6D2B79F5 | 0;
               let t = Math.imul(a ^ a >>> 15, 1 | a);
               t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
               return ((t ^ t >>> 14) >>> 0) / 4294967296;
           };
       }

       // Utility function to clamp values
       function clamp(v, min = 0, max = 255) {
           return v < min ? min : v > max ? max : v;
       }

       // Color Shift Effect
       function applyColorShift(inputImageData, outputImageData, params) {
           const { width, height, data: src } = inputImageData;
           const dst = outputImageData.data;

           const shiftX = Math.round(params.shiftAmount);
           const intensity = params.intensity;

           // Clear output
           dst.fill(0);

           for (let y = 0; y < height; y++) {
               for (let x = 0; x < width; x++) {
                   const srcIdx = (y * width + x) * 4;

                   // Red channel with positive shift
                   const redX = x + shiftX;
                   if (redX >= 0 && redX < width) {
                       const redIdx = (y * width + redX) * 4;
                       dst[redIdx] = Math.min(255, dst[redIdx] + src[srcIdx] * intensity);
                   }

                   // Green channel (no shift)
                   dst[srcIdx + 1] = Math.min(255, dst[srcIdx + 1] + src[srcIdx + 1] * intensity);

                   // Blue channel with negative shift
                   const blueX = x - shiftX;
                   if (blueX >= 0 && blueX < width) {
                       const blueIdx = (y * width + blueX) * 4;
                       dst[blueIdx + 2] = Math.min(255, dst[blueIdx + 2] + src[srcIdx + 2] * intensity);
                   }

                   // Alpha channel
                   dst[srcIdx + 3] = src[srcIdx + 3];
               }
           }

           return outputImageData;
       }

       // Wave Deform Effect
       function applyWaveDeform(inputImageData, outputImageData, params) {
           const { width, height, data: src } = inputImageData;
           const dst = outputImageData.data;

           const { direction, amplitude, frequency } = params;
           const isHorizontal = direction === "horizontal";

           // Clear output
           dst.fill(0);

           for (let y = 0; y < height; y++) {
               for (let x = 0; x < width; x++) {
                   const srcIdx = (y * width + x) * 4;

                   let newX = x;
                   let newY = y;

                   if (isHorizontal) {
                       newX = x + Math.sin(y * frequency) * amplitude;
                   } else {
                       newY = y + Math.sin(x * frequency) * amplitude;
                   }

                   newX = Math.round(newX);
                   newY = Math.round(newY);

                   if (newX >= 0 && newX < width && newY >= 0 && newY < height) {
                       const newIdx = (newY * width + newX) * 4;
                       dst[newIdx] = src[srcIdx];
                       dst[newIdx + 1] = src[srcIdx + 1];
                       dst[newIdx + 2] = src[srcIdx + 2];
                       dst[newIdx + 3] = src[srcIdx + 3];
                   }
               }
           }

           return outputImageData;
       }

       // Displacement Effect
       function applyDisplacement(inputImageData, outputImageData, params) {
           const { width, height, data: src } = inputImageData;
           const dst = outputImageData.data;

           const { mode, displacementIntensity, displacementSize, displacementFrequency } = params;
           const isHorizontal = mode === 'horizontal';
           const random = mulberry32(12345); // Fixed seed for consistency

           // Copy original data first
           for (let i = 0; i < src.length; i++) {
               dst[i] = src[i];
           }

           // Apply displacement in blocks
           const blockCount = Math.floor((isHorizontal ? height : width) / displacementSize);

           for (let block = 0; block < blockCount; block++) {
               if (random() > displacementFrequency) continue;

               const displacement = Math.round((random() - 0.5) * 2 * displacementIntensity);
               const blockStart = block * displacementSize;
               const blockEnd = Math.min(blockStart + displacementSize, isHorizontal ? height : width);

               for (let i = blockStart; i < blockEnd; i++) {
                   if (isHorizontal) {
                       // Horizontal displacement
                       for (let x = 0; x < width; x++) {
                           const srcX = x + displacement;
                           if (srcX >= 0 && srcX < width) {
                               const srcIdx = (i * width + srcX) * 4;
                               const dstIdx = (i * width + x) * 4;
                               dst[dstIdx] = src[srcIdx];
                               dst[dstIdx + 1] = src[srcIdx + 1];
                               dst[dstIdx + 2] = src[srcIdx + 2];
                               dst[dstIdx + 3] = src[srcIdx + 3];
                           }
                       }
                   } else {
                       // Vertical displacement
                       for (let y = 0; y < height; y++) {
                           const srcY = y + displacement;
                           if (srcY >= 0 && srcY < height) {
                               const srcIdx = (srcY * width + i) * 4;
                               const dstIdx = (y * width + i) * 4;
                               dst[dstIdx] = src[srcIdx];
                               dst[dstIdx + 1] = src[srcIdx + 1];
                               dst[dstIdx + 2] = src[srcIdx + 2];
                               dst[dstIdx + 3] = src[srcIdx + 3];
                           }
                       }
                   }
               }
           }

           return outputImageData;
       }

       // Pixel Sort Effect
       function applyPixelSort(inputImageData, outputImageData, params) {
           const { width, height, data: src } = inputImageData;
           const dst = outputImageData.data;

           const { direction, blockSize, frequency } = params;
           const isHorizontal = direction === 'horizontal';
           const random = mulberry32(54321); // Fixed seed for consistency

           // Copy original data first
           for (let i = 0; i < src.length; i++) {
               dst[i] = src[i];
           }

           if (isHorizontal) {
               // Process horizontal blocks
               for (let y = 0; y < height; y += blockSize) {
                   for (let x = 0; x < width; x += blockSize) {
                       if (random() > frequency) continue;

                       const blockWidth = Math.min(blockSize, width - x);
                       const blockHeight = Math.min(blockSize, height - y);

                       // Extract pixels from block
                       const pixels = [];
                       for (let by = 0; by < blockHeight; by++) {
                           for (let bx = 0; bx < blockWidth; bx++) {
                               const idx = ((y + by) * width + (x + bx)) * 4;
                               pixels.push([dst[idx], dst[idx + 1], dst[idx + 2], dst[idx + 3]]);
                           }
                       }

                       // Shuffle pixels
                       for (let i = pixels.length - 1; i > 0; i--) {
                           const j = Math.floor(random() * (i + 1));
                           [pixels[i], pixels[j]] = [pixels[j], pixels[i]];
                       }

                       // Put pixels back
                       let pixelIndex = 0;
                       for (let by = 0; by < blockHeight; by++) {
                           for (let bx = 0; bx < blockWidth; bx++) {
                               const idx = ((y + by) * width + (x + bx)) * 4;
                               const pixel = pixels[pixelIndex++];
                               dst[idx] = pixel[0];
                               dst[idx + 1] = pixel[1];
                               dst[idx + 2] = pixel[2];
                               dst[idx + 3] = pixel[3];
                           }
                       }
                   }
               }
           }

           return outputImageData;
       }

       // Predefined color palettes for palette reduction
       const predefinedPalettes = {
           gameboy: [
               [15, 56, 15],
               [48, 98, 48],
               [139, 172, 15],
               [155, 188, 15]
           ],
           firewatch: [
               [255, 94, 77],
               [255, 160, 0],
               [72, 52, 212],
               [29, 29, 29]
           ],
           desert: [
               [239, 214, 167],
               [201, 133, 61],
               [129, 80, 47],
               [60, 42, 33]
           ],
           lavender: [
               [32, 32, 64],
               [96, 64, 128],
               [160, 128, 192],
               [240, 240, 255]
           ],
           strangerThings: [
               [12, 12, 20],
               [220, 30, 30],
               [240, 240, 240],
               [30, 30, 60]
           ],
           dawnbringer: [
               [20, 12, 28],
               [68, 36, 52],
               [48, 52, 109],
               [208, 70, 72],
               [210, 125, 44],
               [109, 194, 202],
               [218, 212, 94],
               [222, 238, 214]
           ],
           blackwhite: [
               [0, 0, 0],
               [255, 255, 255]
           ],
           grayscale4: [
               [0, 0, 0],
               [85, 85, 85],
               [170, 170, 170],
               [255, 255, 255]
           ],
           bladeRunner: [
               [10, 10, 30],
               [200, 30, 60],
               [30, 150, 200],
               [250, 180, 80]
           ],
           madMax: [
               [255, 213, 79],
               [244, 67, 54],
               [33, 33, 33],
               [158, 158, 158]
           ],
           matrix: [
               [0, 0, 0],
               [0, 255, 70],
               [20, 20, 20],
               [100, 255, 180]
           ],
           tronLegacy: [
               [0, 0, 0],
               [0, 240, 255],
               [255, 255, 255],
               [0, 60, 160]
           ],
           drive: [
               [255, 0, 128],
               [255, 255, 255],
               [10, 10, 10],
               [80, 0, 120]
           ],
           akira: [
               [255, 0, 0],
               [30, 30, 30],
               [255, 230, 200],
               [80, 80, 80]
           ],
           vaporwave: [
               [255, 105, 180],
               [0, 255, 255],
               [255, 255, 255],
               [20, 20, 20]
           ],
           miamiVice: [
               [255, 85, 170],
               [0, 204, 204],
               [255, 255, 255],
               [0, 0, 0]
           ],
           lofi: [
               [144, 129, 112],
               [192, 159, 142],
               [236, 208, 185],
               [78, 61, 53]
           ],
           nes: [
               [124, 124, 124],
               [0, 0, 252],
               [252, 0, 0],
               [0, 0, 0]
           ],
           glitchCore: [
               [0, 255, 255],
               [255, 0, 255],
               [255, 255, 0],
               [0, 0, 0]
           ],
           acid: [
               [255, 0, 255],
               [0, 255, 0],
               [0, 0, 255],
               [255, 255, 0]
           ]
       };

       // Helper function to get distance calculation function
       function getDistanceFunction(mode) {
           switch (mode) {
               case "fast":
                   return function(r, g, b, pr, pg, pb) {
                       return Math.abs(r - pr) + Math.abs(g - pg) + Math.abs(b - pb);
                   };
               case "perceptual":
                   return function(r, g, b, pr, pg, pb) {
                       let dr = r - pr;
                       let dg = g - pg;
                       let db = b - pb;
                       return 0.3 * dr * dr + 0.59 * dg * dg + 0.11 * db * db;
                   };
               case "accurate":
               default:
                   return function(r, g, b, pr, pg, pb) {
                       let dr = r - pr;
                       let dg = g - pg;
                       let db = b - pb;
                       return dr * dr + dg * dg + db * db;
                   };
           }
       }

       // Helper function to distribute error for dithering
       function distributeError(data, width, height, x, y, errR, errG, errB) {
           const diffusion = [
               [1, 0, 7 / 16],
               [-1, 1, 3 / 16],
               [0, 1, 5 / 16],
               [1, 1, 1 / 16]
           ];

           for (const [dx, dy, factor] of diffusion) {
               const nx = x + dx;
               const ny = y + dy;

               if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                   const ni = (ny * width + nx) * 4;
                   data[ni] = clamp(data[ni] + errR * factor);
                   data[ni + 1] = clamp(data[ni + 1] + errG * factor);
                   data[ni + 2] = clamp(data[ni + 2] + errB * factor);
               }
           }
       }

       // Palette Reduction Effect
       function applyPaletteReduction(inputImageData, outputImageData, params) {
           const paletteName = params.paletteName || "desert";
           const distanceMode = params.distanceMode || "accurate";
           const useDithering = params.useDithering;

           const palette = predefinedPalettes[paletteName] || predefinedPalettes.desert;
           const src = inputImageData.data;
           const dst = outputImageData.data;
           const width = inputImageData.width;
           const height = inputImageData.height;
           const len = src.length;
           const palLen = palette.length;

           const getDist = getDistanceFunction(distanceMode);
           const cache = new Map();

           const palette32 = new Uint32Array(palLen);
           for (let j = 0; j < palLen; j++) {
               const [pr, pg, pb] = palette[j];
               palette32[j] = (pr << 24) | (pg << 16) | (pb << 8);
           }

           const temp = useDithering ? new Uint8ClampedArray(src) : src;

           let i = 0, j = 0;
           let r = 0, g = 0, b = 0, a = 0;
           let key = 0, match = 0, minDist = 0, dist = 0, nearest = 0;
           let pr = 0, pg = 0, pb = 0;
           let errR = 0, errG = 0, errB = 0;
           let x = 0, y = 0;

           for (i = 0; i < len; i += 4) {
               r = temp[i];
               g = temp[i + 1];
               b = temp[i + 2];
               a = temp[i + 3];

               key = (r << 16) | (g << 8) | b;

               match = cache.get(key);
               if (match === undefined) {
                   minDist = Infinity;
                   nearest = 0;

                   for (j = 0; j < palLen; j++) {
                       const p = palette32[j];
                       pr = (p >> 24) & 0xFF;
                       pg = (p >> 16) & 0xFF;
                       pb = (p >> 8) & 0xFF;

                       dist = getDist(r, g, b, pr, pg, pb);
                       if (dist < minDist) {
                           minDist = dist;
                           nearest = p;
                           if (dist === 0) break;
                       }
                   }

                   match = nearest;
                   cache.set(key, match);
               }

               const nr = (match >> 24) & 0xFF;
               const ng = (match >> 16) & 0xFF;
               const nb = (match >> 8) & 0xFF;

               dst[i] = nr;
               dst[i + 1] = ng;
               dst[i + 2] = nb;
               dst[i + 3] = a;

               if (useDithering) {
                   errR = r - nr;
                   errG = g - ng;
                   errB = b - nb;

                   x = (i >> 2) % width;
                   y = (i >> 2) / width | 0;

                   distributeError(temp, width, height, x, y, errR, errG, errB);

                   temp[i] = nr;
                   temp[i + 1] = ng;
                   temp[i + 2] = nb;
               }
           }
           return outputImageData;
       }

       // Function to create glitch image using multiple effects
       function createGlinchImageSync(originalImage, effects) {
           try {
               console.log('🎨 [Glinch] Creating glitch image with effects:', effects);

               // Check if image is ready for processing
               if (!isImageReady(originalImage)) {
                   console.log('🎨 [Glinch] Image not ready for processing, skipping glitch effect');
                   return originalImage;
               }

               // Create an offscreen canvas
               const offscreenCanvas = document.createElement('canvas');
               const offscreenCtx = offscreenCanvas.getContext('2d');

               // Set canvas size to match original image
               const width = originalImage.naturalWidth || originalImage.width || 100;
               const height = originalImage.naturalHeight || originalImage.height || 100;

               // Validate dimensions
               if (width <= 0 || height <= 0) {
                   console.error('🎨 [Glinch] Invalid canvas dimensions:', width, 'x', height);
                   return originalImage; // Return original image if dimensions are invalid
               }

               offscreenCanvas.width = width;
               offscreenCanvas.height = height;

               console.log('🎨 [Glinch] Canvas size:', width, 'x', height);

               // Draw the original image
               offscreenCtx.drawImage(originalImage, 0, 0, width, height);

               // Get the image data for pixel manipulation
               let imageData, outputData;
               try {
                   imageData = offscreenCtx.getImageData(0, 0, width, height);
                   outputData = new ImageData(width, height);
               } catch (error) {
                   console.error('🎨 [Glinch] Error getting image data:', error);
                   return originalImage; // Return original image if we can't get image data
               }

               // Apply effects in sequence
               if (effects.paletteReduction && effects.paletteReduction.enabled) {
                   outputData = new ImageData(width, height);
                   applyPaletteReduction(imageData, outputData, effects.paletteReduction);
                   imageData = outputData;
               }

               if (effects.colorShift && effects.colorShift.enabled) {
                   outputData = new ImageData(width, height);
                   applyColorShift(imageData, outputData, effects.colorShift);
                   imageData = outputData;
               }

               if (effects.waveDeform && effects.waveDeform.enabled) {
                   outputData = new ImageData(width, height);
                   applyWaveDeform(imageData, outputData, effects.waveDeform);
                   imageData = outputData;
               }

               if (effects.displacement && effects.displacement.enabled) {
                   outputData = new ImageData(width, height);
                   applyDisplacement(imageData, outputData, effects.displacement);
                   imageData = outputData;
               }

               if (effects.pixelSort && effects.pixelSort.enabled) {
                   outputData = new ImageData(width, height);
                   applyPixelSort(imageData, outputData, effects.pixelSort);
                   imageData = outputData;
               }

               // Put the modified image data back
               offscreenCtx.putImageData(imageData, 0, 0);

               // Create new image from the glitch canvas
               const glinchImg = new Image();
               glinchImg.src = offscreenCanvas.toDataURL();

               console.log('🎨 [Glinch] Glitch image created successfully');
               return glinchImg;

           } catch (error) {
               console.error('🎨 [Glinch] Error creating glitch image:', error);
               return originalImage; // Return original on error
           }
       }

       // Function to apply glitch effects to selected image
       function applyGlinchEffects() {
           console.log('🎨 [Glinch] ===== APPLY GLINCH EFFECTS CALLED =====');

           // Find the selected object
           let selectedObject = null;
           let selectedIndex = -1;

           if (window.canvasObjects) {
               console.log('🎨 [Glinch] Checking', window.canvasObjects.length, 'canvas objects for selection');
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected) {
                       selectedObject = window.canvasObjects[i];
                       selectedIndex = i;
                       console.log('🎨 [Glinch] Found selected object at index', i, 'type:', selectedObject.type);
                       break;
                   }
               }
           }

           if (!selectedObject || selectedObject.type !== 'image') {
               console.log('🎨 [Glinch] No image selected');
               return;
           }

           // Collect enabled effects and their parameters
           const effects = {};

           // Palette Reduction
           const paletteReductionEnabled = document.getElementById('paletteReductionEnabled')?.checked || false;
           if (paletteReductionEnabled) {
               effects.paletteReduction = {
                   enabled: true,
                   paletteName: document.getElementById('paletteName')?.value || 'desert',
                   distanceMode: document.getElementById('distanceMode')?.value || 'accurate',
                   useDithering: document.getElementById('useDithering')?.checked || true
               };
           }

           // Color Shift
           const colorShiftEnabled = document.getElementById('colorShiftEnabled')?.checked || false;
           if (colorShiftEnabled) {
               effects.colorShift = {
                   enabled: true,
                   intensity: parseFloat(document.getElementById('colorShiftIntensity')?.value || 1),
                   shiftAmount: parseFloat(document.getElementById('colorShiftAmount')?.value || 20)
               };
           }

           // Wave Deform
           const waveDeformEnabled = document.getElementById('waveDeformEnabled')?.checked || false;
           if (waveDeformEnabled) {
               effects.waveDeform = {
                   enabled: true,
                   direction: document.getElementById('waveDirection')?.value || 'horizontal',
                   amplitude: parseFloat(document.getElementById('waveAmplitude')?.value || 10),
                   frequency: parseFloat(document.getElementById('waveFrequency')?.value || 0.05)
               };
           }

           // Displacement
           const displacementEnabled = document.getElementById('displacementEnabled')?.checked || false;
           if (displacementEnabled) {
               effects.displacement = {
                   enabled: true,
                   mode: document.getElementById('displacementMode')?.value || 'horizontal',
                   displacementIntensity: parseFloat(document.getElementById('displacementIntensity')?.value || 8),
                   displacementSize: parseFloat(document.getElementById('displacementSize')?.value || 18),
                   displacementFrequency: 0.5
               };
           }

           // Pixel Sort
           const pixelSortEnabled = document.getElementById('pixelSortEnabled')?.checked || false;
           if (pixelSortEnabled) {
               effects.pixelSort = {
                   enabled: true,
                   direction: document.getElementById('pixelSortDirection')?.value || 'horizontal',
                   blockSize: parseFloat(document.getElementById('pixelSortBlockSize')?.value || 5),
                   frequency: parseFloat(document.getElementById('pixelSortFrequency')?.value || 0.5)
               };
           }

           console.log('🎨 [Glinch] Applying effects:', effects);

           // Store glitch settings in the image object
           selectedObject.glinchEffects = effects;
           selectedObject.glinchEnabled = Object.keys(effects).length > 0;

           // 🎯 CRITICAL: Clear glitch cache when parameters change
           // This ensures the new dithering setting is applied
           if (selectedObject.glinchImageCache) {
               selectedObject.glinchImageCache = {};
               console.log('🎨 [Glinch] Cleared glitch cache to apply new parameters');
           }

           // Trigger unified pipeline update to show the glitch effects
           if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
               console.log('🎨 [Glinch] Triggering unified pipeline update');
               window.imageEffectsPipeline.triggerPipelineUpdate('glitch-change');
           } else {
               // Fallback to immediate update if pipeline not available
               if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                   console.log('🎨 [Glinch] Fallback: Using immediate update');
                   window.immediateUpdate('glitch-fallback');
               } else if (window.update && typeof window.update === 'function') {
                   console.log('🎨 [Glinch] Fallback: Calling window.update()');
                   window.update();

                   // Force a second update to ensure glitch is visible
                   setTimeout(() => {
                       console.log('🎨 [Glinch] Forcing second update to ensure visibility');
                       window.update();
                   }, 50);
               }
           }
       }

       // Make applyGlinchEffects globally accessible for template save/load functionality
       window.applyGlinchEffects = applyGlinchEffects;

       // Function to setup glitch controls
       function setupGlinchControls() {
           console.log('🎨 [Glinch] Setting up glitch controls...');

           // Palette Reduction Controls
           const paletteReductionEnabled = document.getElementById('paletteReductionEnabled');
           const paletteReductionControls = document.getElementById('palette-reduction-controls');
           const paletteName = document.getElementById('paletteName');
           const distanceMode = document.getElementById('distanceMode');
           const useDithering = document.getElementById('useDithering');

           if (paletteReductionEnabled) {
               paletteReductionEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Glinch] Palette Reduction toggle changed:', e.target.checked);
                   if (paletteReductionControls) {
                       paletteReductionControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyGlinchEffects();
               });
           }

           if (paletteName) {
               paletteName.addEventListener('change', () => applyGlinchEffects());
           }

           if (distanceMode) {
               distanceMode.addEventListener('change', () => applyGlinchEffects());
           }

           if (useDithering) {
               useDithering.addEventListener('change', () => applyGlinchEffects());
           }

           // Color Shift Controls
           const colorShiftEnabled = document.getElementById('colorShiftEnabled');
           const colorShiftControls = document.getElementById('color-shift-controls');
           const colorShiftIntensity = document.getElementById('colorShiftIntensity');
           const colorShiftAmount = document.getElementById('colorShiftAmount');

           if (colorShiftEnabled) {
               colorShiftEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Glinch] Color Shift toggle changed:', e.target.checked);
                   if (colorShiftControls) {
                       colorShiftControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyGlinchEffects();
               });
           }

           if (colorShiftIntensity) {
               colorShiftIntensity.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vColorShiftIntensity');
                   if (display) display.textContent = Math.round(value * 100) + '%';
                   applyGlinchEffects();
               });
           }

           if (colorShiftAmount) {
               colorShiftAmount.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vColorShiftAmount');
                   if (display) display.textContent = value + 'px';
                   applyGlinchEffects();
               });
           }

           // Wave Deform Controls
           const waveDeformEnabled = document.getElementById('waveDeformEnabled');
           const waveDeformControls = document.getElementById('wave-deform-controls');
           const waveDirection = document.getElementById('waveDirection');
           const waveAmplitude = document.getElementById('waveAmplitude');
           const waveFrequency = document.getElementById('waveFrequency');

           if (waveDeformEnabled) {
               waveDeformEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Glinch] Wave Deform toggle changed:', e.target.checked);
                   if (waveDeformControls) {
                       waveDeformControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyGlinchEffects();
               });
           }

           if (waveDirection) {
               waveDirection.addEventListener('change', () => applyGlinchEffects());
           }

           if (waveAmplitude) {
               waveAmplitude.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vWaveAmplitude');
                   if (display) display.textContent = value + 'px';
                   applyGlinchEffects();
               });
           }

           if (waveFrequency) {
               waveFrequency.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vWaveFrequency');
                   if (display) display.textContent = value.toFixed(2);
                   applyGlinchEffects();
               });
           }

           // Displacement Controls
           const displacementEnabled = document.getElementById('displacementEnabled');
           const displacementControls = document.getElementById('displacement-controls');
           const displacementMode = document.getElementById('displacementMode');
           const displacementIntensity = document.getElementById('displacementIntensity');
           const displacementSize = document.getElementById('displacementSize');

           if (displacementEnabled) {
               displacementEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Glinch] Displacement toggle changed:', e.target.checked);
                   if (displacementControls) {
                       displacementControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyGlinchEffects();
               });
           }

           if (displacementMode) {
               displacementMode.addEventListener('change', () => applyGlinchEffects());
           }

           if (displacementIntensity) {
               displacementIntensity.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vDisplacementIntensity');
                   if (display) display.textContent = value;
                   applyGlinchEffects();
               });
           }

           if (displacementSize) {
               displacementSize.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vDisplacementSize');
                   if (display) display.textContent = value;
                   applyGlinchEffects();
               });
           }

           // Pixel Sort Controls
           const pixelSortEnabled = document.getElementById('pixelSortEnabled');
           const pixelSortControls = document.getElementById('pixel-sort-controls');
           const pixelSortDirection = document.getElementById('pixelSortDirection');
           const pixelSortBlockSize = document.getElementById('pixelSortBlockSize');
           const pixelSortFrequency = document.getElementById('pixelSortFrequency');

           if (pixelSortEnabled) {
               pixelSortEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Glinch] Pixel Sort toggle changed:', e.target.checked);
                   if (pixelSortControls) {
                       pixelSortControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyGlinchEffects();
               });
           }

           if (pixelSortDirection) {
               pixelSortDirection.addEventListener('change', () => applyGlinchEffects());
           }

           if (pixelSortBlockSize) {
               pixelSortBlockSize.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vPixelSortBlockSize');
                   if (display) display.textContent = value;
                   applyGlinchEffects();
               });
           }

           if (pixelSortFrequency) {
               pixelSortFrequency.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vPixelSortFrequency');
                   if (display) display.textContent = Math.round(value * 100) + '%';
                   applyGlinchEffects();
               });
           }

           // Reset button
           const resetGlinchBtn = document.getElementById('resetGlinchBtn');
           if (resetGlinchBtn) {
               resetGlinchBtn.addEventListener('click', () => {
                   console.log('🎨 [Glinch] Reset button clicked');

                   // Reset all toggles
                   if (paletteReductionEnabled) paletteReductionEnabled.checked = false;
                   if (colorShiftEnabled) colorShiftEnabled.checked = false;
                   if (waveDeformEnabled) waveDeformEnabled.checked = false;
                   if (displacementEnabled) displacementEnabled.checked = false;
                   if (pixelSortEnabled) pixelSortEnabled.checked = false;

                   // Hide all control panels
                   if (paletteReductionControls) paletteReductionControls.style.display = 'none';
                   if (colorShiftControls) colorShiftControls.style.display = 'none';
                   if (waveDeformControls) waveDeformControls.style.display = 'none';
                   if (displacementControls) displacementControls.style.display = 'none';
                   if (pixelSortControls) pixelSortControls.style.display = 'none';

                   // Reset all values to defaults
                   if (paletteName) paletteName.value = 'desert';
                   if (distanceMode) distanceMode.value = 'accurate';
                   if (useDithering) useDithering.checked = true;

                   if (colorShiftIntensity) {
                       colorShiftIntensity.value = 1;
                       const display = document.getElementById('vColorShiftIntensity');
                       if (display) display.textContent = '100%';
                   }
                   if (colorShiftAmount) {
                       colorShiftAmount.value = 20;
                       const display = document.getElementById('vColorShiftAmount');
                       if (display) display.textContent = '20px';
                   }
                   if (waveAmplitude) {
                       waveAmplitude.value = 10;
                       const display = document.getElementById('vWaveAmplitude');
                       if (display) display.textContent = '10px';
                   }
                   if (waveFrequency) {
                       waveFrequency.value = 0.05;
                       const display = document.getElementById('vWaveFrequency');
                       if (display) display.textContent = '0.05';
                   }
                   if (displacementIntensity) {
                       displacementIntensity.value = 8;
                       const display = document.getElementById('vDisplacementIntensity');
                       if (display) display.textContent = '8';
                   }
                   if (displacementSize) {
                       displacementSize.value = 18;
                       const display = document.getElementById('vDisplacementSize');
                       if (display) display.textContent = '18';
                   }
                   if (pixelSortBlockSize) {
                       pixelSortBlockSize.value = 5;
                       const display = document.getElementById('vPixelSortBlockSize');
                       if (display) display.textContent = '5';
                   }
                   if (pixelSortFrequency) {
                       pixelSortFrequency.value = 0.5;
                       const display = document.getElementById('vPixelSortFrequency');
                       if (display) display.textContent = '50%';
                   }

                   applyGlinchEffects();
               });
           }

           console.log('🎨 [Glinch] Glitch controls setup complete');
       }

       // Initialize glitch controls when DOM is ready
       document.addEventListener('DOMContentLoaded', () => {
           console.log('🎨 [Glinch] DOMContentLoaded event fired, setting up glitch...');
           setTimeout(() => {
               setupGlinchControls();
           }, 1000); // Delay to ensure all elements are ready
       });

       if (document.readyState !== 'loading') {
           console.log('🎨 [Glinch] DOM already loaded, setting up glitch with delay...');
           setTimeout(setupGlinchControls, 1000);
       }

       // ===== DUOTONE EFFECTS FUNCTIONALITY =====

       // Helper function to check if image is ready for processing
       function isImageReady(image) {
           if (!image) return false;

           if (image.tagName === 'IMG') {
               return image.complete && image.naturalWidth > 0 && image.naturalHeight > 0;
           }

           if (image.tagName === 'CANVAS') {
               return image.width > 0 && image.height > 0;
           }

           return false;
       }

       // Function to create duotone image synchronously
       function createDuotoneImageSync(sourceImage, matrixValues) {
           console.log('🎨 [DuoTone] Creating duotone image synchronously');

           // Check if image is ready for processing
           if (!isImageReady(sourceImage)) {
               console.log('🎨 [DuoTone] Image not ready for processing, skipping duotone effect');
               return sourceImage;
           }

           // Create canvas for duotone processing
           const canvas = document.createElement('canvas');
           const ctx = canvas.getContext('2d');

           // Try multiple ways to get image dimensions
           let width = sourceImage.naturalWidth || sourceImage.width;
           let height = sourceImage.naturalHeight || sourceImage.height;

           // If still no dimensions, try to get from the image element itself
           if ((!width || !height) && sourceImage.tagName === 'IMG') {
               // Force image to load if not loaded
               if (!sourceImage.complete) {
                   console.log('🎨 [DuoTone] Image not loaded yet, skipping duotone effect');
                   return sourceImage;
               }
               width = sourceImage.offsetWidth || sourceImage.clientWidth;
               height = sourceImage.offsetHeight || sourceImage.clientHeight;
           }

           // If it's a canvas, get canvas dimensions
           if ((!width || !height) && sourceImage.tagName === 'CANVAS') {
               width = sourceImage.width;
               height = sourceImage.height;
           }

           // Final fallback - use a default size if we still don't have dimensions
           if (!width || !height) {
               console.warn('🎨 [DuoTone] Could not determine image dimensions, using fallback');
               width = 300;
               height = 300;
           }

           canvas.width = width;
           canvas.height = height;

           // Validate canvas dimensions
           if (canvas.width <= 0 || canvas.height <= 0) {
               console.error('🎨 [DuoTone] Invalid canvas dimensions after all attempts:', canvas.width, 'x', canvas.height);
               console.error('🎨 [DuoTone] Source image details:', {
                   tagName: sourceImage.tagName,
                   naturalWidth: sourceImage.naturalWidth,
                   naturalHeight: sourceImage.naturalHeight,
                   width: sourceImage.width,
                   height: sourceImage.height,
                   complete: sourceImage.complete,
                   src: sourceImage.src ? sourceImage.src.substring(0, 50) + '...' : 'no src'
               });
               return sourceImage; // Return original image if dimensions are invalid
           }

           // Draw the source image
           try {
               ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);
           } catch (error) {
               console.error('🎨 [DuoTone] Error drawing source image:', error);
               return sourceImage;
           }

           // Get image data for processing
           const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
           const data = imageData.data;

           // Parse matrix values - handle both string and array formats
           let matrix;
           if (typeof matrixValues === 'string') {
               matrix = matrixValues.split(' ').map(parseFloat);
           } else if (Array.isArray(matrixValues)) {
               matrix = matrixValues;
           } else {
               console.error('🎨 [DuoTone] Invalid matrix format:', matrixValues);
               return sourceImage;
           }

           // Apply duotone matrix transformation
           for (let i = 0; i < data.length; i += 4) {
               const r = data[i];
               const g = data[i + 1];
               const b = data[i + 2];
               const a = data[i + 3];

               // Apply color matrix transformation
               data[i] = Math.min(255, Math.max(0,
                   r * matrix[0] + g * matrix[1] + b * matrix[2] + a * matrix[3] + matrix[4] * 255));
               data[i + 1] = Math.min(255, Math.max(0,
                   r * matrix[5] + g * matrix[6] + b * matrix[7] + a * matrix[8] + matrix[9] * 255));
               data[i + 2] = Math.min(255, Math.max(0,
                   r * matrix[10] + g * matrix[11] + b * matrix[12] + a * matrix[13] + matrix[14] * 255));
               data[i + 3] = Math.min(255, Math.max(0,
                   r * matrix[15] + g * matrix[16] + b * matrix[17] + a * matrix[18] + matrix[19] * 255));
           }

           // Put the processed data back
           ctx.putImageData(imageData, 0, 0);

           // Create and return new image
           const duotoneImg = new Image();
           duotoneImg.src = canvas.toDataURL();

           console.log('🎨 [DuoTone] Duotone image created successfully');
           return duotoneImg;
       }

       // ===== HALFTONE EFFECTS FUNCTIONALITY =====

       // Function to reset CSS filter UI controls to defaults
       function resetCSSFilterUIControls() {
           const filterControls = [
               { id: 'iImageBlur', defaultValue: 0, unit: 'px' },
               { id: 'iImageBrightness', defaultValue: 1, unit: '%', multiplier: 100 },
               { id: 'iImageContrast', defaultValue: 1, unit: '%', multiplier: 100 },
               { id: 'iImageSaturation', defaultValue: 1, unit: '%', multiplier: 100 },
               { id: 'iImageHue', defaultValue: 0, unit: '°' },
               { id: 'iImageGrayscale', defaultValue: 0, unit: '%', multiplier: 100 },
               { id: 'iImageSepia', defaultValue: 0, unit: '%', multiplier: 100 },
               { id: 'iImageInvert', defaultValue: 0, unit: '%', multiplier: 100 }
           ];

           filterControls.forEach(control => {
               const element = document.getElementById(control.id);
               if (element) {
                   element.value = control.defaultValue;

                   // Update display
                   const displayElement = document.getElementById('v' + control.id.substring(1));
                   if (displayElement) {
                       if (control.multiplier) {
                           displayElement.textContent = Math.round(control.defaultValue * control.multiplier) + control.unit;
                       } else {
                           displayElement.textContent = control.defaultValue + control.unit;
                       }
                   }
               }
           });
       }

       // Function to reset all effect settings to defaults
       function resetAllEffectSettings(selectedObject) {
           console.log('🎨 [All Effects] Resetting all effect settings to defaults');

           if (!selectedObject) return;

           // Clear all effect caches first
           if (selectedObject.duotoneImageCache) {
               selectedObject.duotoneImageCache = {};
               console.log('🎨 [Reset] Cleared duotone cache');
           }
           if (selectedObject.glinchImageCache) {
               selectedObject.glinchImageCache = {};
               console.log('🎨 [Reset] Cleared glitch cache');
           }
           if (selectedObject.halftoneImageCache) {
               selectedObject.halftoneImageCache = {};
               console.log('🎨 [Reset] Cleared halftone cache');
           }

           // Reset CSS filters
           selectedObject.cssFilters = {
               brightness: 100,
               contrast: 100,
               saturation: 100,
               hue: 0,
               blur: 0,
               sepia: 0,
               grayscale: 0,
               invert: 0,
               opacity: 100
           };

           // Reset duotone settings with correct default colors
           selectedObject.duotoneSettings = {
               enabled: false,
               color1: '#3B82F6',  // Default blue
               color2: '#EAB308',  // Default yellow
               intensity: 50
           };
           selectedObject.duotoneEnabled = false;
           delete selectedObject.duotoneColor1;
           delete selectedObject.duotoneColor2;
           delete selectedObject.duotoneMatrix;

           // Reset glitch settings
           selectedObject.glitchSettings = {
               enabled: false,
               rgbShift: 0,
               scanLines: 0,
               noise: 0,
               displacement: 0,
               colorShift: 0
           };
           selectedObject.glinchEnabled = false;
           delete selectedObject.glinchEffects;
           selectedObject.glinchEnabled = false;
           selectedObject.glinchEffects = null;

           // Reset halftone settings
           selectedObject.halftoneSettings = {
               enabled: false,
               dotSize: 4,
               dotColor: '#000000',
               lineContrast: 50,
               photoBrightness: 100,
               photoContrast: 100,
               photoBlur: 0,
               grayscale: true,
               blendMode: 'multiply'
           };
           selectedObject.halftoneEnabled = false;

           // Reset all UI controls to match the reset values
           resetAllEffectUIControls();

           console.log('🎨 [All Effects] All effect settings and UI controls reset to defaults');
       }

       // Function to log all current effect settings
       function logAllEffectSettings(operation = 'Current State') {
           console.log(`🎨 [${operation}] ========== ALL EFFECT SETTINGS ==========`);

           // CSS Filters
           console.log(`🎨 [${operation}] CSS FILTERS:`);
           const cssFilters = {
               blur: document.getElementById('iImageBlur')?.value || 0,
               brightness: document.getElementById('iImageBrightness')?.value || 1,
               contrast: document.getElementById('iImageContrast')?.value || 1,
               saturation: document.getElementById('iImageSaturation')?.value || 1,
               hue: document.getElementById('iImageHue')?.value || 0,
               grayscale: document.getElementById('iImageGrayscale')?.value || 0,
               sepia: document.getElementById('iImageSepia')?.value || 0,
               invert: document.getElementById('iImageInvert')?.value || 0
           };
           console.log(`🎨 [${operation}] CSS Filters:`, cssFilters);

           // Duotone Settings
           console.log(`🎨 [${operation}] DUOTONE SETTINGS:`);
           const duotoneSettings = {
               enabled: document.getElementById('duotoneEnabled')?.checked || false,
               color1: document.getElementById('duotoneColor1')?.value || '#3B82F6',
               color2: document.getElementById('duotoneColor2')?.value || '#EAB308'
           };
           console.log(`🎨 [${operation}] Duotone:`, duotoneSettings);

           // Glitch Settings
           console.log(`🎨 [${operation}] GLITCH SETTINGS:`);
           const glitchSettings = {
               colorShift: {
                   enabled: document.getElementById('colorShiftEnabled')?.checked || false,
                   intensity: document.getElementById('colorShiftIntensity')?.value || 1,
                   amount: document.getElementById('colorShiftAmount')?.value || 20
               },
               waveDeform: {
                   enabled: document.getElementById('waveDeformEnabled')?.checked || false,
                   direction: document.getElementById('waveDirection')?.value || 'horizontal',
                   amplitude: document.getElementById('waveAmplitude')?.value || 10,
                   frequency: document.getElementById('waveFrequency')?.value || 0.05
               },
               displacement: {
                   enabled: document.getElementById('displacementEnabled')?.checked || false,
                   mode: document.getElementById('displacementMode')?.value || 'horizontal',
                   intensity: document.getElementById('displacementIntensity')?.value || 8,
                   size: document.getElementById('displacementSize')?.value || 18
               },
               pixelSort: {
                   enabled: document.getElementById('pixelSortEnabled')?.checked || false,
                   direction: document.getElementById('pixelSortDirection')?.value || 'horizontal',
                   blockSize: document.getElementById('pixelSortBlockSize')?.value || 5,
                   frequency: document.getElementById('pixelSortFrequency')?.value || 0.5
               },
               paletteReduction: {
                   enabled: document.getElementById('paletteReductionEnabled')?.checked || false,
                   palette: document.getElementById('paletteName')?.value || 'desert',
                   distance: document.getElementById('distanceMode')?.value || 'accurate',
                   dithering: document.getElementById('useDithering')?.checked || true
               }
           };
           console.log(`🎨 [${operation}] Glitch Effects:`, glitchSettings);

           // Halftone Settings
           console.log(`🎨 [${operation}] HALFTONE SETTINGS:`);
           const halftoneSettings = {
               enabled: document.getElementById('halftoneEnabled')?.checked || false,
               dotSize: document.getElementById('halftoneDotSize')?.value || 0.4,
               grayscale: document.getElementById('halftoneGrayscale')?.checked || false,
               lineContrast: document.getElementById('halftoneLineContrast')?.value || 1050,
               photoBrightness: document.getElementById('halftonePhotoBrightness')?.value || 70,
               photoContrast: document.getElementById('halftonePhotoContrast')?.value || 100,
               photoBlur: document.getElementById('halftonePhotoBlur')?.value || 0,
               blendMode: document.getElementById('halftoneBlendMode')?.value || 'multiply',
               dotColor: document.getElementById('halftoneDotColor')?.value || '#333333',
               hasUploadedImage: document.getElementById('halftoneImageUpload')?.files?.length > 0 || false
           };
           console.log(`🎨 [${operation}] Halftone:`, halftoneSettings);

           console.log(`🎨 [${operation}] ========== END EFFECT SETTINGS ==========`);

           return {
               cssFilters,
               duotoneSettings,
               glitchSettings,
               halftoneSettings
           };
       }

       // Function to reset all UI controls to default values
       function resetAllEffectUIControls() {
           console.log('🎨 [Reset UI] Resetting all effect UI controls to defaults');

           // Log settings BEFORE reset
           logAllEffectSettings('BEFORE RESET');

           // Reset CSS Filter controls and apply them
           resetCSSFilterUIControls();

           // Apply the reset CSS filters to the image
           setTimeout(() => {
               applyImageFilters().then(() => {
                   console.log('🎨 [Reset UI] CSS filters applied after UI reset');
               });
           }, 100);

           // Reset Duotone controls
           const duotoneEnabled = document.getElementById('duotoneEnabled');
           const duotoneColor1 = document.getElementById('duotoneColor1');
           const duotoneColor1Text = document.getElementById('duotoneColor1Text');
           const duotoneColor2 = document.getElementById('duotoneColor2');
           const duotoneColor2Text = document.getElementById('duotoneColor2Text');
           const duotoneColorControls = document.getElementById('duotone-color-controls');

           if (duotoneEnabled) duotoneEnabled.checked = false;
           if (duotoneColor1) duotoneColor1.value = '#3B82F6';
           if (duotoneColor1Text) duotoneColor1Text.value = '#3B82F6';
           if (duotoneColor2) duotoneColor2.value = '#EAB308';
           if (duotoneColor2Text) duotoneColor2Text.value = '#EAB308';
           if (duotoneColorControls) duotoneColorControls.style.display = 'none';

           // Reset Glitch controls
           // Reset all glitch effect checkboxes
           const glitchCheckboxes = [
               'colorShiftEnabled', 'waveDeformEnabled', 'displacementEnabled',
               'pixelSortEnabled', 'paletteReductionEnabled', 'useDithering'
           ];
           glitchCheckboxes.forEach(checkboxId => {
               const checkbox = document.getElementById(checkboxId);
               if (checkbox) {
                   checkbox.checked = false;
               }
           });

           // Reset all glitch sliders to their default values
           const glitchSliderDefaults = {
               'colorShiftIntensity': { value: 1, display: '100%' },
               'colorShiftAmount': { value: 20, display: '20px' },
               'waveAmplitude': { value: 10, display: '10px' },
               'waveFrequency': { value: 0.05, display: '0.05' },
               'displacementIntensity': { value: 8, display: '8' },
               'displacementSize': { value: 18, display: '18' },
               'pixelSortBlockSize': { value: 5, display: '5' },
               'pixelSortFrequency': { value: 0.5, display: '50%' }
           };

           Object.keys(glitchSliderDefaults).forEach(sliderId => {
               const slider = document.getElementById(sliderId);
               if (slider) {
                   slider.value = glitchSliderDefaults[sliderId].value;
                   const displayId = 'v' + sliderId.charAt(0).toUpperCase() + sliderId.slice(1);
                   const display = document.getElementById(displayId);
                   if (display) display.textContent = glitchSliderDefaults[sliderId].display;
               }
           });

           // Reset glitch dropdowns to their default values
           const waveDirection = document.getElementById('waveDirection');
           if (waveDirection) waveDirection.value = 'horizontal';

           const displacementMode = document.getElementById('displacementMode');
           if (displacementMode) displacementMode.value = 'horizontal';

           const pixelSortDirection = document.getElementById('pixelSortDirection');
           if (pixelSortDirection) pixelSortDirection.value = 'horizontal';

           const paletteName = document.getElementById('paletteName');
           if (paletteName) paletteName.value = 'desert';

           const distanceMode = document.getElementById('distanceMode');
           if (distanceMode) distanceMode.value = 'accurate';

           // Reset Halftone controls
           const halftoneEnabled = document.getElementById('halftoneEnabled');
           if (halftoneEnabled) halftoneEnabled.checked = false;

           // Reset halftone grayscale checkbox
           const halftoneGrayscale = document.getElementById('halftoneGrayscale');
           if (halftoneGrayscale) halftoneGrayscale.checked = false;

           // Reset halftone sliders to their default values
           const halftoneSliderDefaults = {
               'halftoneDotSize': { value: 0.4, display: '0.4em' },
               'halftoneLineContrast': { value: 1050, display: '1050%' },
               'halftonePhotoBrightness': { value: 70, display: '70%' },
               'halftonePhotoContrast': { value: 100, display: '100%' },
               'halftonePhotoBlur': { value: 0, display: '0px' }
           };

           Object.keys(halftoneSliderDefaults).forEach(sliderId => {
               const slider = document.getElementById(sliderId);
               if (slider) {
                   slider.value = halftoneSliderDefaults[sliderId].value;
                   const displayId = 'v' + sliderId.charAt(0).toUpperCase() + sliderId.slice(1);
                   const display = document.getElementById(displayId);
                   if (display) display.textContent = halftoneSliderDefaults[sliderId].display;
               }
           });

           // Reset halftone blend mode
           const halftoneBlendMode = document.getElementById('halftoneBlendMode');
           if (halftoneBlendMode) halftoneBlendMode.value = 'hard-light';

           // Reset halftone dot color (hidden control)
           const halftoneDotColor = document.getElementById('halftoneDotColor');
           if (halftoneDotColor) halftoneDotColor.value = '#333333';

           // Clear halftone image upload
           const halftoneImageUpload = document.getElementById('halftoneImageUpload');
           if (halftoneImageUpload) halftoneImageUpload.value = '';

           const halftoneImagePreview = document.getElementById('halftoneImagePreview');
           if (halftoneImagePreview) halftoneImagePreview.style.display = 'none';

           // Hide effect control panels
           const duotoneControls = document.getElementById('duotone-effect-controls');
           if (duotoneControls) duotoneControls.style.display = 'none';

           // Hide all glitch sub-control panels
           const glitchSubPanels = [
               'color-shift-controls', 'wave-deform-controls', 'displacement-controls',
               'pixel-sort-controls', 'palette-reduction-controls'
           ];
           glitchSubPanels.forEach(panelId => {
               const panel = document.getElementById(panelId);
               if (panel) panel.style.display = 'none';
           });

           const halftoneControls = document.getElementById('halftone-effect-controls');
           if (halftoneControls) halftoneControls.style.display = 'none';

           console.log('🎨 [All Effects] All effect settings reset to defaults');

           // Log settings AFTER reset
           setTimeout(() => {
               logAllEffectSettings('AFTER RESET');
           }, 200);
       }

       // Function to reset ALL image effects (enhanced reset button functionality)
       function resetAllImageEffects(clearDropdown = true) {
           console.log('🎨 [Reset All] Starting comprehensive reset of all image effects');

           // Find the selected image object
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               console.log('🎨 [Reset All] No image selected, resetting UI only');
               // Reset UI even if no image is selected
               resetAllEffectUIControls();
               return;
           }

           console.log('🎨 [Reset All] Resetting effects for selected image object');

           // Use the comprehensive reset function
           resetAllEffectSettings(selectedObject);

           // Clear halftone custom image
           clearHalftoneCustomImage();

           // Clear preset dropdown selection (only if requested)
           if (clearDropdown) {
               const presetSelect = document.getElementById('filterPresetSelect');
               if (presetSelect) {
                   presetSelect.value = '';
                   console.log('🎨 [Reset All] Cleared preset dropdown selection');
               }
           }

           // Trigger canvas update to show the clean image
           if (window.update && typeof window.update === 'function') {
               console.log('🎨 [Reset All] Triggering canvas update');
               window.update();
           }

           console.log('🎨 [Reset All] ✅ Complete reset of all image effects finished');
       }

       // Function to clear halftone custom image
       function clearHalftoneCustomImage() {
           console.log('🎨 [Reset All] Clearing halftone custom image');

           // Clear the global custom image variable
           window.halftoneCustomImage = null;

           // Clear the file input
           const imageUpload = document.getElementById('halftoneImageUpload');
           if (imageUpload) {
               imageUpload.value = '';
           }

           // Hide the image preview
           const imagePreview = document.getElementById('halftoneImagePreview');
           if (imagePreview) {
               imagePreview.style.display = 'none';
           }

           // Clear the preview image source
           const imagePreviewImg = document.getElementById('halftoneImagePreviewImg');
           if (imagePreviewImg) {
               imagePreviewImg.src = '';
           }

           console.log('🎨 [Reset All] Halftone custom image cleared');
       }

       // Function to update duotone UI controls from preset
       function updateDuotoneUIFromPreset(duotoneData) {
           console.log('🎨 [DuoTone] Updating UI controls from preset:', duotoneData);

           if (!duotoneData) {
               console.log('🎨 [DuoTone] No duotone data provided');
               return;
           }

           // Extract colors from the preset data
           let color1 = '#3B82F6'; // Default blue
           let color2 = '#EAB308'; // Default yellow

           // If the preset has color information, use it
           if (duotoneData.color1) {
               color1 = duotoneData.color1;
               console.log('🎨 [DuoTone] Using preset color1:', color1);
           }
           if (duotoneData.color2) {
               color2 = duotoneData.color2;
               console.log('🎨 [DuoTone] Using preset color2:', color2);
           }

           console.log('🎨 [DuoTone] Final colors to apply - Color1:', color1, 'Color2:', color2);

           // Update color picker controls
           const duotoneColor1 = document.getElementById('duotoneColor1');
           const duotoneColor1Text = document.getElementById('duotoneColor1Text');
           const duotoneColor2 = document.getElementById('duotoneColor2');
           const duotoneColor2Text = document.getElementById('duotoneColor2Text');

           console.log('🎨 [DuoTone] Found UI elements:', {
               duotoneColor1: !!duotoneColor1,
               duotoneColor1Text: !!duotoneColor1Text,
               duotoneColor2: !!duotoneColor2,
               duotoneColor2Text: !!duotoneColor2Text
           });

           if (duotoneColor1) {
               duotoneColor1.value = color1;
               console.log('🎨 [DuoTone] Set duotoneColor1.value to:', color1);
           }
           if (duotoneColor1Text) {
               duotoneColor1Text.value = color1;
               console.log('🎨 [DuoTone] Set duotoneColor1Text.value to:', color1);
           }
           if (duotoneColor2) {
               duotoneColor2.value = color2;
               console.log('🎨 [DuoTone] Set duotoneColor2.value to:', color2);
           }
           if (duotoneColor2Text) {
               duotoneColor2Text.value = color2;
               console.log('🎨 [DuoTone] Set duotoneColor2Text.value to:', color2);
           }

           // Store colors in the selected object for consistency
           const selectedObject = getSelectedImageObject();
           if (selectedObject) {
               selectedObject.duotoneColor1 = color1;
               selectedObject.duotoneColor2 = color2;
               console.log('🎨 [DuoTone] Stored colors in selected object:', {
                   duotoneColor1: selectedObject.duotoneColor1,
                   duotoneColor2: selectedObject.duotoneColor2
               });
           }

           console.log('🎨 [DuoTone] UI controls updated with colors:', color1, color2);
       }

       // Helper function to get selected image object
       function getSelectedImageObject() {
           if (window.canvasObjects) {
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected && window.canvasObjects[i].type === 'image') {
                       return window.canvasObjects[i];
                   }
               }
           }
           return null;
       }

       // Function to update halftone UI controls from settings
       function updateHalftoneUIFromSettings(settings) {
           console.log('🎨 [Halftone] Updating UI controls from settings:', settings);

           // Update dot size
           const dotSizeSlider = document.getElementById('halftoneDotSize');
           const dotSizeDisplay = document.getElementById('vHalftoneDotSize');
           if (dotSizeSlider && settings.dotSize !== undefined) {
               dotSizeSlider.value = settings.dotSize;
               if (dotSizeDisplay) dotSizeDisplay.textContent = settings.dotSize + 'em';
           }

           // Update dot color
           const dotColorPicker = document.getElementById('halftoneDotColor');
           if (dotColorPicker && settings.dotColor) {
               dotColorPicker.value = settings.dotColor;
           }

           // Update line contrast
           const lineContrastSlider = document.getElementById('halftoneLineContrast');
           const lineContrastDisplay = document.getElementById('vHalftoneLineContrast');
           if (lineContrastSlider && settings.lineContrast !== undefined) {
               lineContrastSlider.value = settings.lineContrast;
               if (lineContrastDisplay) lineContrastDisplay.textContent = settings.lineContrast + '%';
           }

           // Update photo brightness
           const photoBrightnessSlider = document.getElementById('halftonePhotoBrightness');
           const photoBrightnessDisplay = document.getElementById('vHalftonePhotoBrightness');
           if (photoBrightnessSlider && settings.photoBrightness !== undefined) {
               photoBrightnessSlider.value = settings.photoBrightness;
               if (photoBrightnessDisplay) photoBrightnessDisplay.textContent = settings.photoBrightness + '%';
           }

           // Update photo contrast
           const photoContrastSlider = document.getElementById('halftonePhotoContrast');
           const photoContrastDisplay = document.getElementById('vHalftonePhotoContrast');
           if (photoContrastSlider && settings.photoContrast !== undefined) {
               photoContrastSlider.value = settings.photoContrast;
               if (photoContrastDisplay) photoContrastDisplay.textContent = settings.photoContrast + '%';
           }

           // Update photo blur
           const photoBlurSlider = document.getElementById('halftonePhotoBlur');
           const photoBlurDisplay = document.getElementById('vHalftonePhotoBlur');
           if (photoBlurSlider && settings.photoBlur !== undefined) {
               photoBlurSlider.value = settings.photoBlur;
               if (photoBlurDisplay) photoBlurDisplay.textContent = settings.photoBlur + 'px';
           }

           // Update grayscale toggle
           const grayscaleToggle = document.getElementById('halftoneGrayscale');
           if (grayscaleToggle && settings.grayscale !== undefined) {
               grayscaleToggle.checked = settings.grayscale;
           }

           // Update blend mode
           const blendModeSelect = document.getElementById('halftoneBlendMode');
           if (blendModeSelect && settings.blendMode) {
               blendModeSelect.value = settings.blendMode;
           }

           // Show halftone controls
           const halftoneControls = document.getElementById('halftoneControls');
           if (halftoneControls) {
               halftoneControls.style.display = 'block';
           }

           console.log('🎨 [Halftone] UI controls updated successfully');
       }

       // Canvas-based halftone effect implementation that mimics CSS behavior
       function createHalftoneImageSync(originalImage, settings) {
           try {
               console.log('🎨 [Halftone] Creating canvas halftone with settings:', settings);

               if (!settings.enabled) {
                   return originalImage;
               }

               // Check if image is ready for processing
               if (!isImageReady(originalImage)) {
                   console.log('🎨 [Halftone] Image not ready for processing, skipping halftone effect');
                   return originalImage;
               }

               // Validate image dimensions - handle both loaded and data URL images
               let width, height;

               if (originalImage.naturalWidth && originalImage.naturalHeight) {
                   width = originalImage.naturalWidth;
                   height = originalImage.naturalHeight;
               } else if (originalImage.width && originalImage.height) {
                   width = originalImage.width;
                   height = originalImage.height;
               } else if (originalImage.src && originalImage.src.startsWith('data:')) {
                   // For data URL images that haven't loaded yet, try to get dimensions from canvas
                   console.log('🎨 [Halftone] Data URL image detected, attempting to load...');
                   const tempCanvas = document.createElement('canvas');
                   const tempCtx = tempCanvas.getContext('2d');

                   try {
                       // Try to draw the image to get its dimensions
                       tempCanvas.width = 1;
                       tempCanvas.height = 1;
                       tempCtx.drawImage(originalImage, 0, 0);

                       // If we get here, the image is loaded
                       width = originalImage.naturalWidth || originalImage.width;
                       height = originalImage.naturalHeight || originalImage.height;
                   } catch (error) {
                       console.log('🎨 [Halftone] Image not ready yet, skipping halftone');
                       return originalImage;
                   }
               } else {
                   console.error('🎨 [Halftone] Invalid image dimensions:', originalImage);
                   return originalImage;
               }

               if (width <= 0 || height <= 0) {
                   console.log('🎨 [Halftone] Invalid dimensions - width:', width, 'height:', height, '- skipping halftone effect');
                   return originalImage;
               }

               console.log('🎨 [Halftone] Processing image with dimensions:', width, 'x', height);

               // Create canvas for halftone processing
               const canvas = document.createElement('canvas');
               const ctx = canvas.getContext('2d');
               canvas.width = width;
               canvas.height = height;

               // Step 1: Apply photo filters (conditional grayscale, brightness, contrast, blur)
               const grayscaleFilter = settings.grayscale ? 'grayscale(1)' : '';
               ctx.filter = `
                   ${grayscaleFilter}
                   brightness(${settings.photoBrightness}%)
                   contrast(${settings.photoContrast}%)
                   blur(${settings.photoBlur}px)
               `.replace(/\s+/g, ' ').trim();

               // Draw the original image onto the canvas
               try {
                   ctx.drawImage(originalImage, 0, 0, width, height);
               } catch (error) {
                   console.error('🎨 [Halftone] Error drawing image to canvas:', error);
                   return originalImage;
               }

               // Step 2: Create proper halftone pattern with variable dot sizes
               const patternCanvas = document.createElement('canvas');
               const patternCtx = patternCanvas.getContext('2d');
               patternCanvas.width = width;
               patternCanvas.height = height;

               // Convert dot size from em to pixels (assuming 16px base font size)
               const baseDotSize = settings.dotSize * 16;

               // Get image data to analyze brightness
               let imageData;
               try {
                   imageData = ctx.getImageData(0, 0, width, height);
               } catch (error) {
                   console.error('🎨 [Halftone] Error getting image data:', error);
                   return originalImage;
               }
               const data = imageData.data;

               // For custom images with grayscale disabled, get brightness from original image
               let brightnessData = data;
               if (settings.customImage && !settings.grayscale) {
                   // Create a separate canvas to get brightness from original image without grayscale
                   const originalCanvas = document.createElement('canvas');
                   const originalCtx = originalCanvas.getContext('2d');
                   originalCanvas.width = width;
                   originalCanvas.height = height;

                   // Apply only non-grayscale filters for brightness analysis
                   originalCtx.filter = `
                       brightness(${settings.photoBrightness}%)
                       contrast(${settings.photoContrast}%)
                       blur(${settings.photoBlur}px)
                   `.replace(/\s+/g, ' ').trim();

                   originalCtx.drawImage(originalImage, 0, 0, width, height);

                   try {
                       const originalImageData = originalCtx.getImageData(0, 0, width, height);
                       brightnessData = originalImageData.data;
                       console.log('🎨 [Halftone] Using original image colors for brightness analysis');
                   } catch (error) {
                       console.error('🎨 [Halftone] Error getting original image data:', error);
                       brightnessData = data; // Fallback to processed data
                   }
               }

               // Fill with white background first
               patternCtx.fillStyle = '#ffffff';
               patternCtx.fillRect(0, 0, width, height);

               // Check if we have a custom halftone image
               if (settings.customImage) {
                   console.log('🎨 [Halftone] Using custom image instead of dots');

                   // Draw the custom image scaled to fit the canvas
                   patternCtx.drawImage(settings.customImage, 0, 0, width, height);

                   // Apply brightness-based masking using composite operation
                   patternCtx.globalCompositeOperation = 'destination-in';

                   // Create brightness mask
                   const maskCanvas = document.createElement('canvas');
                   const maskCtx = maskCanvas.getContext('2d');
                   maskCanvas.width = width;
                   maskCanvas.height = height;

                   // Draw brightness-based mask
                   const maskImageData = maskCtx.createImageData(width, height);
                   const maskData = maskImageData.data;

                   for (let i = 0; i < brightnessData.length; i += 4) {
                       // Calculate brightness from RGB values (luminance formula)
                       const r = brightnessData[i] / 255;
                       const g = brightnessData[i + 1] / 255;
                       const b = brightnessData[i + 2] / 255;
                       const brightness = settings.grayscale ? r : (0.299 * r + 0.587 * g + 0.114 * b); // Use luminance for color images

                       const alpha = Math.floor((1 - brightness) * 255); // Darker areas = more visible
                       const pixelPos = i / 4;
                       const maskIndex = pixelPos * 4;

                       maskData[maskIndex] = 255;     // R
                       maskData[maskIndex + 1] = 255; // G
                       maskData[maskIndex + 2] = 255; // B
                       maskData[maskIndex + 3] = alpha; // A - based on brightness
                   }

                   maskCtx.putImageData(maskImageData, 0, 0);
                   patternCtx.drawImage(maskCanvas, 0, 0);

                   // Reset composite operation
                   patternCtx.globalCompositeOperation = 'source-over';

               } else {
                   // Create halftone dots based on image brightness (original method)
                   console.log('🎨 [Halftone] Using dot color:', settings.dotColor);
                   patternCtx.fillStyle = settings.dotColor;

                   // Create dots with variable sizes based on brightness
                   for (let x = 0; x < width; x += baseDotSize) {
                       for (let y = 0; y < height; y += baseDotSize) {
                           // Sample the brightness at this position
                           const sampleX = Math.min(Math.floor(x), width - 1);
                           const sampleY = Math.min(Math.floor(y), height - 1);
                           const pixelIndex = (sampleY * width + sampleX) * 4;

                           // Calculate brightness using appropriate method
                           let brightness;
                           if (settings.grayscale) {
                               brightness = brightnessData[pixelIndex] / 255; // R channel (grayscale)
                           } else {
                               // Use luminance formula for color images
                               const r = brightnessData[pixelIndex] / 255;
                               const g = brightnessData[pixelIndex + 1] / 255;
                               const b = brightnessData[pixelIndex + 2] / 255;
                               brightness = 0.299 * r + 0.587 * g + 0.114 * b;
                           }

                           // Invert brightness for dot size (darker areas = bigger dots)
                           const dotScale = 1 - brightness;
                           const dotRadius = (baseDotSize / 2) * dotScale;

                           if (dotRadius > 0.5) { // Only draw visible dots
                               const centerX = x + baseDotSize/2;
                               const centerY = y + baseDotSize/2;

                               // Use solid color for performance (much faster than individual gradients)
                               patternCtx.fillStyle = settings.dotColor;
                               patternCtx.beginPath();
                               patternCtx.arc(centerX, centerY, dotRadius, 0, Math.PI * 2);
                               patternCtx.fill();
                           }
                       }
                   }
               }

               // Step 3: Apply the original image as a mask to cut the halftone pattern
               // This ensures halftone dots only appear where the original image has content
               patternCtx.globalCompositeOperation = 'destination-in';
               patternCtx.drawImage(originalImage, 0, 0, width, height);

               // Reset composite operation
               patternCtx.globalCompositeOperation = 'source-over';

               // Step 4: Apply blend mode and line contrast
               ctx.globalCompositeOperation = settings.blendMode;
               ctx.drawImage(patternCanvas, 0, 0);

               // Step 5: Apply line contrast effect
               const contrastCanvas = document.createElement('canvas');
               const contrastCtx = contrastCanvas.getContext('2d');
               contrastCanvas.width = width;
               contrastCanvas.height = height;

               contrastCtx.filter = `contrast(${settings.lineContrast}%)`;
               contrastCtx.drawImage(canvas, 0, 0);

               // Create and return new image from the final canvas
               const halftoneImg = new Image();
               halftoneImg.src = contrastCanvas.toDataURL();

               console.log('🎨 [Halftone] Canvas halftone created successfully');
               return halftoneImg;

           } catch (error) {
               console.error('🎨 [Halftone] Error creating canvas halftone:', error);
               return originalImage;
           }
       }

       // Function to apply halftone effects to selected image
       function applyHalftoneEffects() {
           console.log('🎨 [Halftone] ===== APPLY HALFTONE EFFECTS CALLED =====');

           // Find the selected object
           let selectedObject = null;
           let selectedIndex = -1;

           if (window.canvasObjects) {
               console.log('🎨 [Halftone] Checking', window.canvasObjects.length, 'canvas objects for selection');
               for (let i = 0; i < window.canvasObjects.length; i++) {
                   if (window.canvasObjects[i].isSelected) {
                       selectedObject = window.canvasObjects[i];
                       selectedIndex = i;
                       console.log('🎨 [Halftone] Found selected object at index', i, 'type:', selectedObject.type);
                       break;
                   }
               }
           }

           if (!selectedObject || selectedObject.type !== 'image') {
               console.log('🎨 [Halftone] No image selected');
               return;
           }

           // Check if halftone is enabled
           const halftoneEnabled = document.getElementById('halftoneEnabled')?.checked || false;

           // Collect halftone settings
           const settings = {
               enabled: halftoneEnabled,
               dotSize: parseFloat(document.getElementById('halftoneDotSize')?.value || 0.4),
               dotColor: document.getElementById('halftoneDotColor')?.value || '#333333',
               lineContrast: parseFloat(document.getElementById('halftoneLineContrast')?.value || 1050),
               photoBrightness: parseFloat(document.getElementById('halftonePhotoBrightness')?.value || 70),
               photoContrast: parseFloat(document.getElementById('halftonePhotoContrast')?.value || 100),
               photoBlur: parseFloat(document.getElementById('halftonePhotoBlur')?.value || 0),
               blendMode: document.getElementById('halftoneBlendMode')?.value || 'hard-light',
               customImage: window.halftoneCustomImage || null, // Custom uploaded image
               grayscale: document.getElementById('halftoneGrayscale')?.checked !== false // Default to true
           };

           console.log('🎨 [Halftone] Applying halftone with settings:', settings);

           // 🎯 CRITICAL: Clear dependent effect caches when halftone changes
           console.log('🎨 [Halftone] Invalidating glitch and duotone caches due to halftone change');
           if (selectedObject.glinchImageCache) {
               selectedObject.glinchImageCache = {};
               console.log('🎨 [Halftone] Cleared glitch image cache');
           }
           if (selectedObject.duotoneImageCache) {
               selectedObject.duotoneImageCache = {};
               console.log('🎨 [Halftone] Cleared duotone image cache');
           }
           if (selectedObject.halftoneImageCache) {
               selectedObject.halftoneImageCache = {};
               console.log('🎨 [Halftone] Cleared halftone image cache');
           }

           // Store halftone settings in the image object
           selectedObject.halftoneEnabled = halftoneEnabled;
           selectedObject.halftoneSettings = settings;

           // Apply CSS-based halftone effect directly to the canvas image element
           // We need to find the actual image element on the canvas
           const canvas = document.getElementById('canvas');
           if (canvas) {
               // For now, we'll store the settings and apply them during canvas rendering
               // The actual CSS application will happen in the drawImageObject function
               console.log('🎨 [Halftone] Halftone settings stored for canvas rendering');
           }

           // Trigger unified pipeline update to show the halftone effect
           if (window.imageEffectsPipeline && typeof window.imageEffectsPipeline.triggerPipelineUpdate === 'function') {
               console.log('🎨 [Halftone] Triggering unified pipeline update');
               window.imageEffectsPipeline.triggerPipelineUpdate('halftone-change');
           } else {
               // Fallback to immediate update if pipeline not available
               if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                   console.log('🎨 [Halftone] Fallback: Using immediate update');
                   window.immediateUpdate('halftone-fallback');
               } else if (window.update && typeof window.update === 'function') {
                   console.log('🎨 [Halftone] Fallback: Calling window.update()');
                   window.update();

                   // Force a second update to ensure halftone is visible
                   setTimeout(() => {
                       console.log('🎨 [Halftone] Forcing second update to ensure visibility');
                       window.update();
                   }, 50);
               }
           }
       }

       // Make applyHalftoneEffects globally accessible
       window.applyHalftoneEffects = applyHalftoneEffects;

       // Function to capture current halftone state for save/load functionality
       function captureHalftoneState() {
           const halftoneState = {};

           // Capture halftone enabled state
           const halftoneEnabled = document.getElementById('halftoneEnabled')?.checked || false;
           halftoneState.enabled = halftoneEnabled;

           if (halftoneEnabled) {
               halftoneState.dotSize = parseFloat(document.getElementById('halftoneDotSize')?.value || 0.4);
               halftoneState.dotColor = document.getElementById('halftoneDotColor')?.value || '#333333';
               halftoneState.lineContrast = parseFloat(document.getElementById('halftoneLineContrast')?.value || 1050);
               halftoneState.photoBrightness = parseFloat(document.getElementById('halftonePhotoBrightness')?.value || 70);
               halftoneState.photoContrast = parseFloat(document.getElementById('halftonePhotoContrast')?.value || 100);
               halftoneState.photoBlur = parseFloat(document.getElementById('halftonePhotoBlur')?.value || 0);
               halftoneState.blendMode = document.getElementById('halftoneBlendMode')?.value || 'hard-light';
               halftoneState.grayscale = document.getElementById('halftoneGrayscale')?.checked || false; // ✅ FIXED: Added missing grayscale property
               console.log('🎨 [Halftone] ✅ CAPTURED GRAYSCALE VALUE:', halftoneState.grayscale, 'From element:', document.getElementById('halftoneGrayscale')?.checked);
           }

           console.log('🎨 [Halftone] Captured halftone state:', halftoneState);
           return halftoneState;
       }

       // Function to restore halftone state from saved data
       function restoreHalftoneState(halftoneState) {
           console.log('🎨 [Halftone] Restoring halftone state:', halftoneState);

           if (!halftoneState || typeof halftoneState !== 'object') {
               console.log('🎨 [Halftone] No valid halftone state to restore');
               return;
           }

           // Restore halftone enabled state
           const halftoneEnabled = document.getElementById('halftoneEnabled');
           const halftoneControls = document.getElementById('halftone-effect-controls');

           if (halftoneEnabled) {
               halftoneEnabled.checked = halftoneState.enabled || false;
               if (halftoneControls) {
                   halftoneControls.style.display = halftoneState.enabled ? 'block' : 'none';
               }
           }

           // Restore halftone settings
           if (halftoneState.enabled) {
               const dotSizeSlider = document.getElementById('halftoneDotSize');
               const dotColorPicker = document.getElementById('halftoneDotColor');
               const lineContrastSlider = document.getElementById('halftoneLineContrast');
               const photoBrightnessSlider = document.getElementById('halftonePhotoBrightness');
               const photoContrastSlider = document.getElementById('halftonePhotoContrast');
               const photoBlurSlider = document.getElementById('halftonePhotoBlur');
               const blendModeSelect = document.getElementById('halftoneBlendMode');

               if (dotSizeSlider) {
                   dotSizeSlider.value = halftoneState.dotSize || 0.25;
                   const display = document.getElementById('vHalftoneDotSize');
                   if (display) display.textContent = (halftoneState.dotSize || 0.25) + 'em';
               }
               if (dotColorPicker) dotColorPicker.value = halftoneState.dotColor || '#333333';
               if (lineContrastSlider) {
                   lineContrastSlider.value = halftoneState.lineContrast || 2000;
                   const display = document.getElementById('vHalftoneLineContrast');
                   if (display) display.textContent = (halftoneState.lineContrast || 2000) + '%';
               }
               if (photoBrightnessSlider) {
                   photoBrightnessSlider.value = halftoneState.photoBrightness || 80;
                   const display = document.getElementById('vHalftonePhotoBrightness');
                   if (display) display.textContent = (halftoneState.photoBrightness || 80) + '%';
               }
               if (photoContrastSlider) {
                   photoContrastSlider.value = halftoneState.photoContrast || 150;
                   const display = document.getElementById('vHalftonePhotoContrast');
                   if (display) display.textContent = (halftoneState.photoContrast || 150) + '%';
               }
               if (photoBlurSlider) {
                   photoBlurSlider.value = halftoneState.photoBlur !== undefined ? halftoneState.photoBlur : 2;
                   const display = document.getElementById('vHalftonePhotoBlur');
                   if (display) display.textContent = (halftoneState.photoBlur !== undefined ? halftoneState.photoBlur : 2) + 'px';
               }
               if (blendModeSelect) blendModeSelect.value = halftoneState.blendMode || 'hard-light';

               // Restore grayscale toggle
               const grayscaleToggle = document.getElementById('halftoneGrayscale');
               if (grayscaleToggle && halftoneState.grayscale !== undefined) {
                   grayscaleToggle.checked = halftoneState.grayscale;
                   console.log('🎨 [Halftone] ✅ RESTORED GRAYSCALE CHECKBOX:', halftoneState.grayscale, 'Element checked:', grayscaleToggle.checked);
               } else {
                   console.log('🎨 [Halftone] ❌ FAILED TO RESTORE GRAYSCALE - Element:', !!grayscaleToggle, 'Value:', halftoneState.grayscale);
               }

               // Restore custom halftone image if available
               if (halftoneState.customImageData) {
                   console.log('🎨 [Halftone] Restoring custom halftone image...');
                   try {
                       const img = new Image();
                       img.onload = function() {
                           window.halftoneCustomImage = img;
                           console.log('🎨 [Halftone] Custom halftone image restored successfully');

                           // Update UI to show the restored image
                           const imagePreview = document.getElementById('halftoneImagePreview');
                           const imagePreviewImg = document.getElementById('halftoneImagePreviewImg');
                           if (imagePreview && imagePreviewImg) {
                               imagePreviewImg.src = halftoneState.customImageData;
                               imagePreview.style.display = 'block';
                           }

                           // Apply halftone effects with the restored image
                           setTimeout(() => {
                               applyHalftoneEffects();
                           }, 100);
                       };
                       img.onerror = function() {
                           console.error('🎨 [Halftone] Failed to restore custom halftone image');
                       };
                       img.src = halftoneState.customImageData;
                   } catch (error) {
                       console.error('🎨 [Halftone] Error restoring custom halftone image:', error);
                   }
               } else {
                   // Apply the restored halftone effects (no custom image)
                   setTimeout(() => {
                       applyHalftoneEffects();
                   }, 100);
               }
           } else {
               // Apply the restored halftone effects (halftone disabled)
               setTimeout(() => {
                   applyHalftoneEffects();
               }, 100);
           }

           console.log('🎨 [Halftone] Halftone state restored successfully');
       }

       // Function to setup halftone controls
       function setupHalftoneControls() {
           console.log('🎨 [Halftone] Setting up halftone controls...');

           // Halftone Enable Toggle
           const halftoneEnabled = document.getElementById('halftoneEnabled');
           const halftoneControls = document.getElementById('halftone-effect-controls');

           if (halftoneEnabled) {
               halftoneEnabled.addEventListener('change', (e) => {
                   console.log('🎨 [Halftone] Halftone toggle changed:', e.target.checked);
                   if (halftoneControls) {
                       halftoneControls.style.display = e.target.checked ? 'block' : 'none';
                   }
                   applyHalftoneEffects();
               });
           }

           // Dot Size Control
           const dotSizeSlider = document.getElementById('halftoneDotSize');
           if (dotSizeSlider) {
               dotSizeSlider.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vHalftoneDotSize');
                   if (display) display.textContent = value + 'em';
                   applyHalftoneEffects();
               });
           }

           // Dot Color Control
           const dotColorPicker = document.getElementById('halftoneDotColor');
           if (dotColorPicker) {
               dotColorPicker.addEventListener('input', () => {
                   applyHalftoneEffects();
               });
           }

           // Line Contrast Control
           const lineContrastSlider = document.getElementById('halftoneLineContrast');
           if (lineContrastSlider) {
               lineContrastSlider.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vHalftoneLineContrast');
                   if (display) display.textContent = value + '%';
                   applyHalftoneEffects();
               });
           }

           // Photo Brightness Control
           const photoBrightnessSlider = document.getElementById('halftonePhotoBrightness');
           if (photoBrightnessSlider) {
               photoBrightnessSlider.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vHalftonePhotoBrightness');
                   if (display) display.textContent = value + '%';
                   applyHalftoneEffects();
               });
           }

           // Photo Contrast Control
           const photoContrastSlider = document.getElementById('halftonePhotoContrast');
           if (photoContrastSlider) {
               photoContrastSlider.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vHalftonePhotoContrast');
                   if (display) display.textContent = value + '%';
                   applyHalftoneEffects();
               });
           }

           // Photo Blur Control
           const photoBlurSlider = document.getElementById('halftonePhotoBlur');
           if (photoBlurSlider) {
               photoBlurSlider.addEventListener('input', (e) => {
                   const value = parseFloat(e.target.value);
                   const display = document.getElementById('vHalftonePhotoBlur');
                   if (display) display.textContent = value + 'px';
                   applyHalftoneEffects();
               });
           }

           // Blend Mode Control
           const blendModeSelect = document.getElementById('halftoneBlendMode');
           if (blendModeSelect) {
               blendModeSelect.addEventListener('change', () => {
                   applyHalftoneEffects();
               });
           }

           // Reset button
           const resetHalftoneBtn = document.getElementById('resetHalftoneBtn');
           if (resetHalftoneBtn) {
               resetHalftoneBtn.addEventListener('click', () => {
                   console.log('🎨 [Halftone] Reset button clicked');

                   // Reset halftone toggle
                   if (halftoneEnabled) halftoneEnabled.checked = false;

                   // Hide control panel
                   if (halftoneControls) halftoneControls.style.display = 'none';

                   // Reset all values to defaults
                   if (dotSizeSlider) {
                       dotSizeSlider.value = 0.25;
                       const display = document.getElementById('vHalftoneDotSize');
                       if (display) display.textContent = '0.25em';
                   }
                   if (dotColorPicker) dotColorPicker.value = '#333333';
                   if (lineContrastSlider) {
                       lineContrastSlider.value = 2000;
                       const display = document.getElementById('vHalftoneLineContrast');
                       if (display) display.textContent = '2000%';
                   }
                   if (photoBrightnessSlider) {
                       photoBrightnessSlider.value = 80;
                       const display = document.getElementById('vHalftonePhotoBrightness');
                       if (display) display.textContent = '80%';
                   }
                   if (photoContrastSlider) {
                       photoContrastSlider.value = 150;
                       const display = document.getElementById('vHalftonePhotoContrast');
                       if (display) display.textContent = '150%';
                   }
                   if (photoBlurSlider) {
                       photoBlurSlider.value = 2;
                       const display = document.getElementById('vHalftonePhotoBlur');
                       if (display) display.textContent = '2px';
                   }
                   if (blendModeSelect) blendModeSelect.value = 'hard-light';

                   applyHalftoneEffects();
               });
           }

           // Grayscale Toggle Control
           const grayscaleToggle = document.getElementById('halftoneGrayscale');
           if (grayscaleToggle) {
               grayscaleToggle.addEventListener('change', () => {
                   console.log('🎨 [Halftone] Grayscale toggle changed:', grayscaleToggle.checked);
                   applyHalftoneEffects();
               });
           }

           // Image Upload Control
           const imageUpload = document.getElementById('halftoneImageUpload');
           const imagePreview = document.getElementById('halftoneImagePreview');
           const imagePreviewImg = document.getElementById('halftoneImagePreviewImg');
           const clearImageBtn = document.getElementById('clearHalftoneImage');

           if (imageUpload) {
               imageUpload.addEventListener('change', (e) => {
                   const file = e.target.files[0];
                   if (file && file.type.startsWith('image/')) {
                       const reader = new FileReader();
                       reader.onload = (event) => {
                           const img = new Image();
                           img.onload = () => {
                               window.halftoneCustomImage = img;
                               if (imagePreviewImg) imagePreviewImg.src = event.target.result;
                               if (imagePreview) imagePreview.style.display = 'block';
                               console.log('🎨 [Halftone] Custom image loaded');
                               applyHalftoneEffects();
                           };
                           img.src = event.target.result;
                       };
                       reader.readAsDataURL(file);
                   }
               });
           }

           if (clearImageBtn) {
               clearImageBtn.addEventListener('click', () => {
                   window.halftoneCustomImage = null;
                   if (imageUpload) imageUpload.value = '';
                   if (imagePreview) imagePreview.style.display = 'none';
                   console.log('🎨 [Halftone] Custom image cleared');
                   applyHalftoneEffects();
               });
           }

           console.log('🎨 [Halftone] Halftone controls setup complete');
       }

       // Make halftone functions globally accessible
       window.captureHalftoneState = captureHalftoneState;
       window.restoreHalftoneState = restoreHalftoneState;
       window.createHalftoneImageSync = createHalftoneImageSync;

       // ===== DRAW IMAGE OBJECT WITH EFFECTS PIPELINE =====

       // Function to draw image objects with unified effects pipeline
       async function drawImageObject(obj, ctx) {
           try {
               console.log('🎨 [DrawImage] ===== STARTING DRAW IMAGE OBJECT =====');
               console.log('🎨 [DrawImage] Object ID:', obj.id);
               console.log('🎨 [DrawImage] Object details:', {
                   hasImage: !!obj.image,
                   hasOriginalImage: !!obj.originalImage,
                   imageComplete: obj.image?.complete,
                   naturalWidth: obj.image?.naturalWidth,
                   naturalHeight: obj.image?.naturalHeight,
                   x: obj.x,
                   y: obj.y,
                   width: obj.width,
                   height: obj.height
               });
               console.log('🎨 [DrawImage] Context type:', ctx.constructor.name);

               if (!obj || !obj.image || !ctx) {
                   console.log('🎨 [DrawImage] ❌ Invalid parameters - obj:', !!obj, 'obj.image:', !!obj?.image, 'ctx:', !!ctx);
                   return;
               }

               // Use the unified pipeline to process all effects in correct order
               let currentImage = obj.originalImage || obj.image;
               console.log('🎨 [DrawImage] Using image source:', obj.originalImage ? 'originalImage' : 'image');
               console.log('🎨 [DrawImage] Current image dimensions:', currentImage.naturalWidth, 'x', currentImage.naturalHeight);

               // 🚀 PERFORMANCE: Check if we're in drag mode and this is a background image
               const isDragMode = window.imageEffectsPipeline?.isDragMode || false;
               const isDraggedObject = window.selectedObjectIndex !== -1 &&
                                     window.canvasObjects &&
                                     window.canvasObjects[window.selectedObjectIndex] === obj;

               if (isDragMode && !isDraggedObject) {
                   console.log('🎨 [DrawImage] 🚀 DRAG OPTIMIZATION: Skipping effects pipeline for background image during drag');
                   // For background images during drag, use cached or original image without processing
                   if (window.imageEffectsPipeline.lastProcessedImages?.has(obj.id)) {
                       const cached = window.imageEffectsPipeline.lastProcessedImages.get(obj.id);
                       currentImage = cached.processedImage;
                       console.log('🎨 [DrawImage] 🚀 Using cached processed image for background');
                   } else {
                       console.log('🎨 [DrawImage] 🚀 Using original image for background (no cache)');
                   }
               } else {
                   console.log('🎨 [DrawImage] Processing effects pipeline...');
                   if (window.imageEffectsPipeline) {
                       console.log('🎨 [DrawImage] Unified pipeline available, processing effects');
                       currentImage = await window.imageEffectsPipeline.processImageEffects(obj);
                       console.log('🎨 [DrawImage] Pipeline processing complete, result type:', currentImage.constructor.name);
                       console.log('🎨 [DrawImage] Processed image dimensions:',
                           currentImage instanceof HTMLCanvasElement ?
                               `${currentImage.width}x${currentImage.height}` :
                               `${currentImage.naturalWidth}x${currentImage.naturalHeight}`);
                   } else {
                       console.warn('🎨 [DrawImage] Unified pipeline not available, using original image');
                   }
               }

               // Apply CSS filters to the drawing context (Step 4 - final adjustments)
               if (obj.cssFilterString && obj.cssFilterString !== 'none') {
                   console.log('🎨 [DrawImage] Applying CSS filters to context:', obj.cssFilterString);
                   ctx.filter = obj.cssFilterString;
               } else {
                   console.log('🎨 [DrawImage] No CSS filters to apply');
                   ctx.filter = 'none';
               }

               // Draw the final processed image
               console.log('🎨 [DrawImage] Setting up canvas transforms...');
               console.log('🎨 [DrawImage] Canvas scaleFactor:', ctx.canvas.scaleFactor);
               console.log('🎨 [DrawImage] Current transform before object transforms:', ctx.getTransform());

               ctx.save();
               ctx.translate(obj.x, obj.y);
               console.log('🎨 [DrawImage] Translated to:', obj.x, obj.y);
               if (obj.rotation) {
                   ctx.rotate(obj.rotation * Math.PI / 180);
                   console.log('🎨 [DrawImage] Rotated by:', obj.rotation, 'degrees');
               }
               if (obj.scale) {
                   ctx.scale(obj.scale, obj.scale);
                   console.log('🎨 [DrawImage] Scaled by:', obj.scale);
                   console.log('🎨 [DrawImage] Transform after object scale:', ctx.getTransform());
               }

               const width = obj.originalWidth || obj.width || currentImage.width;
               const height = obj.originalHeight || obj.height || currentImage.height;

               console.log('🎨 [DrawImage] Final drawing parameters:', {
                   width: width,
                   height: height,
                   drawX: -width / 2,
                   drawY: -height / 2,
                   currentImageType: currentImage.constructor.name,
                   currentImageDimensions: currentImage instanceof HTMLCanvasElement ?
                       `${currentImage.width}x${currentImage.height}` :
                       `${currentImage.naturalWidth}x${currentImage.naturalHeight}`
               });

               // Calculate expected visual dimensions after scaling
               const expectedVisualWidth = width * (obj.scale || 1);
               const expectedVisualHeight = height * (obj.scale || 1);
               console.log('🎨 [DrawImage] Expected visual dimensions after scaling:', expectedVisualWidth, 'x', expectedVisualHeight);

               // Apply image opacity (separate from stroke opacity)
               const imageOpacity = (obj.opacity !== undefined) ? obj.opacity / 100 : 1;
               console.log('🎨 [DrawImage] Applying image opacity:', imageOpacity, '(from obj.opacity:', obj.opacity, ')');
               ctx.globalAlpha = imageOpacity;

               // Apply shadow if enabled
               if (obj.shadowMode === 'standard') {
                   const shadowOpacity = (obj.shadowOpacity !== undefined) ? obj.shadowOpacity / 100 : 1;
                   console.log('🎨 [DrawImage] Applying shadow:', {
                       shadowMode: obj.shadowMode,
                       shadowColor: obj.shadowColor || '#000000',
                       shadowOpacity: shadowOpacity,
                       shadowOffsetX: obj.shadowOffsetX || 5,
                       shadowOffsetY: obj.shadowOffsetY || 5,
                       shadowBlur: obj.shadowBlur || 10
                   });

                   // Convert hex color to rgba with opacity
                   const shadowColor = obj.shadowColor || '#000000';
                   let finalShadowColor = shadowColor;
                   if (shadowOpacity < 1) {
                       const r = parseInt(shadowColor.slice(1, 3), 16);
                       const g = parseInt(shadowColor.slice(3, 5), 16);
                       const b = parseInt(shadowColor.slice(5, 7), 16);
                       finalShadowColor = `rgba(${r}, ${g}, ${b}, ${shadowOpacity})`;
                   }

                   ctx.shadowColor = finalShadowColor;
                   ctx.shadowOffsetX = obj.shadowOffsetX || 5;
                   ctx.shadowOffsetY = obj.shadowOffsetY || 5;
                   ctx.shadowBlur = obj.shadowBlur || 10;
               } else {
                   console.log('🎨 [DrawImage] No shadow to apply (shadowMode:', obj.shadowMode, ')');
                   ctx.shadowColor = 'transparent';
                   ctx.shadowOffsetX = 0;
                   ctx.shadowOffsetY = 0;
                   ctx.shadowBlur = 0;
               }

               // Handle both Image objects and Canvas objects
               if (currentImage instanceof HTMLCanvasElement) {
                   console.log('🎨 [DrawImage] Drawing canvas image to context');
                   ctx.drawImage(
                       currentImage,
                       -width / 2,
                       -height / 2,
                       width,
                       height
                   );
               } else {
                   console.log('🎨 [DrawImage] Drawing HTML image to context');
                   ctx.drawImage(
                       currentImage,
                       -width / 2,
                       -height / 2,
                       width,
                       height
                   );
               }

               // Reset globalAlpha and shadow properties after drawing the image
               ctx.globalAlpha = 1;
               ctx.shadowColor = 'transparent';
               ctx.shadowOffsetX = 0;
               ctx.shadowOffsetY = 0;
               ctx.shadowBlur = 0;

               // Draw stroke/border if specified
               if (obj.strokeMode === 'standard' && obj.strokeWidth && obj.strokeWidth > 0) {
                   console.log('🎨 [DrawImage] Drawing image stroke:', {
                       strokeMode: obj.strokeMode,
                       strokeWidth: obj.strokeWidth,
                       strokeColor: obj.strokeColor || '#000000',
                       strokeOpacity: obj.strokeOpacity || 100
                   });

                   // Apply stroke opacity
                   const strokeOpacity = (obj.strokeOpacity || 100) / 100;
                   const strokeColor = obj.strokeColor || '#000000';

                   // Convert hex color to rgba with opacity
                   let finalStrokeColor = strokeColor;
                   if (strokeOpacity < 1) {
                       // Convert hex to rgba
                       const r = parseInt(strokeColor.slice(1, 3), 16);
                       const g = parseInt(strokeColor.slice(3, 5), 16);
                       const b = parseInt(strokeColor.slice(5, 7), 16);
                       finalStrokeColor = `rgba(${r}, ${g}, ${b}, ${strokeOpacity})`;
                   }

                   ctx.strokeStyle = finalStrokeColor;
                   ctx.lineWidth = obj.strokeWidth;
                   ctx.strokeRect(-width / 2, -height / 2, width, height);
               }

               ctx.restore();
               console.log('🎨 [DrawImage] ===== IMAGE OBJECT DRAWN SUCCESSFULLY =====');

           } catch (error) {
               console.error('🎨 [DrawImage] Error drawing image object:', error);
           }
       }

       // Make drawImageObject globally accessible only if not already defined
       // This prevents overriding the main editor's drawImageObject function
       if (!window.drawImageObject) {
           window.drawImageObject = drawImageObject;
           console.log('🎨 [DrawImage] Registered drawImageObject function from design-editor.html');
       } else {
           console.log('🎨 [DrawImage] drawImageObject already exists, not overriding (preventing duplicate renders)');
       }

       // ===== UNIFIED IMAGE EFFECTS PIPELINE SYSTEM =====

       /**
        * Centralized Image Effects Pipeline Manager
        * Ensures consistent processing order: Duotone → Halftone → Glitch → CSS Filters
        */
       class ImageEffectsPipeline {
           constructor() {
               this.isProcessing = false;
               this.pendingUpdate = false;
               this.processingQueue = new Set();

               // 🚀 PERFORMANCE OPTIMIZATION: Add drag-aware caching
               this.isDragMode = false;
               this.dragStartTime = 0;
               this.lastProcessedImages = new Map(); // objectId -> processed image cache
               this.dragSkipCount = 0;
               this.dragProcessCount = 0;
               this.dragFrameCounter = 0; // Frame counter for drag operations
               this.dragProcessInterval = 3; // Process effects every N frames during drag (reduces from 15fps to 5fps)

               console.log('🎨 [Pipeline] Image Effects Pipeline initialized with drag optimization');
           }

           /**
            * 🚀 PERFORMANCE: Set drag mode to optimize image processing
            */
           setDragMode(isDragging) {
               if (isDragging && !this.isDragMode) {
                   this.isDragMode = true;
                   this.dragStartTime = performance.now();
                   this.dragSkipCount = 0;
                   this.dragProcessCount = 0;
                   console.log('🎨 [Pipeline] 🚀 DRAG MODE: Enabled - will skip unnecessary image processing');
               } else if (!isDragging && this.isDragMode) {
                   this.isDragMode = false;
                   const dragDuration = performance.now() - this.dragStartTime;
                   console.log(`🎨 [Pipeline] 🚀 DRAG MODE: Disabled after ${dragDuration.toFixed(1)}ms - Skipped: ${this.dragSkipCount}, Processed: ${this.dragProcessCount}`);

                   // Reset counters and clear cache after drag to ensure fresh processing
                   this.dragFrameCounter = 0;
                   this.lastProcessedImages.clear();
               }
           }

           /**
            * Process all effects for a given image object in the correct order
            * @param {Object} imageObject - The image object to process
            * @returns {HTMLImageElement|HTMLCanvasElement} - The processed image
            */
           async processImageEffects(imageObject) {
               if (!imageObject || !imageObject.image) {
                   console.warn('🎨 [Pipeline] Invalid image object provided');
                   return null;
               }

               // 🚀 PERFORMANCE OPTIMIZATION: Skip processing during drag if image hasn't changed
               if (this.isDragMode) {
                   this.dragFrameCounter++;

                   const cacheKey = this.generateImageCacheKey(imageObject);
                   const cachedImage = this.lastProcessedImages.get(imageObject.id);

                   // Use cached image if available and effects haven't changed
                   if (cachedImage && cachedImage.cacheKey === cacheKey) {
                       this.dragSkipCount++;
                       console.log(`🎨 [Pipeline] 🚀 DRAG SKIP: Using cached image for object ${imageObject.id} (skip #${this.dragSkipCount})`);
                       return cachedImage.processedImage;
                   }

                   // Additional frame skipping: only process every N frames during drag
                   if (this.dragFrameCounter % this.dragProcessInterval !== 0) {
                       this.dragSkipCount++;
                       console.log(`🎨 [Pipeline] 🚀 DRAG FRAME SKIP: Skipping frame ${this.dragFrameCounter} (interval: ${this.dragProcessInterval})`);
                       // Return cached image if available, otherwise original
                       return cachedImage ? cachedImage.processedImage : (imageObject.originalImage || imageObject.image);
                   }

                   this.dragProcessCount++;
                   console.log(`🎨 [Pipeline] 🚀 DRAG PROCESS: Processing image for object ${imageObject.id} (process #${this.dragProcessCount})`);
               }

               console.log('🎨 [Pipeline] ===== STARTING UNIFIED EFFECTS PIPELINE =====');

               // Start with the original image
               let currentImage = imageObject.originalImage || imageObject.image;
               const effectsApplied = [];

               try {
                   // Step 1: Apply Duotone Effect (FIRST - changes base colors)
                   if (imageObject.duotoneEnabled && imageObject.duotoneMatrix) {
                       console.log('🎨 [Pipeline] Step 1: Applying Duotone Effect');
                       currentImage = await this.applyDuotoneStep(currentImage, imageObject);
                       effectsApplied.push('duotone');
                   }

                   // Step 2: Apply Halftone Effect (SECOND - modifies rendering style)
                   if (imageObject.halftoneEnabled && imageObject.halftoneSettings) {
                       console.log('🎨 [Pipeline] Step 2: Applying Halftone Effect');
                       currentImage = await this.applyHalftoneStep(currentImage, imageObject);
                       effectsApplied.push('halftone');
                   }

                   // Step 3: Apply Glitch Effects (THIRD - adds visual distortions)
                   if (imageObject.glinchEnabled && imageObject.glinchEffects) {
                       console.log('🎨 [Pipeline] Step 3: Applying Glitch Effects');
                       currentImage = await this.applyGlitchStep(currentImage, imageObject);
                       effectsApplied.push('glitch');
                   }

                   // Step 4: CSS Filters will be applied during drawing (FOURTH - final adjustments)
                   if (imageObject.cssFilterString && imageObject.cssFilterString !== 'none') {
                       console.log('🎨 [Pipeline] Step 4: CSS Filters will be applied during drawing');
                       effectsApplied.push('css-filters');
                   }

                   console.log('🎨 [Pipeline] ===== PIPELINE COMPLETE =====');
                   console.log('🎨 [Pipeline] Effects applied:', effectsApplied.join(' → '));

                   // 🚀 PERFORMANCE: Cache the processed image during drag mode
                   if (this.isDragMode) {
                       const cacheKey = this.generateImageCacheKey(imageObject);
                       this.lastProcessedImages.set(imageObject.id, {
                           processedImage: currentImage,
                           cacheKey: cacheKey,
                           timestamp: performance.now()
                       });
                   }

                   return currentImage;

               } catch (error) {
                   console.error('🎨 [Pipeline] Error in effects pipeline:', error);
                   return imageObject.originalImage || imageObject.image;
               }
           }

           /**
            * 🚀 PERFORMANCE: Generate cache key for image effects state
            */
           generateImageCacheKey(imageObject) {
               const effectsState = {
                   duotone: imageObject.duotoneEnabled ? imageObject.duotoneMatrix : null,
                   halftone: imageObject.halftoneEnabled ? JSON.stringify(imageObject.halftoneSettings) : null,
                   glitch: imageObject.glinchEnabled ? JSON.stringify(imageObject.glinchEffects) : null,
                   cssFilters: imageObject.cssFilterString || 'none',
                   imageUrl: imageObject.image?.src || imageObject.imageUrl
               };
               return JSON.stringify(effectsState);
           }

           /**
            * Apply duotone effect with caching
            */
           async applyDuotoneStep(inputImage, imageObject) {
               const cacheKey = JSON.stringify({
                   type: 'duotone',
                   matrix: imageObject.duotoneMatrix
               });

               if (!imageObject.effectsCache) {
                   imageObject.effectsCache = {};
               }

               if (!imageObject.effectsCache[cacheKey]) {
                   console.log('🎨 [Pipeline] Creating new duotone image');
                   if (imageObject.duotoneMatrix && (typeof imageObject.duotoneMatrix === 'string' || Array.isArray(imageObject.duotoneMatrix))) {
                       imageObject.effectsCache[cacheKey] = createDuotoneImageSync(inputImage, imageObject.duotoneMatrix);
                   } else {
                       console.warn('🎨 [Pipeline] Invalid duotone matrix, skipping duotone effect');
                       imageObject.effectsCache[cacheKey] = inputImage;
                   }
               }

               return imageObject.effectsCache[cacheKey];
           }

           /**
            * Apply halftone effect with caching
            */
           async applyHalftoneStep(inputImage, imageObject) {
               const cacheKey = JSON.stringify({
                   type: 'halftone',
                   settings: imageObject.halftoneSettings,
                   hasDuotone: imageObject.duotoneEnabled
               });

               if (!imageObject.effectsCache) {
                   imageObject.effectsCache = {};
               }

               if (!imageObject.effectsCache[cacheKey]) {
                   console.log('🎨 [Pipeline] Creating new halftone image');
                   const imgWidth = inputImage.naturalWidth || inputImage.width;
                   const imgHeight = inputImage.naturalHeight || inputImage.height;

                   if (imgWidth > 0 && imgHeight > 0) {
                       const halftoneResult = createHalftoneImageSync(inputImage, imageObject.halftoneSettings);
                       imageObject.effectsCache[cacheKey] = halftoneResult !== inputImage ? halftoneResult : inputImage;
                   } else {
                       console.warn('🎨 [Pipeline] Invalid image dimensions for halftone:', imgWidth, 'x', imgHeight);
                       imageObject.effectsCache[cacheKey] = inputImage;
                   }
               }

               return imageObject.effectsCache[cacheKey];
           }

           /**
            * Apply glitch effects with caching
            */
           async applyGlitchStep(inputImage, imageObject) {
               const cacheKey = JSON.stringify({
                   type: 'glitch',
                   effects: imageObject.glinchEffects,
                   hasDuotone: imageObject.duotoneEnabled,
                   hasHalftone: imageObject.halftoneEnabled
               });

               if (!imageObject.effectsCache) {
                   imageObject.effectsCache = {};
               }

               if (!imageObject.effectsCache[cacheKey]) {
                   console.log('🎨 [Pipeline] Creating new glitch image');
                   imageObject.effectsCache[cacheKey] = createGlinchImageSync(inputImage, imageObject.glinchEffects);
               }

               return imageObject.effectsCache[cacheKey];
           }

           /**
            * Clear all effect caches for an image object
            */
           clearImageCache(imageObject) {
               if (imageObject && imageObject.effectsCache) {
                   console.log('🎨 [Pipeline] Clearing effects cache for image object');
                   imageObject.effectsCache = {};
               }

               // Also clear old individual caches for backward compatibility
               if (imageObject) {
                   imageObject.duotoneImageCache = {};
                   imageObject.halftoneImageCache = {};
                   imageObject.glinchImageCache = {};
               }
           }

           /**
            * Trigger a unified pipeline update for all images
            */
           async triggerPipelineUpdate(reason = 'manual') {
               if (this.isProcessing) {
                   this.pendingUpdate = true;
                   console.log('🎨 [Pipeline] Update queued (already processing):', reason);
                   return;
               }

               this.isProcessing = true;
               console.log('🎨 [Pipeline] Triggering unified pipeline update:', reason);

               try {
                   // Clear all caches to ensure fresh processing
                   if (window.canvasObjects && Array.isArray(window.canvasObjects)) {
                       window.canvasObjects.forEach(obj => {
                           if (obj.type === 'image') {
                               this.clearImageCache(obj);
                           }
                       });
                   }

                   // 🔥 CRITICAL FIX: Use immediate update to bypass debouncing for effects
                   if (window.immediateUpdate && typeof window.immediateUpdate === 'function') {
                       console.log('🎨 [Pipeline] Using immediate update to bypass debouncing');
                       window.immediateUpdate('effects-pipeline');
                   } else if (window.update && typeof window.update === 'function') {
                       console.log('🎨 [Pipeline] Fallback to regular update');
                       window.update();
                   }

                   // Process any pending updates
                   if (this.pendingUpdate) {
                       this.pendingUpdate = false;
                       setTimeout(() => {
                           this.isProcessing = false;
                           this.triggerPipelineUpdate('pending');
                       }, 100);
                   } else {
                       this.isProcessing = false;
                   }

               } catch (error) {
                   console.error('🎨 [Pipeline] Error during pipeline update:', error);
                   this.isProcessing = false;
               }
           }
       }

       // Create global pipeline instance
       window.imageEffectsPipeline = new ImageEffectsPipeline();

       // Initialize halftone controls when DOM is ready
       document.addEventListener('DOMContentLoaded', () => {
           console.log('🎨 [Halftone] DOMContentLoaded event fired, setting up halftone...');
           setTimeout(() => {
               setupHalftoneControls();
           }, 1000); // Delay to ensure all elements are ready
       });

       if (document.readyState !== 'loading') {
           console.log('🎨 [Halftone] DOM already loaded, setting up halftone with delay...');
           setTimeout(setupHalftoneControls, 1000);
       }

       // ===== USER-FRIENDLY TEXT EDITING WITHOUT SELECTION =====

       // Function to get or create a text object to work with
       function getOrCreateTextObject() {
           // Check if we have canvas objects
           if (!window.canvasObjects || !Array.isArray(window.canvasObjects)) {
               console.log('🎯 No canvas objects available');
               return null;
           }

           // Find all text objects
           const textObjects = window.canvasObjects.filter(obj => obj.type === 'text');

           if (textObjects.length === 0) {
               // No text objects exist, create a new one
               console.log('🎯 No text objects found, creating new text');

               // Create a new text object
               const newText = {
                   id: Date.now(),
                   type: 'text',
                   text: 'Sample Text',
                   x: 400, // Center of typical canvas
                   y: 300,
                   fontSize: 48,
                   fontFamily: 'Arial',
                   color: '#000000',
                   rotation: 0
               };

               // Add to canvas objects
               window.canvasObjects.push(newText);

               // Update canvas
               if (window.update && typeof window.update === 'function') {
                   window.update();
               }

               console.log('🎯 Created new text object:', newText);
               return newText;
           } else {
               // Use the first text object
               console.log('🎯 Using first text object:', textObjects[0]);
               return textObjects[0];
           }
       }

       // Debounce timer for expensive rendering operations
       let renderDebounceTimer = null;
       const RENDER_DEBOUNCE_DELAY = 300; // 300ms delay

       // Function to apply changes to text object
       function applyTextChanges(textObj, changes) {
           if (!textObj) return;

           // Apply changes immediately to the object
           Object.keys(changes).forEach(key => {
               if (changes[key] !== undefined) {
                   textObj[key] = changes[key];
                   console.log(`🎯 Applied ${key}: ${changes[key]} to text "${textObj.text}"`);
               }
           });

           // Debounce the expensive canvas update
           if (renderDebounceTimer) {
               clearTimeout(renderDebounceTimer);
           }

           renderDebounceTimer = setTimeout(() => {
               console.log(`🎯 DEBOUNCED: Rendering after ${RENDER_DEBOUNCE_DELAY}ms delay for text: "${textObj.text}"`);
               if (window.update && typeof window.update === 'function') {
                   window.update();
               }
               renderDebounceTimer = null;
           }, RENDER_DEBOUNCE_DELAY);
       }

       // Setup text input to work without selection
       function setupUserFriendlyTextEditing() {
           try {
               console.log('🔧 Setting up user-friendly text editing...');

               const textInput = document.getElementById('iText');
               const colorInput = document.getElementById('iTextColor');
               const rotationInput = document.getElementById('iTextRotation');
               const rotationValue = document.getElementById('vTextRotation');

               console.log('🔧 Elements found:', {
                   textInput: !!textInput,
                   colorInput: !!colorInput,
                   rotationInput: !!rotationInput,
                   rotationValue: !!rotationValue
               });

           if (textInput) {
               textInput.addEventListener('input', function() {
                   const newText = this.value.trim();
                   if (newText) {
                       const textObj = getOrCreateTextObject();
                       if (textObj) {
                           console.log(`🎯 IMMEDIATE: Text input changed to "${newText}" (render will be debounced)`);
                           // Use debounced rendering for expensive operations
                           applyTextChanges(textObj, { text: newText });
                       }
                   }
               });
           }

           if (colorInput) {
               colorInput.addEventListener('input', function() {
                   const newColor = this.value;
                   const textObj = getOrCreateTextObject();
                   if (textObj) {
                       applyTextChanges(textObj, { color: newColor });
                   }
               });
           }

           if (rotationInput && rotationValue) {
               rotationInput.addEventListener('input', function() {
                   const newRotation = parseInt(this.value);
                   rotationValue.textContent = newRotation + '°';

                   const textObj = getOrCreateTextObject();
                   if (textObj) {
                       applyTextChanges(textObj, { rotation: newRotation });
                   }
               });
           }

           console.log('🎯 User-friendly text editing setup complete');
           } catch (error) {
               console.error('🚨 Error in setupUserFriendlyTextEditing:', error);
           }
       }

       // DISABLED: Initialize user-friendly text editing - CONFLICTS WITH MAIN TEXT INPUT HANDLER
       // document.addEventListener('DOMContentLoaded', setupUserFriendlyTextEditing);
       // if (document.readyState !== 'loading') {
       //     setupUserFriendlyTextEditing();
       // }
       console.log('🚨 DISABLED conflicting text input handler to fix ID collision issue');

       // ===== FONT NAVIGATION ARROWS FUNCTIONALITY =====

       function setupFontNavigation() {
           const fontSelect = document.getElementById('iFontFamily');
           const fontNavUp = document.getElementById('fontNavUp');
           const fontNavDown = document.getElementById('fontNavDown');
           const fontFilter = document.getElementById('iFontFilter');

           if (!fontSelect || !fontNavUp || !fontNavDown || !fontFilter) {
               console.log('🔤 Font navigation elements not found');
               return;
           }

           // Font tagging system - same tags as font-preview.html
           const FONT_TAGS = [
               'All',
               'Condensed',
               'Condensed Regular',
               'Sans Serif',
               'Serif',
               'Elegant',
               'Modern',
               'Playful',
               'Bold',
               'Light',
               'Script',
               'Black',
               'Rounded',
               'Extended Regular',
               'Extended'
           ];

           // Global font tags cache for design editor
           let designEditorFontTags = {};

           // Load saved font tags from database
           async function loadFontTags() {
               try {
                   console.log('🏷️ [DESIGN-EDITOR] Loading font tags from database...');
                   const response = await fetch('/api/font-tags');

                   if (!response.ok) {
                       throw new Error(`HTTP error! status: ${response.status}`);
                   }

                   const result = await response.json();

                   if (result.success) {
                       designEditorFontTags = result.data;
                       console.log('🏷️ [DESIGN-EDITOR] Successfully loaded font tags for', Object.keys(designEditorFontTags).length, 'fonts');
                       console.log('🏷️ [DESIGN-EDITOR] Font tags data:', designEditorFontTags);
                       return designEditorFontTags;
                   } else {
                       console.error('🏷️ [DESIGN-EDITOR] Failed to load font tags:', result.error);
                       return {};
                   }
               } catch (error) {
                   console.error('🏷️ [DESIGN-EDITOR] Error loading font tags from database:', error);

                   // Fallback to localStorage if database fails
                   console.log('🏷️ [DESIGN-EDITOR] Falling back to localStorage...');
                   const saved = localStorage.getItem('fontTags');
                   const localData = saved ? JSON.parse(saved) : {};
                   console.log('🏷️ [DESIGN-EDITOR] Loaded font tags from localStorage:', localData);
                   return localData;
               }
           }

           // Get fonts that match the selected filter
           function getFilteredFonts(allFonts, selectedFilter) {
               if (selectedFilter === 'All') {
                   return allFonts;
               }

               // Use cached font tags data
               const fontTags = designEditorFontTags;
               const filteredFonts = [];

               console.log(`🏷️ [DESIGN-EDITOR] Filtering for "${selectedFilter}" from ${allFonts.length} fonts`);
               console.log('🏷️ [DESIGN-EDITOR] Available fonts:', allFonts);
               console.log('🏷️ [DESIGN-EDITOR] Font tags database:', fontTags);

               allFonts.forEach(fontName => {
                   const tags = fontTags[fontName] || [];
                   console.log(`🏷️ [DESIGN-EDITOR] Font "${fontName}" has tags:`, tags);
                   if (tags.includes(selectedFilter)) {
                       filteredFonts.push(fontName);
                       console.log(`🏷️ [DESIGN-EDITOR] ✅ Font "${fontName}" matches filter "${selectedFilter}"`);
                   }
               });

               console.log(`🏷️ [DESIGN-EDITOR] Filter "${selectedFilter}" found ${filteredFonts.length} fonts:`, filteredFonts);
               return filteredFonts;
           }



           // ===== FONT DROPDOWN HANDLED BY JAVASCRIPT FILE =====
           // Font population is handled by design-editor-fixed-new.js
           // This avoids conflicts and ensures proper font styling
           function populateFontDropdown_DISABLED(filterTag = 'All') {
               // Get fonts from fontMap (same as font-preview.html)
               let allFonts = [];

               if (typeof window.fontMap !== 'undefined' && window.fontMap) {
                   // Use fontMap if available (preferred method)
                   allFonts = Object.keys(window.fontMap);
                   console.log(`🔤 [DESIGN-EDITOR] Using fontMap: ${allFonts.length} fonts`);
                   console.log(`🔤 [DESIGN-EDITOR] First 10 fonts:`, allFonts.slice(0, 10));
               } else {
                   // Fallback to CSS variables + basic fonts
                   const availableFonts = getComputedStyle(document.documentElement)
                       .getPropertyValue('--available-fonts')
                       .split(',')
                       .map(font => font.trim().replace(/['"]/g, ''));

                   const basicFonts = ['Poppins', 'Arial', 'Verdana', 'Georgia', 'Times New Roman', 'Courier New', 'Impact', 'Comic Sans MS'];
                   allFonts = [...new Set([...basicFonts, ...availableFonts])];
                   console.log(`🔤 [DESIGN-EDITOR] Fallback method: ${allFonts.length} fonts`);
               }

               console.log(`🔤 [DESIGN-EDITOR] Total fonts available: ${allFonts.length}`, allFonts.slice(0, 10), '...');

               // Apply filter
               const filteredFonts = getFilteredFonts(allFonts, filterTag);

               console.log(`🔤 Populating dropdown with ${filteredFonts.length} fonts (filter: ${filterTag})`);

               // Store current selection to preserve it if possible
               const currentFont = fontSelect.value;

               // Clear existing options except the first one (keep the structure)
               const firstOption = fontSelect.options[0];
               fontSelect.innerHTML = '';
               if (firstOption) {
                   fontSelect.appendChild(firstOption);
               }

               // Add filtered fonts to dropdown
               filteredFonts.forEach(fontName => {
                   if (fontName.trim()) {
                       const option = document.createElement('option');
                       option.value = fontName;
                       option.textContent = fontName;
                       option.style.fontFamily = `"${fontName}", sans-serif`;
                       option.style.fontSize = '14px';
                       option.style.padding = '4px 8px';
                       console.log(`🔤 Font option created: ${fontName} with style: ${option.style.fontFamily}`);
                       fontSelect.appendChild(option);
                   }
               });

               // Font dropdown populated successfully
               console.log(`🔤 Font dropdown populated with ${filteredFonts.length} fonts`);

               // Try to restore previous selection if it's still available
               if (currentFont && filteredFonts.includes(currentFont)) {
                   fontSelect.value = currentFont;
               } else if (filteredFonts.length > 0) {
                   // If current font is not in filtered list, select first available font
                   fontSelect.value = filteredFonts[0];
                   // Apply the new font to the selected object
                   if (typeof applyFontChange === 'function') {
                       applyFontChange(filteredFonts[0]);
                   }
               }

               console.log(`🔤 Font dropdown populated with ${fontSelect.options.length} fonts (showing ${filteredFonts.length} filtered fonts)`);

               // Update button states after population
               updateButtonStates();
           }

           // ===== FONT FILTER FUNCTIONALITY =====
           fontFilter.addEventListener('change', async function(e) {
               const selectedFilter = e.target.value;
               console.log('🏷️ [DESIGN-EDITOR] Font filter changed to:', selectedFilter);

               // Load font tags from database first (if not already loaded)
               if (Object.keys(designEditorFontTags).length === 0) {
                   console.log('🏷️ [DESIGN-EDITOR] Font tags not loaded, loading from database...');
                   await loadFontTags();
               }

               // Repopulate dropdown with filtered fonts
               // populateFontDropdown(selectedFilter); // DISABLED - handled by JS file
           });

           // Load font tags and populate the dropdown
           async function initializeFontSystem() {
               console.log('🏷️ [DESIGN-EDITOR] Initializing font system...');
               await loadFontTags();
               // populateFontDropdown('All'); // DISABLED - handled by JS file
           }

           // Initialize the font system
           initializeFontSystem();

           // Get all font options after population
           const fontOptions = Array.from(fontSelect.options).map(option => option.value);
           console.log('🔤 Font navigation setup:', fontOptions.length, 'fonts available');

           // ===== MAIN FONT APPLICATION HANDLER =====
           function applyFontChange(fontFamily) {
               console.log('🔤 Applying font change to:', fontFamily);

               // Find the selected text object
               const selectedObject = canvasObjects[selectedObjectIndex];
               if (!selectedObject || selectedObject.type !== 'text') {
                   console.log('🔤 No text object selected');
                   return;
               }

               // Update the font family property using the same method as the existing dropdown
               if (typeof updateSelectedObjectFromUI === 'function') {
                   updateSelectedObjectFromUI('fontFamily', fontFamily);
                   console.log('🔤 Font applied successfully via updateSelectedObjectFromUI:', fontFamily);
               } else {
                   // Fallback: direct property update
                   selectedObject.fontFamily = fontFamily;
                   if (typeof update === 'function') {
                       update();
                   }
                   console.log('🔤 Font applied successfully via direct update:', fontFamily);
               }
           }

           // ===== DROPDOWN SYNC FUNCTION =====
           function syncDropdownWithCurrentFont() {
               const selectedObject = canvasObjects[selectedObjectIndex];
               if (!selectedObject || selectedObject.type !== 'text') {
                   return;
               }

               const currentFont = selectedObject.fontFamily;
               // Get fresh font options in case dropdown was repopulated
               const currentFontOptions = Array.from(fontSelect.options).map(option => option.value);
               const fontIndex = currentFontOptions.indexOf(currentFont);

               if (fontIndex >= 0) {
                   fontSelect.selectedIndex = fontIndex;
                   console.log('🔤 Synced dropdown to current font:', currentFont, 'at index', fontIndex);
               } else {
                   // Font not in dropdown, keep current selection or reset to first option
                   console.log('🔤 Current font not in dropdown:', currentFont, 'keeping current selection');
                   // Don't reset to avoid the Acme issue - just keep current selection
               }
           }

           // Function to update button states
           function updateButtonStates() {
               let currentIndex = fontSelect.selectedIndex;
               const isDisabled = fontSelect.disabled;

               // Get fresh font options in case dropdown was repopulated
               const currentFontOptions = Array.from(fontSelect.options).map(option => option.value);

               // FIX: Validate and correct invalid selectedIndex - but don't auto-reset to 0
               if (currentIndex < 0 || currentIndex >= currentFontOptions.length) {
                   console.log('🔤 Invalid selectedIndex detected:', currentIndex, 'out of', currentFontOptions.length, 'fonts');
                   // Don't auto-reset to prevent the Acme issue
                   currentIndex = Math.max(0, Math.min(currentIndex, currentFontOptions.length - 1));
                   console.log('🔤 Corrected to valid index:', currentIndex);
               }

               if (isDisabled) {
                   // If dropdown is disabled, disable both buttons
                   fontNavUp.disabled = true;
                   fontNavDown.disabled = true;
               } else {
                   // If dropdown is enabled, check position in list
                   fontNavUp.disabled = (currentIndex <= 0);
                   fontNavDown.disabled = (currentIndex >= currentFontOptions.length - 1);
               }
           }

           // ===== MAIN FONT DROPDOWN CHANGE HANDLER =====
           fontSelect.addEventListener('change', function(e) {
               const selectedFont = e.target.value;
               console.log('🔤 Font dropdown changed to:', selectedFont);

               // Apply the font change
               applyFontChange(selectedFont);

               // Update button states
               updateButtonStates();
           });

           // Function to change font (works with filtered fonts)
           function changeFontByDirection(direction) {
               if (fontSelect.disabled) return;

               let currentIndex = fontSelect.selectedIndex;

               // Get fresh font options in case dropdown was repopulated by filter
               const currentFontOptions = Array.from(fontSelect.options).map(option => option.value);

               // FIX: Validate and correct invalid selectedIndex
               if (currentIndex < 0 || currentIndex >= currentFontOptions.length) {
                   currentIndex = Math.max(0, Math.min(currentIndex, currentFontOptions.length - 1));
                   fontSelect.selectedIndex = currentIndex;
               }

               let newIndex;
               if (direction === 'up') {
                   newIndex = Math.max(0, currentIndex - 1);
               } else if (direction === 'down') {
                   newIndex = Math.min(currentFontOptions.length - 1, currentIndex + 1);
               }

               if (newIndex !== currentIndex && newIndex >= 0 && newIndex < currentFontOptions.length) {
                   // Update dropdown selection
                   fontSelect.selectedIndex = newIndex;

                   // Apply font change directly (no need to trigger change event)
                   const newFont = currentFontOptions[newIndex];
                   applyFontChange(newFont);

                   const currentFilter = fontFilter.value;
                   console.log(`🔤 Font navigation (filter: ${currentFilter}):`, currentFontOptions[currentIndex], '→', newFont);
               }

               // Update button states after change
               updateButtonStates();
           }

           // Add event listeners
           fontNavUp.addEventListener('click', () => changeFontByDirection('up'));
           fontNavDown.addEventListener('click', () => changeFontByDirection('down'));

           // Listen for disabled state changes
           const observer = new MutationObserver(function(mutations) {
               mutations.forEach(function(mutation) {
                   if (mutation.type === 'attributes' && mutation.attributeName === 'disabled') {
                       // Add small delay to ensure state is fully updated
                       setTimeout(() => {
                           updateButtonStates();
                           // Sync dropdown when enabled
                           if (!fontSelect.disabled) {
                               syncDropdownWithCurrentFont();
                           }
                       }, 10);
                   }
               });
           });

           observer.observe(fontSelect, {
               attributes: true,
               attributeFilter: ['disabled']
           });

           // ===== GLOBAL SYNC FUNCTION =====
           // Make sync function available globally for other parts of the app
           window.syncFontDropdown = syncDropdownWithCurrentFont;

           // Force reset font dropdown to valid state
           function resetFontDropdownToValidState() {
               const currentIndex = fontSelect.selectedIndex;
               if (currentIndex < 0 || currentIndex >= fontOptions.length) {
                   console.log('🔤 🔧 FORCE RESET: Invalid selectedIndex', currentIndex, 'resetting to sync with current font');
                   syncDropdownWithCurrentFont();
               }
           }

           // Initial font state reset and button state update
           resetFontDropdownToValidState();
           updateButtonStates();

           // Limited periodic check - only for 15 seconds after setup
           let intervalCount = 0;
           const maxIntervals = 15; // 15 seconds
           const cleanupInterval = setInterval(() => {
               intervalCount++;

               if (intervalCount >= maxIntervals) {
                   clearInterval(cleanupInterval);
                   console.log('🔤 Font navigation cleanup completed - stopped periodic checks');
                   return;
               }

               // Only check and fix if there's actually an issue
               const currentIndex = fontSelect.selectedIndex;
               if (currentIndex < 0 || currentIndex >= fontOptions.length) {
                   resetFontDropdownToValidState();
                   updateButtonStates();
                   console.log('🔤 Fixed invalid font state during cleanup check');
               }
           }, 1000);

           console.log('🔤 Font navigation setup complete');

           // ===== DEBUG HELPER FUNCTIONS =====
           // Make debug functions available globally
           window.debugFontTags = function() {
               const tags = loadFontTags();
               console.log('🏷️ [DEBUG] Current font tags in localStorage:', tags);
               console.log('🏷️ [DEBUG] Number of tagged fonts:', Object.keys(tags).length);

               // Show which fonts have which tags
               Object.keys(tags).forEach(fontName => {
                   console.log(`🏷️ [DEBUG] "${fontName}": [${tags[fontName].join(', ')}]`);
               });

               return tags;
           };

           window.clearFontTags = function() {
               localStorage.removeItem('fontTags');
               console.log('🏷️ [DEBUG] Font tags cleared from localStorage');
           };

           window.checkLocalStorage = function() {
               console.log('🏷️ [STORAGE] All localStorage keys:', Object.keys(localStorage));
               console.log('🏷️ [STORAGE] fontTags raw value:', localStorage.getItem('fontTags'));

               try {
                   const parsed = JSON.parse(localStorage.getItem('fontTags') || '{}');
                   console.log('🏷️ [STORAGE] fontTags parsed:', parsed);
                   console.log('🏷️ [STORAGE] Number of tagged fonts:', Object.keys(parsed).length);
                   return parsed;
               } catch (e) {
                   console.error('🏷️ [STORAGE] Error parsing fontTags:', e);
                   return null;
               }
           };

           window.addTestTags = function() {
               const testTags = {
                   'Arial': ['Sans Serif', 'Modern'],
                   'Poppins': ['Sans Serif', 'Modern'],
                   'Georgia': ['Serif', 'Elegant'],
                   'Times New Roman': ['Serif'],
                   'Impact': ['Bold', 'Extended']
               };
               localStorage.setItem('fontTags', JSON.stringify(testTags));
               console.log('🏷️ [DEBUG] Test tags added:', testTags);

               // Refresh the font dropdown
               const currentFilter = document.getElementById('iFontFilter').value;
               // populateFontDropdown(currentFilter); // DISABLED - handled by JS file
           };

           window.compareFontLists = function() {
               // Get fonts from design editor
               const availableFonts = getComputedStyle(document.documentElement)
                   .getPropertyValue('--available-fonts')
                   .split(',')
                   .map(font => font.trim().replace(/['"]/g, ''));
               const basicFonts = ['Poppins', 'Arial', 'Verdana', 'Georgia', 'Times New Roman', 'Courier New', 'Impact', 'Comic Sans MS'];
               const designEditorFonts = [...new Set([...basicFonts, ...availableFonts])];

               console.log('🔤 [COMPARE] Design Editor fonts:', designEditorFonts);
               console.log('🔤 [COMPARE] Design Editor font count:', designEditorFonts.length);

               // Check if fontMap is available (from font-preview.html)
               if (typeof window.fontMap !== 'undefined') {
                   const fontPreviewFonts = Object.keys(window.fontMap);
                   console.log('🔤 [COMPARE] Font Preview fonts:', fontPreviewFonts);
                   console.log('🔤 [COMPARE] Font Preview font count:', fontPreviewFonts.length);

                   // Find differences
                   const onlyInDesignEditor = designEditorFonts.filter(f => !fontPreviewFonts.includes(f));
                   const onlyInFontPreview = fontPreviewFonts.filter(f => !designEditorFonts.includes(f));

                   console.log('🔤 [COMPARE] Only in Design Editor:', onlyInDesignEditor);
                   console.log('🔤 [COMPARE] Only in Font Preview:', onlyInFontPreview);
               } else {
                   console.log('🔤 [COMPARE] fontMap not available - open font-preview.html first');
               }

               return designEditorFonts;
           };
       }

       // Initialize font navigation
       document.addEventListener('DOMContentLoaded', setupFontNavigation);
       if (document.readyState !== 'loading') {
           setupFontNavigation();
       }

       // ===== ENSURE FONT/DECOR BUTTONS ARE ALWAYS ENABLED =====

       function ensureButtonsEnabled() {
           const buttons = [
               'changeFontsBtn', 'changeDecorBtn', 'changeColorsBtn',
               'changeImageEffectBtn', 'changeImageColorsBtn', 'resetImageEffectBtn',
               'saveFontStyleBtn', 'saveDecorStyleBtn'
           ];

           let enabledCount = 0;
           buttons.forEach(buttonId => {
               const button = document.getElementById(buttonId);
               if (button && button.disabled) {
                   button.disabled = false;
                   button.removeAttribute('disabled');
                   enabledCount++;
               }
           });

           // Only log if buttons were actually enabled
           if (enabledCount > 0) {
               console.log('🎯 Enabled', enabledCount, 'buttons');
           }
       }

       // Flag to track if template/project is fully loaded
       let isFullyLoaded = false;
       let buttonProtectionInterval = null;

       // Run immediately and limited protection to prevent other code from disabling buttons
       function setupButtonProtection() {
           ensureButtonsEnabled();

           // Only run interval if not fully loaded - LIMITED TO 15 SECONDS MAX
           if (!isFullyLoaded) {
               let protectionCount = 0;
               const maxProtectionRuns = 3; // Only 3 times (15 seconds total)

               buttonProtectionInterval = setInterval(() => {
                   protectionCount++;

                   if (isFullyLoaded || protectionCount >= maxProtectionRuns) {
                       clearInterval(buttonProtectionInterval);
                       console.log('🎯 Button protection stopped - limit reached or fully loaded');
                       return;
                   }
                   ensureButtonsEnabled();
               }, 5000); // Every 5 seconds, max 3 times

               // Single delayed run
               setTimeout(ensureButtonsEnabled, 2000);
           }

           console.log('🎯 Button protection setup (limited)');
       }

       // Function to mark as fully loaded and stop protection loops
       function markAsFullyLoaded() {
           isFullyLoaded = true;
           window.isFullyLoaded = true; // Also set global flag

           // 🔧 PERFORMANCE FIX: Set state flags to stop monitoring loops
           window._isTemplateLoaded = true;
           window._fontStylesMonitoringComplete = true;
           window._decorStylesMonitoringComplete = true;

           if (buttonProtectionInterval) {
               clearInterval(buttonProtectionInterval);
               buttonProtectionInterval = null;
           }
           console.log('🛡️ PERFORMANCE: System marked as fully loaded - all monitoring stopped');
       }

       // Expose globally for access from other scripts
       window.markAsFullyLoaded = markAsFullyLoaded;

       // Initialize button protection
       document.addEventListener('DOMContentLoaded', setupButtonProtection);
       if (document.readyState !== 'loading') {
           setupButtonProtection();
       }

       // ===== MUTATION OBSERVER TO PREVENT BUTTON DISABLING =====

       function setupMutationObserver() {
           const targetButtons = ['changeFontsBtn', 'changeDecorBtn', 'changeColorsBtn', 'changeImageEffectBtn', 'resetImageEffectBtn', 'saveFontStyleBtn', 'saveDecorStyleBtn'];
           let observerCount = 0;

           targetButtons.forEach(buttonId => {
               const button = document.getElementById(buttonId);
               if (button) {
                   // Create observer for this button - LIMITED LOGGING
                   const observer = new MutationObserver(function(mutations) {
                       mutations.forEach(function(mutation) {
                           if (mutation.type === 'attributes' && mutation.attributeName === 'disabled') {
                               // If button gets disabled, immediately re-enable it
                               if (button.disabled) {
                                   button.disabled = false;
                                   button.removeAttribute('disabled');
                                   // Only log first few times to avoid spam
                                   if (observerCount < 3) {
                                       console.log(`🎯 Re-enabled ${buttonId}`);
                                       observerCount++;
                                   }
                               }
                           }
                       });
                   });

                   // Start observing
                   observer.observe(button, {
                       attributes: true,
                       attributeFilter: ['disabled']
                   });
               }
           });

           console.log(`🎯 Mutation observers setup for ${targetButtons.length} buttons`);
       }

       // Setup mutation observer after DOM is ready
       document.addEventListener('DOMContentLoaded', function() {
           setTimeout(setupMutationObserver, 1000); // Delay to ensure buttons exist
       });
       if (document.readyState !== 'loading') {
           setTimeout(setupMutationObserver, 1000);
       }

       // ===== IMAGE EFFECT BUTTONS FUNCTIONALITY =====

       // Track last applied preset to avoid consecutive repeats
       let lastAppliedImageEffect = null;

       // Function to get comprehensive presets only (those with version property)
       function getComprehensivePresets() {
           const comprehensivePresets = [];
           for (const [key, preset] of Object.entries(filterPresets)) {
               if (preset && preset.version) {
                   comprehensivePresets.push(key);
               }
           }
           return comprehensivePresets;
       }

       // Function to apply random image effect
       function applyRandomImageEffect() {
           console.log('🎭 [Random Image Effect] Applying random image effect...');

           // Check if an image is selected
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               console.log('🎭 [Random Image Effect] No image selected');
               updateImageEffectStatus('Please select an image first');
               return;
           }

           const comprehensivePresets = getComprehensivePresets();
           if (comprehensivePresets.length === 0) {
               console.log('🎭 [Random Image Effect] No comprehensive presets available');
               updateImageEffectStatus('No image effect presets available');
               return;
           }

           // Filter out the last applied preset to avoid consecutive repeats
           let availablePresets = comprehensivePresets;
           if (lastAppliedImageEffect && comprehensivePresets.length > 1) {
               availablePresets = comprehensivePresets.filter(preset => preset !== lastAppliedImageEffect);
           }

           // Select random preset
           const randomIndex = Math.floor(Math.random() * availablePresets.length);
           const selectedPreset = availablePresets[randomIndex];
           const presetData = filterPresets[selectedPreset];

           console.log('🎭 [Random Image Effect] Selected preset:', selectedPreset);
           console.log('🎭 [Random Image Effect] Available presets:', availablePresets.length);

           // Update the dropdown to show the selected preset
           const presetSelect = document.getElementById('filterPresetSelect');
           if (presetSelect) {
               presetSelect.value = selectedPreset;
           }

           // Apply the preset using the same workflow as dropdown selection
           resetAllImageEffects(false); // Don't clear dropdown

           setTimeout(() => {
               applyComprehensivePreset(presetData);
               lastAppliedImageEffect = selectedPreset;
               updateImageEffectStatus(`Applied: ${selectedPreset}`);
               console.log('🎭 [Random Image Effect] Successfully applied:', selectedPreset);
           }, 100);
       }

       // Function to change image colors (hue rotation only)
       function changeImageColors() {
           console.log('🎨 [Change Image Colors] ===== FUNCTION CALLED =====');
           console.log('🎨 [Change Image Colors] Changing image colors via hue rotation...');

           // Check if an image is selected
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               console.log('🎨 [Change Image Colors] No image selected');
               updateImageEffectStatus('Please select an image first');
               return;
           }

           // Generate random hue rotation value (0-360 degrees)
           const randomHue = Math.floor(Math.random() * 361);
           console.log('🎨 [Change Image Colors] Generated random hue:', randomHue + '°');

           // Get the current CSS filter hue-rotate slider (correct ID is iImageHue)
           const hueRotateSlider = document.getElementById('iImageHue');
           const hueRotateDisplay = document.getElementById('vImageHue');

           if (hueRotateSlider && hueRotateDisplay) {
               // Update the slider value
               hueRotateSlider.value = randomHue;
               hueRotateDisplay.textContent = randomHue + '°';

               // Trigger the CSS filters system to apply the change
               // This will automatically use the unified pipeline
               if (window.applyImageFilters && typeof window.applyImageFilters === 'function') {
                   console.log('🎨 [Change Image Colors] Calling applyImageFilters() to apply hue rotation');
                   window.applyImageFilters();
               } else {
                   console.error('🎨 [Change Image Colors] applyImageFilters function not available');
                   updateImageEffectStatus('Error: CSS filters system not available');
                   return;
               }

               updateImageEffectStatus(`Hue rotated to ${randomHue}°`);
               console.log('🎨 [Change Image Colors] Successfully applied hue rotation:', randomHue + '°');
           } else {
               console.error('🎨 [Change Image Colors] Hue rotate controls not found');
               updateImageEffectStatus('Error: Hue rotate controls not found');
           }
       }

       // Function to reset image effects
       function resetImageEffects() {
           console.log('🔄 [Reset Image Effect] Resetting all image effects...');

           // Check if an image is selected
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               console.log('🔄 [Reset Image Effect] No image selected');
               updateImageEffectStatus('Please select an image first');
               return;
           }

           // Call the existing reset function
           resetAllImageEffects(true); // Clear dropdown as well
           lastAppliedImageEffect = null;
           updateImageEffectStatus('All effects reset');
           console.log('🔄 [Reset Image Effect] All effects reset successfully');
       }

       // Make changeImageColors globally accessible
       window.changeImageColors = changeImageColors;

       // Function to update the status display
       function updateImageEffectStatus(message) {
           const statusElement = document.getElementById('imageEffectStatus');
           if (statusElement) {
               statusElement.textContent = message;
           }
       }

       // Setup event handlers for image effect buttons
       function setupImageEffectButtons() {
           const changeImageEffectBtn = document.getElementById('changeImageEffectBtn');
           const changeImageColorsBtn = document.getElementById('changeImageColorsBtn');
           const resetImageEffectBtn = document.getElementById('resetImageEffectBtn');

           if (changeImageEffectBtn) {
               changeImageEffectBtn.addEventListener('click', applyRandomImageEffect);
               console.log('🎭 [Setup] Change Image Effect button event handler added');
           }

           if (changeImageColorsBtn) {
               // Add test click listener first
               changeImageColorsBtn.addEventListener('click', function(e) {
                   console.log('🎨 [DEBUG] Button clicked! Event:', e);
                   console.log('🎨 [DEBUG] Button disabled state:', changeImageColorsBtn.disabled);
                   console.log('🎨 [DEBUG] Button attributes:', changeImageColorsBtn.attributes);
               });

               changeImageColorsBtn.addEventListener('click', changeImageColors);
               // Ensure button is enabled
               changeImageColorsBtn.disabled = false;
               changeImageColorsBtn.removeAttribute('disabled');
               console.log('🎨 [Setup] Change Image Colors button event handler added and enabled');
               console.log('🎨 [Setup] Button element:', changeImageColorsBtn);
           } else {
               console.error('🎨 [Setup] changeImageColorsBtn not found!');
           }

           if (resetImageEffectBtn) {
               resetImageEffectBtn.addEventListener('click', resetImageEffects);
               console.log('🔄 [Setup] Reset Image Effect button event handler added');
           }
       }

       // Setup Image Action Buttons
       function setupImageActionButtons() {
           const removeBgBtn = document.getElementById('removeBgBtn');
           const regenerateBtn = document.getElementById('regenerateBtn');
           const restyleBtn = document.getElementById('restyleBtn');
           const replaceBtn = document.getElementById('replaceBtn');

           // Remove Background button is handled by external JS file (design-editor-fixed-new.js)
           if (removeBgBtn) {
               console.log('🖼️ [Setup] Remove Background button found - handler will be added by design-editor-fixed-new.js');
           }

           // Regenerate button is handled by external JS file (design-editor-fixed-new.js)

           if (restyleBtn) {
               restyleBtn.addEventListener('click', handleRestyleImage);
               console.log('🎨 [Setup] Restyle button event handler added');
           }

           if (replaceBtn) {
               replaceBtn.addEventListener('click', handleReplaceImage);
               console.log('🔄 [Setup] Replace button event handler added');
           }
       }

       // Handle Remove Background
       async function handleRemoveBackground() {
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               if (window.showToast) window.showToast('Please select an image first', 'error');
               return;
           }

           const removeBgBtn = document.getElementById('removeBgBtn');
           if (!removeBgBtn) return;

           try {
               removeBgBtn.disabled = true;
               removeBgBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Removing Background...';

               const response = await fetch('/api/images/bgremove', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   credentials: 'include',
                   body: JSON.stringify({
                       imageUrl: selectedObject.src,
                       generationId: selectedObject.generationId || 'temp-' + Date.now()
                   })
               });

               const data = await response.json();
               if (!response.ok) {
                   throw new Error(data.error || 'Failed to remove background');
               }

               // Update the selected object with the new image
               selectedObject.src = data.imageUrl;

               // Update admin image URL if available
               const adminImageUrl = document.getElementById('adminImageUrl');
               if (adminImageUrl) {
                   adminImageUrl.value = data.imageUrl;
               }

               // Redraw canvas
               if (typeof window.update === 'function') {
                   window.update();
               }

               if (window.showToast) window.showToast('Background removed successfully!', 'success');

           } catch (error) {
               console.error('Error removing background:', error);
               if (window.showToast) window.showToast('Failed to remove background: ' + error.message, 'error');
           } finally {
               removeBgBtn.disabled = false;
               removeBgBtn.innerHTML = '<i class="fas fa-cut"></i> Remove Background';
           }
       }





       // Handle Restyle Image
       async function handleRestyleImage() {
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               if (window.showToast) window.showToast('Please select an image first', 'error');
               return;
           }

           // Set restyle mode and trigger generation
           window.isRestyleMode = true;
           window.isReplaceMode = false;

           // Trigger the existing AI generation workflow
           if (typeof window.generateAIImage === 'function') {
               window.generateAIImage();
           } else {
               if (window.showToast) window.showToast('Restyle functionality not available', 'error');
           }
       }

       // Handle Replace Image
       async function handleReplaceImage() {
           const selectedObject = getSelectedImageObject();
           if (!selectedObject) {
               if (window.showToast) window.showToast('Please select an image first', 'error');
               return;
           }

           // Set replace mode and trigger generation
           window.isReplaceMode = true;
           window.isRestyleMode = false;

           // Trigger the existing AI generation workflow
           if (typeof window.generateAIImage === 'function') {
               window.generateAIImage();
           } else {
               if (window.showToast) window.showToast('Replace functionality not available', 'error');
           }
       }



       // Update image action buttons visibility
       function updateImageActionButtonsVisibility() {
           const removeBgBtn = document.getElementById('removeBgBtn');
           const regenerateBtn = document.getElementById('regenerateBtn');
           const restyleBtn = document.getElementById('restyleBtn');
           const replaceBtn = document.getElementById('replaceBtn');

           const selectedImageObject = getSelectedImageObject();
           const shouldShow = selectedImageObject !== null;

           // Show/hide buttons based on whether an image is selected
           if (removeBgBtn) {
               removeBgBtn.classList.toggle('hidden', !shouldShow);
           }
           if (regenerateBtn) {
               regenerateBtn.classList.toggle('hidden', !shouldShow);
           }
           if (restyleBtn) {
               restyleBtn.classList.toggle('hidden', !shouldShow);
           }
           if (replaceBtn) {
               replaceBtn.classList.toggle('hidden', !shouldShow);
           }

           console.log('🖼️ Image action buttons visibility updated:', shouldShow ? 'visible' : 'hidden');
       }

       // Setup selection monitoring for image action buttons
       function setupImageActionButtonsSelectionMonitoring() {
           // Hook into the updateUIFromSelectedObject function
           const originalUpdate = window.updateUIFromSelectedObject;
           if (originalUpdate) {
               window.updateUIFromSelectedObject = function(...args) {
                   originalUpdate.apply(this, args);
                   updateImageActionButtonsVisibility();
               };
           }

           // Also hook into the update function
           const originalCanvasUpdate = window.update;
           if (originalCanvasUpdate) {
               window.update = function(...args) {
                   originalCanvasUpdate.apply(this, args);
                   // Small delay to ensure UI is updated after canvas render
                   setTimeout(() => updateImageActionButtonsVisibility(), 10);
               };
           }
       }

       // Initialize image effect buttons when DOM is ready
       document.addEventListener('DOMContentLoaded', () => {
           setTimeout(() => {
               setupImageEffectButtons();
               setupImageActionButtons();
               setupImageActionButtonsSelectionMonitoring();
           }, 1000); // Delay to ensure all elements are ready
       });

       if (document.readyState !== 'loading') {
           setTimeout(() => {
               setupImageEffectButtons();
               setupImageActionButtons();
               setupImageActionButtonsSelectionMonitoring();
           }, 1000);
       }

       // AI Generator functionality is handled by left-menu.js

       // ===== SHAPE REPLACEMENT FUNCTIONALITY =====

       // Shape replacement system
       class ShapeReplacementManager {
           constructor() {
               this.adminFolders = [];
               this.isInitialized = false;
               this.originalShapeSize = null; // Store the original shape size for consistent replacements
           }

           async init() {
               console.log('🔷 [ShapeReplacement] Initializing shape replacement system...');

               try {
                   await this.loadAdminFolders();
                   this.setupEventListeners();
                   this.setupSelectionMonitoring();
                   this.isInitialized = true;
                   console.log('🔷 [ShapeReplacement] Shape replacement system initialized successfully');
               } catch (error) {
                   console.error('🔷 [ShapeReplacement] Error initializing shape replacement:', error);
               }
           }

           async loadAdminFolders() {
               try {
                   console.log('🔷 [ShapeReplacement] Loading admin folders...');
                   const response = await fetch('/api/stock-shapes?folder=admin');

                   if (!response.ok) {
                       throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                   }

                   const data = await response.json();
                   this.adminFolders = data.folders || [];

                   console.log('🔷 [ShapeReplacement] Found admin folders:', this.adminFolders);
                   this.populateDropdown();

               } catch (error) {
                   console.error('🔷 [ShapeReplacement] Error loading admin folders:', error);
                   this.updateStatus('Error loading shape categories', 'error');
               }
           }

           populateDropdown() {
               const dropdown = document.getElementById('shapeReplacementFolder');
               if (!dropdown) return;

               // Clear existing options except the first one
               dropdown.innerHTML = '<option value="">Select size...</option>';

               // Add admin folders
               this.adminFolders.forEach(folder => {
                   const option = document.createElement('option');
                   option.value = folder.path;

                   // Clean up the display name (remove "admin-" prefix)
                   let displayName = folder.name;
                   if (displayName.startsWith('admin-')) {
                       displayName = displayName.substring(6); // Remove "admin-" prefix
                   }
                   option.textContent = displayName.charAt(0).toUpperCase() + displayName.slice(1);
                   dropdown.appendChild(option);
               });

               console.log('🔷 [ShapeReplacement] Populated dropdown with', this.adminFolders.length, 'folders');
           }

           setupEventListeners() {
               const changeShapeBtn = document.getElementById('changeShapeBtn');
               const resetSizeBtn = document.getElementById('resetSizeBtn');
               const dropdown = document.getElementById('shapeReplacementFolder');

               if (changeShapeBtn) {
                   changeShapeBtn.addEventListener('click', () => this.handleShapeReplacement());
               }

               if (resetSizeBtn) {
                   resetSizeBtn.addEventListener('click', () => this.handleResetSize());
               }

               if (dropdown) {
                   dropdown.addEventListener('change', () => this.updateButtonState());
               }
           }

           handleResetSize() {
               console.log('🔷 [ShapeReplacement] Reset size button clicked');
               this.resetOriginalShapeSize();
               this.captureOriginalShapeSize(); // Capture new original size from currently selected shape
               this.updateButtonState();
               this.updateStatus('New original size captured!', 'info');
               setTimeout(() => this.updateStatus(), 2000); // Reset status after 2 seconds
           }

           setupSelectionMonitoring() {
               // Monitor canvas selection changes
               const originalUpdate = window.updateUIFromSelectedObject;
               if (originalUpdate) {
                   window.updateUIFromSelectedObject = (...args) => {
                       originalUpdate.apply(this, args);
                       this.onSelectionChange();
                   };
               }

               // Also monitor when objects are selected directly
               const originalSelectObject = window.selectObject;
               if (originalSelectObject) {
                   window.selectObject = (...args) => {
                       originalSelectObject.apply(this, args);
                       this.onSelectionChange();
                   };
               }
           }

           onSelectionChange() {
               setTimeout(() => {
                   this.captureOriginalShapeSize();
                   this.updateButtonState();
               }, 100); // Small delay to ensure selection is processed
           }

           captureOriginalShapeSize() {
               if (!this.isShapeSelected()) {
                   this.originalShapeSize = null;
                   return;
               }

               const selectedObject = window.canvasObjects[window.selectedObjectIndex];
               if (!selectedObject) return;

               // Only capture size if we don't already have an original size stored
               // This ensures we always use the FIRST selected shape's size
               if (!this.originalShapeSize) {
                   const visualWidth = (selectedObject.originalWidth || selectedObject.image.naturalWidth) * selectedObject.scale;
                   const visualHeight = (selectedObject.originalHeight || selectedObject.image.naturalHeight) * selectedObject.scale;

                   this.originalShapeSize = {
                       width: visualWidth,
                       height: visualHeight,
                       x: selectedObject.x,
                       y: selectedObject.y,
                       rotation: selectedObject.rotation || 0
                   };

                   console.log('🔷 [ShapeReplacement] Captured original shape size:', this.originalShapeSize);
               }
           }

           resetOriginalShapeSize() {
               this.originalShapeSize = null;
               console.log('🔷 [ShapeReplacement] Reset original shape size');
           }

           updateButtonState() {
               const dropdown = document.getElementById('shapeReplacementFolder');
               const changeButton = document.getElementById('changeShapeBtn');
               const resetButton = document.getElementById('resetSizeBtn');

               const hasSelectedShape = this.isShapeSelected();
               const hasSelectedFolder = dropdown && dropdown.value !== '';

               const shouldEnableChange = hasSelectedShape && hasSelectedFolder;
               const shouldEnableReset = hasSelectedShape && this.originalShapeSize;

               if (dropdown) dropdown.disabled = !hasSelectedShape;
               if (changeButton) changeButton.disabled = !shouldEnableChange;
               if (resetButton) resetButton.disabled = !shouldEnableReset;

               this.updateStatus();
           }

           isShapeSelected() {
               if (typeof window.selectedObjectIndex === 'undefined' || window.selectedObjectIndex === -1) {
                   return false;
               }

               const selectedObject = window.canvasObjects && window.canvasObjects[window.selectedObjectIndex];
               return selectedObject && (selectedObject.type === 'image' || selectedObject.image);
           }

           updateStatus(message = null, type = 'info') {
               const statusDiv = document.getElementById('shapeReplacementStatus');
               if (!statusDiv) return;

               if (message) {
                   statusDiv.textContent = message;
                   statusDiv.style.color = type === 'error' ? '#e74c3c' : '#666';
                   return;
               }

               const hasSelectedShape = this.isShapeSelected();
               const dropdown = document.getElementById('shapeReplacementFolder');
               const hasSelectedFolder = dropdown && dropdown.value !== '';

               if (!hasSelectedShape) {
                   statusDiv.textContent = 'Select a shape object to enable replacement';
                   statusDiv.style.color = '#666';
               } else if (!this.originalShapeSize) {
                   statusDiv.textContent = 'Original shape size captured - select category to replace';
                   statusDiv.style.color = '#3498db';
               } else if (!hasSelectedFolder) {
                   statusDiv.textContent = `Using original size (${Math.round(this.originalShapeSize.width)}×${Math.round(this.originalShapeSize.height)}) - select category`;
                   statusDiv.style.color = '#3498db';
               } else {
                   statusDiv.textContent = `Ready to replace with original size (${Math.round(this.originalShapeSize.width)}×${Math.round(this.originalShapeSize.height)})`;
                   statusDiv.style.color = '#27ae60';
               }
           }

           async handleShapeReplacement() {
               try {
                   console.log('🔷 [ShapeReplacement] Starting shape replacement...');

                   if (!this.isShapeSelected()) {
                       this.updateStatus('No shape selected', 'error');
                       return;
                   }

                   const dropdown = document.getElementById('shapeReplacementFolder');
                   if (!dropdown || !dropdown.value) {
                       this.updateStatus('Please select a size category', 'error');
                       return;
                   }

                   this.updateStatus('Loading shapes...', 'info');

                   // Get shapes from selected folder
                   const shapes = await this.getShapesFromFolder(dropdown.value);
                   if (shapes.length === 0) {
                       this.updateStatus('No shapes found in selected category', 'error');
                       return;
                   }

                   // Select random shape
                   const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
                   console.log('🔷 [ShapeReplacement] Selected random shape:', randomShape);

                   // Replace the shape
                   await this.replaceSelectedShape(randomShape);

                   this.updateStatus('Shape replaced successfully!', 'info');
                   setTimeout(() => this.updateStatus(), 2000); // Reset status after 2 seconds

               } catch (error) {
                   console.error('🔷 [ShapeReplacement] Error during shape replacement:', error);
                   this.updateStatus('Error replacing shape', 'error');
               }
           }

           async getShapesFromFolder(folderPath) {
               try {
                   const response = await fetch(`/api/stock-shapes?folder=${encodeURIComponent(folderPath)}`);
                   if (!response.ok) {
                       throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                   }

                   const data = await response.json();
                   return data.shapes || [];

               } catch (error) {
                   console.error('🔷 [ShapeReplacement] Error fetching shapes from folder:', error);
                   throw error;
               }
           }

           async replaceSelectedShape(newShapeUrl) {
               return new Promise((resolve, reject) => {
                   try {
                       const selectedObject = window.canvasObjects[window.selectedObjectIndex];
                       if (!selectedObject) {
                           reject(new Error('No selected object found'));
                           return;
                       }

                       // Use original shape size if available, otherwise use current size
                       let targetWidth, targetHeight, targetX, targetY, targetRotation;

                       if (this.originalShapeSize) {
                           // Always use the original shape's size and position
                           targetWidth = this.originalShapeSize.width;
                           targetHeight = this.originalShapeSize.height;
                           targetX = this.originalShapeSize.x;
                           targetY = this.originalShapeSize.y;
                           targetRotation = this.originalShapeSize.rotation;
                           console.log('🔷 [ShapeReplacement] Using ORIGINAL shape size:', this.originalShapeSize);
                       } else {
                           // Fallback to current size if no original size captured
                           targetX = selectedObject.x;
                           targetY = selectedObject.y;
                           targetRotation = selectedObject.rotation || 0;
                           targetWidth = (selectedObject.originalWidth || selectedObject.image.naturalWidth) * selectedObject.scale;
                           targetHeight = (selectedObject.originalHeight || selectedObject.image.naturalHeight) * selectedObject.scale;
                           console.log('🔷 [ShapeReplacement] Using current shape size (no original captured)');
                       }

                       console.log('🔷 [ShapeReplacement] Target properties:', {
                           x: targetX,
                           y: targetY,
                           rotation: targetRotation,
                           targetWidth: targetWidth,
                           targetHeight: targetHeight
                       });

                       // Load new image
                       const newImage = new Image();
                       newImage.crossOrigin = 'anonymous';

                       newImage.onload = () => {
                           try {
                               console.log('🔷 [ShapeReplacement] New shape loaded:', {
                                   naturalWidth: newImage.naturalWidth,
                                   naturalHeight: newImage.naturalHeight
                               });

                               // Calculate new scale to match the TARGET size (original shape size)
                               const newScaleX = targetWidth / newImage.naturalWidth;
                               const newScaleY = targetHeight / newImage.naturalHeight;

                               // Use the smaller scale to maintain aspect ratio while fitting the target size
                               const newScale = Math.min(newScaleX, newScaleY);

                               console.log('🔷 [ShapeReplacement] Calculated new scale for ORIGINAL size:', {
                                   targetWidth,
                                   targetHeight,
                                   newScaleX,
                                   newScaleY,
                                   finalScale: newScale
                               });

                               // Update the selected object with new image and calculated scale
                               selectedObject.image = newImage;
                               selectedObject.imageUrl = newShapeUrl;
                               selectedObject.originalWidth = newImage.naturalWidth;
                               selectedObject.originalHeight = newImage.naturalHeight;

                               // Apply target positioning and scaling (always original shape's properties)
                               selectedObject.x = targetX;
                               selectedObject.y = targetY;
                               selectedObject.scale = newScale;
                               selectedObject.rotation = targetRotation;

                               console.log('🔷 [ShapeReplacement] Final object properties (using ORIGINAL size):', {
                                   x: selectedObject.x,
                                   y: selectedObject.y,
                                   scale: selectedObject.scale,
                                   rotation: selectedObject.rotation,
                                   newVisualWidth: selectedObject.originalWidth * selectedObject.scale,
                                   newVisualHeight: selectedObject.originalHeight * selectedObject.scale
                               });

                               // Update the canvas
                               if (typeof window.update === 'function') {
                                   window.update();
                               }

                               resolve();

                           } catch (error) {
                               console.error('🔷 [ShapeReplacement] Error updating object:', error);
                               reject(error);
                           }
                       };

                       newImage.onerror = (error) => {
                           console.error('🔷 [ShapeReplacement] Error loading new shape:', newShapeUrl, error);
                           reject(new Error('Failed to load new shape'));
                       };

                       newImage.src = newShapeUrl;

                   } catch (error) {
                       console.error('🔷 [ShapeReplacement] Error in replaceSelectedShape:', error);
                       reject(error);
                   }
               });
           }
       }

       // Initialize shape replacement system
       let shapeReplacementManager;

       document.addEventListener('DOMContentLoaded', () => {
           console.log('🔷 [ShapeReplacement] DOMContentLoaded event fired, setting up shape replacement...');
           setTimeout(async () => {
               shapeReplacementManager = new ShapeReplacementManager();
               await shapeReplacementManager.init();
           }, 1500); // Delay to ensure all other systems are ready
       });

       if (document.readyState !== 'loading') {
           setTimeout(async () => {
               shapeReplacementManager = new ShapeReplacementManager();
               await shapeReplacementManager.init();
           }, 1500);
       }

       // Function to handle updating an existing project
       async function handleUpdateProject() {
           console.log('[UpdateProject] 🚀 Starting update process...');

           // 🔧 CRITICAL FIX: Set flag to prevent CSS filter restoration during update
           window._isProjectUpdate = true;
           console.log('[UpdateProject] 🔧 Set project update flag to preserve current CSS filter state');

           if (!window.currentProjectId) {
               console.error('[UpdateProject] ❌ No current project ID found');
               // 🔧 Clear flag on early return
               window._isProjectUpdate = false;
               return;
           }

           try {
               // 1. Generate preview image
               console.log('[UpdateProject] 📸 Generating preview image...');
               let previewImageUrl;

               try {
                   // Create export canvas for preview - ONLY artboard size
                   const exportCanvas = document.createElement('canvas');
                   exportCanvas.width = window.artboard.width;
                   exportCanvas.height = window.artboard.height;
                   const exportCtx = exportCanvas.getContext('2d');

                   // Fill with background color first
                   exportCtx.fillStyle = window.canvasBackgroundColor || '#ffffff';
                   exportCtx.fillRect(0, 0, window.artboard.width, window.artboard.height);

                   exportCtx.save();
                   // Translate context so drawing happens relative to artboard's top-left
                   exportCtx.translate(-window.artboard.x, -window.artboard.y);

                   // Draw objects individually (same as save project)
                   if (window.canvasObjects) {
                       for (const obj of window.canvasObjects) {
                           if (obj.type === 'text' && window.drawTextObject) {
                               console.log('[UpdateProject] 🎨 Drawing text object:', obj.text);
                               window.drawTextObject(obj, exportCtx);
                           } else if (obj.type === 'image' && window.drawImageObject) {
                               console.log('[UpdateProject] 🎨 Drawing image object');
                               await window.drawImageObject(obj, exportCtx);
                           }
                       }
                   }

                   exportCtx.restore();

                   // Convert to data URL
                   const previewDataUrl = exportCanvas.toDataURL('image/png');
                   console.log('[UpdateProject] Preview image generated, length:', previewDataUrl.length);

                   // Upload preview image
                   const blob = await (await fetch(previewDataUrl)).blob();
                   const formData = new FormData();
                   formData.append('image', blob, 'project_preview.png');

                   const uploadResponse = await fetch('/api/images/upload', {
                       method: 'POST',
                       body: formData
                   });

                   if (uploadResponse.ok) {
                       const uploadData = await uploadResponse.json();
                       previewImageUrl = uploadData.imageUrl;
                       console.log('[UpdateProject] Preview uploaded successfully:', previewImageUrl);
                   } else {
                       console.error('[UpdateProject] Failed to upload preview');
                       previewImageUrl = previewDataUrl; // Fallback to data URL
                   }
               } catch (previewError) {
                   console.error('[UpdateProject] Error generating preview:', previewError);
                   previewImageUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
               }

               // 2. Prepare artboard data
               const validatedArtboard = {
                   width: window.artboard?.width || 800,
                   height: window.artboard?.height || 600,
                   backgroundColor: window.artboard?.backgroundColor || '#ffffff',
                   x: window.artboard?.x || 0,
                   y: window.artboard?.y || 0
               };

               // 3. Clean canvas objects for serialization
               const serializableObjects = window.canvasObjects.map(obj => cleanObjectForSerialization(obj));

               // 4. Prepare editor state
               const editorState = {
                   canvasBackgroundColor: window.canvasBackgroundColor || '#ffffff',
                   zoom: {
                       scale: window.scale || 1.0,
                       offsetX: window.offsetX || 0,
                       offsetY: window.offsetY || 0
                   },
                   selectedObjectIndex: window.selectedObjectIndex || -1,
                   nextId: window.nextId || 0,
                   editorSettings: {
                       lastUpdateTimestamp: Date.now()
                   }
               };

               // 5. Capture effect states
               console.log('[UpdateProject] 🎨 Capturing effect states...');
               let cssFilterState = {};
               let duotoneState = {};
               let glitchState = {};
               let halftoneState = {};

               // 🔧 CRITICAL FIX: Capture CSS filter state during project updates
               if (typeof window.captureCSSFilterState === 'function') {
                   cssFilterState = window.captureCSSFilterState();
                   console.log('[UpdateProject] 🎨 Captured CSS filter state:', cssFilterState);
                   console.log('[UpdateProject] 🎨 🔍 CSS FILTER DETAILS:', JSON.stringify(cssFilterState, null, 2));
               } else {
                   console.log('[UpdateProject] 🎨 ⚠️ captureCSSFilterState function not available');
               }

               if (typeof window.captureDuotoneState === 'function') {
                   duotoneState = window.captureDuotoneState();
                   console.log('[UpdateProject] 🎨 Captured duotone state:', duotoneState);
               }

               if (typeof window.captureGlitchState === 'function') {
                   glitchState = window.captureGlitchState();
                   console.log('[UpdateProject] 🎨 Captured glitch state:', glitchState);
               }

               if (typeof window.captureHalftoneState === 'function') {
                   halftoneState = window.captureHalftoneState();
                   console.log('[UpdateProject] 🎨 Captured halftone state:', halftoneState);
               }

               // 6. Prepare admin data
               const adminData = {
                   cssFilterState,
                   duotoneState,
                   glitchState,
                   halftoneState
               };

               // 7. Prepare update payload
               const updatePayload = {
                   editorState,
                   adminData,
                   previewImageUrl,
                   artboard: validatedArtboard,
                   canvasObjects: serializableObjects,
                   cssFilterState,
                   duotoneState,
                   glitchState,
                   halftoneState
               };

               console.log('[UpdateProject] 📤 Sending update request...');

               // 8. Send update request
               const response = await fetch(`/api/projects/${window.currentProjectId}`, {
                   method: 'PUT',
                   headers: {
                       'Content-Type': 'application/json',
                       'Authorization': `Bearer ${localStorage.getItem('token')}`
                   },
                   body: JSON.stringify(updatePayload)
               });

               if (response.ok) {
                   console.log('[UpdateProject] ✅ Project updated successfully');

                   // Show success message
                   if (window.showToast) {
                       window.showToast('Project updated successfully!', 'success');
                   } else {
                       alert('Project updated successfully!');
                   }

                   // Dispatch project saved event
                   window.dispatchEvent(new CustomEvent('projectSaved', {
                       detail: { projectId: window.currentProjectId }
                   }));
               } else {
                   const errorData = await response.json();
                   console.error('[UpdateProject] ❌ Update failed:', errorData);

                   if (window.showToast) {
                       window.showToast('Failed to update project: ' + (errorData.error || 'Unknown error'), 'error');
                   } else {
                       alert('Failed to update project: ' + (errorData.error || 'Unknown error'));
                   }
               }
           } catch (error) {
               console.error('[UpdateProject] ❌ Error updating project:', error);

               if (window.showToast) {
                   window.showToast('Error updating project: ' + error.message, 'error');
               } else {
                   alert('Error updating project: ' + error.message);
               }
           } finally {
               // 🔧 CRITICAL FIX: Always clear project update flag
               window._isProjectUpdate = false;
               console.log('[UpdateProject] 🔧 Cleared project update flag (finally block)');
           }
       }

       // Make the function globally available
       window.handleUpdateProject = handleUpdateProject;
    </script>

    <!-- SVG Filter Definition for DuoTone Effect -->
    <svg class="svg-hidden">
        <defs>
            <filter id="duotone-filter" color-interpolation-filters="sRGB" x="0" y="0" height="100%" width="100%">
                <feColorMatrix id="duotone-matrix" type="matrix" values="0.375 0 0 0 0.3515625 0.83203125 0 0 0 0.1640625 0.40234375 0 0 0 0.5234375 0 0 0 1 0">
                </feColorMatrix>
            </filter>
        </defs>
    </svg>

<script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr@1.9.1/dist/pickr.min.js"></script>
<collection-modal></collection-modal>
<project-modal></project-modal>
<toast-notification></toast-notification>
</body>
</html>
